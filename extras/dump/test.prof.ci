
---------- Compile: `cmplStd/stdlib.ci`
warn: variable `args` hides previous declaration
cmplStd/stdlib.ci:40: debug: inline file: `cmplStd/lib/debug.ci`
cmplStd/lib/debug.ci:65: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/debug.ci:67: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/debug.ci:68: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/debug.ci:69: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/stdlib.ci:43: debug: inline file: `cmplStd/lib/math.ci`
cmplStd/lib/math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:23: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:24: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:64: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:67: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:67: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:78: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:86: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:94: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math.ci:102: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:191: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math.ci:191: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math.ci:192: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:192: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math.ci:202: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:206: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:216: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math.ci:220: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:231: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/math.ci:239: warn: adding implicit cast float64(signed(data.length): int32)
cmplStd/lib/math.ci:257: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math.ci:309: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:315: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:316: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math.ci:319: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math.ci:323: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math.ci:323: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math.ci:327: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math.ci:332: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:367: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:371: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:379: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:387: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:396: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:399: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:421: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:426: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:427: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:432: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:448: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:451: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math.ci:452: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:454: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:463: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:469: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math.ci:474: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:479: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math.ci:481: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:497: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math.ci:521: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math.ci:524: warn: adding implicit cast float64(180: int32)
cmplStd/stdlib.ci:46: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:24: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/stdlib.ci:47: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/stdlib.ci:48: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:113: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:137: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:165: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:166: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:168: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:176: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:177: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:178: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(1: int32)
cmplStd/stdlib.ci:49: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/stdlib.ci:54: debug: inline file: `cmplStd/lib/string.ci`
cmplStd/lib/string.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/string.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/string.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/string.ci:117: warn: padding `FormatFlags.precision` with 3 bytes: (1 -> 4)
cmplStd/lib/string.ci:123: warn: padding `FormatFlags.padLen` with 3 bytes: (9 -> 12)
cmplStd/lib/string.ci:129: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:136: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:137: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:137: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:139: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:152: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:162: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/string.ci:165: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/string.ci:165: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:166: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/string.ci:180: warn: adding implicit cast int32(sign: char)
cmplStd/lib/string.ci:185: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:190: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:197: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:204: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:209: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/string.ci:210: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/string.ci:210: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/string.ci:212: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:225: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:225: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:225: warn: adding implicit cast int64(0: int32)
cmplStd/lib/string.ci:227: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:229: warn: adding implicit cast int32(value: int16)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:231: warn: adding implicit cast int32(value: int8)
cmplStd/lib/string.ci:248: warn: adding implicit cast float64(0: int32)
cmplStd/lib/string.ci:248: warn: adding implicit cast int32('-': char)
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.showSign := false
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.precision := 0
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/string.ci:120: warn: adding implicit cast char(0: int32)
cmplStd/lib/string.ci:263: debug: using default field initializer: FormatFlags.padLen := 0

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/std/number.ci`
cmplStd/test/std/number.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/number.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/number.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/std/number.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/std/memory.ci`
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/std/tryExec.ci`
cmplStd/test/std/tryExec.ci:25: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/debug.ci:48: warn: previously defined as `NotEquals`
cmplStd/test/std/tryExec.ci:25: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/std/tryExec.ci:31: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:31: debug: inline file: `cmplStd/test/lang/init.array.ci`
cmplStd/test/lang/init.array.ci:2: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(42: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(43: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(44: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(45: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(46: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(47: int32)
cmplStd/test/lang/init.array.ci:11: warn: adding implicit cast int64(48: int32)
cmplStd/test/lang/init.array.ci:34: warn: adding implicit cast char(0: int32)
cmplStd/test/lang/init.array.ci:48: warn: adding implicit cast uint32(0: int32)
cmplStd/test/lang/init.array.ci:49: warn: adding implicit cast int64(42: int32)
cmplStd/test/lang/init.array.ci:56: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:57: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:58: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:62: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:63: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:64: warn: adding implicit cast int32(length: uint32)
cmplStd/test/lang/init.array.ci:66: warn: adding implicit cast int32(length: uint32)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:49: debug: inline file: `cmplStd/test/std/test.math.ci`
cmplStd/test/std/test.math.ci:57: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:58: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:59: warn: adding implicit cast float64(4: int32)
cmplStd/test/std/test.math.ci:60: warn: adding implicit cast float64(2: int32)
cmplStd/test/std/test.math.ci:61: warn: adding implicit cast float64(2: int32)

---------- Generate: byte-code
cmplStd/lib/math.ci:48: warn: using default type initializer: Math.floor.result := 0
cmplStd/lib/math.ci:314: warn: using default type initializer: Math.sinCos.y := 0
cmplStd/lib/math.ci:317: warn: using default type initializer: e := 0
cmplStd/lib/math.ci:321: warn: using default type initializer: f := 0
cmplStd/lib/math.ci:373: warn: using default type initializer: Math.tan.e := 0
cmplStd/lib/math.ci:430: warn: using default type initializer: Math.sinh.result := 0
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:41: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/recUnion.ci:31: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
cmplStd/test/lang/init.method.ci:78: warn: accessing static member using instance variable `RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void`/ RecordMethodTest
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0
cmplStd/lib/debug.ci:45: warn: no code will be generated for statement: 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.offset: <@000008>
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, offs: <+32>, cast: const variable)
.field offset: int32 (size: 4, offs: <+40>, cast: const variable)
.field base: function (size: 0, offs: <@006500>, cast: static const inline)
.field file: function (size: 0, offs: <@006718>, cast: static const inline)
.field line: function (size: 0, offs: <@006930>, cast: static const inline)
.field name: function (size: 0, offs: <@006b48>, cast: static const inline)
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/init.array.ci:2: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplStd/stdlib.ci:39: referenced as `typename`
	cmplStd/stdlib.ci:37: referenced as `typename`
	internal usages: 10
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+32>
.name: 'size'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/stdlib.ci:37: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.offset: <+40>
.name: 'offset'
.print: '@%06x'
.owner: typename
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006500>
.name: 'base'
.owner: typename
.param .result: typename (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006718>
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006930>
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006b48>
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0000b8>
.name: 'void'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/std/tryExec.ci:43: referenced as `void`
	cmplStd/test/std/tryExec.ci:38: referenced as `void`
	cmplStd/test/std/tryExec.ci:24: referenced as `void`
	cmplStd/test/std/tryExec.ci:20: referenced as `void`
	cmplStd/test/std/tryExec.ci:14: referenced as `void`
	cmplStd/test/std/tryExec.ci:11: referenced as `void`
	cmplStd/lib/debug.ci:61: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:45: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:43: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	cmplStd/lib/debug.ci:41: referenced as `void`
	internal usages: 6
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.offset: <@000160>
.name: 'bool'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `bool`
	cmplStd/test/std/test.math.ci:67: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplStd/lib/string.ci:114: referenced as `bool`
	cmplStd/lib/string.ci:46: referenced as `bool`
	cmplStd/lib/string.ci:36: referenced as `bool`
	cmplStd/lib/math.ci:468: referenced as `bool`
	cmplStd/lib/math.ci:420: referenced as `bool`
	cmplStd/lib/math.ci:365: referenced as `bool`
	cmplStd/lib/math.ci:364: referenced as `bool`
	cmplStd/lib/debug.ci:45: referenced as `bool`
	cmplStd/lib/debug.ci:43: referenced as `bool`
	cmplStd/lib/debug.ci:41: referenced as `bool`
	cmplStd/stdlib.ci:3: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@000208>
.name: 'char'
.print: '%c'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/init.array.ci:40: referenced as `char`
	cmplStd/test/lang/init.array.ci:37: referenced as `char`
	cmplStd/test/lang/init.array.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/std/tryExec.ci:26: referenced as `char`
	cmplStd/test/lang/emit.ci:29: referenced as `char`
	cmplStd/lib/string.ci:262: referenced as `char`
	cmplStd/lib/string.ci:259: referenced as `char`
	cmplStd/lib/string.ci:248: referenced as `char`
	cmplStd/lib/string.ci:234: referenced as `char`
	cmplStd/lib/string.ci:231: referenced as `char`
	cmplStd/lib/string.ci:229: referenced as `char`
	cmplStd/lib/string.ci:227: referenced as `char`
	cmplStd/lib/string.ci:225: referenced as `char`
	cmplStd/lib/string.ci:223: referenced as `char`
	cmplStd/lib/string.ci:221: referenced as `char`
	cmplStd/lib/string.ci:219: referenced as `char`
	cmplStd/lib/string.ci:217: referenced as `char`
	cmplStd/lib/string.ci:174: referenced as `char`
	cmplStd/lib/string.ci:149: referenced as `char`
	cmplStd/lib/string.ci:146: referenced as `char`
	cmplStd/lib/string.ci:145: referenced as `char`
	cmplStd/lib/string.ci:144: referenced as `char`
	cmplStd/lib/string.ci:144: referenced as `char`
	cmplStd/lib/string.ci:127: referenced as `char`
	cmplStd/lib/string.ci:127: referenced as `char`
	cmplStd/lib/string.ci:120: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:98: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:95: referenced as `char`
	cmplStd/lib/string.ci:94: referenced as `char`
	cmplStd/lib/string.ci:94: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:93: referenced as `char`
	cmplStd/lib/string.ci:92: referenced as `char`
	cmplStd/lib/string.ci:92: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:88: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:74: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:73: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:61: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:46: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:36: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:25: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:15: referenced as `char`
	cmplStd/lib/string.ci:4: referenced as `char`
	cmplStd/lib/debug.ci:61: referenced as `char`
	cmplStd/lib/debug.ci:43: referenced as `char`
	cmplStd/lib/debug.ci:41: referenced as `char`
	cmplStd/lib/debug.ci:36: referenced as `char`
	cmplStd/lib/debug.ci:34: referenced as `char`
	cmplStd/lib/debug.ci:31: referenced as `char`
	cmplStd/lib/debug.ci:29: referenced as `char`
	cmplStd/lib/debug.ci:26: referenced as `char`
	cmplStd/lib/debug.ci:24: referenced as `char`
	cmplStd/lib/debug.ci:21: referenced as `char`
	cmplStd/lib/debug.ci:19: referenced as `char`
	cmplStd/lib/debug.ci:16: referenced as `char`
	cmplStd/lib/debug.ci:14: referenced as `char`
	cmplStd/lib/debug.ci:11: referenced as `char`
	cmplStd/lib/debug.ci:9: referenced as `char`
	cmplStd/lib/debug.ci:6: referenced as `char`
	cmplStd/lib/debug.ci:4: referenced as `char`
	internal usages: 2
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.offset: <@0002b0>
.name: 'int8'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/string.ci:231: referenced as `int8`
	cmplStd/stdlib.ci:25: referenced as `int8`
	cmplStd/stdlib.ci:13: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.offset: <@000358>
.name: 'int16'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/string.ci:229: referenced as `int16`
	cmplStd/stdlib.ci:28: referenced as `int16`
	cmplStd/stdlib.ci:16: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.offset: <@000400>
.name: 'int32'
.print: '%d'
.value: 0
.usages:
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.array.ci:66: referenced as `int`
	cmplStd/test/lang/init.array.ci:54: referenced as `int`
	cmplStd/test/lang/init.array.ci:53: referenced as `int`
	cmplStd/test/lang/init.array.ci:52: referenced as `int`
	cmplStd/test/lang/init.array.ci:51: referenced as `int`
	cmplStd/test/lang/init.array.ci:3: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/std/tryExec.ci:53: referenced as `int`
	cmplStd/test/std/tryExec.ci:52: referenced as `int`
	cmplStd/test/std/tryExec.ci:51: referenced as `int`
	cmplStd/test/std/tryExec.ci:50: referenced as `int`
	cmplStd/test/std/tryExec.ci:49: referenced as `int`
	cmplStd/test/std/tryExec.ci:48: referenced as `int`
	cmplStd/test/std/tryExec.ci:47: referenced as `int`
	cmplStd/test/std/tryExec.ci:40: referenced as `int`
	cmplStd/test/std/tryExec.ci:39: referenced as `int32`
	cmplStd/test/std/tryExec.ci:28: referenced as `int`
	cmplStd/test/std/tryExec.ci:27: referenced as `int`
	cmplStd/test/std/tryExec.ci:21: referenced as `int`
	cmplStd/test/std/memory.ci:4: referenced as `int`
	cmplStd/test/std/memory.ci:3: referenced as `int`
	cmplStd/test/std/number.ci:66: referenced as `int32`
	cmplStd/test/std/number.ci:65: referenced as `int32`
	cmplStd/test/std/number.ci:63: referenced as `int32`
	cmplStd/test/std/number.ci:62: referenced as `int32`
	cmplStd/test/std/number.ci:60: referenced as `int32`
	cmplStd/test/std/number.ci:59: referenced as `int32`
	cmplStd/test/std/number.ci:58: referenced as `int32`
	cmplStd/test/std/number.ci:57: referenced as `int32`
	cmplStd/test/std/number.ci:55: referenced as `int32`
	cmplStd/test/std/number.ci:35: referenced as `int32`
	cmplStd/test/std/number.ci:34: referenced as `int32`
	cmplStd/test/std/number.ci:33: referenced as `int32`
	cmplStd/test/std/number.ci:31: referenced as `int32`
	cmplStd/test/std/number.ci:30: referenced as `int32`
	cmplStd/test/std/number.ci:29: referenced as `int32`
	cmplStd/test/std/number.ci:27: referenced as `int32`
	cmplStd/test/std/number.ci:26: referenced as `int32`
	cmplStd/test/std/number.ci:25: referenced as `int32`
	cmplStd/test/std/number.ci:23: referenced as `int32`
	cmplStd/test/std/number.ci:22: referenced as `int32`
	cmplStd/test/std/number.ci:21: referenced as `int32`
	cmplStd/test/std/number.ci:19: referenced as `int32`
	cmplStd/test/std/number.ci:18: referenced as `int32`
	cmplStd/test/std/number.ci:16: referenced as `int`
	cmplStd/test/std/number.ci:15: referenced as `int`
	cmplStd/test/std/number.ci:14: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:12: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/std/number.ci:10: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:29: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:262: referenced as `int`
	cmplStd/lib/string.ci:259: referenced as `int`
	cmplStd/lib/string.ci:234: referenced as `int`
	cmplStd/lib/string.ci:234: referenced as `int`
	cmplStd/lib/string.ci:231: referenced as `int`
	cmplStd/lib/string.ci:229: referenced as `int`
	cmplStd/lib/string.ci:227: referenced as `int32`
	cmplStd/lib/string.ci:227: referenced as `int`
	cmplStd/lib/string.ci:225: referenced as `int`
	cmplStd/lib/string.ci:223: referenced as `int`
	cmplStd/lib/string.ci:221: referenced as `int`
	cmplStd/lib/string.ci:219: referenced as `int`
	cmplStd/lib/string.ci:217: referenced as `int`
	cmplStd/lib/string.ci:203: referenced as `int`
	cmplStd/lib/string.ci:172: referenced as `int`
	cmplStd/lib/string.ci:157: referenced as `int`
	cmplStd/lib/string.ci:148: referenced as `int`
	cmplStd/lib/string.ci:144: referenced as `int`
	cmplStd/lib/string.ci:144: referenced as `int`
	cmplStd/lib/string.ci:128: referenced as `int`
	cmplStd/lib/string.ci:127: referenced as `int`
	cmplStd/lib/string.ci:127: referenced as `int`
	cmplStd/lib/string.ci:123: referenced as `int`
	cmplStd/lib/string.ci:117: referenced as `int`
	cmplStd/lib/string.ci:88: referenced as `int`
	cmplStd/lib/string.ci:73: referenced as `int`
	cmplStd/lib/string.ci:63: referenced as `int`
	cmplStd/lib/string.ci:62: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:61: referenced as `int`
	cmplStd/lib/string.ci:52: referenced as `int`
	cmplStd/lib/string.ci:48: referenced as `int`
	cmplStd/lib/string.ci:47: referenced as `int`
	cmplStd/lib/string.ci:46: referenced as `int`
	cmplStd/lib/string.ci:37: referenced as `int`
	cmplStd/lib/string.ci:36: referenced as `int`
	cmplStd/lib/string.ci:27: referenced as `int`
	cmplStd/lib/string.ci:26: referenced as `int`
	cmplStd/lib/string.ci:25: referenced as `int`
	cmplStd/lib/string.ci:16: referenced as `int`
	cmplStd/lib/string.ci:15: referenced as `int`
	cmplStd/lib/string.ci:8: referenced as `int`
	cmplStd/lib/string.ci:4: referenced as `int`
	cmplStd/lib/math.ci:375: referenced as `int`
	cmplStd/lib/math.ci:375: referenced as `int`
	cmplStd/lib/math.ci:326: referenced as `int`
	cmplStd/lib/math.ci:294: referenced as `int`
	cmplStd/lib/math.ci:279: referenced as `int`
	cmplStd/lib/math.ci:264: referenced as `int`
	cmplStd/lib/math.ci:257: referenced as `int`
	cmplStd/lib/math.ci:231: referenced as `int`
	cmplStd/lib/math.ci:220: referenced as `int`
	cmplStd/lib/math.ci:206: referenced as `int`
	cmplStd/lib/math.ci:67: referenced as `int`
	cmplStd/lib/math.ci:67: referenced as `int`
	cmplStd/lib/math.ci:64: referenced as `int`
	cmplStd/lib/math.ci:64: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:74: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/lib/debug.ci:61: referenced as `int`
	cmplStd/stdlib.ci:37: referenced as `int`
	cmplStd/stdlib.ci:31: referenced as `int32`
	cmplStd/stdlib.ci:19: referenced as `int32`
	internal usages: 38
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.offset: <@0004a8>
.name: 'int64'
.print: '%D'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/init.array.ci:67: referenced as `integer`
	cmplStd/test/lang/init.array.ci:54: referenced as `integer`
	cmplStd/test/lang/init.array.ci:54: referenced as `integer`
	cmplStd/test/lang/init.array.ci:53: referenced as `integer`
	cmplStd/test/lang/init.array.ci:53: referenced as `integer`
	cmplStd/test/lang/init.array.ci:52: referenced as `integer`
	cmplStd/test/lang/init.array.ci:52: referenced as `integer`
	cmplStd/test/lang/init.array.ci:51: referenced as `integer`
	cmplStd/test/lang/init.array.ci:30: referenced as `integer`
	cmplStd/test/lang/init.array.ci:27: referenced as `integer`
	cmplStd/test/lang/init.array.ci:26: referenced as `integer`
	cmplStd/test/lang/init.array.ci:23: referenced as `integer`
	cmplStd/test/lang/init.array.ci:22: referenced as `integer`
	cmplStd/test/lang/init.array.ci:19: referenced as `integer`
	cmplStd/test/lang/init.array.ci:18: referenced as `integer`
	cmplStd/test/lang/init.array.ci:11: referenced as `integer`
	cmplStd/test/lang/init.array.ci:2: referenced as `integer`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/std/memory.ci:30: referenced as `int64`
	cmplStd/test/std/memory.ci:29: referenced as `int64`
	cmplStd/test/std/memory.ci:24: referenced as `int64`
	cmplStd/test/std/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplStd/lib/string.ci:254: referenced as `int64`
	cmplStd/lib/string.ci:250: referenced as `int64`
	cmplStd/lib/string.ci:225: referenced as `int64`
	cmplStd/stdlib.ci:34: referenced as `int64`
	cmplStd/stdlib.ci:22: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.offset: <@000550>
.name: 'uint8'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/std/tryExec.ci:16: referenced as `byte`
	cmplStd/lib/string.ci:223: referenced as `uint8`
	cmplStd/stdlib.ci:25: referenced as `uint8`
	cmplStd/stdlib.ci:13: referenced as `uint8`
	cmplStd/stdlib.ci:8: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.offset: <@0005f8>
.name: 'uint16'
.print: '%u'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/string.ci:221: referenced as `uint16`
	cmplStd/stdlib.ci:28: referenced as `uint16`
	cmplStd/stdlib.ci:16: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.offset: <@0006a0>
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, offs: <@009f48>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00a2a0>, cast: static const inline)
.field pop: function (size: 0, offs: <@00a4b8>, cast: static const inline)
.field swap: function (size: 0, offs: <@00a6d0>, cast: static const inline)
.field bsr: function (size: 0, offs: <@00a8e8>, cast: static const inline)
.field bsf: function (size: 0, offs: <@00ab00>, cast: static const inline)
.field hib: function (size: 0, offs: <@00ad18>, cast: static const inline)
.field lob: function (size: 0, offs: <@00af30>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplStd/test/std/number.ci:63: referenced as `uint32`
	cmplStd/test/std/number.ci:62: referenced as `uint32`
	cmplStd/test/std/number.ci:60: referenced as `uint32`
	cmplStd/test/std/number.ci:59: referenced as `uint32`
	cmplStd/test/std/number.ci:58: referenced as `uint32`
	cmplStd/test/std/number.ci:57: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:56: referenced as `uint32`
	cmplStd/test/std/number.ci:55: referenced as `uint32`
	cmplStd/test/std/number.ci:35: referenced as `uint32`
	cmplStd/test/std/number.ci:34: referenced as `uint32`
	cmplStd/test/std/number.ci:33: referenced as `uint32`
	cmplStd/test/std/number.ci:31: referenced as `uint32`
	cmplStd/test/std/number.ci:30: referenced as `uint32`
	cmplStd/test/std/number.ci:29: referenced as `uint32`
	cmplStd/test/std/number.ci:27: referenced as `uint32`
	cmplStd/test/std/number.ci:26: referenced as `uint32`
	cmplStd/test/std/number.ci:25: referenced as `uint32`
	cmplStd/test/std/number.ci:23: referenced as `uint32`
	cmplStd/test/std/number.ci:22: referenced as `uint32`
	cmplStd/test/std/number.ci:21: referenced as `uint32`
	cmplStd/lib/string.ci:219: referenced as `uint32`
	cmplStd/stdlib.ci:31: referenced as `uint32`
	cmplStd/stdlib.ci:19: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009f48>
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(21)
.usages:
	cmplStd/test/std/number.ci:62: referenced as `zxt`
	cmplStd/test/std/number.ci:31: referenced as `zxt`
	cmplStd/test/std/number.ci:30: referenced as `zxt`
	cmplStd/test/std/number.ci:29: referenced as `zxt`
	cmplStd/test/std/number.ci:23: referenced as `zxt`
	cmplStd/test/std/number.ci:22: referenced as `zxt`
	cmplStd/test/std/number.ci:21: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a2a0>
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param offs: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(22)
.usages:
	cmplStd/test/std/number.ci:63: referenced as `sxt`
	cmplStd/test/std/number.ci:35: referenced as `sxt`
	cmplStd/test/std/number.ci:34: referenced as `sxt`
	cmplStd/test/std/number.ci:33: referenced as `sxt`
	cmplStd/test/std/number.ci:27: referenced as `sxt`
	cmplStd/test/std/number.ci:26: referenced as `sxt`
	cmplStd/test/std/number.ci:25: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a4b8>
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(23)
.usages:
	cmplStd/test/std/number.ci:55: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a6d0>
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(24)
.usages:
	cmplStd/test/std/number.ci:56: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00a8e8>
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(25)
.usages:
	cmplStd/test/std/number.ci:57: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ab00>
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(26)
.usages:
	cmplStd/test/std/number.ci:58: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ad18>
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(27)
.usages:
	cmplStd/test/std/number.ci:59: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00af30>
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(28)
.usages:
	cmplStd/test/std/number.ci:60: referenced as `lob`
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.offset: <@000748>
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, offs: <@00b280>, cast: static const inline)
.field sxt: function (size: 0, offs: <@00b5d0>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/test/std/number.ci:66: referenced as `uint64`
	cmplStd/test/std/number.ci:65: referenced as `uint64`
	cmplStd/lib/string.ci:254: referenced as `uint64`
	cmplStd/lib/string.ci:250: referenced as `uint64`
	cmplStd/lib/string.ci:231: referenced as `uint64`
	cmplStd/lib/string.ci:229: referenced as `uint64`
	cmplStd/lib/string.ci:227: referenced as `uint64`
	cmplStd/lib/string.ci:225: referenced as `uint64`
	cmplStd/lib/string.ci:223: referenced as `uint64`
	cmplStd/lib/string.ci:221: referenced as `uint64`
	cmplStd/lib/string.ci:219: referenced as `uint64`
	cmplStd/lib/string.ci:217: referenced as `uint64`
	cmplStd/lib/string.ci:217: referenced as `uint64`
	cmplStd/lib/string.ci:144: referenced as `uint64`
	cmplStd/stdlib.ci:34: referenced as `uint64`
	cmplStd/stdlib.ci:22: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b280>
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(29)
.usages:
	cmplStd/test/std/number.ci:65: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b5d0>
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param offs: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param count: int32 (size: 4, offs: <+16>, cast: variable(i32))
.value: nfc(30)
.usages:
	cmplStd/test/std/number.ci:66: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.offset: <@0007f0>
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, offs: <@00b7e8>, cast: static const inline)
.field cos: function (size: 0, offs: <@00ba00>, cast: static const inline)
.field tan: function (size: 0, offs: <@00bc18>, cast: static const inline)
.field log: function (size: 0, offs: <@00be30>, cast: static const inline)
.field exp: function (size: 0, offs: <@00c048>, cast: static const inline)
.field pow: function (size: 0, offs: <@00c300>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00c518>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00c7d0>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `float32`
	cmplStd/test/std/test.math.ci:95: referenced as `float32`
	cmplStd/test/std/test.math.ci:94: referenced as `float32`
	cmplStd/test/std/test.math.ci:93: referenced as `float32`
	cmplStd/test/std/test.math.ci:91: referenced as `float32`
	cmplStd/test/std/test.math.ci:90: referenced as `float32`
	cmplStd/test/std/test.math.ci:89: referenced as `float32`
	cmplStd/test/std/test.math.ci:88: referenced as `float32`
	cmplStd/test/std/test.math.ci:86: referenced as `float32`
	cmplStd/test/std/test.math.ci:85: referenced as `float32`
	cmplStd/test/std/test.math.ci:84: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:53: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:52: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:51: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:50: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:49: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:48: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:47: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:46: referenced as `float32`
	cmplStd/test/std/number.ci:7: referenced as `float32`
	cmplStd/test/std/number.ci:6: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/lib/string.ci:259: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:137: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:132: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math.ci:264: referenced as `float32`
	cmplStd/lib/math.ci:264: referenced as `float32`
	cmplStd/lib/math.ci:264: referenced as `float32`
	cmplStd/lib/math.ci:195: referenced as `float32`
	cmplStd/lib/math.ci:195: referenced as `float32`
	cmplStd/lib/math.ci:195: referenced as `float32`
	cmplStd/lib/math.ci:195: referenced as `float32`
	cmplStd/lib/math.ci:195: referenced as `float32`
	cmplStd/lib/math.ci:191: referenced as `float32`
	cmplStd/lib/math.ci:186: referenced as `float32`
	cmplStd/lib/math.ci:186: referenced as `float32`
	cmplStd/lib/math.ci:186: referenced as `float32`
	cmplStd/lib/math.ci:159: referenced as `float32`
	cmplStd/lib/math.ci:159: referenced as `float32`
	cmplStd/lib/math.ci:159: referenced as `float32`
	cmplStd/lib/math.ci:159: referenced as `float32`
	cmplStd/lib/math.ci:137: referenced as `float32`
	cmplStd/lib/math.ci:137: referenced as `float32`
	cmplStd/lib/math.ci:137: referenced as `float32`
	cmplStd/lib/math.ci:115: referenced as `float32`
	cmplStd/lib/math.ci:115: referenced as `float32`
	cmplStd/lib/math.ci:115: referenced as `float32`
	cmplStd/lib/math.ci:93: referenced as `float32`
	cmplStd/lib/math.ci:93: referenced as `float32`
	cmplStd/lib/math.ci:93: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:77: referenced as `float32`
	cmplStd/lib/math.ci:64: referenced as `float32`
	cmplStd/stdlib.ci:9: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00b7e8>
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(31)
.usages:
	cmplStd/test/std/number.ci:46: referenced as `sin`
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ba00>
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(32)
.usages:
	cmplStd/test/std/number.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:136: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00bc18>
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(33)
.usages:
	cmplStd/test/std/number.ci:48: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00be30>
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(34)
.usages:
	cmplStd/test/std/number.ci:49: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c048>
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(35)
.usages:
	cmplStd/test/std/number.ci:50: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c300>
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(36)
.usages:
	cmplStd/test/std/number.ci:51: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c518>
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: nfc(37)
.usages:
	cmplStd/test/std/number.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c7d0>
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, offs: <+4>, cast: inline)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param y: float32 (size: 4, offs: <+8>, cast: variable(f32))
.value: nfc(38)
.usages:
	cmplStd/test/std/number.ci:53: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.offset: <@000898>
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, offs: <@00c9e0>, cast: static const inline)
.field cos: function (size: 0, offs: <@00cbf0>, cast: static const inline)
.field tan: function (size: 0, offs: <@00ce00>, cast: static const inline)
.field log: function (size: 0, offs: <@00d010>, cast: static const inline)
.field exp: function (size: 0, offs: <@00d220>, cast: static const inline)
.field pow: function (size: 0, offs: <@00d4d0>, cast: static const inline)
.field sqrt: function (size: 0, offs: <@00d6e0>, cast: static const inline)
.field atan2: function (size: 0, offs: <@00d990>, cast: static const inline)
.value: 0
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `float64`
	cmplStd/test/std/test.math.ci:81: referenced as `float64`
	cmplStd/test/std/test.math.ci:80: referenced as `float64`
	cmplStd/test/std/test.math.ci:79: referenced as `float64`
	cmplStd/test/std/test.math.ci:77: referenced as `float64`
	cmplStd/test/std/test.math.ci:76: referenced as `float64`
	cmplStd/test/std/test.math.ci:75: referenced as `float64`
	cmplStd/test/std/test.math.ci:74: referenced as `float64`
	cmplStd/test/std/test.math.ci:72: referenced as `float64`
	cmplStd/test/std/test.math.ci:71: referenced as `float64`
	cmplStd/test/std/test.math.ci:70: referenced as `float64`
	cmplStd/test/std/test.math.ci:64: referenced as `float64`
	cmplStd/test/std/test.math.ci:63: referenced as `float64`
	cmplStd/test/std/test.math.ci:61: referenced as `float64`
	cmplStd/test/std/test.math.ci:60: referenced as `float64`
	cmplStd/test/std/test.math.ci:59: referenced as `float64`
	cmplStd/test/std/test.math.ci:58: referenced as `float64`
	cmplStd/test/std/test.math.ci:57: referenced as `float64`
	cmplStd/test/std/test.math.ci:55: referenced as `float64`
	cmplStd/test/std/test.math.ci:54: referenced as `float64`
	cmplStd/test/std/test.math.ci:53: referenced as `float64`
	cmplStd/test/std/test.math.ci:52: referenced as `float64`
	cmplStd/test/std/test.math.ci:51: referenced as `float64`
	cmplStd/test/std/test.math.ci:50: referenced as `float64`
	cmplStd/test/std/test.math.ci:49: referenced as `float64`
	cmplStd/test/std/test.math.ci:48: referenced as `float64`
	cmplStd/test/std/test.math.ci:46: referenced as `float64`
	cmplStd/test/std/test.math.ci:45: referenced as `float64`
	cmplStd/test/std/test.math.ci:44: referenced as `float64`
	cmplStd/test/std/test.math.ci:43: referenced as `float64`
	cmplStd/test/std/test.math.ci:41: referenced as `float64`
	cmplStd/test/std/test.math.ci:40: referenced as `float64`
	cmplStd/test/std/test.math.ci:39: referenced as `float64`
	cmplStd/test/std/test.math.ci:38: referenced as `float64`
	cmplStd/test/std/test.math.ci:36: referenced as `float64`
	cmplStd/test/std/test.math.ci:35: referenced as `float64`
	cmplStd/test/std/test.math.ci:33: referenced as `float64`
	cmplStd/test/std/test.math.ci:32: referenced as `float64`
	cmplStd/test/std/test.math.ci:30: referenced as `float64`
	cmplStd/test/std/test.math.ci:29: referenced as `float64`
	cmplStd/test/std/test.math.ci:27: referenced as `float64`
	cmplStd/test/std/test.math.ci:26: referenced as `float64`
	cmplStd/test/std/test.math.ci:25: referenced as `float64`
	cmplStd/test/std/test.math.ci:24: referenced as `float64`
	cmplStd/test/std/test.math.ci:22: referenced as `float64`
	cmplStd/test/std/test.math.ci:21: referenced as `float64`
	cmplStd/test/std/test.math.ci:20: referenced as `float64`
	cmplStd/test/std/test.math.ci:19: referenced as `float64`
	cmplStd/test/std/test.math.ci:18: referenced as `float64`
	cmplStd/test/std/test.math.ci:17: referenced as `float64`
	cmplStd/test/std/test.math.ci:15: referenced as `float64`
	cmplStd/test/std/test.math.ci:14: referenced as `float64`
	cmplStd/test/std/test.math.ci:13: referenced as `float64`
	cmplStd/test/std/test.math.ci:12: referenced as `float64`
	cmplStd/test/std/test.math.ci:11: referenced as `float64`
	cmplStd/test/std/test.math.ci:10: referenced as `float64`
	cmplStd/test/std/test.math.ci:8: referenced as `float64`
	cmplStd/test/std/test.math.ci:7: referenced as `float64`
	cmplStd/test/std/test.math.ci:6: referenced as `float64`
	cmplStd/test/std/test.math.ci:5: referenced as `float64`
	cmplStd/test/std/test.math.ci:4: referenced as `float64`
	cmplStd/test/std/test.math.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:44: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:43: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:42: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:41: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:40: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:39: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:38: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:37: referenced as `float64`
	cmplStd/test/std/number.ci:4: referenced as `float64`
	cmplStd/test/std/number.ci:3: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/lib/string.ci:259: referenced as `float64`
	cmplStd/lib/string.ci:253: referenced as `float64`
	cmplStd/lib/string.ci:249: referenced as `float64`
	cmplStd/lib/string.ci:234: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:187: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:151: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:149: referenced as `float64`
	cmplStd/lib/math/Complex.ci:146: referenced as `float64`
	cmplStd/lib/math/Complex.ci:142: referenced as `float64`
	cmplStd/lib/math/Complex.ci:141: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:139: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:138: referenced as `float64`
	cmplStd/lib/math/Complex.ci:137: referenced as `float64`
	cmplStd/lib/math/Complex.ci:136: referenced as `float64`
	cmplStd/lib/math/Complex.ci:132: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:129: referenced as `float64`
	cmplStd/lib/math/Complex.ci:118: referenced as `float64`
	cmplStd/lib/math/Complex.ci:114: referenced as `float64`
	cmplStd/lib/math/Complex.ci:112: referenced as `float64`
	cmplStd/lib/math/Complex.ci:109: referenced as `float64`
	cmplStd/lib/math/Complex.ci:107: referenced as `float64`
	cmplStd/lib/math/Complex.ci:99: referenced as `float64`
	cmplStd/lib/math/Complex.ci:98: referenced as `float64`
	cmplStd/lib/math/Complex.ci:92: referenced as `float64`
	cmplStd/lib/math/Complex.ci:91: referenced as `float64`
	cmplStd/lib/math/Complex.ci:83: referenced as `float64`
	cmplStd/lib/math/Complex.ci:81: referenced as `float64`
	cmplStd/lib/math/Complex.ci:73: referenced as `float64`
	cmplStd/lib/math/Complex.ci:71: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:64: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:31: referenced as `float64`
	cmplStd/lib/math/Complex.ci:24: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math.ci:524: referenced as `float64`
	cmplStd/lib/math.ci:524: referenced as `float64`
	cmplStd/lib/math.ci:521: referenced as `float64`
	cmplStd/lib/math.ci:521: referenced as `float64`
	cmplStd/lib/math.ci:497: referenced as `float64`
	cmplStd/lib/math.ci:484: referenced as `float64`
	cmplStd/lib/math.ci:481: referenced as `float64`
	cmplStd/lib/math.ci:479: referenced as `float64`
	cmplStd/lib/math.ci:479: referenced as `float64`
	cmplStd/lib/math.ci:462: referenced as `float64`
	cmplStd/lib/math.ci:462: referenced as `float64`
	cmplStd/lib/math.ci:454: referenced as `float64`
	cmplStd/lib/math.ci:454: referenced as `float64`
	cmplStd/lib/math.ci:452: referenced as `float64`
	cmplStd/lib/math.ci:447: referenced as `float64`
	cmplStd/lib/math.ci:447: referenced as `float64`
	cmplStd/lib/math.ci:435: referenced as `float64`
	cmplStd/lib/math.ci:432: referenced as `float64`
	cmplStd/lib/math.ci:432: referenced as `float64`
	cmplStd/lib/math.ci:430: referenced as `float64`
	cmplStd/lib/math.ci:427: referenced as `float64`
	cmplStd/lib/math.ci:410: referenced as `float64`
	cmplStd/lib/math.ci:408: referenced as `float64`
	cmplStd/lib/math.ci:408: referenced as `float64`
	cmplStd/lib/math.ci:392: referenced as `float64`
	cmplStd/lib/math.ci:391: referenced as `float64`
	cmplStd/lib/math.ci:374: referenced as `float64`
	cmplStd/lib/math.ci:373: referenced as `float64`
	cmplStd/lib/math.ci:352: referenced as `float64`
	cmplStd/lib/math.ci:351: referenced as `float64`
	cmplStd/lib/math.ci:351: referenced as `float64`
	cmplStd/lib/math.ci:348: referenced as `float64`
	cmplStd/lib/math.ci:345: referenced as `float64`
	cmplStd/lib/math.ci:340: referenced as `float64`
	cmplStd/lib/math.ci:339: referenced as `float64`
	cmplStd/lib/math.ci:338: referenced as `float64`
	cmplStd/lib/math.ci:321: referenced as `float64`
	cmplStd/lib/math.ci:317: referenced as `float64`
	cmplStd/lib/math.ci:314: referenced as `float64`
	cmplStd/lib/math.ci:308: referenced as `float64`
	cmplStd/lib/math.ci:295: referenced as `float64`
	cmplStd/lib/math.ci:294: referenced as `float64`
	cmplStd/lib/math.ci:294: referenced as `float64`
	cmplStd/lib/math.ci:279: referenced as `float64`
	cmplStd/lib/math.ci:279: referenced as `float64`
	cmplStd/lib/math.ci:279: referenced as `float64`
	cmplStd/lib/math.ci:256: referenced as `float64`
	cmplStd/lib/math.ci:255: referenced as `float64`
	cmplStd/lib/math.ci:255: referenced as `float64`
	cmplStd/lib/math.ci:255: referenced as `float64`
	cmplStd/lib/math.ci:252: referenced as `float64`
	cmplStd/lib/math.ci:252: referenced as `float64`
	cmplStd/lib/math.ci:252: referenced as `float64`
	cmplStd/lib/math.ci:252: referenced as `float64`
	cmplStd/lib/math.ci:252: referenced as `float64`
	cmplStd/lib/math.ci:249: referenced as `float64`
	cmplStd/lib/math.ci:249: referenced as `float64`
	cmplStd/lib/math.ci:249: referenced as `float64`
	cmplStd/lib/math.ci:249: referenced as `float64`
	cmplStd/lib/math.ci:246: referenced as `float64`
	cmplStd/lib/math.ci:246: referenced as `float64`
	cmplStd/lib/math.ci:246: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:243: referenced as `float64`
	cmplStd/lib/math.ci:238: referenced as `float64`
	cmplStd/lib/math.ci:238: referenced as `float64`
	cmplStd/lib/math.ci:230: referenced as `float64`
	cmplStd/lib/math.ci:229: referenced as `float64`
	cmplStd/lib/math.ci:229: referenced as `float64`
	cmplStd/lib/math.ci:219: referenced as `float64`
	cmplStd/lib/math.ci:215: referenced as `float64`
	cmplStd/lib/math.ci:215: referenced as `float64`
	cmplStd/lib/math.ci:205: referenced as `float64`
	cmplStd/lib/math.ci:201: referenced as `float64`
	cmplStd/lib/math.ci:201: referenced as `float64`
	cmplStd/lib/math.ci:198: referenced as `float64`
	cmplStd/lib/math.ci:198: referenced as `float64`
	cmplStd/lib/math.ci:198: referenced as `float64`
	cmplStd/lib/math.ci:198: referenced as `float64`
	cmplStd/lib/math.ci:198: referenced as `float64`
	cmplStd/lib/math.ci:192: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:189: referenced as `float64`
	cmplStd/lib/math.ci:170: referenced as `float64`
	cmplStd/lib/math.ci:170: referenced as `float64`
	cmplStd/lib/math.ci:170: referenced as `float64`
	cmplStd/lib/math.ci:170: referenced as `float64`
	cmplStd/lib/math.ci:145: referenced as `float64`
	cmplStd/lib/math.ci:145: referenced as `float64`
	cmplStd/lib/math.ci:145: referenced as `float64`
	cmplStd/lib/math.ci:123: referenced as `float64`
	cmplStd/lib/math.ci:123: referenced as `float64`
	cmplStd/lib/math.ci:123: referenced as `float64`
	cmplStd/lib/math.ci:101: referenced as `float64`
	cmplStd/lib/math.ci:101: referenced as `float64`
	cmplStd/lib/math.ci:101: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:85: referenced as `float64`
	cmplStd/lib/math.ci:67: referenced as `float64`
	cmplStd/lib/math.ci:57: referenced as `float64`
	cmplStd/lib/math.ci:54: referenced as `float64`
	cmplStd/lib/math.ci:48: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:47: referenced as `float64`
	cmplStd/lib/math.ci:32: referenced as `float64`
	cmplStd/lib/math.ci:25: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:22: referenced as `float64`
	cmplStd/lib/math.ci:5: referenced as `float64`
	cmplStd/stdlib.ci:10: referenced as `float64`
	internal usages: 18
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00c9e0>
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(39)
.usages:
	cmplStd/test/std/number.ci:37: referenced as `sin`
	cmplStd/lib/math/Complex.ci:187: referenced as `sin`
	cmplStd/lib/math/Complex.ci:151: referenced as `sin`
	cmplStd/lib/math/Complex.ci:149: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:129: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00cbf0>
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(40)
.usages:
	cmplStd/test/std/number.ci:38: referenced as `cos`
	cmplStd/lib/math/Complex.ci:187: referenced as `cos`
	cmplStd/lib/math/Complex.ci:151: referenced as `cos`
	cmplStd/lib/math/Complex.ci:149: referenced as `cos`
	cmplStd/lib/math/Complex.ci:141: referenced as `cos`
	cmplStd/lib/math/Complex.ci:129: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00ce00>
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(41)
.usages:
	cmplStd/test/std/number.ci:39: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d010>
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(42)
.usages:
	cmplStd/test/std/number.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:138: referenced as `log`
	cmplStd/lib/math/Complex.ci:132: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d220>
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(43)
.usages:
	cmplStd/test/std/number.ci:41: referenced as `exp`
	cmplStd/lib/math/Complex.ci:139: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math.ci:454: referenced as `exp`
	cmplStd/lib/math.ci:454: referenced as `exp`
	cmplStd/lib/math.ci:452: referenced as `exp`
	cmplStd/lib/math.ci:432: referenced as `exp`
	cmplStd/lib/math.ci:432: referenced as `exp`
	cmplStd/lib/math.ci:427: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d4d0>
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(44)
.usages:
	cmplStd/test/std/number.ci:42: referenced as `pow`
	cmplStd/lib/string.ci:253: referenced as `pow`
	cmplStd/lib/math/Complex.ci:139: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d6e0>
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: nfc(45)
.usages:
	cmplStd/test/std/number.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:112: referenced as `sqrt`
	cmplStd/lib/math.ci:479: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@00d990>
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, offs: <+8>, cast: inline)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+16>, cast: variable(f64))
.value: nfc(46)
.usages:
	cmplStd/test/std/number.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:114: referenced as `atan2`
	cmplStd/lib/math.ci:484: referenced as `atan2`
	cmplStd/lib/math.ci:481: referenced as `atan2`
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000940>
.name: 'pointer'
.field alloc: function (size: 0, offs: <@0084f0>, cast: static const inline)
.field fill: function (size: 0, offs: <@008850>, cast: static const inline)
.field copy: function (size: 0, offs: <@008bb0>, cast: static const inline)
.field move: function (size: 0, offs: <@008f08>, cast: static const inline)
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:43: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:38: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:24: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:20: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:14: referenced as `pointer`
	cmplStd/test/std/tryExec.ci:11: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:30: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:29: referenced as `pointer`
	cmplStd/test/std/memory.ci:14: referenced as `pointer`
	cmplStd/test/std/memory.ci:13: referenced as `pointer`
	cmplStd/test/std/memory.ci:10: referenced as `pointer`
	cmplStd/test/std/memory.ci:9: referenced as `pointer`
	cmplStd/test/std/memory.ci:8: referenced as `pointer`
	cmplStd/test/std/memory.ci:7: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:5: referenced as `pointer`
	cmplStd/test/std/memory.ci:4: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/std/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:29: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0084f0>
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: nfc(10)
.usages:
	cmplStd/test/std/memory.ci:5: referenced as `alloc`
	cmplStd/test/std/memory.ci:4: referenced as `alloc`
	cmplStd/test/std/memory.ci:3: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008850>
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param value: uint8 (size: 4, offs: <+8>, cast: variable(u32))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(11)
.usages:
	cmplStd/test/std/memory.ci:30: referenced as `fill`
	cmplStd/test/std/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008bb0>
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(12)
.usages:
	cmplStd/test/std/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008f08>
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param dst: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param src: pointer (size: 4, offs: <+8>, cast: variable(ref))
.param size: int32 (size: 4, offs: <+12>, cast: variable(i32))
.value: nfc(13)
.usages:
	cmplStd/test/std/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.offset: <@0009e8>
.name: 'variant'
.field as: function (size: 0, offs: <@006198>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplStd/lib/debug.ci:65: referenced as `variant`
	cmplStd/lib/debug.ci:56: referenced as `variant`
	cmplStd/lib/debug.ci:53: referenced as `variant`
	cmplStd/lib/debug.ci:50: referenced as `variant`
	cmplStd/lib/debug.ci:41: referenced as `variant`
	cmplStd/lib/debug.ci:34: referenced as `variant`
	cmplStd/lib/debug.ci:29: referenced as `variant`
	cmplStd/lib/debug.ci:24: referenced as `variant`
	cmplStd/lib/debug.ci:19: referenced as `variant`
	cmplStd/lib/debug.ci:14: referenced as `variant`
	cmplStd/lib/debug.ci:9: referenced as `variant`
	cmplStd/lib/debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006198>
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param var: variant (size: 8, offs: <+8>, cast: variable(var))
.param type: typename (size: 4, offs: <+12>, cast: variable(ref))
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000a90>
.name: 'function'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/stdlib.ci:39: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.offset: <@000b40>
.name: 'object'
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	internal usages: 1
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.offset: <@000000>
.name: 'null'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `null`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.array.ci:60: referenced as `null`
	cmplStd/test/lang/init.array.ci:19: referenced as `null`
	cmplStd/test/lang/init.array.ci:18: referenced as `null`
	cmplStd/test/lang/init.array.ci:2: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/std/tryExec.ci:53: referenced as `null`
	cmplStd/test/std/tryExec.ci:52: referenced as `null`
	cmplStd/test/std/tryExec.ci:51: referenced as `null`
	cmplStd/test/std/tryExec.ci:50: referenced as `null`
	cmplStd/test/std/tryExec.ci:49: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:48: referenced as `null`
	cmplStd/test/std/tryExec.ci:47: referenced as `null`
	cmplStd/test/std/tryExec.ci:39: referenced as `null`
	cmplStd/test/std/memory.ci:4: referenced as `null`
	cmplStd/lib/string.ci:5: referenced as `null`
	cmplStd/lib/debug.ci:74: referenced as `null`
	cmplStd/lib/debug.ci:56: referenced as `null`
	cmplStd/lib/debug.ci:38: referenced as `null`
	cmplStd/lib/debug.ci:36: referenced as `null`
	cmplStd/lib/debug.ci:31: referenced as `null`
	cmplStd/lib/debug.ci:26: referenced as `null`
	cmplStd/lib/debug.ci:21: referenced as `null`
	cmplStd/lib/debug.ci:16: referenced as `null`
	cmplStd/lib/debug.ci:11: referenced as `null`
	cmplStd/lib/debug.ci:6: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.offset: <@000de0>
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.offset: <@000e88>
.name: 'emit'
.field nop: void (size: 0, offs: <@000000>, cast: static const inline)
.field not: bool (size: 0, offs: <@000000>, cast: static const inline)
.field set: void (size: 0, offs: <@000000>, cast: static const inline)
.field ret: void (size: 0, offs: <@000000>, cast: static const inline)
.field call: void (size: 0, offs: <@000000>, cast: static const inline)
.field p4x: typename (size: 16, offs: <@001278>, cast: static const typename(val))
.field dup: typename (size: 0, offs: <@001320>, cast: static const typename(void))
.field load: typename (size: 0, offs: <@0015c0>, cast: static const typename(void))
.field store: typename (size: 0, offs: <@001ba8>, cast: static const typename(void))
.field cmt: typename (size: 0, offs: <@001f70>, cast: static const typename(void))
.field and: typename (size: 0, offs: <@002168>, cast: static const typename(void))
.field or: typename (size: 0, offs: <@002350>, cast: static const typename(void))
.field xor: typename (size: 0, offs: <@002538>, cast: static const typename(void))
.field shl: typename (size: 0, offs: <@002720>, cast: static const typename(void))
.field shr: typename (size: 0, offs: <@002908>, cast: static const typename(void))
.field neg: typename (size: 0, offs: <@002c30>, cast: static const typename(void))
.field add: typename (size: 0, offs: <@0030b8>, cast: static const typename(void))
.field sub: typename (size: 0, offs: <@003520>, cast: static const typename(void))
.field mul: typename (size: 0, offs: <@003988>, cast: static const typename(void))
.field div: typename (size: 0, offs: <@003f30>, cast: static const typename(void))
.field mod: typename (size: 0, offs: <@0044d8>, cast: static const typename(void))
.field ceq: typename (size: 0, offs: <@004940>, cast: static const typename(void))
.field clt: typename (size: 0, offs: <@004da8>, cast: static const typename(void))
.field cgt: typename (size: 0, offs: <@005210>, cast: static const typename(void))
.field min: typename (size: 0, offs: <@005678>, cast: static const typename(void))
.field max: typename (size: 0, offs: <@005860>, cast: static const typename(void))
.field swz: typename (size: 0, offs: <@005a48>, cast: static const typename(void))
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:29: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:76: referenced as `emit`
	cmplStd/lib/math/Complex.ci:69: referenced as `emit`
	cmplStd/lib/math/Complex.ci:62: referenced as `emit`
	cmplStd/lib/math/Complex.ci:59: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'set'
.owner: emit
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'ret'
.owner: emit
.value: ret
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@001278>
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dp4: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field dph: float32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:112: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:120: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:116: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001320>
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field x2: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field x4: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x1'
.owner: emit.dup
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.dup
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'x4'
.owner: emit.dup
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0015c0>
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field z64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field z128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field i8: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i16: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field i128: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'z32'
.owner: emit.load
.value: load.z32
.usages:
	cmplStd/test/std/tryExec.ci:44: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'z64'
.owner: emit.load
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001ba8>
.name: 'store'
.owner: emit
.field i8: void (size: 0, offs: <@000000>, cast: static const inline)
.field i16: void (size: 0, offs: <@000000>, cast: static const inline)
.field i32: void (size: 0, offs: <@000000>, cast: static const inline)
.field i64: void (size: 0, offs: <@000000>, cast: static const inline)
.field i128: void (size: 0, offs: <@000000>, cast: static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.offset: <@000000>
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@001f70>
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002168>
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002350>
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002538>
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002720>
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002908>
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@002c30>
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:59: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0030b8>
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:77: referenced as `add`
	cmplStd/lib/math/Complex.ci:62: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.add
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.add
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:77: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.add
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.add
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:62: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003520>
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:78: referenced as `sub`
	cmplStd/lib/math/Complex.ci:69: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.sub
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:69: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003988>
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:78: referenced as `mul`
	cmplStd/lib/math/Complex.ci:77: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:78: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:77: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@003f30>
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.div
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.div
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.div
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.div
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0044d8>
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, offs: <@000000>, cast: static const inline)
.field i64: int64 (size: 0, offs: <@000000>, cast: static const inline)
.field u32: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field u64: uint32 (size: 0, offs: <@000000>, cast: static const inline)
.field f32: float32 (size: 0, offs: <@000000>, cast: static const inline)
.field f64: float64 (size: 0, offs: <@000000>, cast: static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004940>
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p4f: bool (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: bool (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@004da8>
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005210>
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field i64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field u64: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f32: bool (size: 0, offs: <@000000>, cast: static const inline)
.field f64: bool (size: 0, offs: <@000000>, cast: static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005678>
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.min
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:100: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.min
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005860>
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.field p2d: emit.p4x (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p4f'
.owner: emit.max
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:102: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.offset: <@000000>
.name: 'p2d'
.owner: emit.max
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@005a48>
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, offs: <@000000>, cast: static const inline)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `swz`
	cmplStd/lib/math/Complex.ci:77: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.offset: <@000000>
.name: 'x2'
.owner: emit.swz
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:78: referenced as `x2`
	cmplStd/lib/math/Complex.ci:77: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@005ed8>
.name: 'halt'
.param .result: void (size: 0, offs: <+0>, cast: inline)
.value: nfc(0)
.usages:
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0078e0>
.name: 'raise'
.field abort: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field error: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field warn: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field info: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field debug: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field verbose: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field noTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field defTrace: int64 (size: 0, offs: <@000000>, cast: static const i64)
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param file: char[*] (size: 4, offs: <+4>, cast: const variable(ref))
.param line: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param level: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param trace: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.param inspect: variant (size: 8, offs: <+28>, cast: const variable(var))
.doc: 'Report messages or raise errors.'
.value: nfc(8)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:71: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:38: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:36: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:34: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:31: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:29: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:26: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:24: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:21: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:19: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:16: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:14: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:11: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:9: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:6: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/lib/debug.ci:4: referenced as `raise`
	cmplStd/stdlib.ci:39: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
.usages:
	cmplStd/lib/debug.ci:71: referenced as `abort`
	cmplStd/lib/debug.ci:38: referenced as `abort`
	cmplStd/lib/debug.ci:36: referenced as `abort`
	cmplStd/lib/debug.ci:34: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
.usages:
	cmplStd/lib/debug.ci:31: referenced as `error`
	cmplStd/lib/debug.ci:29: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
.usages:
	cmplStd/lib/debug.ci:26: referenced as `warn`
	cmplStd/lib/debug.ci:24: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
.usages:
	cmplStd/lib/debug.ci:21: referenced as `info`
	cmplStd/lib/debug.ci:19: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/debug.ci:16: referenced as `debug`
	cmplStd/lib/debug.ci:14: referenced as `debug`
	cmplStd/lib/debug.ci:11: referenced as `debug`
	cmplStd/lib/debug.ci:9: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
.usages:
	cmplStd/lib/debug.ci:6: referenced as `verbose`
	cmplStd/lib/debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
.usages:
	cmplStd/lib/debug.ci:26: referenced as `noTrace`
	cmplStd/lib/debug.ci:24: referenced as `noTrace`
	cmplStd/lib/debug.ci:21: referenced as `noTrace`
	cmplStd/lib/debug.ci:19: referenced as `noTrace`
	cmplStd/lib/debug.ci:11: referenced as `noTrace`
	cmplStd/lib/debug.ci:9: referenced as `noTrace`
	cmplStd/lib/debug.ci:6: referenced as `noTrace`
	cmplStd/lib/debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.offset: <@000000>
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
.usages:
	cmplStd/lib/debug.ci:71: referenced as `defTrace`
	cmplStd/lib/debug.ci:38: referenced as `defTrace`
	cmplStd/lib/debug.ci:36: referenced as `defTrace`
	cmplStd/lib/debug.ci:34: referenced as `defTrace`
	cmplStd/lib/debug.ci:31: referenced as `defTrace`
	cmplStd/lib/debug.ci:29: referenced as `defTrace`
	cmplStd/lib/debug.ci:16: referenced as `defTrace`
	cmplStd/lib/debug.ci:14: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@008230>
.name: 'tryExec'
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.param action: function (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(9)
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:52: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:51: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:50: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:49: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:48: referenced as `tryExec`
	cmplStd/test/std/tryExec.ci:47: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@008f38>
.name: 'System'
.field exit: function (size: 0, offs: <@0091d0>, cast: static const inline)
.field srand: function (size: 0, offs: <@0093f0>, cast: static const inline)
.field rand: function (size: 0, offs: <@009568>, cast: static const inline)
.field time: function (size: 0, offs: <@0096e0>, cast: static const inline)
.field clock: function (size: 0, offs: <@009858>, cast: static const inline)
.field millis: function (size: 0, offs: <@0099d0>, cast: static const inline)
.field sleep: function (size: 0, offs: <@009be8>, cast: static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0091d0>
.name: 'exit'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param code: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(14)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0093f0>
.name: 'srand'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param seed: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: nfc(15)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009568>
.name: 'rand'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(16)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0096e0>
.name: 'time'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(17)
.usages:
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009858>
.name: 'clock'
.owner: System
.param .result: int32 (size: 4, offs: <+4>, cast: inline)
.value: nfc(18)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0099d0>
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, offs: <+8>, cast: inline)
.value: nfc(19)
.usages:
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@009be8>
.name: 'sleep'
.owner: System
.param .result: void (size: 0, offs: <+0>, cast: inline)
.param millis: int64 (size: 8, offs: <+8>, cast: variable(i64))
.value: nfc(20)
.usages:
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'true'
.file: 'cmplStd/stdlib.ci:4'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplStd/lib/string.ci:57: referenced as `true`
	cmplStd/lib/string.ci:42: referenced as `true`
	cmplStd/lib/math.ci:470: referenced as `true`
	cmplStd/lib/math.ci:423: referenced as `true`
	cmplStd/lib/math.ci:384: referenced as `true`
	cmplStd/lib/math.ci:380: referenced as `true`
	cmplStd/lib/math.ci:369: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.offset: <@000000>
.name: 'false'
.file: 'cmplStd/stdlib.ci:5'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplStd/lib/string.ci:242: referenced as `false`
	cmplStd/lib/string.ci:114: referenced as `false`
	cmplStd/lib/string.ci:54: referenced as `false`
	cmplStd/lib/string.ci:50: referenced as `false`
	cmplStd/lib/string.ci:39: referenced as `false`
	cmplStd/lib/math.ci:468: referenced as `false`
	cmplStd/lib/math.ci:420: referenced as `false`
	cmplStd/lib/math.ci:365: referenced as `false`
	cmplStd/lib/math.ci:364: referenced as `false`
}
byte: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'byte'
.file: 'cmplStd/stdlib.ci:8'
.value: uint8
.usages:
}
float: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'float'
.file: 'cmplStd/stdlib.ci:9'
.value: float32
.usages:
}
double: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'double'
.file: 'cmplStd/stdlib.ci:10'
.value: float64
.usages:
}
signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:13'
.param .result: int8 (size: 1, offs: <+0>, cast: i32)
.param value: uint8 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:16'
.param .result: int16 (size: 2, offs: <+0>, cast: i32)
.param value: uint16 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: uint32 (size: 4, offs: <+4>, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math.ci:239: referenced as `signed`
}
signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'signed'
.file: 'cmplStd/stdlib.ci:22'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: uint64 (size: 8, offs: <+8>, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:25'
.param .result: uint8 (size: 1, offs: <+0>, cast: u32)
.param value: int8 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:28'
.param .result: uint16 (size: 2, offs: <+0>, cast: u32)
.param value: int16 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:31'
.param .result: uint32 (size: 4, offs: <+0>, cast: u32)
.param value: int32 (size: 4, offs: <+4>, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'unsigned'
.file: 'cmplStd/stdlib.ci:34'
.param .result: uint64 (size: 8, offs: <+0>, cast: u64)
.param value: int64 (size: 8, offs: <+8>, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
sizeof(type: typename): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sizeof'
.file: 'cmplStd/stdlib.ci:37'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param type: typename (size: 4, offs: <+4>, cast: ref)
.doc: 'Returns the size of the given type'
.value: int32(type.size)
.usages:
	cmplStd/test/lang/reflect.ci:40: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:33: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/std/memory.ci:30: referenced as `sizeof`
	cmplStd/test/std/memory.ci:29: referenced as `sizeof`
}
verbose(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), inspect))
.usages:
}
verbose(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'verbose'
.file: 'cmplStd/lib/debug.ci:6'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `verbose` logging level'
.value: raise(void(void(void(raise.verbose, raise.noTrace), message), null))
.usages:
}
debug(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:9'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), inspect))
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/lang/init.array.ci:41: referenced as `debug`
	cmplStd/test/lang/init.array.ci:38: referenced as `debug`
	cmplStd/test/lang/init.array.ci:35: referenced as `debug`
	cmplStd/test/std/memory.ci:33: referenced as `debug`
	cmplStd/test/std/memory.ci:32: referenced as `debug`
	cmplStd/test/std/memory.ci:27: referenced as `debug`
	cmplStd/test/std/memory.ci:26: referenced as `debug`
}
debug(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'debug'
.file: 'cmplStd/lib/debug.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.noTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
}
trace(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `trace`
}
trace(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'trace'
.file: 'cmplStd/lib/debug.ci:16'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(void(void(void(raise.debug, raise.defTrace), message), null))
.usages:
}
info(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:19'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), inspect))
.usages:
}
info(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'info'
.file: 'cmplStd/lib/debug.ci:21'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `info` logging level'
.value: raise(void(void(void(raise.info, raise.noTrace), message), null))
.usages:
}
warn(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), inspect))
.usages:
}
warn(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'warn'
.file: 'cmplStd/lib/debug.ci:26'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message at `warn` logging level'
.value: raise(void(void(void(raise.warn, raise.noTrace), message), null))
.usages:
}
error(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:29'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), inspect))
.usages:
}
error(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'error'
.file: 'cmplStd/lib/debug.ci:31'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(void(void(void(raise.error, raise.defTrace), message), null))
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
}
abort(message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:34'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.param inspect: variant (size: 8, offs: <+12>, cast: const var)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), inspect))
.usages:
	cmplStd/test/std/tryExec.ci:35: referenced as `abort`
	cmplStd/lib/debug.ci:41: referenced as `abort`
}
abort(message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:36'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param message: char[*] (size: 4, offs: <+4>, cast: const ref)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), message), null))
.usages:
	cmplStd/lib/debug.ci:45: referenced as `abort`
	cmplStd/lib/debug.ci:43: referenced as `abort`
}
abort(): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abort'
.file: 'cmplStd/lib/debug.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null))
.usages:
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:41'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.param inspect: variant (size: 8, offs: <+16>, cast: const var)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(void(message, inspect)))
.usages:
	cmplStd/lib/string.ci:162: referenced as `assert`
	cmplStd/lib/string.ci:161: referenced as `assert`
}
assert(condition: bool, message: char[*]): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.param message: char[*] (size: 4, offs: <+8>, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message))
.usages:
}
assert(condition: bool): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assert'
.file: 'cmplStd/lib/debug.ci:45'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param condition: bool (size: 4, offs: <+4>, cast: bool)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort("assertion failed!"))
.usages:
	cmplStd/test/lang/init.array.ci:84: referenced as `assert`
	cmplStd/test/lang/init.array.ci:82: referenced as `assert`
	cmplStd/test/lang/init.array.ci:80: referenced as `assert`
	cmplStd/test/lang/init.array.ci:78: referenced as `assert`
	cmplStd/test/lang/init.array.ci:77: referenced as `assert`
	cmplStd/test/lang/init.array.ci:76: referenced as `assert`
	cmplStd/test/lang/init.array.ci:74: referenced as `assert`
	cmplStd/test/lang/init.array.ci:73: referenced as `assert`
	cmplStd/test/lang/init.array.ci:72: referenced as `assert`
	cmplStd/test/lang/init.array.ci:70: referenced as `assert`
	cmplStd/test/lang/init.array.ci:69: referenced as `assert`
	cmplStd/test/lang/init.array.ci:68: referenced as `assert`
	cmplStd/test/lang/init.array.ci:49: referenced as `assert`
	cmplStd/test/lang/init.array.ci:48: referenced as `assert`
	cmplStd/lib/string.ci:204: referenced as `assert`
	cmplStd/lib/string.ci:197: referenced as `assert`
	cmplStd/lib/string.ci:190: referenced as `assert`
	cmplStd/lib/string.ci:185: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@012348>
.name: 'NotEquals'
.file: 'cmplStd/lib/debug.ci:48'
.field expected: variant (size: 8, offs: <+0>, cast: const variable(var))
.field returned: variant (size: 8, offs: <+8>, cast: const variable(var))
.field extras: variant[] (size: 8, offs: <+16>, cast: const variable(arr))
.doc: '@public'
.usages:
	cmplStd/lib/debug.ci:66: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+0>
.name: 'expected'
.file: 'cmplStd/lib/debug.ci:50'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/debug.ci:67: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.offset: <+8>
.name: 'returned'
.file: 'cmplStd/lib/debug.ci:53'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/debug.ci:68: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.offset: <+16>
.name: 'extras'
.file: 'cmplStd/lib/debug.ci:56'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.value: null
.usages:
	cmplStd/lib/debug.ci:69: referenced as `extras`
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 103
.offset: <@05ed78>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:61'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param expected: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param returned: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param message: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (bool(returned == expected)) {
		return;
	}
	extras: variant[1] := {
		void(extras[0] := (message));
	};
	details: NotEquals := {
		void(details.expected := (expected));
		void(details.returned := (returned));
		void(details.extras := (extras));
	};
	raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
}
.instructions: (103 bytes: <assertEq @05ed78> - <assertEq+103 @05eddf>)
	cmplStd/lib/debug.ci:62: (10 bytes: <assertEq @05ed78> - <assertEq+10 @05ed82>): if (returned == expected)
	<assertEq @05ed78>      : 10 02                      dup.x32 sp(2)
	<assertEq+2 @05ed7a>    : 10 04                      dup.x32 sp(4)
	<assertEq+4 @05ed7c>    : 57                         ceq.i32
	<assertEq+5 @05ed7d>    : 06 05 00 00                jz <assertEq+10 @05ed82>
	cmplStd/lib/debug.ci:63: (1 byte: <assertEq+9 @05ed81> - <assertEq+10 @05ed82>): return;
	<assertEq+9 @05ed81>    : 03                         ret
	cmplStd/lib/debug.ci:65: (13 bytes: <assertEq+10 @05ed82> - <assertEq+23 @05ed8f>): extras: variant[1] := {...}
	<assertEq+10 @05ed82>   : 09 08 00 00                inc.sp(+8)
	cmplStd/lib/debug.ci:65: (9 bytes: <assertEq+14 @05ed86> - <assertEq+23 @05ed8f>): extras[0] := (message);
	<assertEq+14 @05ed86>   : 1f 48 28 01 00             load.ref <@012848>
	<assertEq+19 @05ed8b>   : 10 04                      dup.x32 sp(4)
	<assertEq+21 @05ed8d>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:66: (37 bytes: <assertEq+23 @05ed8f> - <assertEq+60 @05edb4>): details: NotEquals := {...}
	<assertEq+23 @05ed8f>   : 09 18 00 00                inc.sp(+24)
	cmplStd/lib/debug.ci:67: (11 bytes: <assertEq+27 @05ed93> - <assertEq+38 @05ed9e>): details.expected := (expected);
	<assertEq+27 @05ed93>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+32 @05ed98>   : 0a 30 00 00                load.sp(+48)
	<assertEq+36 @05ed9c>   : 14 02                      set.x64 sp(2)
	cmplStd/lib/debug.ci:68: (11 bytes: <assertEq+38 @05ed9e> - <assertEq+49 @05eda9>): details.returned := (returned);
	<assertEq+38 @05ed9e>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<assertEq+43 @05eda3>   : 0a 2c 00 00                load.sp(+44)
	<assertEq+47 @05eda7>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/debug.ci:69: (11 bytes: <assertEq+49 @05eda9> - <assertEq+60 @05edb4>): details.extras := (extras);
	<assertEq+49 @05eda9>   : 1c 01 00 00 00             load.c32 1
	<assertEq+54 @05edae>   : 0a 1c 00 00                load.sp(+28)
	<assertEq+58 @05edb2>   : 14 06                      set.x64 sp(6)
	cmplStd/lib/debug.ci:71: (38 bytes: <assertEq+60 @05edb4> - <assertEq+98 @05edda>): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+60 @05edb4>   : 1f f0 ee 00 00             load.ref <@00eef0> ;"cmplStd/lib/debug.ci"
	<assertEq+65 @05edb9>   : 1c 47 00 00 00             load.c32 71
	<assertEq+70 @05edbe>   : 1c fe ff ff ff             load.c32 -2
	<assertEq+75 @05edc3>   : 1c 80 00 00 00             load.c32 128
	<assertEq+80 @05edc8>   : 1f d0 f1 00 00             load.ref <@00f1d0> ;"assertion failed"
	<assertEq+85 @05edcd>   : 1f 48 23 01 00             load.ref <@012348> ;NotEquals
	<assertEq+90 @05edd2>   : 0a 18 00 00                load.sp(+24)
	<assertEq+94 @05edd6>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+98 @05edda>   : 09 e0 ff ff                inc.sp(-32)
	<assertEq+102 @05edde>  : 03                         ret
.usages:
	cmplStd/lib/debug.ci:74: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'assertEq'
.file: 'cmplStd/lib/debug.ci:74'
.param .result: void (size: 0, offs: <+0>, cast: void)
.param expected: int32 (size: 4, offs: <+4>, cast: i32)
.param returned: int32 (size: 4, offs: <+8>, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(void(void(expected, returned), null))
.usages:
	cmplStd/test/lang/init.array.ci:64: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:63: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:62: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:61: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:60: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:58: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:57: referenced as `assertEq`
	cmplStd/test/lang/init.array.ci:56: referenced as `assertEq`
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.offset: <@0135e0>
.name: 'Math'
.file: 'cmplStd/lib/math.ci:2'
.field pi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field e: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log2E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field ln10: float64 (size: 0, offs: <@000000>, cast: static const val)
.field log10E: float64 (size: 0, offs: <@000000>, cast: static const val)
.field phi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrt2: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtE: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field sqrtPhi: float64 (size: 0, offs: <@000000>, cast: static const val)
.field nan: float64 (size: 0, offs: <@000000>, cast: static const val)
.field inf: float64 (size: 0, offs: <@000000>, cast: static const val)
.field modf: function (size: 86, offs: <@05ede0>, cast: static function)
.field floor: function (size: 24, offs: <@05ee38>, cast: static function)
.field ceil: function (size: 0, offs: <@000000>, cast: static inline)
.field round: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field sign: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 18, offs: <@05ee50>, cast: static function)
.field abs: function (size: 18, offs: <@05ee68>, cast: static function)
.field absMod: function (size: 27, offs: <@05ee80>, cast: static function)
.field absMod: function (size: 27, offs: <@05eea0>, cast: static function)
.field min: function (size: 17, offs: <@05eec0>, cast: static function)
.field min: function (size: 17, offs: <@05eed8>, cast: static function)
.field max: function (size: 17, offs: <@05eef0>, cast: static function)
.field max: function (size: 17, offs: <@05ef08>, cast: static function)
.field clamp: function (size: 30, offs: <@05ef20>, cast: static function)
.field clamp: function (size: 30, offs: <@05ef40>, cast: static function)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field lerp: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field smooth: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 79, offs: <@05ef60>, cast: static function)
.field max: function (size: 79, offs: <@05efb0>, cast: static function)
.field sum: function (size: 40, offs: <@05f000>, cast: static function)
.field mean: function (size: 20, offs: <@05f028>, cast: static function)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 47, offs: <@05f040>, cast: static function)
.field cmp: function (size: 57, offs: <@05f070>, cast: static function)
.field cmp: function (size: 57, offs: <@05f0b0>, cast: static function)
.field sinCos: function (size: 335, offs: <@05f0f0>, cast: static function)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 378, offs: <@05f240>, cast: static function)
.field sinh: function (size: 241, offs: <@05f3c0>, cast: static function)
.field cosh: function (size: 75, offs: <@05f4b8>, cast: static function)
.field asin: function (size: 173, offs: <@05f508>, cast: static function)
.field acos: function (size: 0, offs: <@000000>, cast: static inline)
.field radians: function (size: 0, offs: <@000000>, cast: static inline)
.field degrees: function (size: 0, offs: <@000000>, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `Math`
	cmplStd/test/std/test.math.ci:95: referenced as `Math`
	cmplStd/test/std/test.math.ci:94: referenced as `Math`
	cmplStd/test/std/test.math.ci:93: referenced as `Math`
	cmplStd/test/std/test.math.ci:91: referenced as `Math`
	cmplStd/test/std/test.math.ci:90: referenced as `Math`
	cmplStd/test/std/test.math.ci:89: referenced as `Math`
	cmplStd/test/std/test.math.ci:88: referenced as `Math`
	cmplStd/test/std/test.math.ci:86: referenced as `Math`
	cmplStd/test/std/test.math.ci:85: referenced as `Math`
	cmplStd/test/std/test.math.ci:84: referenced as `Math`
	cmplStd/test/std/test.math.ci:82: referenced as `Math`
	cmplStd/test/std/test.math.ci:81: referenced as `Math`
	cmplStd/test/std/test.math.ci:80: referenced as `Math`
	cmplStd/test/std/test.math.ci:79: referenced as `Math`
	cmplStd/test/std/test.math.ci:77: referenced as `Math`
	cmplStd/test/std/test.math.ci:76: referenced as `Math`
	cmplStd/test/std/test.math.ci:75: referenced as `Math`
	cmplStd/test/std/test.math.ci:74: referenced as `Math`
	cmplStd/test/std/test.math.ci:72: referenced as `Math`
	cmplStd/test/std/test.math.ci:71: referenced as `Math`
	cmplStd/test/std/test.math.ci:70: referenced as `Math`
	cmplStd/test/std/test.math.ci:68: referenced as `Math`
	cmplStd/test/std/test.math.ci:67: referenced as `Math`
	cmplStd/test/std/test.math.ci:64: referenced as `Math`
	cmplStd/test/std/test.math.ci:63: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:61: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:60: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:59: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:58: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:57: referenced as `Math`
	cmplStd/test/std/test.math.ci:55: referenced as `Math`
	cmplStd/test/std/test.math.ci:54: referenced as `Math`
	cmplStd/test/std/test.math.ci:53: referenced as `Math`
	cmplStd/test/std/test.math.ci:52: referenced as `Math`
	cmplStd/test/std/test.math.ci:51: referenced as `Math`
	cmplStd/test/std/test.math.ci:50: referenced as `Math`
	cmplStd/test/std/test.math.ci:49: referenced as `Math`
	cmplStd/test/std/test.math.ci:46: referenced as `Math`
	cmplStd/test/std/test.math.ci:45: referenced as `Math`
	cmplStd/test/std/test.math.ci:44: referenced as `Math`
	cmplStd/test/std/test.math.ci:43: referenced as `Math`
	cmplStd/test/std/test.math.ci:41: referenced as `Math`
	cmplStd/test/std/test.math.ci:40: referenced as `Math`
	cmplStd/test/std/test.math.ci:39: referenced as `Math`
	cmplStd/test/std/test.math.ci:38: referenced as `Math`
	cmplStd/test/std/test.math.ci:36: referenced as `Math`
	cmplStd/test/std/test.math.ci:35: referenced as `Math`
	cmplStd/test/std/test.math.ci:33: referenced as `Math`
	cmplStd/test/std/test.math.ci:32: referenced as `Math`
	cmplStd/test/std/test.math.ci:30: referenced as `Math`
	cmplStd/test/std/test.math.ci:29: referenced as `Math`
	cmplStd/test/std/test.math.ci:27: referenced as `Math`
	cmplStd/test/std/test.math.ci:26: referenced as `Math`
	cmplStd/test/std/test.math.ci:25: referenced as `Math`
	cmplStd/test/std/test.math.ci:24: referenced as `Math`
	cmplStd/test/std/test.math.ci:22: referenced as `Math`
	cmplStd/test/std/test.math.ci:21: referenced as `Math`
	cmplStd/test/std/test.math.ci:20: referenced as `Math`
	cmplStd/test/std/test.math.ci:19: referenced as `Math`
	cmplStd/test/std/test.math.ci:18: referenced as `Math`
	cmplStd/test/std/test.math.ci:17: referenced as `Math`
	cmplStd/test/std/test.math.ci:15: referenced as `Math`
	cmplStd/test/std/test.math.ci:14: referenced as `Math`
	cmplStd/test/std/test.math.ci:13: referenced as `Math`
	cmplStd/test/std/test.math.ci:12: referenced as `Math`
	cmplStd/test/std/test.math.ci:11: referenced as `Math`
	cmplStd/test/std/test.math.ci:10: referenced as `Math`
	cmplStd/test/std/test.math.ci:8: referenced as `Math`
	cmplStd/test/std/test.math.ci:7: referenced as `Math`
	cmplStd/test/std/test.math.ci:6: referenced as `Math`
	cmplStd/test/std/test.math.ci:5: referenced as `Math`
	cmplStd/test/std/test.math.ci:4: referenced as `Math`
	cmplStd/test/std/test.math.ci:3: referenced as `Math`
	cmplStd/lib/string.ci:249: referenced as `Math`
	cmplStd/lib/string.ci:249: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:151: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:149: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
	cmplStd/lib/math/Complex.ci:90: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'pi'
.file: 'cmplStd/lib/math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `pi`
	cmplStd/test/std/test.math.ci:60: referenced as `pi`
	cmplStd/test/std/test.math.ci:59: referenced as `pi`
	cmplStd/test/std/test.math.ci:58: referenced as `pi`
	cmplStd/test/std/test.math.ci:57: referenced as `pi`
	cmplStd/lib/math.ci:524: referenced as `pi`
	cmplStd/lib/math.ci:521: referenced as `pi`
	cmplStd/lib/math.ci:497: referenced as `pi`
	cmplStd/lib/math.ci:481: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'e'
.file: 'cmplStd/lib/math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln2'
.file: 'cmplStd/lib/math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log2E'
.file: 'cmplStd/lib/math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'ln10'
.file: 'cmplStd/lib/math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'log10E'
.file: 'cmplStd/lib/math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'phi'
.file: 'cmplStd/lib/math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrt2'
.file: 'cmplStd/lib/math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtE'
.file: 'cmplStd/lib/math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPi'
.file: 'cmplStd/lib/math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'nan'
.file: 'cmplStd/lib/math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/math.ci:476: referenced as `nan`
	cmplStd/lib/math.ci:397: referenced as `nan`
	cmplStd/lib/math.ci:217: referenced as `nan`
	cmplStd/lib/math.ci:203: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.offset: <@000000>
.name: 'inf'
.file: 'cmplStd/lib/math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 86
.offset: <@05ede0>
.name: 'modf'
.file: 'cmplStd/lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param intPart: float64 (size: 4, offs: <+20>, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (bool(x < (1))) {
		if (bool(x < (0))) {
			result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
			float64(intPart := float64(-intPart));
			return float64(.result := result);
		}
		float64(intPart := (0));
		return float64(.result := x);
	}
	result: float64 := float64(x % (1));
	float64(intPart := float64(x - result));
	return float64(.result := result);
}
.instructions: (86 bytes: <modf @05ede0> - <modf+86 @05ee36>)
	cmplStd/lib/math.ci:23: (63 bytes: <modf @05ede0> - <modf+63 @05ee1f>): if (x < (1))
	<modf @05ede0>      : 11 02                      dup.x64 sp(2)
	<modf+2 @05ede2>    : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+11 @05edeb>   : 88                         clt.f64
	<modf+12 @05edec>   : 06 33 00 00                jz <modf+63 @05ee1f>
	cmplStd/lib/math.ci:24: (39 bytes: <modf+16 @05edf0> - <modf+55 @05ee17>): if (x < (0))
	<modf+16 @05edf0>   : 11 02                      dup.x64 sp(2)
	<modf+18 @05edf2>   : 1a                         load.z64
	<modf+19 @05edf3>   : 88                         clt.f64
	<modf+20 @05edf4>   : 06 23 00 00                jz <modf+55 @05ee17>
	cmplStd/lib/math.ci:25: (17 bytes: <modf+24 @05edf8> - <modf+41 @05ee09>): result: float64 := -modf(-x, &intPart)
	<modf+24 @05edf8>   : 1a                         load.z64
	<modf+25 @05edf9>   : 11 04                      dup.x64 sp(4)
	<modf+27 @05edfb>   : 80                         neg.f64
	<modf+28 @05edfc>   : 10 05                      dup.x32 sp(5)
	<modf+30 @05edfe>   : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<modf+35 @05ee03>   : 02                         call
	<modf+36 @05ee04>   : 09 f4 ff ff                inc.sp(-12)
	<modf+40 @05ee08>   : 80                         neg.f64
	cmplStd/lib/math.ci:26: (7 bytes: <modf+41 @05ee09> - <modf+48 @05ee10>): intPart := -intPart;
	<modf+41 @05ee09>   : 10 03                      dup.x32 sp(3)
	<modf+43 @05ee0b>   : 29                         load.i64
	<modf+44 @05ee0c>   : 80                         neg.f64
	<modf+45 @05ee0d>   : 10 05                      dup.x32 sp(5)
	<modf+47 @05ee0f>   : 2e                         store.i64
	cmplStd/lib/math.ci:27: (3 bytes: <modf+48 @05ee10> - <modf+51 @05ee13>): return .result := result;
	<modf+48 @05ee10>   : 14 06                      set.x64 sp(6)
	<modf+50 @05ee12>   : 03                         ret
	<modf+51 @05ee13>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:29: (4 bytes: <modf+55 @05ee17> - <modf+59 @05ee1b>): intPart := (0);
	<modf+55 @05ee17>   : 1a                         load.z64
	<modf+56 @05ee18>   : 10 03                      dup.x32 sp(3)
	<modf+58 @05ee1a>   : 2e                         store.i64
	cmplStd/lib/math.ci:30: (4 bytes: <modf+59 @05ee1b> - <modf+63 @05ee1f>): return .result := x;
	<modf+59 @05ee1b>   : 17 04 02                   mov.x64 sp(4, 2)
	<modf+62 @05ee1e>   : 03                         ret
	cmplStd/lib/math.ci:32: (12 bytes: <modf+63 @05ee1f> - <modf+75 @05ee2b>): result: float64 := x % (1)
	<modf+63 @05ee1f>   : 11 02                      dup.x64 sp(2)
	<modf+65 @05ee21>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<modf+74 @05ee2a>   : 85                         mod.f64
	cmplStd/lib/math.ci:33: (8 bytes: <modf+75 @05ee2b> - <modf+83 @05ee33>): intPart := x - result;
	<modf+75 @05ee2b>   : 11 04                      dup.x64 sp(4)
	<modf+77 @05ee2d>   : 11 02                      dup.x64 sp(2)
	<modf+79 @05ee2f>   : 82                         sub.f64
	<modf+80 @05ee30>   : 10 05                      dup.x32 sp(5)
	<modf+82 @05ee32>   : 2e                         store.i64
	cmplStd/lib/math.ci:34: (3 bytes: <modf+83 @05ee33> - <modf+86 @05ee36>): return .result := result;
	<modf+83 @05ee33>   : 14 06                      set.x64 sp(6)
	<modf+85 @05ee35>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:249: referenced as `modf`
	cmplStd/lib/math.ci:374: referenced as `modf`
	cmplStd/lib/math.ci:322: referenced as `modf`
	cmplStd/lib/math.ci:318: referenced as `modf`
	cmplStd/lib/math.ci:49: referenced as `modf`
	cmplStd/lib/math.ci:25: referenced as `modf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@05ee38>
.name: 'floor'
.file: 'cmplStd/lib/math.ci:47'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	result: float64;
	modf(void(x, float64(&result)));
	return float64(.result := result);
}
.instructions: (24 bytes: <floor @05ee38> - <floor+24 @05ee50>)
	cmplStd/lib/math.ci:48: (1 byte: <floor @05ee38> - <floor+1 @05ee39>): result: float64
	<floor @05ee38>      : 1b                         load.z128
	cmplStd/lib/math.ci:49: (20 bytes: <floor+1 @05ee39> - <floor+21 @05ee4d>): modf(x, &result);
	<floor+1 @05ee39>    : 11 05                      dup.x64 sp(5)
	<floor+3 @05ee3b>    : 0a 10 00 00                load.sp(+16)
	<floor+7 @05ee3f>    : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<floor+12 @05ee44>   : 02                         call
	<floor+13 @05ee45>   : 09 f4 ff ff                inc.sp(-12)
	<floor+17 @05ee49>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:50: (3 bytes: <floor+21 @05ee4d> - <floor+24 @05ee50>): return .result := result;
	<floor+21 @05ee4d>   : 14 05                      set.x64 sp(5)
	<floor+23 @05ee4f>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:8: referenced as `floor`
	cmplStd/test/std/test.math.ci:7: referenced as `floor`
	cmplStd/test/std/test.math.ci:6: referenced as `floor`
	cmplStd/test/std/test.math.ci:5: referenced as `floor`
	cmplStd/test/std/test.math.ci:4: referenced as `floor`
	cmplStd/test/std/test.math.ci:3: referenced as `floor`
	cmplStd/lib/math.ci:57: referenced as `floor`
	cmplStd/lib/math.ci:54: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceil'
.file: 'cmplStd/lib/math.ci:54'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: float64(-floor(float64(-x)))
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'round'
.file: 'cmplStd/lib/math.ci:57'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(float64(x + 0.500000))
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:64'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:15: referenced as `sign`
	cmplStd/test/std/test.math.ci:14: referenced as `sign`
	cmplStd/test/std/test.math.ci:13: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sign'
.file: 'cmplStd/lib/math.ci:67'
.owner: Math
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(int32(bool(x > (0))) - int32(bool(x < (0))))
.usages:
	cmplStd/test/std/test.math.ci:12: referenced as `sign`
	cmplStd/test/std/test.math.ci:11: referenced as `sign`
	cmplStd/test/std/test.math.ci:10: referenced as `sign`
}
Math.abs(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 18
.offset: <@05ee50>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:77'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float32(.result := float32(-x));
	}
	return float32(.result := x);
}
.instructions: (18 bytes: <abs @05ee50> - <abs+18 @05ee62>)
	cmplStd/lib/math.ci:78: (14 bytes: <abs @05ee50> - <abs+14 @05ee5e>): if (x < (0))
	<abs @05ee50>      : 10 01                      dup.x32 sp(1)
	<abs+2 @05ee52>    : 19                         load.z32
	<abs+3 @05ee53>    : 78                         clt.f32
	<abs+4 @05ee54>    : 06 0a 00 00                jz <abs+14 @05ee5e>
	cmplStd/lib/math.ci:79: (6 bytes: <abs+8 @05ee58> - <abs+14 @05ee5e>): return .result := -x;
	<abs+8 @05ee58>    : 10 01                      dup.x32 sp(1)
	<abs+10 @05ee5a>   : 70                         neg.f32
	<abs+11 @05ee5b>   : 13 03                      set.x32 sp(3)
	<abs+13 @05ee5d>   : 03                         ret
	cmplStd/lib/math.ci:81: (4 bytes: <abs+14 @05ee5e> - <abs+18 @05ee62>): return .result := x;
	<abs+14 @05ee5e>   : 16 02 01                   mov.x32 sp(2, 1)
	<abs+17 @05ee61>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:22: referenced as `abs`
	cmplStd/test/std/test.math.ci:21: referenced as `abs`
	cmplStd/test/std/test.math.ci:20: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 18
.offset: <@05ee68>
.name: 'abs'
.file: 'cmplStd/lib/math.ci:85'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: {
	if (bool(x < (0))) {
		return float64(.result := float64(-x));
	}
	return float64(.result := x);
}
.instructions: (18 bytes: <abs @05ee68> - <abs+18 @05ee7a>)
	cmplStd/lib/math.ci:86: (14 bytes: <abs @05ee68> - <abs+14 @05ee76>): if (x < (0))
	<abs @05ee68>      : 11 01                      dup.x64 sp(1)
	<abs+2 @05ee6a>    : 1a                         load.z64
	<abs+3 @05ee6b>    : 88                         clt.f64
	<abs+4 @05ee6c>    : 06 0a 00 00                jz <abs+14 @05ee76>
	cmplStd/lib/math.ci:87: (6 bytes: <abs+8 @05ee70> - <abs+14 @05ee76>): return .result := -x;
	<abs+8 @05ee70>    : 11 01                      dup.x64 sp(1)
	<abs+10 @05ee72>   : 80                         neg.f64
	<abs+11 @05ee73>   : 14 05                      set.x64 sp(5)
	<abs+13 @05ee75>   : 03                         ret
	cmplStd/lib/math.ci:89: (4 bytes: <abs+14 @05ee76> - <abs+18 @05ee7a>): return .result := x;
	<abs+14 @05ee76>   : 17 03 01                   mov.x64 sp(3, 1)
	<abs+17 @05ee79>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:19: referenced as `abs`
	cmplStd/test/std/test.math.ci:18: referenced as `abs`
	cmplStd/test/std/test.math.ci:17: referenced as `abs`
	cmplStd/lib/string.ci:249: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math/Complex.ci:90: referenced as `abs`
	cmplStd/lib/math.ci:348: referenced as `abs`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@05ee80>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:93'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param val: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param mod: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float32(val := float32(val % mod))) < (0))) {
		return float32(.result := float32(val + mod));
	}
	return float32(.result := val);
}
.instructions: (27 bytes: <absMod @05ee80> - <absMod+27 @05ee9b>)
	cmplStd/lib/math.ci:94: (23 bytes: <absMod @05ee80> - <absMod+23 @05ee97>): if ((val := val % mod) < (0))
	<absMod @05ee80>      : 10 02                      dup.x32 sp(2)
	<absMod+2 @05ee82>    : 10 02                      dup.x32 sp(2)
	<absMod+4 @05ee84>    : 75                         mod.f32
	<absMod+5 @05ee85>    : 10 00                      dup.x32 sp(0)
	<absMod+7 @05ee87>    : 13 04                      set.x32 sp(4)
	<absMod+9 @05ee89>    : 19                         load.z32
	<absMod+10 @05ee8a>   : 78                         clt.f32
	<absMod+11 @05ee8b>   : 06 0c 00 00                jz <absMod+23 @05ee97>
	cmplStd/lib/math.ci:95: (8 bytes: <absMod+15 @05ee8f> - <absMod+23 @05ee97>): return .result := val + mod;
	<absMod+15 @05ee8f>   : 10 02                      dup.x32 sp(2)
	<absMod+17 @05ee91>   : 10 02                      dup.x32 sp(2)
	<absMod+19 @05ee93>   : 71                         add.f32
	<absMod+20 @05ee94>   : 13 04                      set.x32 sp(4)
	<absMod+22 @05ee96>   : 03                         ret
	cmplStd/lib/math.ci:97: (4 bytes: <absMod+23 @05ee97> - <absMod+27 @05ee9b>): return .result := val;
	<absMod+23 @05ee97>   : 16 03 02                   mov.x32 sp(3, 2)
	<absMod+26 @05ee9a>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:96: referenced as `absMod`
	cmplStd/test/std/test.math.ci:95: referenced as `absMod`
	cmplStd/test/std/test.math.ci:94: referenced as `absMod`
	cmplStd/test/std/test.math.ci:93: referenced as `absMod`
	cmplStd/test/std/test.math.ci:91: referenced as `absMod`
	cmplStd/test/std/test.math.ci:90: referenced as `absMod`
	cmplStd/test/std/test.math.ci:89: referenced as `absMod`
	cmplStd/test/std/test.math.ci:88: referenced as `absMod`
	cmplStd/test/std/test.math.ci:86: referenced as `absMod`
	cmplStd/test/std/test.math.ci:85: referenced as `absMod`
	cmplStd/test/std/test.math.ci:84: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.offset: <@05eea0>
.name: 'absMod'
.file: 'cmplStd/lib/math.ci:101'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param val: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param mod: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if (bool((float64(val := float64(val % mod))) < (0))) {
		return float64(.result := float64(val + mod));
	}
	return float64(.result := val);
}
.instructions: (27 bytes: <absMod @05eea0> - <absMod+27 @05eebb>)
	cmplStd/lib/math.ci:102: (23 bytes: <absMod @05eea0> - <absMod+23 @05eeb7>): if ((val := val % mod) < (0))
	<absMod @05eea0>      : 11 03                      dup.x64 sp(3)
	<absMod+2 @05eea2>    : 11 03                      dup.x64 sp(3)
	<absMod+4 @05eea4>    : 85                         mod.f64
	<absMod+5 @05eea5>    : 11 00                      dup.x64 sp(0)
	<absMod+7 @05eea7>    : 14 07                      set.x64 sp(7)
	<absMod+9 @05eea9>    : 1a                         load.z64
	<absMod+10 @05eeaa>   : 88                         clt.f64
	<absMod+11 @05eeab>   : 06 0c 00 00                jz <absMod+23 @05eeb7>
	cmplStd/lib/math.ci:103: (8 bytes: <absMod+15 @05eeaf> - <absMod+23 @05eeb7>): return .result := val + mod;
	<absMod+15 @05eeaf>   : 11 03                      dup.x64 sp(3)
	<absMod+17 @05eeb1>   : 11 03                      dup.x64 sp(3)
	<absMod+19 @05eeb3>   : 81                         add.f64
	<absMod+20 @05eeb4>   : 14 07                      set.x64 sp(7)
	<absMod+22 @05eeb6>   : 03                         ret
	cmplStd/lib/math.ci:105: (4 bytes: <absMod+23 @05eeb7> - <absMod+27 @05eebb>): return .result := val;
	<absMod+23 @05eeb7>   : 17 05 03                   mov.x64 sp(5, 3)
	<absMod+26 @05eeba>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:82: referenced as `absMod`
	cmplStd/test/std/test.math.ci:81: referenced as `absMod`
	cmplStd/test/std/test.math.ci:80: referenced as `absMod`
	cmplStd/test/std/test.math.ci:79: referenced as `absMod`
	cmplStd/test/std/test.math.ci:77: referenced as `absMod`
	cmplStd/test/std/test.math.ci:76: referenced as `absMod`
	cmplStd/test/std/test.math.ci:75: referenced as `absMod`
	cmplStd/test/std/test.math.ci:74: referenced as `absMod`
	cmplStd/test/std/test.math.ci:72: referenced as `absMod`
	cmplStd/test/std/test.math.ci:71: referenced as `absMod`
	cmplStd/test/std/test.math.ci:70: referenced as `absMod`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 17
.offset: <@05eec0>
.name: 'min'
.file: 'cmplStd/lib/math.ci:115'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <min @05eec0> - <min+17 @05eed1>)
	cmplStd/lib/math.ci:116: (13 bytes: <min @05eec0> - <min+13 @05eecd>): if (a < b)
	<min @05eec0>      : 10 02                      dup.x32 sp(2)
	<min+2 @05eec2>    : 10 02                      dup.x32 sp(2)
	<min+4 @05eec4>    : 78                         clt.f32
	<min+5 @05eec5>    : 06 08 00 00                jz <min+13 @05eecd>
	cmplStd/lib/math.ci:117: (4 bytes: <min+9 @05eec9> - <min+13 @05eecd>): return .result := a;
	<min+9 @05eec9>    : 16 03 02                   mov.x32 sp(3, 2)
	<min+12 @05eecc>   : 03                         ret
	cmplStd/lib/math.ci:119: (4 bytes: <min+13 @05eecd> - <min+17 @05eed1>): return .result := b;
	<min+13 @05eecd>   : 16 03 01                   mov.x32 sp(3, 1)
	<min+16 @05eed0>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:24: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 17
.offset: <@05eed8>
.name: 'min'
.file: 'cmplStd/lib/math.ci:123'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(a < b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <min @05eed8> - <min+17 @05eee9>)
	cmplStd/lib/math.ci:124: (13 bytes: <min @05eed8> - <min+13 @05eee5>): if (a < b)
	<min @05eed8>      : 11 03                      dup.x64 sp(3)
	<min+2 @05eeda>    : 11 03                      dup.x64 sp(3)
	<min+4 @05eedc>    : 88                         clt.f64
	<min+5 @05eedd>    : 06 08 00 00                jz <min+13 @05eee5>
	cmplStd/lib/math.ci:125: (4 bytes: <min+9 @05eee1> - <min+13 @05eee5>): return .result := a;
	<min+9 @05eee1>    : 17 05 03                   mov.x64 sp(5, 3)
	<min+12 @05eee4>   : 03                         ret
	cmplStd/lib/math.ci:127: (4 bytes: <min+13 @05eee5> - <min+17 @05eee9>): return .result := b;
	<min+13 @05eee5>   : 17 05 01                   mov.x64 sp(5, 1)
	<min+16 @05eee8>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:26: referenced as `min`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 17
.offset: <@05eef0>
.name: 'max'
.file: 'cmplStd/lib/math.ci:137'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float32(.result := a);
	}
	return float32(.result := b);
}
.instructions: (17 bytes: <max @05eef0> - <max+17 @05ef01>)
	cmplStd/lib/math.ci:138: (13 bytes: <max @05eef0> - <max+13 @05eefd>): if (a > b)
	<max @05eef0>      : 10 02                      dup.x32 sp(2)
	<max+2 @05eef2>    : 10 02                      dup.x32 sp(2)
	<max+4 @05eef4>    : 79                         cgt.f32
	<max+5 @05eef5>    : 06 08 00 00                jz <max+13 @05eefd>
	cmplStd/lib/math.ci:139: (4 bytes: <max+9 @05eef9> - <max+13 @05eefd>): return .result := a;
	<max+9 @05eef9>    : 16 03 02                   mov.x32 sp(3, 2)
	<max+12 @05eefc>   : 03                         ret
	cmplStd/lib/math.ci:141: (4 bytes: <max+13 @05eefd> - <max+17 @05ef01>): return .result := b;
	<max+13 @05eefd>   : 16 03 01                   mov.x32 sp(3, 1)
	<max+16 @05ef00>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:25: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 17
.offset: <@05ef08>
.name: 'max'
.file: 'cmplStd/lib/math.ci:145'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(a > b)) {
		return float64(.result := a);
	}
	return float64(.result := b);
}
.instructions: (17 bytes: <max @05ef08> - <max+17 @05ef19>)
	cmplStd/lib/math.ci:146: (13 bytes: <max @05ef08> - <max+13 @05ef15>): if (a > b)
	<max @05ef08>      : 11 03                      dup.x64 sp(3)
	<max+2 @05ef0a>    : 11 03                      dup.x64 sp(3)
	<max+4 @05ef0c>    : 89                         cgt.f64
	<max+5 @05ef0d>    : 06 08 00 00                jz <max+13 @05ef15>
	cmplStd/lib/math.ci:147: (4 bytes: <max+9 @05ef11> - <max+13 @05ef15>): return .result := a;
	<max+9 @05ef11>    : 17 05 03                   mov.x64 sp(5, 3)
	<max+12 @05ef14>   : 03                         ret
	cmplStd/lib/math.ci:149: (4 bytes: <max+13 @05ef15> - <max+17 @05ef19>): return .result := b;
	<max+13 @05ef15>   : 17 05 01                   mov.x64 sp(5, 1)
	<max+16 @05ef18>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:27: referenced as `max`
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@05ef20>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:159'
.owner: Math
.param .result: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param t: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param a: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float32(.result := a);
	}
	if (bool(t > b)) {
		return float32(.result := b);
	}
	return float32(.result := t);
}
.instructions: (30 bytes: <clamp @05ef20> - <clamp+30 @05ef3e>)
	cmplStd/lib/math.ci:160: (13 bytes: <clamp @05ef20> - <clamp+13 @05ef2d>): if (t < a)
	<clamp @05ef20>      : 10 03                      dup.x32 sp(3)
	<clamp+2 @05ef22>    : 10 03                      dup.x32 sp(3)
	<clamp+4 @05ef24>    : 78                         clt.f32
	<clamp+5 @05ef25>    : 06 08 00 00                jz <clamp+13 @05ef2d>
	cmplStd/lib/math.ci:161: (4 bytes: <clamp+9 @05ef29> - <clamp+13 @05ef2d>): return .result := a;
	<clamp+9 @05ef29>    : 16 04 02                   mov.x32 sp(4, 2)
	<clamp+12 @05ef2c>   : 03                         ret
	cmplStd/lib/math.ci:163: (13 bytes: <clamp+13 @05ef2d> - <clamp+26 @05ef3a>): if (t > b)
	<clamp+13 @05ef2d>   : 10 03                      dup.x32 sp(3)
	<clamp+15 @05ef2f>   : 10 02                      dup.x32 sp(2)
	<clamp+17 @05ef31>   : 79                         cgt.f32
	<clamp+18 @05ef32>   : 06 08 00 00                jz <clamp+26 @05ef3a>
	cmplStd/lib/math.ci:164: (4 bytes: <clamp+22 @05ef36> - <clamp+26 @05ef3a>): return .result := b;
	<clamp+22 @05ef36>   : 16 04 01                   mov.x32 sp(4, 1)
	<clamp+25 @05ef39>   : 03                         ret
	cmplStd/lib/math.ci:166: (4 bytes: <clamp+26 @05ef3a> - <clamp+30 @05ef3e>): return .result := t;
	<clamp+26 @05ef3a>   : 16 04 03                   mov.x32 sp(4, 3)
	<clamp+29 @05ef3d>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:29: referenced as `clamp`
	cmplStd/lib/math.ci:195: referenced as `clamp`
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static function
.base: `function`
.size: 30
.offset: <@05ef40>
.name: 'clamp'
.file: 'cmplStd/lib/math.ci:170'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param t: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param a: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Returns the value of `t` clamped between `a` and `b`'
.value: {
	if (bool(t < a)) {
		return float64(.result := a);
	}
	if (bool(t > b)) {
		return float64(.result := b);
	}
	return float64(.result := t);
}
.instructions: (30 bytes: <clamp @05ef40> - <clamp+30 @05ef5e>)
	cmplStd/lib/math.ci:171: (13 bytes: <clamp @05ef40> - <clamp+13 @05ef4d>): if (t < a)
	<clamp @05ef40>      : 11 05                      dup.x64 sp(5)
	<clamp+2 @05ef42>    : 11 05                      dup.x64 sp(5)
	<clamp+4 @05ef44>    : 88                         clt.f64
	<clamp+5 @05ef45>    : 06 08 00 00                jz <clamp+13 @05ef4d>
	cmplStd/lib/math.ci:172: (4 bytes: <clamp+9 @05ef49> - <clamp+13 @05ef4d>): return .result := a;
	<clamp+9 @05ef49>    : 17 07 03                   mov.x64 sp(7, 3)
	<clamp+12 @05ef4c>   : 03                         ret
	cmplStd/lib/math.ci:174: (13 bytes: <clamp+13 @05ef4d> - <clamp+26 @05ef5a>): if (t > b)
	<clamp+13 @05ef4d>   : 11 05                      dup.x64 sp(5)
	<clamp+15 @05ef4f>   : 11 03                      dup.x64 sp(3)
	<clamp+17 @05ef51>   : 89                         cgt.f64
	<clamp+18 @05ef52>   : 06 08 00 00                jz <clamp+26 @05ef5a>
	cmplStd/lib/math.ci:175: (4 bytes: <clamp+22 @05ef56> - <clamp+26 @05ef5a>): return .result := b;
	<clamp+22 @05ef56>   : 17 07 01                   mov.x64 sp(7, 1)
	<clamp+25 @05ef59>   : 03                         ret
	cmplStd/lib/math.ci:177: (4 bytes: <clamp+26 @05ef5a> - <clamp+30 @05ef5e>): return .result := t;
	<clamp+26 @05ef5a>   : 17 07 05                   mov.x64 sp(7, 5)
	<clamp+29 @05ef5d>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:30: referenced as `clamp`
	cmplStd/lib/math.ci:198: referenced as `clamp`
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:186'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float32(a + float32(t * (float32(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:32: referenced as `lerp`
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'lerp'
.file: 'cmplStd/lib/math.ci:189'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: float64(a + float64(t * (float64(b - a))))
.usages:
	cmplStd/test/std/test.math.ci:33: referenced as `lerp`
}
Math.smooth(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:191'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: variable(f32))
.value: float32(float32(t * t) * (float32((3) - float32((2) * t))))
.usages:
	cmplStd/lib/math.ci:195: referenced as `smooth`
}
Math.smooth(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:192'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: variable(f64))
.value: float64(float64(t * t) * (float64((3) - float64((2) * t))))
.usages:
	cmplStd/lib/math.ci:198: referenced as `smooth`
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:195'
.owner: Math
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param t: float32 (size: 4, offs: <+4>, cast: f32)
.param a: float32 (size: 4, offs: <+4>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))))
.usages:
	cmplStd/test/std/test.math.ci:35: referenced as `smooth`
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'smooth'
.file: 'cmplStd/lib/math.ci:198'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param t: float64 (size: 8, offs: <+8>, cast: f64)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Returns smooth interpolation between `a` and `b` by `t`'
.value: smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))))
.usages:
	cmplStd/test/std/test.math.ci:36: referenced as `smooth`
}
Math.min(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@05ef60>
.name: 'min'
.file: 'cmplStd/lib/math.ci:201'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result > data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <min @05ef60> - <min+79 @05efaf>)
	cmplStd/lib/math.ci:202: (20 bytes: <min @05ef60> - <min+20 @05ef74>): if (data.length == (0))
	<min @05ef60>      : 10 02                      dup.x32 sp(2)
	<min+2 @05ef62>    : 19                         load.z32
	<min+3 @05ef63>    : 57                         ceq.i32
	<min+4 @05ef64>    : 06 10 00 00                jz <min+20 @05ef74>
	cmplStd/lib/math.ci:203: (12 bytes: <min+8 @05ef68> - <min+20 @05ef74>): return .result := nan;
	<min+8 @05ef68>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<min+17 @05ef71>   : 14 05                      set.x64 sp(5)
	<min+19 @05ef73>   : 03                         ret
	cmplStd/lib/math.ci:205: (3 bytes: <min+20 @05ef74> - <min+23 @05ef77>): result: float64 := data[0]
	<min+20 @05ef74>   : 10 01                      dup.x32 sp(1)
	<min+22 @05ef76>   : 29                         load.i64
	cmplStd/lib/math.ci:206: (53 bytes: <min+23 @05ef77> - <min+76 @05efac>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<min+23 @05ef77>   : 1c 01 00 00 00             load.c32 1
	<min+28 @05ef7c>   : 04 23 00 00                jmp <min+63 @05ef9f>
	cmplStd/lib/math.ci:207: (27 bytes: <min+32 @05ef80> - <min+59 @05ef9b>): if (result > data[i])
	<min+32 @05ef80>   : 11 01                      dup.x64 sp(1)
	<min+34 @05ef82>   : 10 06                      dup.x32 sp(6)
	<min+36 @05ef84>   : 10 03                      dup.x32 sp(3)
	<min+38 @05ef86>   : 0d 08 00 00                mad.u32 8
	<min+42 @05ef8a>   : 29                         load.i64
	<min+43 @05ef8b>   : 89                         cgt.f64
	<min+44 @05ef8c>   : 06 0f 00 00                jz <min+59 @05ef9b>
	cmplStd/lib/math.ci:208: (11 bytes: <min+48 @05ef90> - <min+59 @05ef9b>): result := data[i];
	<min+48 @05ef90>   : 10 04                      dup.x32 sp(4)
	<min+50 @05ef92>   : 10 01                      dup.x32 sp(1)
	<min+52 @05ef94>   : 0d 08 00 00                mad.u32 8
	<min+56 @05ef98>   : 29                         load.i64
	<min+57 @05ef99>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:206: (4 bytes: <min+59 @05ef9b> - <min+63 @05ef9f>): i := i + 1
	<min+59 @05ef9b>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:206: (9 bytes: <min+63 @05ef9f> - <min+72 @05efa8>): i < (data.length)
	<min+63 @05ef9f>   : 10 00                      dup.x32 sp(0)
	<min+65 @05efa1>   : 10 06                      dup.x32 sp(6)
	<min+67 @05efa3>   : 58                         clt.i32
	<min+68 @05efa4>   : 05 dc ff ff                jnz <min+32 @05ef80>
	<min+72 @05efa8>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:211: (3 bytes: <min+76 @05efac> - <min+79 @05efaf>): return .result := result;
	<min+76 @05efac>   : 14 05                      set.x64 sp(5)
	<min+78 @05efae>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:39: referenced as `min`
	cmplStd/test/std/test.math.ci:38: referenced as `min`
}
Math.max(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.offset: <@05efb0>
.name: 'max'
.file: 'cmplStd/lib/math.ci:215'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (bool(data.length == (0))) {
		return float64(.result := nan);
	}
	result: float64 := data[0];
	for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
		if (bool(result < data[i])) {
			float64(result := data[i]);
		}
	}
	return float64(.result := result);
}
.instructions: (79 bytes: <max @05efb0> - <max+79 @05efff>)
	cmplStd/lib/math.ci:216: (20 bytes: <max @05efb0> - <max+20 @05efc4>): if (data.length == (0))
	<max @05efb0>      : 10 02                      dup.x32 sp(2)
	<max+2 @05efb2>    : 19                         load.z32
	<max+3 @05efb3>    : 57                         ceq.i32
	<max+4 @05efb4>    : 06 10 00 00                jz <max+20 @05efc4>
	cmplStd/lib/math.ci:217: (12 bytes: <max+8 @05efb8> - <max+20 @05efc4>): return .result := nan;
	<max+8 @05efb8>    : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<max+17 @05efc1>   : 14 05                      set.x64 sp(5)
	<max+19 @05efc3>   : 03                         ret
	cmplStd/lib/math.ci:219: (3 bytes: <max+20 @05efc4> - <max+23 @05efc7>): result: float64 := data[0]
	<max+20 @05efc4>   : 10 01                      dup.x32 sp(1)
	<max+22 @05efc6>   : 29                         load.i64
	cmplStd/lib/math.ci:220: (53 bytes: <max+23 @05efc7> - <max+76 @05effc>): for (i: int32 := 1; i < (data.length); i := i + 1)
	<max+23 @05efc7>   : 1c 01 00 00 00             load.c32 1
	<max+28 @05efcc>   : 04 23 00 00                jmp <max+63 @05efef>
	cmplStd/lib/math.ci:221: (27 bytes: <max+32 @05efd0> - <max+59 @05efeb>): if (result < data[i])
	<max+32 @05efd0>   : 11 01                      dup.x64 sp(1)
	<max+34 @05efd2>   : 10 06                      dup.x32 sp(6)
	<max+36 @05efd4>   : 10 03                      dup.x32 sp(3)
	<max+38 @05efd6>   : 0d 08 00 00                mad.u32 8
	<max+42 @05efda>   : 29                         load.i64
	<max+43 @05efdb>   : 88                         clt.f64
	<max+44 @05efdc>   : 06 0f 00 00                jz <max+59 @05efeb>
	cmplStd/lib/math.ci:222: (11 bytes: <max+48 @05efe0> - <max+59 @05efeb>): result := data[i];
	<max+48 @05efe0>   : 10 04                      dup.x32 sp(4)
	<max+50 @05efe2>   : 10 01                      dup.x32 sp(1)
	<max+52 @05efe4>   : 0d 08 00 00                mad.u32 8
	<max+56 @05efe8>   : 29                         load.i64
	<max+57 @05efe9>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:220: (4 bytes: <max+59 @05efeb> - <max+63 @05efef>): i := i + 1
	<max+59 @05efeb>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:220: (9 bytes: <max+63 @05efef> - <max+72 @05eff8>): i < (data.length)
	<max+63 @05efef>   : 10 00                      dup.x32 sp(0)
	<max+65 @05eff1>   : 10 06                      dup.x32 sp(6)
	<max+67 @05eff3>   : 58                         clt.i32
	<max+68 @05eff4>   : 05 dc ff ff                jnz <max+32 @05efd0>
	<max+72 @05eff8>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:225: (3 bytes: <max+76 @05effc> - <max+79 @05efff>): return .result := result;
	<max+76 @05effc>   : 14 05                      set.x64 sp(5)
	<max+78 @05effe>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:41: referenced as `max`
	cmplStd/test/std/test.math.ci:40: referenced as `max`
}
Math.sum(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.offset: <@05f000>
.name: 'sum'
.file: 'cmplStd/lib/math.ci:229'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
		float64(result := float64(result + data[i]));
	}
	return float64(.result := result);
}
.instructions: (40 bytes: <sum @05f000> - <sum+40 @05f028>)
	cmplStd/lib/math.ci:230: (1 byte: <sum @05f000> - <sum+1 @05f001>): result: float64 := 0
	<sum @05f000>      : 1b                         load.z128
	cmplStd/lib/math.ci:231: (36 bytes: <sum+1 @05f001> - <sum+37 @05f025>): for (i: int32 := 0; i < (data.length); i := i + 1)
	<sum+1 @05f001>    : 6a                         i64.2i32
	<sum+2 @05f002>    : 04 16 00 00                jmp <sum+24 @05f018>
	cmplStd/lib/math.ci:232: (14 bytes: <sum+6 @05f006> - <sum+20 @05f014>): result := result + data[i];
	<sum+6 @05f006>    : 11 01                      dup.x64 sp(1)
	<sum+8 @05f008>    : 10 06                      dup.x32 sp(6)
	<sum+10 @05f00a>   : 10 03                      dup.x32 sp(3)
	<sum+12 @05f00c>   : 0d 08 00 00                mad.u32 8
	<sum+16 @05f010>   : 29                         load.i64
	<sum+17 @05f011>   : 81                         add.f64
	<sum+18 @05f012>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:231: (4 bytes: <sum+20 @05f014> - <sum+24 @05f018>): i := i + 1
	<sum+20 @05f014>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/math.ci:231: (9 bytes: <sum+24 @05f018> - <sum+33 @05f021>): i < (data.length)
	<sum+24 @05f018>   : 10 00                      dup.x32 sp(0)
	<sum+26 @05f01a>   : 10 06                      dup.x32 sp(6)
	<sum+28 @05f01c>   : 58                         clt.i32
	<sum+29 @05f01d>   : 05 e9 ff ff                jnz <sum+6 @05f006>
	<sum+33 @05f021>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:234: (3 bytes: <sum+37 @05f025> - <sum+40 @05f028>): return .result := result;
	<sum+37 @05f025>   : 14 05                      set.x64 sp(5)
	<sum+39 @05f027>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:46: referenced as `sum`
	cmplStd/test/std/test.math.ci:45: referenced as `sum`
	cmplStd/test/std/test.math.ci:44: referenced as `sum`
	cmplStd/test/std/test.math.ci:43: referenced as `sum`
	cmplStd/lib/math.ci:239: referenced as `sum`
}
Math.mean(data: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.offset: <@05f028>
.name: 'mean'
.file: 'cmplStd/lib/math.ci:238'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param data: float64[] (size: 8, offs: <+16>, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
}
.instructions: (20 bytes: <mean @05f028> - <mean+20 @05f03c>)
	cmplStd/lib/math.ci:239: (20 bytes: <mean @05f028> - <mean+20 @05f03c>): return .result := sum(...data) / (signed(data.length));
	<mean @05f028>      : 1a                         load.z64
	<mean+1 @05f029>    : 11 03                      dup.x64 sp(3)
	<mean+3 @05f02b>    : 1f 00 f0 05 00             load.ref <@05f000> ;Math.sum(data: float64[]): float64
	<mean+8 @05f030>    : 02                         call
	<mean+9 @05f031>    : 09 f8 ff ff                inc.sp(-8)
	<mean+13 @05f035>   : 10 04                      dup.x32 sp(4)
	<mean+15 @05f037>   : 5d                         i32.2f64
	<mean+16 @05f038>   : 84                         div.f64
	<mean+17 @05f039>   : 14 05                      set.x64 sp(5)
	<mean+19 @05f03b>   : 03                         ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:243'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (a0)
.usages:
	cmplStd/test/std/test.math.ci:50: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:246'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * a1)))
.usages:
	cmplStd/test/std/test.math.ci:51: referenced as `eval`
	cmplStd/lib/math.ci:249: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:249'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(x, a1), a2)))))
.usages:
	cmplStd/test/std/test.math.ci:52: referenced as `eval`
	cmplStd/lib/math.ci:252: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:252'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param a0: float64 (size: 8, offs: <+16>, cast: f64)
.param a1: float64 (size: 8, offs: <+24>, cast: f64)
.param a2: float64 (size: 8, offs: <+32>, cast: f64)
.param a3: float64 (size: 8, offs: <+40>, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))))
.usages:
	cmplStd/test/std/test.math.ci:53: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.offset: <@05f040>
.name: 'eval'
.file: 'cmplStd/lib/math.ci:255'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param polynomial: float64[] (size: 8, offs: <+24>, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
		float64(result := float64(float64(result * x) + polynomial[i]));
	}
	return float64(.result := result);
}
.instructions: (47 bytes: <eval @05f040> - <eval+47 @05f06f>)
	cmplStd/lib/math.ci:256: (1 byte: <eval @05f040> - <eval+1 @05f041>): result: float64 := 0
	<eval @05f040>      : 1a                         load.z64
	cmplStd/lib/math.ci:257: (43 bytes: <eval+1 @05f041> - <eval+44 @05f06c>): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+1 @05f041>    : 10 04                      dup.x32 sp(4)
	<eval+3 @05f043>    : 0c ff ff ff                inc.i32(-1)
	<eval+7 @05f047>    : 04 19 00 00                jmp <eval+32 @05f060>
	cmplStd/lib/math.ci:258: (17 bytes: <eval+11 @05f04b> - <eval+28 @05f05c>): result := result * x + polynomial[i];
	<eval+11 @05f04b>   : 11 01                      dup.x64 sp(1)
	<eval+13 @05f04d>   : 11 08                      dup.x64 sp(8)
	<eval+15 @05f04f>   : 83                         mul.f64
	<eval+16 @05f050>   : 10 06                      dup.x32 sp(6)
	<eval+18 @05f052>   : 10 03                      dup.x32 sp(3)
	<eval+20 @05f054>   : 0d 08 00 00                mad.u32 8
	<eval+24 @05f058>   : 29                         load.i64
	<eval+25 @05f059>   : 81                         add.f64
	<eval+26 @05f05a>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:257: (4 bytes: <eval+28 @05f05c> - <eval+32 @05f060>): i := i - 1
	<eval+28 @05f05c>   : 0c ff ff ff                inc.i32(-1)
	cmplStd/lib/math.ci:257: (8 bytes: <eval+32 @05f060> - <eval+40 @05f068>): i >= 0
	<eval+32 @05f060>   : 10 00                      dup.x32 sp(0)
	<eval+34 @05f062>   : 19                         load.z32
	<eval+35 @05f063>   : 58                         clt.i32
	<eval+36 @05f064>   : 06 e7 ff ff                jz <eval+11 @05f04b>
	<eval+40 @05f068>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:260: (3 bytes: <eval+44 @05f06c> - <eval+47 @05f06f>): return .result := result;
	<eval+44 @05f06c>   : 14 07                      set.x64 sp(7)
	<eval+46 @05f06e>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `eval`
	cmplStd/test/std/test.math.ci:54: referenced as `eval`
	cmplStd/test/std/test.math.ci:49: referenced as `eval`
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@05f070>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:264'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float32 (size: 4, offs: <+8>, cast: variable(f32))
.param b: float32 (size: 4, offs: <+12>, cast: variable(f32))
.param eps: float32 (size: 4, offs: <+16>, cast: variable(f32))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float32(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float32(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @05f070> - <cmp+57 @05f0a9>)
	cmplStd/lib/math.ci:265: (53 bytes: <cmp @05f070> - <cmp+53 @05f0a5>): if (a < b)
	<cmp @05f070>      : 10 03                      dup.x32 sp(3)
	<cmp+2 @05f072>    : 10 03                      dup.x32 sp(3)
	<cmp+4 @05f074>    : 78                         clt.f32
	<cmp+5 @05f075>    : 06 1c 00 00                jz <cmp+33 @05f091>
	cmplStd/lib/math.ci:266: (20 bytes: <cmp+9 @05f079> - <cmp+29 @05f08d>): if (eps < (b - a))
	<cmp+9 @05f079>    : 10 01                      dup.x32 sp(1)
	<cmp+11 @05f07b>   : 10 03                      dup.x32 sp(3)
	<cmp+13 @05f07d>   : 10 05                      dup.x32 sp(5)
	<cmp+15 @05f07f>   : 72                         sub.f32
	<cmp+16 @05f080>   : 78                         clt.f32
	<cmp+17 @05f081>   : 06 0c 00 00                jz <cmp+29 @05f08d>
	cmplStd/lib/math.ci:267: (8 bytes: <cmp+21 @05f085> - <cmp+29 @05f08d>): return .result := -1;
	<cmp+21 @05f085>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05f08a>   : 13 05                      set.x32 sp(5)
	<cmp+28 @05f08c>   : 03                         ret
	<cmp+29 @05f08d>   : 04 18 00 00                jmp <cmp+53 @05f0a5>
	cmplStd/lib/math.ci:271: (20 bytes: <cmp+33 @05f091> - <cmp+53 @05f0a5>): if (eps < (a - b))
	<cmp+33 @05f091>   : 10 01                      dup.x32 sp(1)
	<cmp+35 @05f093>   : 10 04                      dup.x32 sp(4)
	<cmp+37 @05f095>   : 10 04                      dup.x32 sp(4)
	<cmp+39 @05f097>   : 72                         sub.f32
	<cmp+40 @05f098>   : 78                         clt.f32
	<cmp+41 @05f099>   : 06 0c 00 00                jz <cmp+53 @05f0a5>
	cmplStd/lib/math.ci:272: (8 bytes: <cmp+45 @05f09d> - <cmp+53 @05f0a5>): return .result := +1;
	<cmp+45 @05f09d>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05f0a2>   : 13 05                      set.x32 sp(5)
	<cmp+52 @05f0a4>   : 03                         ret
	cmplStd/lib/math.ci:275: (4 bytes: <cmp+53 @05f0a5> - <cmp+57 @05f0a9>): return .result := 0;
	<cmp+53 @05f0a5>   : 19                         load.z32
	<cmp+54 @05f0a6>   : 13 05                      set.x32 sp(5)
	<cmp+56 @05f0a8>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:67: referenced as `cmp`
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static function
.base: `function`
.size: 57
.offset: <@05f0b0>
.name: 'cmp'
.file: 'cmplStd/lib/math.ci:279'
.owner: Math
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param a: float64 (size: 8, offs: <+12>, cast: variable(f64))
.param b: float64 (size: 8, offs: <+20>, cast: variable(f64))
.param eps: float64 (size: 8, offs: <+28>, cast: variable(f64))
.doc: 'Compare `a` and `b` floating point with `eps` tolerance'
.value: {
	if (bool(a < b)) {
		if (bool(eps < (float64(b - a)))) {
			return int32(.result := int32(-1));
		}
	}
	else if (bool(eps < (float64(a - b)))) {
		return int32(.result := int32(+1));
	}
	return int32(.result := 0);
}
.instructions: (57 bytes: <cmp @05f0b0> - <cmp+57 @05f0e9>)
	cmplStd/lib/math.ci:280: (53 bytes: <cmp @05f0b0> - <cmp+53 @05f0e5>): if (a < b)
	<cmp @05f0b0>      : 11 05                      dup.x64 sp(5)
	<cmp+2 @05f0b2>    : 11 05                      dup.x64 sp(5)
	<cmp+4 @05f0b4>    : 88                         clt.f64
	<cmp+5 @05f0b5>    : 06 1c 00 00                jz <cmp+33 @05f0d1>
	cmplStd/lib/math.ci:281: (20 bytes: <cmp+9 @05f0b9> - <cmp+29 @05f0cd>): if (eps < (b - a))
	<cmp+9 @05f0b9>    : 11 01                      dup.x64 sp(1)
	<cmp+11 @05f0bb>   : 11 05                      dup.x64 sp(5)
	<cmp+13 @05f0bd>   : 11 09                      dup.x64 sp(9)
	<cmp+15 @05f0bf>   : 82                         sub.f64
	<cmp+16 @05f0c0>   : 88                         clt.f64
	<cmp+17 @05f0c1>   : 06 0c 00 00                jz <cmp+29 @05f0cd>
	cmplStd/lib/math.ci:282: (8 bytes: <cmp+21 @05f0c5> - <cmp+29 @05f0cd>): return .result := -1;
	<cmp+21 @05f0c5>   : 1c ff ff ff ff             load.c32 -1
	<cmp+26 @05f0ca>   : 13 08                      set.x32 sp(8)
	<cmp+28 @05f0cc>   : 03                         ret
	<cmp+29 @05f0cd>   : 04 18 00 00                jmp <cmp+53 @05f0e5>
	cmplStd/lib/math.ci:286: (20 bytes: <cmp+33 @05f0d1> - <cmp+53 @05f0e5>): if (eps < (a - b))
	<cmp+33 @05f0d1>   : 11 01                      dup.x64 sp(1)
	<cmp+35 @05f0d3>   : 11 07                      dup.x64 sp(7)
	<cmp+37 @05f0d5>   : 11 07                      dup.x64 sp(7)
	<cmp+39 @05f0d7>   : 82                         sub.f64
	<cmp+40 @05f0d8>   : 88                         clt.f64
	<cmp+41 @05f0d9>   : 06 0c 00 00                jz <cmp+53 @05f0e5>
	cmplStd/lib/math.ci:287: (8 bytes: <cmp+45 @05f0dd> - <cmp+53 @05f0e5>): return .result := +1;
	<cmp+45 @05f0dd>   : 1c 01 00 00 00             load.c32 1
	<cmp+50 @05f0e2>   : 13 08                      set.x32 sp(8)
	<cmp+52 @05f0e4>   : 03                         ret
	cmplStd/lib/math.ci:290: (4 bytes: <cmp+53 @05f0e5> - <cmp+57 @05f0e9>): return .result := 0;
	<cmp+53 @05f0e5>   : 19                         load.z32
	<cmp+54 @05f0e6>   : 13 08                      set.x32 sp(8)
	<cmp+56 @05f0e8>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:68: referenced as `cmp`
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 335
.offset: <@05f0f0>
.name: 'sinCos'
.file: 'cmplStd/lib/math.ci:294'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.param quad: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	x: float64 := arg;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		int32(quad := int32(quad + 2));
	}
	y: float64;
	float64(x := float64(x * float64((1) / PIO2)));
	if (bool(x > (32764))) {
		e: float64;
		float64(y := modf(void(x, float64(&e))));
		float64(e := float64(e + (quad)));
		f: float64;
		modf(void(float64(0.250000 * e), float64(&f)));
		int32(quad := (float64(e - float64((4) * f))));
	}
	else {
		k: int32 := x;
		float64(y := float64(x - (k)));
		int32(quad := int32(quad + k));
		int32(quad := int32(quad & 3));
	}
	if (int32(quad & 1)) {
		float64(y := float64((1) - y));
	}
	if (bool(quad > 1)) {
		float64(y := float64(-y));
	}
	ysq: float64 := float64(y * y);
	temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
	temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
	return float64(.result := float64(temp1 / temp2));
}
.instructions: (335 bytes: <sinCos @05f0f0> - <sinCos+335 @05f23f>)
	cmplStd/lib/math.ci:308: (2 bytes: <sinCos @05f0f0> - <sinCos+2 @05f0f2>): x: float64 := arg
	<sinCos @05f0f0>      : 11 02                      dup.x64 sp(2)
	cmplStd/lib/math.ci:309: (17 bytes: <sinCos+2 @05f0f2> - <sinCos+19 @05f103>): if (x < (0))
	<sinCos+2 @05f0f2>    : 11 00                      dup.x64 sp(0)
	<sinCos+4 @05f0f4>    : 1a                         load.z64
	<sinCos+5 @05f0f5>    : 88                         clt.f64
	<sinCos+6 @05f0f6>    : 06 0d 00 00                jz <sinCos+19 @05f103>
	cmplStd/lib/math.ci:310: (1 byte: <sinCos+10 @05f0fa> - <sinCos+11 @05f0fb>): x := -x;
	<sinCos+10 @05f0fa>   : 80                         neg.f64
	cmplStd/lib/math.ci:311: (8 bytes: <sinCos+11 @05f0fb> - <sinCos+19 @05f103>): quad := quad + 2;
	<sinCos+11 @05f0fb>   : 10 03                      dup.x32 sp(3)
	<sinCos+13 @05f0fd>   : 0c 02 00 00                inc.i32(+2)
	<sinCos+17 @05f101>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math.ci:314: (1 byte: <sinCos+19 @05f103> - <sinCos+20 @05f104>): y: float64
	<sinCos+19 @05f103>   : 1a                         load.z64
	cmplStd/lib/math.ci:315: (24 bytes: <sinCos+20 @05f104> - <sinCos+44 @05f11c>): x := x * (1) / PIO2;
	<sinCos+20 @05f104>   : 11 02                      dup.x64 sp(2)
	<sinCos+22 @05f106>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+31 @05f10f>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<sinCos+40 @05f118>   : 84                         div.f64
	<sinCos+41 @05f119>   : 83                         mul.f64
	<sinCos+42 @05f11a>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:316: (124 bytes: <sinCos+44 @05f11c> - <sinCos+168 @05f198>): if (x > (32764))
	<sinCos+44 @05f11c>   : 11 02                      dup.x64 sp(2)
	<sinCos+46 @05f11e>   : 8f 00 00 00 00 00 ff df 40 load.f64 32764.000000
	<sinCos+55 @05f127>   : 89                         cgt.f64
	<sinCos+56 @05f128>   : 06 54 00 00                jz <sinCos+140 @05f17c>
	cmplStd/lib/math.ci:317: (1 byte: <sinCos+60 @05f12c> - <sinCos+61 @05f12d>): e: float64
	<sinCos+60 @05f12c>   : 1b                         load.z128
	cmplStd/lib/math.ci:318: (18 bytes: <sinCos+61 @05f12d> - <sinCos+79 @05f13f>): y := modf(x, &e);
	<sinCos+61 @05f12d>   : 11 06                      dup.x64 sp(6)
	<sinCos+63 @05f12f>   : 0a 10 00 00                load.sp(+16)
	<sinCos+67 @05f133>   : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+72 @05f138>   : 02                         call
	<sinCos+73 @05f139>   : 09 f4 ff ff                inc.sp(-12)
	<sinCos+77 @05f13d>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:319: (4 bytes: <sinCos+79 @05f13f> - <sinCos+83 @05f143>): e := e + (quad);
	<sinCos+79 @05f13f>   : 10 07                      dup.x32 sp(7)
	<sinCos+81 @05f141>   : 5d                         i32.2f64
	<sinCos+82 @05f142>   : 81                         add.f64
	cmplStd/lib/math.ci:321: (1 byte: <sinCos+83 @05f143> - <sinCos+84 @05f144>): f: float64
	<sinCos+83 @05f143>   : 1b                         load.z128
	cmplStd/lib/math.ci:322: (30 bytes: <sinCos+84 @05f144> - <sinCos+114 @05f162>): modf(0.250000 * e, &f);
	<sinCos+84 @05f144>   : 8f 00 00 00 00 00 00 d0 3f load.f64 0.250000
	<sinCos+93 @05f14d>   : 11 06                      dup.x64 sp(6)
	<sinCos+95 @05f14f>   : 83                         mul.f64
	<sinCos+96 @05f150>   : 0a 10 00 00                load.sp(+16)
	<sinCos+100 @05f154>  : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+105 @05f159>  : 02                         call
	<sinCos+106 @05f15a>  : 09 f4 ff ff                inc.sp(-12)
	<sinCos+110 @05f15e>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:323: (18 bytes: <sinCos+114 @05f162> - <sinCos+132 @05f174>): quad := (e - (4) * f);
	<sinCos+114 @05f162>  : 11 02                      dup.x64 sp(2)
	<sinCos+116 @05f164>  : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<sinCos+125 @05f16d>  : 11 04                      dup.x64 sp(4)
	<sinCos+127 @05f16f>  : 83                         mul.f64
	<sinCos+128 @05f170>  : 82                         sub.f64
	<sinCos+129 @05f171>  : 8a                         f64.2i32
	<sinCos+130 @05f172>  : 13 0a                      set.x32 sp(10)
	<sinCos+132 @05f174>  : 09 f0 ff ff                inc.sp(-16)
	<sinCos+136 @05f178>  : 04 20 00 00                jmp <sinCos+168 @05f198>
	cmplStd/lib/math.ci:326: (3 bytes: <sinCos+140 @05f17c> - <sinCos+143 @05f17f>): k: int32 := x
	<sinCos+140 @05f17c>  : 11 02                      dup.x64 sp(2)
	<sinCos+142 @05f17e>  : 8a                         f64.2i32
	cmplStd/lib/math.ci:327: (8 bytes: <sinCos+143 @05f17f> - <sinCos+151 @05f187>): y := x - (k);
	<sinCos+143 @05f17f>  : 11 03                      dup.x64 sp(3)
	<sinCos+145 @05f181>  : 10 02                      dup.x32 sp(2)
	<sinCos+147 @05f183>  : 5d                         i32.2f64
	<sinCos+148 @05f184>  : 82                         sub.f64
	<sinCos+149 @05f185>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:328: (7 bytes: <sinCos+151 @05f187> - <sinCos+158 @05f18e>): quad := quad + k;
	<sinCos+151 @05f187>  : 10 06                      dup.x32 sp(6)
	<sinCos+153 @05f189>  : 10 01                      dup.x32 sp(1)
	<sinCos+155 @05f18b>  : 51                         add.i32
	<sinCos+156 @05f18c>  : 13 07                      set.x32 sp(7)
	cmplStd/lib/math.ci:329: (6 bytes: <sinCos+158 @05f18e> - <sinCos+164 @05f194>): quad := quad & 3;
	<sinCos+158 @05f18e>  : 10 06                      dup.x32 sp(6)
	<sinCos+160 @05f190>  : 3f 02                      b32.and 0x003
	<sinCos+162 @05f192>  : 13 07                      set.x32 sp(7)
	<sinCos+164 @05f194>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/math.ci:331: (22 bytes: <sinCos+168 @05f198> - <sinCos+190 @05f1ae>): if (quad & 1)
	<sinCos+168 @05f198>  : 10 05                      dup.x32 sp(5)
	<sinCos+170 @05f19a>  : 3f 01                      b32.and 0x001
	<sinCos+172 @05f19c>  : 06 12 00 00                jz <sinCos+190 @05f1ae>
	cmplStd/lib/math.ci:332: (14 bytes: <sinCos+176 @05f1a0> - <sinCos+190 @05f1ae>): y := (1) - y;
	<sinCos+176 @05f1a0>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<sinCos+185 @05f1a9>  : 11 02                      dup.x64 sp(2)
	<sinCos+187 @05f1ab>  : 82                         sub.f64
	<sinCos+188 @05f1ac>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:334: (13 bytes: <sinCos+190 @05f1ae> - <sinCos+203 @05f1bb>): if (quad > 1)
	<sinCos+190 @05f1ae>  : 10 05                      dup.x32 sp(5)
	<sinCos+192 @05f1b0>  : 1c 01 00 00 00             load.c32 1
	<sinCos+197 @05f1b5>  : 59                         cgt.i32
	<sinCos+198 @05f1b6>  : 06 05 00 00                jz <sinCos+203 @05f1bb>
	cmplStd/lib/math.ci:335: (1 byte: <sinCos+202 @05f1ba> - <sinCos+203 @05f1bb>): y := -y;
	<sinCos+202 @05f1ba>  : 80                         neg.f64
	cmplStd/lib/math.ci:338: (5 bytes: <sinCos+203 @05f1bb> - <sinCos+208 @05f1c0>): ysq: float64 := y * y
	<sinCos+203 @05f1bb>  : 11 00                      dup.x64 sp(0)
	<sinCos+205 @05f1bd>  : 11 02                      dup.x64 sp(2)
	<sinCos+207 @05f1bf>  : 83                         mul.f64
	cmplStd/lib/math.ci:339: (64 bytes: <sinCos+208 @05f1c0> - <sinCos+272 @05f200>): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+208 @05f1c0>  : 8f 70 3f 24 be 00 3f 62 40 load.f64 145.968841
	<sinCos+217 @05f1c9>  : 11 02                      dup.x64 sp(2)
	<sinCos+219 @05f1cb>  : 83                         mul.f64
	<sinCos+220 @05f1cc>  : 8f 42 35 46 e1 a2 0b cb c0 load.f64 -13847.272500
	<sinCos+229 @05f1d5>  : 81                         add.f64
	<sinCos+230 @05f1d6>  : 11 02                      dup.x64 sp(2)
	<sinCos+232 @05f1d8>  : 83                         mul.f64
	<sinCos+233 @05f1d9>  : 8f 98 8a d2 36 9c dc 1a 41 load.f64 440103.053538
	<sinCos+242 @05f1e2>  : 81                         add.f64
	<sinCos+243 @05f1e3>  : 11 02                      dup.x64 sp(2)
	<sinCos+245 @05f1e5>  : 83                         mul.f64
	<sinCos+246 @05f1e6>  : 8f 34 31 75 06 0f db 52 c1 load.f64 -4942908.100903
	<sinCos+255 @05f1ef>  : 81                         add.f64
	<sinCos+256 @05f1f0>  : 11 02                      dup.x64 sp(2)
	<sinCos+258 @05f1f2>  : 83                         mul.f64
	<sinCos+259 @05f1f3>  : 8f 57 1d 52 1f 4b e6 69 41 load.f64 13578840.978774
	<sinCos+268 @05f1fc>  : 81                         add.f64
	<sinCos+269 @05f1fd>  : 11 04                      dup.x64 sp(4)
	<sinCos+271 @05f1ff>  : 83                         mul.f64
	cmplStd/lib/math.ci:340: (51 bytes: <sinCos+272 @05f200> - <sinCos+323 @05f233>): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+272 @05f200>  : 11 02                      dup.x64 sp(2)
	<sinCos+274 @05f202>  : 8f 28 fc b3 65 e9 94 60 40 load.f64 132.653491
	<sinCos+283 @05f20b>  : 81                         add.f64
	<sinCos+284 @05f20c>  : 11 04                      dup.x64 sp(4)
	<sinCos+286 @05f20e>  : 83                         mul.f64
	<sinCos+287 @05f20f>  : 8f da 21 0e 4d 8c 7b c2 40 load.f64 9463.096102
	<sinCos+296 @05f218>  : 81                         add.f64
	<sinCos+297 @05f219>  : 11 04                      dup.x64 sp(4)
	<sinCos+299 @05f21b>  : 83                         mul.f64
	<sinCos+300 @05f21c>  : 8f 05 d4 a3 e6 cc e9 18 41 load.f64 408179.225234
	<sinCos+309 @05f225>  : 81                         add.f64
	<sinCos+310 @05f226>  : 11 04                      dup.x64 sp(4)
	<sinCos+312 @05f228>  : 83                         mul.f64
	<sinCos+313 @05f229>  : 8f cd bd e4 d4 f9 7c 60 41 load.f64 8644558.652923
	<sinCos+322 @05f232>  : 81                         add.f64
	cmplStd/lib/math.ci:341: (12 bytes: <sinCos+323 @05f233> - <sinCos+335 @05f23f>): return .result := temp1 / temp2;
	<sinCos+323 @05f233>  : 11 02                      dup.x64 sp(2)
	<sinCos+325 @05f235>  : 11 02                      dup.x64 sp(2)
	<sinCos+327 @05f237>  : 84                         div.f64
	<sinCos+328 @05f238>  : 14 10                      set.x64 sp(16)
	<sinCos+330 @05f23a>  : 09 d8 ff ff                inc.sp(-40)
	<sinCos+334 @05f23e>  : 03                         ret
.usages:
	cmplStd/lib/math.ci:348: referenced as `sinCos`
	cmplStd/lib/math.ci:345: referenced as `sinCos`
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math.ci:345'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the sine of the input'
.value: sinCos(void(arg, 0))
.usages:
	cmplStd/test/std/test.math.ci:57: referenced as `sin`
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math.ci:348'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param arg: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the cosine of the input'
.value: sinCos(void(abs(arg), 1))
.usages:
	cmplStd/test/std/test.math.ci:58: referenced as `cos`
}
Math.tan(arg: float64): float64: function {
.kind: static function
.base: `function`
.size: 378
.offset: <@05f240>
.name: 'tan'
.file: 'cmplStd/lib/math.ci:351'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param arg: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the tangent of the input'
.value: {
	complement: bool := false;
	negate: bool := false;
	if (bool(arg < (0))) {
		float64(arg := float64(-arg));
		bool(negate := true);
	}
	float64(arg := float64(float64((2) * arg) / PIO2));
	e: float64;
	x: float64 := modf(void(arg, float64(&e)));
	i: int32 := int32(int32(e) % 4);
	if (bool(i == 0)) ;
	else if (bool(i == 1)) {
		float64(x := float64((1) - x));
		bool(complement := true);
	}
	else if (bool(i == 2)) {
		bool(negate := bool(!negate));
		bool(complement := true);
	}
	else if (bool(i == 3)) {
		float64(x := float64((1) - x));
		bool(negate := bool(!negate));
	}
	xsq: float64 := float64(x * x);
	result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
	float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
	if (complement) {
		if (bool(result == (0))) {
			return float64(.result := nan);
		}
		float64(result := float64((1) / result));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (378 bytes: <tan @05f240> - <tan+378 @05f3ba>)
	cmplStd/lib/math.ci:364: (1 byte: <tan @05f240> - <tan+1 @05f241>): complement: bool := false
	<tan @05f240>      : 19                         load.z32
	cmplStd/lib/math.ci:365: (1 byte: <tan+1 @05f241> - <tan+2 @05f242>): negate: bool := false
	<tan+1 @05f241>    : 19                         load.z32
	cmplStd/lib/math.ci:367: (23 bytes: <tan+2 @05f242> - <tan+25 @05f259>): if (arg < (0))
	<tan+2 @05f242>    : 11 03                      dup.x64 sp(3)
	<tan+4 @05f244>    : 1a                         load.z64
	<tan+5 @05f245>    : 88                         clt.f64
	<tan+6 @05f246>    : 06 13 00 00                jz <tan+25 @05f259>
	cmplStd/lib/math.ci:368: (5 bytes: <tan+10 @05f24a> - <tan+15 @05f24f>): arg := -arg;
	<tan+10 @05f24a>   : 11 03                      dup.x64 sp(3)
	<tan+12 @05f24c>   : 80                         neg.f64
	<tan+13 @05f24d>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:369: (10 bytes: <tan+15 @05f24f> - <tan+25 @05f259>): negate := true;
	<tan+15 @05f24f>   : 1c 01 00 00 00             load.c32 1
	<tan+20 @05f254>   : 0a 04 00 00                load.sp(+4)
	<tan+24 @05f258>   : 2b                         store.i8
	cmplStd/lib/math.ci:371: (24 bytes: <tan+25 @05f259> - <tan+49 @05f271>): arg := (2) * arg / PIO2;
	<tan+25 @05f259>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<tan+34 @05f262>   : 11 05                      dup.x64 sp(5)
	<tan+36 @05f264>   : 83                         mul.f64
	<tan+37 @05f265>   : 8f 18 2d 44 54 fb 21 f9 3f load.f64 1.570796
	<tan+46 @05f26e>   : 84                         div.f64
	<tan+47 @05f26f>   : 14 05                      set.x64 sp(5)
	cmplStd/lib/math.ci:373: (1 byte: <tan+49 @05f271> - <tan+50 @05f272>): e: float64
	<tan+49 @05f271>   : 1b                         load.z128
	cmplStd/lib/math.ci:374: (16 bytes: <tan+50 @05f272> - <tan+66 @05f282>): x: float64 := modf(arg, &e)
	<tan+50 @05f272>   : 11 07                      dup.x64 sp(7)
	<tan+52 @05f274>   : 0a 10 00 00                load.sp(+16)
	<tan+56 @05f278>   : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<tan+61 @05f27d>   : 02                         call
	<tan+62 @05f27e>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math.ci:375: (9 bytes: <tan+66 @05f282> - <tan+75 @05f28b>): i: int32 := int32(e) % 4
	<tan+66 @05f282>   : 11 02                      dup.x64 sp(2)
	<tan+68 @05f284>   : 8a                         f64.2i32
	<tan+69 @05f285>   : 1c 04 00 00 00             load.c32 4
	<tan+74 @05f28a>   : 55                         mod.i32
	cmplStd/lib/math.ci:377: (122 bytes: <tan+75 @05f28b> - <tan+197 @05f305>): if (i == 0)
	<tan+75 @05f28b>   : 10 00                      dup.x32 sp(0)
	<tan+77 @05f28d>   : 19                         load.z32
	<tan+78 @05f28e>   : 57                         ceq.i32
	<tan+79 @05f28f>   : 05 76 00 00                jnz <tan+197 @05f305>
	cmplStd/lib/math.ci:378: (114 bytes: <tan+83 @05f293> - <tan+197 @05f305>): if (i == 1)
	<tan+83 @05f293>   : 10 00                      dup.x32 sp(0)
	<tan+85 @05f295>   : 1c 01 00 00 00             load.c32 1
	<tan+90 @05f29a>   : 57                         ceq.i32
	<tan+91 @05f29b>   : 06 20 00 00                jz <tan+123 @05f2bb>
	cmplStd/lib/math.ci:379: (14 bytes: <tan+95 @05f29f> - <tan+109 @05f2ad>): x := (1) - x;
	<tan+95 @05f29f>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+104 @05f2a8>  : 11 03                      dup.x64 sp(3)
	<tan+106 @05f2aa>  : 82                         sub.f64
	<tan+107 @05f2ab>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:380: (10 bytes: <tan+109 @05f2ad> - <tan+119 @05f2b7>): complement := true;
	<tan+109 @05f2ad>  : 1c 01 00 00 00             load.c32 1
	<tan+114 @05f2b2>  : 0a 1c 00 00                load.sp(+28)
	<tan+118 @05f2b6>  : 2b                         store.i8
	<tan+119 @05f2b7>  : 04 4e 00 00                jmp <tan+197 @05f305>
	cmplStd/lib/math.ci:382: (74 bytes: <tan+123 @05f2bb> - <tan+197 @05f305>): if (i == 2)
	<tan+123 @05f2bb>  : 10 00                      dup.x32 sp(0)
	<tan+125 @05f2bd>  : 1c 02 00 00 00             load.c32 2
	<tan+130 @05f2c2>  : 57                         ceq.i32
	<tan+131 @05f2c3>  : 06 1d 00 00                jz <tan+160 @05f2e0>
	cmplStd/lib/math.ci:383: (11 bytes: <tan+135 @05f2c7> - <tan+146 @05f2d2>): negate := !negate;
	<tan+135 @05f2c7>  : 0a 14 00 00                load.sp(+20)
	<tan+139 @05f2cb>  : 26                         load.i8
	<tan+140 @05f2cc>  : 0b                         not.b32
	<tan+141 @05f2cd>  : 0a 18 00 00                load.sp(+24)
	<tan+145 @05f2d1>  : 2b                         store.i8
	cmplStd/lib/math.ci:384: (10 bytes: <tan+146 @05f2d2> - <tan+156 @05f2dc>): complement := true;
	<tan+146 @05f2d2>  : 1c 01 00 00 00             load.c32 1
	<tan+151 @05f2d7>  : 0a 1c 00 00                load.sp(+28)
	<tan+155 @05f2db>  : 2b                         store.i8
	<tan+156 @05f2dc>  : 04 29 00 00                jmp <tan+197 @05f305>
	cmplStd/lib/math.ci:386: (37 bytes: <tan+160 @05f2e0> - <tan+197 @05f305>): if (i == 3)
	<tan+160 @05f2e0>  : 10 00                      dup.x32 sp(0)
	<tan+162 @05f2e2>  : 1c 03 00 00 00             load.c32 3
	<tan+167 @05f2e7>  : 57                         ceq.i32
	<tan+168 @05f2e8>  : 06 1d 00 00                jz <tan+197 @05f305>
	cmplStd/lib/math.ci:387: (14 bytes: <tan+172 @05f2ec> - <tan+186 @05f2fa>): x := (1) - x;
	<tan+172 @05f2ec>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+181 @05f2f5>  : 11 03                      dup.x64 sp(3)
	<tan+183 @05f2f7>  : 82                         sub.f64
	<tan+184 @05f2f8>  : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:388: (11 bytes: <tan+186 @05f2fa> - <tan+197 @05f305>): negate := !negate;
	<tan+186 @05f2fa>  : 0a 14 00 00                load.sp(+20)
	<tan+190 @05f2fe>  : 26                         load.i8
	<tan+191 @05f2ff>  : 0b                         not.b32
	<tan+192 @05f300>  : 0a 18 00 00                load.sp(+24)
	<tan+196 @05f304>  : 2b                         store.i8
	cmplStd/lib/math.ci:391: (5 bytes: <tan+197 @05f305> - <tan+202 @05f30a>): xsq: float64 := x * x
	<tan+197 @05f305>  : 11 01                      dup.x64 sp(1)
	<tan+199 @05f307>  : 11 03                      dup.x64 sp(3)
	<tan+201 @05f309>  : 83                         mul.f64
	cmplStd/lib/math.ci:392: (64 bytes: <tan+202 @05f30a> - <tan+266 @05f34a>): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+202 @05f30a>  : 8f 47 ff 55 2d 78 c1 01 3f load.f64 0.000034
	<tan+211 @05f313>  : 11 02                      dup.x64 sp(2)
	<tan+213 @05f315>  : 83                         mul.f64
	<tan+214 @05f316>  : 8f 4d 58 3d af 02 86 a1 3f load.f64 0.034226
	<tan+223 @05f31f>  : 81                         add.f64
	<tan+224 @05f320>  : 11 02                      dup.x64 sp(2)
	<tan+226 @05f322>  : 83                         mul.f64
	<tan+227 @05f323>  : 8f 88 bd 21 b3 82 03 2f c0 load.f64 -15.506857
	<tan+236 @05f32c>  : 81                         add.f64
	<tan+237 @05f32d>  : 11 02                      dup.x64 sp(2)
	<tan+239 @05f32f>  : 83                         mul.f64
	<tan+240 @05f330>  : 8f 6b 25 0f 34 e2 7f 90 40 load.f64 1055.970902
	<tan+249 @05f339>  : 81                         add.f64
	<tan+250 @05f33a>  : 11 02                      dup.x64 sp(2)
	<tan+252 @05f33c>  : 83                         mul.f64
	<tan+253 @05f33d>  : 8f 31 d8 5a f0 19 86 c9 c0 load.f64 -13068.202648
	<tan+262 @05f346>  : 81                         add.f64
	<tan+263 @05f347>  : 11 05                      dup.x64 sp(5)
	<tan+265 @05f349>  : 83                         mul.f64
	cmplStd/lib/math.ci:393: (39 bytes: <tan+266 @05f34a> - <tan+305 @05f371>): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+266 @05f34a>  : 11 02                      dup.x64 sp(2)
	<tan+268 @05f34c>  : 8f 1d 65 00 2b 1b 70 63 c0 load.f64 -155.503316
	<tan+277 @05f355>  : 81                         add.f64
	<tan+278 @05f356>  : 11 04                      dup.x64 sp(4)
	<tan+280 @05f358>  : 83                         mul.f64
	<tan+281 @05f359>  : 8f ba f1 51 59 c0 9d b2 40 load.f64 4765.751363
	<tan+290 @05f362>  : 81                         add.f64
	<tan+291 @05f363>  : 11 04                      dup.x64 sp(4)
	<tan+293 @05f365>  : 83                         mul.f64
	<tan+294 @05f366>  : 8f f4 f7 f2 f3 bc 3f d0 c0 load.f64 -16638.952389
	<tan+303 @05f36f>  : 81                         add.f64
	<tan+304 @05f370>  : 84                         div.f64
	cmplStd/lib/math.ci:395: (47 bytes: <tan+305 @05f371> - <tan+352 @05f3a0>): if (complement)
	<tan+305 @05f371>  : 0a 28 00 00                load.sp(+40)
	<tan+309 @05f375>  : 26                         load.i8
	<tan+310 @05f376>  : 06 2a 00 00                jz <tan+352 @05f3a0>
	cmplStd/lib/math.ci:396: (24 bytes: <tan+314 @05f37a> - <tan+338 @05f392>): if (result == (0))
	<tan+314 @05f37a>  : 11 00                      dup.x64 sp(0)
	<tan+316 @05f37c>  : 1a                         load.z64
	<tan+317 @05f37d>  : 87                         ceq.f64
	<tan+318 @05f37e>  : 06 14 00 00                jz <tan+338 @05f392>
	cmplStd/lib/math.ci:397: (16 bytes: <tan+322 @05f382> - <tan+338 @05f392>): return .result := nan;
	<tan+322 @05f382>  : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<tan+331 @05f38b>  : 14 10                      set.x64 sp(16)
	<tan+333 @05f38d>  : 09 d4 ff ff                inc.sp(-44)
	<tan+337 @05f391>  : 03                         ret
	cmplStd/lib/math.ci:399: (14 bytes: <tan+338 @05f392> - <tan+352 @05f3a0>): result := (1) / result;
	<tan+338 @05f392>  : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<tan+347 @05f39b>  : 11 02                      dup.x64 sp(2)
	<tan+349 @05f39d>  : 84                         div.f64
	<tan+350 @05f39e>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:401: (19 bytes: <tan+352 @05f3a0> - <tan+371 @05f3b3>): if (negate)
	<tan+352 @05f3a0>  : 0a 24 00 00                load.sp(+36)
	<tan+356 @05f3a4>  : 26                         load.i8
	<tan+357 @05f3a5>  : 06 0e 00 00                jz <tan+371 @05f3b3>
	cmplStd/lib/math.ci:402: (10 bytes: <tan+361 @05f3a9> - <tan+371 @05f3b3>): return .result := -result;
	<tan+361 @05f3a9>  : 11 00                      dup.x64 sp(0)
	<tan+363 @05f3ab>  : 80                         neg.f64
	<tan+364 @05f3ac>  : 14 10                      set.x64 sp(16)
	<tan+366 @05f3ae>  : 09 d4 ff ff                inc.sp(-44)
	<tan+370 @05f3b2>  : 03                         ret
	cmplStd/lib/math.ci:404: (7 bytes: <tan+371 @05f3b3> - <tan+378 @05f3ba>): return .result := result;
	<tan+371 @05f3b3>  : 14 0e                      set.x64 sp(14)
	<tan+373 @05f3b5>  : 09 dc ff ff                inc.sp(-36)
	<tan+377 @05f3b9>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:59: referenced as `tan`
}
Math.sinh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 241
.offset: <@05f3c0>
.name: 'sinh'
.file: 'cmplStd/lib/math.ci:408'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the input'
.value: {
	negate: bool := false;
	if (bool(x < (0))) {
		float64(x := float64(-x));
		bool(negate := true);
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	result: float64;
	if (bool(x > 0.500000)) {
		float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
	}
	else {
		sq: float64 := float64(x * x);
		float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
		float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (241 bytes: <sinh @05f3c0> - <sinh+241 @05f4b1>)
	cmplStd/lib/math.ci:420: (1 byte: <sinh @05f3c0> - <sinh+1 @05f3c1>): negate: bool := false
	<sinh @05f3c0>      : 19                         load.z32
	cmplStd/lib/math.ci:421: (23 bytes: <sinh+1 @05f3c1> - <sinh+24 @05f3d8>): if (x < (0))
	<sinh+1 @05f3c1>    : 11 02                      dup.x64 sp(2)
	<sinh+3 @05f3c3>    : 1a                         load.z64
	<sinh+4 @05f3c4>    : 88                         clt.f64
	<sinh+5 @05f3c5>    : 06 13 00 00                jz <sinh+24 @05f3d8>
	cmplStd/lib/math.ci:422: (5 bytes: <sinh+9 @05f3c9> - <sinh+14 @05f3ce>): x := -x;
	<sinh+9 @05f3c9>    : 11 02                      dup.x64 sp(2)
	<sinh+11 @05f3cb>   : 80                         neg.f64
	<sinh+12 @05f3cc>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:423: (10 bytes: <sinh+14 @05f3ce> - <sinh+24 @05f3d8>): negate := true;
	<sinh+14 @05f3ce>   : 1c 01 00 00 00             load.c32 1
	<sinh+19 @05f3d3>   : 0a 04 00 00                load.sp(+4)
	<sinh+23 @05f3d7>   : 2b                         store.i8
	cmplStd/lib/math.ci:426: (39 bytes: <sinh+24 @05f3d8> - <sinh+63 @05f3ff>): if (x > (21))
	<sinh+24 @05f3d8>   : 11 02                      dup.x64 sp(2)
	<sinh+26 @05f3da>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<sinh+35 @05f3e3>   : 89                         cgt.f64
	<sinh+36 @05f3e4>   : 06 1b 00 00                jz <sinh+63 @05f3ff>
	cmplStd/lib/math.ci:427: (23 bytes: <sinh+40 @05f3e8> - <sinh+63 @05f3ff>): return .result := float64.exp(x) / (2);
	<sinh+40 @05f3e8>   : 11 02                      dup.x64 sp(2)
	<sinh+42 @05f3ea>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+46 @05f3ee>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+55 @05f3f7>   : 84                         div.f64
	<sinh+56 @05f3f8>   : 14 06                      set.x64 sp(6)
	<sinh+58 @05f3fa>   : 09 fc ff ff                inc.sp(-4)
	<sinh+62 @05f3fe>   : 03                         ret
	cmplStd/lib/math.ci:430: (1 byte: <sinh+63 @05f3ff> - <sinh+64 @05f400>): result: float64
	<sinh+63 @05f3ff>   : 1a                         load.z64
	cmplStd/lib/math.ci:431: (151 bytes: <sinh+64 @05f400> - <sinh+215 @05f497>): if (x > 0.500000)
	<sinh+64 @05f400>   : 11 04                      dup.x64 sp(4)
	<sinh+66 @05f402>   : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<sinh+75 @05f40b>   : 89                         cgt.f64
	<sinh+76 @05f40c>   : 06 22 00 00                jz <sinh+110 @05f42e>
	cmplStd/lib/math.ci:432: (26 bytes: <sinh+80 @05f410> - <sinh+106 @05f42a>): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+80 @05f410>   : 11 04                      dup.x64 sp(4)
	<sinh+82 @05f412>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+86 @05f416>   : 11 06                      dup.x64 sp(6)
	<sinh+88 @05f418>   : 80                         neg.f64
	<sinh+89 @05f419>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<sinh+93 @05f41d>   : 82                         sub.f64
	<sinh+94 @05f41e>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<sinh+103 @05f427>  : 84                         div.f64
	<sinh+104 @05f428>  : 14 02                      set.x64 sp(2)
	<sinh+106 @05f42a>  : 04 6d 00 00                jmp <sinh+215 @05f497>
	cmplStd/lib/math.ci:435: (5 bytes: <sinh+110 @05f42e> - <sinh+115 @05f433>): sq: float64 := x * x
	<sinh+110 @05f42e>  : 11 04                      dup.x64 sp(4)
	<sinh+112 @05f430>  : 11 06                      dup.x64 sp(6)
	<sinh+114 @05f432>  : 83                         mul.f64
	cmplStd/lib/math.ci:436: (53 bytes: <sinh+115 @05f433> - <sinh+168 @05f468>): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+115 @05f433>  : 8f 79 07 54 e8 3d 4e 3a c0 load.f64 -26.305632
	<sinh+124 @05f43c>  : 11 02                      dup.x64 sp(2)
	<sinh+126 @05f43e>  : 83                         mul.f64
	<sinh+127 @05f43f>  : 8f fb 2d da 36 6c 9c a6 c0 load.f64 -2894.211356
	<sinh+136 @05f448>  : 81                         add.f64
	<sinh+137 @05f449>  : 11 02                      dup.x64 sp(2)
	<sinh+139 @05f44b>  : 83                         mul.f64
	<sinh+140 @05f44c>  : 8f 2d d2 05 86 8b f3 f5 c0 load.f64 -89912.720220
	<sinh+149 @05f455>  : 81                         add.f64
	<sinh+150 @05f456>  : 11 02                      dup.x64 sp(2)
	<sinh+152 @05f458>  : 83                         mul.f64
	<sinh+153 @05f459>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+162 @05f462>  : 81                         add.f64
	<sinh+163 @05f463>  : 11 08                      dup.x64 sp(8)
	<sinh+165 @05f465>  : 83                         mul.f64
	<sinh+166 @05f466>  : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:437: (43 bytes: <sinh+168 @05f468> - <sinh+211 @05f493>): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+168 @05f468>  : 11 02                      dup.x64 sp(2)
	<sinh+170 @05f46a>  : 11 02                      dup.x64 sp(2)
	<sinh+172 @05f46c>  : 8f bb 03 d0 fc b9 b5 65 c0 load.f64 -173.678954
	<sinh+181 @05f475>  : 81                         add.f64
	<sinh+182 @05f476>  : 11 04                      dup.x64 sp(4)
	<sinh+184 @05f478>  : 83                         mul.f64
	<sinh+185 @05f479>  : 8f e1 91 ae 3e 96 b7 cd 40 load.f64 15215.173788
	<sinh+194 @05f482>  : 81                         add.f64
	<sinh+195 @05f483>  : 11 04                      dup.x64 sp(4)
	<sinh+197 @05f485>  : 83                         mul.f64
	<sinh+198 @05f486>  : 8f 4f bb 64 ba de 3f 23 c1 load.f64 -630767.364050
	<sinh+207 @05f48f>  : 81                         add.f64
	<sinh+208 @05f490>  : 84                         div.f64
	<sinh+209 @05f491>  : 14 04                      set.x64 sp(4)
	<sinh+211 @05f493>  : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math.ci:440: (19 bytes: <sinh+215 @05f497> - <sinh+234 @05f4aa>): if (negate)
	<sinh+215 @05f497>  : 0a 08 00 00                load.sp(+8)
	<sinh+219 @05f49b>  : 26                         load.i8
	<sinh+220 @05f49c>  : 06 0e 00 00                jz <sinh+234 @05f4aa>
	cmplStd/lib/math.ci:441: (10 bytes: <sinh+224 @05f4a0> - <sinh+234 @05f4aa>): return .result := -result;
	<sinh+224 @05f4a0>  : 11 00                      dup.x64 sp(0)
	<sinh+226 @05f4a2>  : 80                         neg.f64
	<sinh+227 @05f4a3>  : 14 08                      set.x64 sp(8)
	<sinh+229 @05f4a5>  : 09 f4 ff ff                inc.sp(-12)
	<sinh+233 @05f4a9>  : 03                         ret
	cmplStd/lib/math.ci:443: (7 bytes: <sinh+234 @05f4aa> - <sinh+241 @05f4b1>): return .result := result;
	<sinh+234 @05f4aa>  : 14 06                      set.x64 sp(6)
	<sinh+236 @05f4ac>  : 09 fc ff ff                inc.sp(-4)
	<sinh+240 @05f4b0>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:60: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:151: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:149: referenced as `sinh`
}
Math.cosh(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 75
.offset: <@05f4b8>
.name: 'cosh'
.file: 'cmplStd/lib/math.ci:447'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the input'
.value: {
	if (bool(x < (0))) {
		float64(x := float64(-x));
	}
	if (bool(x > (21))) {
		return float64(.result := float64(float64.exp(x) / (2)));
	}
	return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
}
.instructions: (75 bytes: <cosh @05f4b8> - <cosh+75 @05f503>)
	cmplStd/lib/math.ci:448: (13 bytes: <cosh @05f4b8> - <cosh+13 @05f4c5>): if (x < (0))
	<cosh @05f4b8>      : 11 01                      dup.x64 sp(1)
	<cosh+2 @05f4ba>    : 1a                         load.z64
	<cosh+3 @05f4bb>    : 88                         clt.f64
	<cosh+4 @05f4bc>    : 06 09 00 00                jz <cosh+13 @05f4c5>
	cmplStd/lib/math.ci:449: (5 bytes: <cosh+8 @05f4c0> - <cosh+13 @05f4c5>): x := -x;
	<cosh+8 @05f4c0>    : 11 01                      dup.x64 sp(1)
	<cosh+10 @05f4c2>   : 80                         neg.f64
	<cosh+11 @05f4c3>   : 14 03                      set.x64 sp(3)
	cmplStd/lib/math.ci:451: (35 bytes: <cosh+13 @05f4c5> - <cosh+48 @05f4e8>): if (x > (21))
	<cosh+13 @05f4c5>   : 11 01                      dup.x64 sp(1)
	<cosh+15 @05f4c7>   : 8f 00 00 00 00 00 00 35 40 load.f64 21.000000
	<cosh+24 @05f4d0>   : 89                         cgt.f64
	<cosh+25 @05f4d1>   : 06 17 00 00                jz <cosh+48 @05f4e8>
	cmplStd/lib/math.ci:452: (19 bytes: <cosh+29 @05f4d5> - <cosh+48 @05f4e8>): return .result := float64.exp(x) / (2);
	<cosh+29 @05f4d5>   : 11 01                      dup.x64 sp(1)
	<cosh+31 @05f4d7>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+35 @05f4db>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+44 @05f4e4>   : 84                         div.f64
	<cosh+45 @05f4e5>   : 14 05                      set.x64 sp(5)
	<cosh+47 @05f4e7>   : 03                         ret
	cmplStd/lib/math.ci:454: (27 bytes: <cosh+48 @05f4e8> - <cosh+75 @05f503>): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+48 @05f4e8>   : 11 01                      dup.x64 sp(1)
	<cosh+50 @05f4ea>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+54 @05f4ee>   : 11 03                      dup.x64 sp(3)
	<cosh+56 @05f4f0>   : 80                         neg.f64
	<cosh+57 @05f4f1>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<cosh+61 @05f4f5>   : 81                         add.f64
	<cosh+62 @05f4f6>   : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<cosh+71 @05f4ff>   : 84                         div.f64
	<cosh+72 @05f500>   : 14 05                      set.x64 sp(5)
	<cosh+74 @05f502>   : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:61: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:151: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:149: referenced as `cosh`
}
Math.asin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 173
.offset: <@05f508>
.name: 'asin'
.file: 'cmplStd/lib/math.ci:462'
.owner: Math
.param .result: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param x: float64 (size: 8, offs: <+16>, cast: variable(f64))
.doc: 'Returns the arc sine of the input
 Special cases are:
   Asin(0) = 0
   Asin(x) = NaN if x < -1 or x > 1'
.value: {
	if (bool(x == (0))) {
		return float64(.result := x);
	}
	negate: bool := false;
	if (bool(x < (0))) {
		bool(negate := true);
		float64(x := float64(-x));
	}
	if (bool(x > (1))) {
		return float64(.result := nan);
	}
	result: float64 := float64.sqrt(float64((1) - float64(x * x)));
	if (bool(x > 0.700000)) {
		float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
	}
	else {
		float64(result := float64.atan2(void(x, result)));
	}
	if (negate) {
		return float64(.result := float64(-result));
	}
	return float64(.result := result);
}
.instructions: (173 bytes: <asin @05f508> - <asin+173 @05f5b5>)
	cmplStd/lib/math.ci:463: (12 bytes: <asin @05f508> - <asin+12 @05f514>): if (x == (0))
	<asin @05f508>      : 11 01                      dup.x64 sp(1)
	<asin+2 @05f50a>    : 1a                         load.z64
	<asin+3 @05f50b>    : 87                         ceq.f64
	<asin+4 @05f50c>    : 06 08 00 00                jz <asin+12 @05f514>
	cmplStd/lib/math.ci:465: (4 bytes: <asin+8 @05f510> - <asin+12 @05f514>): return .result := x;
	<asin+8 @05f510>    : 17 03 01                   mov.x64 sp(3, 1)
	<asin+11 @05f513>   : 03                         ret
	cmplStd/lib/math.ci:468: (1 byte: <asin+12 @05f514> - <asin+13 @05f515>): negate: bool := false
	<asin+12 @05f514>   : 19                         load.z32
	cmplStd/lib/math.ci:469: (23 bytes: <asin+13 @05f515> - <asin+36 @05f52c>): if (x < (0))
	<asin+13 @05f515>   : 11 02                      dup.x64 sp(2)
	<asin+15 @05f517>   : 1a                         load.z64
	<asin+16 @05f518>   : 88                         clt.f64
	<asin+17 @05f519>   : 06 13 00 00                jz <asin+36 @05f52c>
	cmplStd/lib/math.ci:470: (10 bytes: <asin+21 @05f51d> - <asin+31 @05f527>): negate := true;
	<asin+21 @05f51d>   : 1c 01 00 00 00             load.c32 1
	<asin+26 @05f522>   : 0a 04 00 00                load.sp(+4)
	<asin+30 @05f526>   : 2b                         store.i8
	cmplStd/lib/math.ci:471: (5 bytes: <asin+31 @05f527> - <asin+36 @05f52c>): x := -x;
	<asin+31 @05f527>   : 11 02                      dup.x64 sp(2)
	<asin+33 @05f529>   : 80                         neg.f64
	<asin+34 @05f52a>   : 14 04                      set.x64 sp(4)
	cmplStd/lib/math.ci:474: (32 bytes: <asin+36 @05f52c> - <asin+68 @05f54c>): if (x > (1))
	<asin+36 @05f52c>   : 11 02                      dup.x64 sp(2)
	<asin+38 @05f52e>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+47 @05f537>   : 89                         cgt.f64
	<asin+48 @05f538>   : 06 14 00 00                jz <asin+68 @05f54c>
	cmplStd/lib/math.ci:476: (16 bytes: <asin+52 @05f53c> - <asin+68 @05f54c>): return .result := nan;
	<asin+52 @05f53c>   : 8f 00 00 00 00 00 00 f8 ff load.f64 -nan
	<asin+61 @05f545>   : 14 06                      set.x64 sp(6)
	<asin+63 @05f547>   : 09 fc ff ff                inc.sp(-4)
	<asin+67 @05f54b>   : 03                         ret
	cmplStd/lib/math.ci:479: (19 bytes: <asin+68 @05f54c> - <asin+87 @05f55f>): result: float64 := float64.sqrt((1) - x * x)
	<asin+68 @05f54c>   : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<asin+77 @05f555>   : 11 04                      dup.x64 sp(4)
	<asin+79 @05f557>   : 11 06                      dup.x64 sp(6)
	<asin+81 @05f559>   : 83                         mul.f64
	<asin+82 @05f55a>   : 82                         sub.f64
	<asin+83 @05f55b>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	cmplStd/lib/math.ci:480: (60 bytes: <asin+87 @05f55f> - <asin+147 @05f59b>): if (x > 0.700000)
	<asin+87 @05f55f>   : 11 04                      dup.x64 sp(4)
	<asin+89 @05f561>   : 8f 66 66 66 66 66 66 e6 3f load.f64 0.700000
	<asin+98 @05f56a>   : 89                         cgt.f64
	<asin+99 @05f56b>   : 06 26 00 00                jz <asin+137 @05f591>
	cmplStd/lib/math.ci:481: (30 bytes: <asin+103 @05f56f> - <asin+133 @05f58d>): result := pi / (2) - float64.atan2(result, x);
	<asin+103 @05f56f>  : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<asin+112 @05f578>  : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<asin+121 @05f581>  : 84                         div.f64
	<asin+122 @05f582>  : 11 02                      dup.x64 sp(2)
	<asin+124 @05f584>  : 11 08                      dup.x64 sp(8)
	<asin+126 @05f586>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+130 @05f58a>  : 82                         sub.f64
	<asin+131 @05f58b>  : 14 02                      set.x64 sp(2)
	<asin+133 @05f58d>  : 04 0e 00 00                jmp <asin+147 @05f59b>
	cmplStd/lib/math.ci:484: (10 bytes: <asin+137 @05f591> - <asin+147 @05f59b>): result := float64.atan2(x, result);
	<asin+137 @05f591>  : 11 04                      dup.x64 sp(4)
	<asin+139 @05f593>  : 11 02                      dup.x64 sp(2)
	<asin+141 @05f595>  : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<asin+145 @05f599>  : 14 02                      set.x64 sp(2)
	cmplStd/lib/math.ci:487: (19 bytes: <asin+147 @05f59b> - <asin+166 @05f5ae>): if (negate)
	<asin+147 @05f59b>  : 0a 08 00 00                load.sp(+8)
	<asin+151 @05f59f>  : 26                         load.i8
	<asin+152 @05f5a0>  : 06 0e 00 00                jz <asin+166 @05f5ae>
	cmplStd/lib/math.ci:488: (10 bytes: <asin+156 @05f5a4> - <asin+166 @05f5ae>): return .result := -result;
	<asin+156 @05f5a4>  : 11 00                      dup.x64 sp(0)
	<asin+158 @05f5a6>  : 80                         neg.f64
	<asin+159 @05f5a7>  : 14 08                      set.x64 sp(8)
	<asin+161 @05f5a9>  : 09 f4 ff ff                inc.sp(-12)
	<asin+165 @05f5ad>  : 03                         ret
	cmplStd/lib/math.ci:490: (7 bytes: <asin+166 @05f5ae> - <asin+173 @05f5b5>): return .result := result;
	<asin+166 @05f5ae>  : 14 06                      set.x64 sp(6)
	<asin+168 @05f5b0>  : 09 fc ff ff                inc.sp(-4)
	<asin+172 @05f5b4>  : 03                         ret
.usages:
	cmplStd/test/std/test.math.ci:63: referenced as `asin`
	cmplStd/lib/math.ci:497: referenced as `asin`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'acos'
.file: 'cmplStd/lib/math.ci:497'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param x: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Returns the arc cosine of the input
 Special case is:
   Acos(x) = NaN if x < -1 or x > 1'
.value: (float64(float64(pi / (2)) - asin(x)))
.usages:
	cmplStd/test/std/test.math.ci:64: referenced as `acos`
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'radians'
.file: 'cmplStd/lib/math.ci:521'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param degrees: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(float64(float64(degrees * pi) / (180)))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'degrees'
.file: 'cmplStd/lib/math.ci:524'
.owner: Math
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param radians: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(float64(float64(radians * (180)) / pi))
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@01cda0>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:184: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:182: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:180: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:178: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:175: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:173: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:171: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:169: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:166: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:164: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:117: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:114: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:112: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:86: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:69: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:62: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:59: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:31: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:24: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:187: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:151: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:149: referenced as `re`
	cmplStd/lib/math/Complex.ci:141: referenced as `re`
	cmplStd/lib/math/Complex.ci:139: referenced as `re`
	cmplStd/lib/math/Complex.ci:138: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:129: referenced as `re`
	cmplStd/lib/math/Complex.ci:126: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:120: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:114: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:112: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:102: referenced as `re`
	cmplStd/lib/math/Complex.ci:101: referenced as `re`
	cmplStd/lib/math/Complex.ci:99: referenced as `re`
	cmplStd/lib/math/Complex.ci:98: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:95: referenced as `re`
	cmplStd/lib/math/Complex.ci:94: referenced as `re`
	cmplStd/lib/math/Complex.ci:92: referenced as `re`
	cmplStd/lib/math/Complex.ci:91: referenced as `re`
	cmplStd/lib/math/Complex.ci:90: referenced as `re`
	cmplStd/lib/math/Complex.ci:83: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:73: referenced as `re`
	cmplStd/lib/math/Complex.ci:71: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:64: referenced as `re`
	cmplStd/lib/math/Complex.ci:33: referenced as `re`
	cmplStd/lib/math/Complex.ci:26: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:187: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:151: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:149: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:139: referenced as `im`
	cmplStd/lib/math/Complex.ci:138: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:129: referenced as `im`
	cmplStd/lib/math/Complex.ci:126: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:121: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:114: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:112: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:102: referenced as `im`
	cmplStd/lib/math/Complex.ci:101: referenced as `im`
	cmplStd/lib/math/Complex.ci:99: referenced as `im`
	cmplStd/lib/math/Complex.ci:98: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:95: referenced as `im`
	cmplStd/lib/math/Complex.ci:94: referenced as `im`
	cmplStd/lib/math/Complex.ci:92: referenced as `im`
	cmplStd/lib/math/Complex.ci:91: referenced as `im`
	cmplStd/lib/math/Complex.ci:90: referenced as `im`
	cmplStd/lib/math/Complex.ci:83: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:73: referenced as `im`
	cmplStd/lib/math/Complex.ci:71: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:64: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	internal usages: 1
}
Complex(re: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@05f5b8>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:24'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
}
.instructions: (7 bytes: <Complex @05f5b8> - <Complex+7 @05f5bf>)
	cmplStd/lib/math/Complex.ci:25: (7 bytes: <Complex @05f5b8> - <Complex+7 @05f5bf>): return .result := {...};
	cmplStd/lib/math/Complex.ci:26: (3 bytes: <Complex @05f5b8> - <Complex+3 @05f5bb>): .result.re := re;
	<Complex @05f5b8>      : 17 03 01                   mov.x64 sp(3, 1)
	:: (3 bytes: <Complex+3 @05f5bb> - <Complex+6 @05f5be>): .result.im := (0);
	<Complex+3 @05f5bb>    : 1a                         load.z64
	<Complex+4 @05f5bc>    : 14 07                      set.x64 sp(7)
	<Complex+6 @05f5be>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:109: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:107: referenced as `Complex`
}
Complex(re: float64, im: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@05f5c0>
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:31'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param re: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param im: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: '@public'
.value: {
	return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
}
.instructions: (7 bytes: <Complex @05f5c0> - <Complex+7 @05f5c7>)
	cmplStd/lib/math/Complex.ci:32: (7 bytes: <Complex @05f5c0> - <Complex+7 @05f5c7>): return .result := {...};
	cmplStd/lib/math/Complex.ci:33: (3 bytes: <Complex @05f5c0> - <Complex+3 @05f5c3>): .result.re := re;
	<Complex @05f5c0>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:34: (3 bytes: <Complex+3 @05f5c3> - <Complex+6 @05f5c6>): .result.im := im;
	<Complex+3 @05f5c3>    : 17 07 01                   mov.x64 sp(7, 1)
	<Complex+6 @05f5c6>    : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:187: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:151: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:149: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:132: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:83: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:73: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:71: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:66: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:64: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:59'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public: Complex(-a.re, -a.im);'
.value: Complex(emit(void(struct(a), neg.p2d)))
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:171: referenced as `neg`
	cmplStd/lib/math/Complex.ci:169: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:62'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:64'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re + b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `add`
	cmplStd/lib/math/Complex.ci:173: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:66'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a + b.re), b.im))
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:69'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: Complex (size: 16, offs: <+32>, cast: val)
.doc: '@public: Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
	cmplStd/lib/math/Complex.ci:169: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:71'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: Complex(void(float64(a.re - b), a.im))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `sub`
	cmplStd/lib/math/Complex.ci:173: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:73'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a - b.re), b.im))
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: '@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)))
.usages:
}
mul(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.param b: float64 (size: 8, offs: <+24>, cast: variable(f64))
.doc: '@public'
.value: Complex(void(float64(a.re * b), float64(a.im * b)))
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:83'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: variable(f64))
.param b: Complex (size: 16, offs: <+24>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(a * b.re), float64(a * b.im)))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:175: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
	cmplStd/lib/math/Complex.ci:173: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 123
.offset: <@05f5c8>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:86'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
		r: float64 := float64(b.im / b.re);
		den: float64 := float64(b.re + float64(r * b.im));
		return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
	}
	r: float64 := float64(b.re / b.im);
	den: float64 := float64(b.im + float64(r * b.re));
	return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
}
.instructions: (123 bytes: <div @05f5c8> - <div+123 @05f643>)
	cmplStd/lib/math/Complex.ci:90: (79 bytes: <div @05f5c8> - <div+79 @05f617>): if (Math.abs(b.re) >= Math.abs(b.im))
	<div @05f5c8>      : 1a                         load.z64
	<div+1 @05f5c9>    : 11 03                      dup.x64 sp(3)
	<div+3 @05f5cb>    : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<div+8 @05f5d0>    : 02                         call
	<div+9 @05f5d1>    : 09 f8 ff ff                inc.sp(-8)
	<div+13 @05f5d5>   : 1a                         load.z64
	<div+14 @05f5d6>   : 11 07                      dup.x64 sp(7)
	<div+16 @05f5d8>   : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<div+21 @05f5dd>   : 02                         call
	<div+22 @05f5de>   : 09 f8 ff ff                inc.sp(-8)
	<div+26 @05f5e2>   : 88                         clt.f64
	<div+27 @05f5e3>   : 05 34 00 00                jnz <div+79 @05f617>
	cmplStd/lib/math/Complex.ci:91: (5 bytes: <div+31 @05f5e7> - <div+36 @05f5ec>): r: float64 := b.im / b.re
	<div+31 @05f5e7>   : 11 03                      dup.x64 sp(3)
	<div+33 @05f5e9>   : 11 03                      dup.x64 sp(3)
	<div+35 @05f5eb>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:92: (8 bytes: <div+36 @05f5ec> - <div+44 @05f5f4>): den: float64 := b.re + r * b.im
	<div+36 @05f5ec>   : 11 03                      dup.x64 sp(3)
	<div+38 @05f5ee>   : 11 02                      dup.x64 sp(2)
	<div+40 @05f5f0>   : 11 09                      dup.x64 sp(9)
	<div+42 @05f5f2>   : 83                         mul.f64
	<div+43 @05f5f3>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:93: (31 bytes: <div+44 @05f5f4> - <div+75 @05f613>): return .result := {...};
	cmplStd/lib/math/Complex.ci:94: (13 bytes: <div+44 @05f5f4> - <div+57 @05f601>): .result.re := (a.re + r * a.im) / den;
	<div+44 @05f5f4>   : 11 09                      dup.x64 sp(9)
	<div+46 @05f5f6>   : 11 04                      dup.x64 sp(4)
	<div+48 @05f5f8>   : 11 0f                      dup.x64 sp(15)
	<div+50 @05f5fa>   : 83                         mul.f64
	<div+51 @05f5fb>   : 81                         add.f64
	<div+52 @05f5fc>   : 11 02                      dup.x64 sp(2)
	<div+54 @05f5fe>   : 84                         div.f64
	<div+55 @05f5ff>   : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:95: (13 bytes: <div+57 @05f601> - <div+70 @05f60e>): .result.im := (a.im - r * a.re) / den;
	<div+57 @05f601>   : 11 0b                      dup.x64 sp(11)
	<div+59 @05f603>   : 11 04                      dup.x64 sp(4)
	<div+61 @05f605>   : 11 0d                      dup.x64 sp(13)
	<div+63 @05f607>   : 83                         mul.f64
	<div+64 @05f608>   : 82                         sub.f64
	<div+65 @05f609>   : 11 02                      dup.x64 sp(2)
	<div+67 @05f60b>   : 84                         div.f64
	<div+68 @05f60c>   : 14 11                      set.x64 sp(17)
	<div+70 @05f60e>   : 09 f0 ff ff                inc.sp(-16)
	<div+74 @05f612>   : 03                         ret
	<div+75 @05f613>   : 09 f0 ff ff                inc.sp(-16)
	cmplStd/lib/math/Complex.ci:98: (5 bytes: <div+79 @05f617> - <div+84 @05f61c>): r: float64 := b.re / b.im
	<div+79 @05f617>   : 11 01                      dup.x64 sp(1)
	<div+81 @05f619>   : 11 05                      dup.x64 sp(5)
	<div+83 @05f61b>   : 84                         div.f64
	cmplStd/lib/math/Complex.ci:99: (8 bytes: <div+84 @05f61c> - <div+92 @05f624>): den: float64 := b.im + r * b.re
	<div+84 @05f61c>   : 11 05                      dup.x64 sp(5)
	<div+86 @05f61e>   : 11 02                      dup.x64 sp(2)
	<div+88 @05f620>   : 11 07                      dup.x64 sp(7)
	<div+90 @05f622>   : 83                         mul.f64
	<div+91 @05f623>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:100: (31 bytes: <div+92 @05f624> - <div+123 @05f643>): return .result := {...};
	cmplStd/lib/math/Complex.ci:101: (13 bytes: <div+92 @05f624> - <div+105 @05f631>): .result.re := (a.re * r + a.im) / den;
	<div+92 @05f624>   : 11 09                      dup.x64 sp(9)
	<div+94 @05f626>   : 11 04                      dup.x64 sp(4)
	<div+96 @05f628>   : 83                         mul.f64
	<div+97 @05f629>   : 11 0d                      dup.x64 sp(13)
	<div+99 @05f62b>   : 81                         add.f64
	<div+100 @05f62c>  : 11 02                      dup.x64 sp(2)
	<div+102 @05f62e>  : 84                         div.f64
	<div+103 @05f62f>  : 14 0f                      set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:102: (13 bytes: <div+105 @05f631> - <div+118 @05f63e>): .result.im := (a.im * r - a.re) / den;
	<div+105 @05f631>  : 11 0b                      dup.x64 sp(11)
	<div+107 @05f633>  : 11 04                      dup.x64 sp(4)
	<div+109 @05f635>  : 83                         mul.f64
	<div+110 @05f636>  : 11 0b                      dup.x64 sp(11)
	<div+112 @05f638>  : 82                         sub.f64
	<div+113 @05f639>  : 11 02                      dup.x64 sp(2)
	<div+115 @05f63b>  : 84                         div.f64
	<div+116 @05f63c>  : 14 11                      set.x64 sp(17)
	<div+118 @05f63e>  : 09 f0 ff ff                inc.sp(-16)
	<div+122 @05f642>  : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `div`
	cmplStd/lib/math/Complex.ci:173: referenced as `div`
	cmplStd/lib/math/Complex.ci:166: referenced as `div`
	cmplStd/lib/math/Complex.ci:164: referenced as `div`
	cmplStd/lib/math/Complex.ci:109: referenced as `div`
	cmplStd/lib/math/Complex.ci:107: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:107'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: div(void(a, Complex(b)))
.usages:
	cmplStd/lib/math/Complex.ci:171: referenced as `div`
	cmplStd/lib/math/Complex.ci:169: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:109'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: float64 (size: 8, offs: <+8>, cast: f64)
.param b: Complex (size: 16, offs: <+24>, cast: val)
.doc: '@public'
.value: div(void(Complex(a), b))
.usages:
}
abs(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:112'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `abs`
	cmplStd/lib/math/Complex.ci:136: referenced as `abs`
	cmplStd/lib/math/Complex.ci:132: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:114'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: float64.atan2(void(a.re, a.im))
.usages:
	cmplStd/lib/math/Complex.ci:189: referenced as `arg`
	cmplStd/lib/math/Complex.ci:137: referenced as `arg`
	cmplStd/lib/math/Complex.ci:132: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.offset: <@05f648>
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:117'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.doc: 'Reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
	return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
}
.instructions: (31 bytes: <inv @05f648> - <inv+31 @05f667>)
	cmplStd/lib/math/Complex.ci:118: (11 bytes: <inv @05f648> - <inv+11 @05f653>): d: float64 := a.re * a.re + a.im * a.im
	<inv @05f648>      : 11 01                      dup.x64 sp(1)
	<inv+2 @05f64a>    : 11 03                      dup.x64 sp(3)
	<inv+4 @05f64c>    : 83                         mul.f64
	<inv+5 @05f64d>    : 11 05                      dup.x64 sp(5)
	<inv+7 @05f64f>    : 11 07                      dup.x64 sp(7)
	<inv+9 @05f651>    : 83                         mul.f64
	<inv+10 @05f652>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:119: (20 bytes: <inv+11 @05f653> - <inv+31 @05f667>): return .result := {...};
	cmplStd/lib/math/Complex.ci:120: (7 bytes: <inv+11 @05f653> - <inv+18 @05f65a>): .result.re := +a.re / d;
	<inv+11 @05f653>   : 11 03                      dup.x64 sp(3)
	<inv+13 @05f655>   : 11 02                      dup.x64 sp(2)
	<inv+15 @05f657>   : 84                         div.f64
	<inv+16 @05f658>   : 14 09                      set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:121: (8 bytes: <inv+18 @05f65a> - <inv+26 @05f662>): .result.im := -a.im / d;
	<inv+18 @05f65a>   : 11 05                      dup.x64 sp(5)
	<inv+20 @05f65c>   : 80                         neg.f64
	<inv+21 @05f65d>   : 11 02                      dup.x64 sp(2)
	<inv+23 @05f65f>   : 84                         div.f64
	<inv+24 @05f660>   : 14 0b                      set.x64 sp(11)
	<inv+26 @05f662>   : 09 f8 ff ff                inc.sp(-8)
	<inv+30 @05f666>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `inv`
	cmplStd/lib/math/Complex.ci:182: referenced as `inv`
	cmplStd/lib/math/Complex.ci:180: referenced as `inv`
	cmplStd/lib/math/Complex.ci:178: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(a.re, float64(-a.im)))
.usages:
}
exp(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:175: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:173: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:171: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
	cmplStd/lib/math/Complex.ci:169: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:132'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64.log(abs(a)), arg(a)))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 100
.offset: <@05f668>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, offs: <+16>, cast: variable(val))
.param a: Complex (size: 16, offs: <+32>, cast: variable(val))
.param b: Complex (size: 16, offs: <+48>, cast: variable(val))
.doc: '@public'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
	v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
	return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
}
.instructions: (100 bytes: <pow @05f668> - <pow+100 @05f6cc>)
	cmplStd/lib/math/Complex.ci:136: (23 bytes: <pow @05f668> - <pow+23 @05f67f>): r: float64 := abs(a)
	<pow @05f668>      : 12 05                      dup.x128 sp(5)
	<pow+2 @05f66a>    : 11 00                      dup.x64 sp(0)
	<pow+4 @05f66c>    : 11 02                      dup.x64 sp(2)
	<pow+6 @05f66e>    : 83                         mul.f64
	<pow+7 @05f66f>    : 11 04                      dup.x64 sp(4)
	<pow+9 @05f671>    : 11 06                      dup.x64 sp(6)
	<pow+11 @05f673>   : 83                         mul.f64
	<pow+12 @05f674>   : 81                         add.f64
	<pow+13 @05f675>   : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<pow+17 @05f679>   : 14 04                      set.x64 sp(4)
	<pow+19 @05f67b>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:137: (16 bytes: <pow+23 @05f67f> - <pow+39 @05f68f>): t: float64 := arg(a)
	<pow+23 @05f67f>   : 12 07                      dup.x128 sp(7)
	<pow+25 @05f681>   : 11 00                      dup.x64 sp(0)
	<pow+27 @05f683>   : 11 04                      dup.x64 sp(4)
	<pow+29 @05f685>   : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<pow+33 @05f689>   : 14 04                      set.x64 sp(4)
	<pow+35 @05f68b>   : 09 f8 ff ff                inc.sp(-8)
	cmplStd/lib/math/Complex.ci:138: (15 bytes: <pow+39 @05f68f> - <pow+54 @05f69e>): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+39 @05f68f>   : 11 05                      dup.x64 sp(5)
	<pow+41 @05f691>   : 11 02                      dup.x64 sp(2)
	<pow+43 @05f693>   : 83                         mul.f64
	<pow+44 @05f694>   : 11 09                      dup.x64 sp(9)
	<pow+46 @05f696>   : 11 06                      dup.x64 sp(6)
	<pow+48 @05f698>   : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<pow+52 @05f69c>   : 83                         mul.f64
	<pow+53 @05f69d>   : 81                         add.f64
	cmplStd/lib/math/Complex.ci:139: (19 bytes: <pow+54 @05f69e> - <pow+73 @05f6b1>): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+54 @05f69e>   : 11 04                      dup.x64 sp(4)
	<pow+56 @05f6a0>   : 11 09                      dup.x64 sp(9)
	<pow+58 @05f6a2>   : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<pow+62 @05f6a6>   : 11 0b                      dup.x64 sp(11)
	<pow+64 @05f6a8>   : 80                         neg.f64
	<pow+65 @05f6a9>   : 11 06                      dup.x64 sp(6)
	<pow+67 @05f6ab>   : 83                         mul.f64
	<pow+68 @05f6ac>   : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<pow+72 @05f6b0>   : 83                         mul.f64
	cmplStd/lib/math/Complex.ci:140: (27 bytes: <pow+73 @05f6b1> - <pow+100 @05f6cc>): return .result := {...};
	cmplStd/lib/math/Complex.ci:141: (11 bytes: <pow+73 @05f6b1> - <pow+84 @05f6bc>): .result.re := v * float64.cos(u);
	<pow+73 @05f6b1>   : 11 00                      dup.x64 sp(0)
	<pow+75 @05f6b3>   : 11 04                      dup.x64 sp(4)
	<pow+77 @05f6b5>   : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<pow+81 @05f6b9>   : 83                         mul.f64
	<pow+82 @05f6ba>   : 14 13                      set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:142: (11 bytes: <pow+84 @05f6bc> - <pow+95 @05f6c7>): .result.im := v * float64.sin(u);
	<pow+84 @05f6bc>   : 11 00                      dup.x64 sp(0)
	<pow+86 @05f6be>   : 11 04                      dup.x64 sp(4)
	<pow+88 @05f6c0>   : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<pow+92 @05f6c4>   : 83                         mul.f64
	<pow+93 @05f6c5>   : 14 15                      set.x64 sp(21)
	<pow+95 @05f6c7>   : 09 e0 ff ff                inc.sp(-32)
	<pow+99 @05f6cb>   : 03                         ret
.usages:
	cmplStd/lib/math/Complex.ci:146: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:146'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.param b: float64 (size: 8, offs: <+24>, cast: f64)
.doc: '@public'
.value: pow(void(a, Complex(b)))
.usages:
}
sin(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:149'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:180: referenced as `sin`
	cmplStd/lib/math/Complex.ci:166: referenced as `sin`
	cmplStd/lib/math/Complex.ci:164: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:151'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))))
.usages:
	cmplStd/lib/math/Complex.ci:178: referenced as `cos`
	cmplStd/lib/math/Complex.ci:166: referenced as `cos`
	cmplStd/lib/math/Complex.ci:164: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:164'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sin(a), cos(a)))
.usages:
}
cot(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:166'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(cos(a), sin(a)))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:169'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:184: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:171'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(a), exp(neg(a)))), 2))
.usages:
	cmplStd/lib/math/Complex.ci:182: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:173'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))))
.usages:
}
coth(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:175'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))))
.usages:
}
sec(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:178'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:180'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sin(a))
.usages:
}
sech(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:182'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:184'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param a: Complex (size: 16, offs: <+16>, cast: val)
.doc: '@public'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:187'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:189'
.param .result: Complex (size: 16, offs: <+0>, cast: val)
.param x: Complex (size: 16, offs: <+16>, cast: variable(val))
.doc: '@public'
.value: Complex(void(abs(x), arg(x)))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@0228e8>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float32 (size: 0, offs: <+0>, cast: inline)
.field y: float32 (size: 0, offs: <+0>, cast: inline)
.field z: float32 (size: 0, offs: <+0>, cast: inline)
.field w: float32 (size: 0, offs: <+0>, cast: inline)
.field data: float32[4] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:120: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:112: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:102: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:141'
.owner: vec4f
.field x: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field y: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field z: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field w: float32 (size: 4, offs: <+12>, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.param w: float32 (size: 4, offs: <+16>, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.param z: float32 (size: 4, offs: <+12>, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(void(void(void(x, y), z), 1.000000))
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param x: float32 (size: 4, offs: <+4>, cast: f32)
.param y: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(void(void(void(x, y), 0.000000), 1.000000))
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param xyz: vec4f (size: 16, offs: <+16>, cast: variable(val))
.param w: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w))
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param val: float32 (size: 4, offs: <+4>, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(void(void(void(val, val), val), val))
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param rhs: vec4f (size: 16, offs: <+16>, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(void(struct(rhs), neg.p4f)))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)))
.usages:
	cmplStd/lib/math/Vector4f.ci:128: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(void(vec4f(a), b))
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(void(a, vec4f(b)))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(vec4f(a), b))
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(void(a, vec4f(b)))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(vec4f(a), b))
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(void(a, vec4f(b)))
.usages:
}
div(a: float32, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.param b: vec4f (size: 16, offs: <+20>, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(vec4f(a), b))
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 16, offs: <+16>, cast: val)
.param b: float32 (size: 4, offs: <+20>, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(void(a, vec4f(b)))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:102'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: vec4f (size: 16, offs: <+32>, cast: val)
.param max: vec4f (size: 16, offs: <+48>, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(void(max(void(vec, min)), max))
.usages:
	cmplStd/lib/math/Vector4f.ci:108: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param vec: vec4f (size: 16, offs: <+16>, cast: val)
.param min: float32 (size: 4, offs: <+20>, cast: f32)
.param max: float32 (size: 4, offs: <+24>, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(void(void(vec, vec4f(min)), vec4f(max)))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:112'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:126: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:116'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:120'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param lhs: vec4f (size: 16, offs: <+16>, cast: val)
.param rhs: vec4f (size: 16, offs: <+32>, cast: val)
.doc: 'Dot product'
.value: float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param a: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))))
.usages:
}
length(v: vec4f): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:126'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 16, offs: <+16>, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: float32.sqrt(dp3(void(v, v)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:128: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:128'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(void(v, vec4f(length(v))))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, offs: <+0>, cast: f32)
.param v: vec4f (size: 4, offs: <+4>, cast: const variable(ref))
.param x: float32 (size: 4, offs: <+8>, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x))
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.offset: <@027d80>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, offs: <+0>, cast: variable(val))
.field data: float32[16] (size: 64, offs: <+0>, cast: variable(val))
.field v: vec4f[4] (size: 64, offs: <+0>, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field x: vec4f (size: 0, offs: <+0>, cast: inline)
.field y: vec4f (size: 0, offs: <+0>, cast: inline)
.field z: vec4f (size: 0, offs: <+0>, cast: inline)
.field w: vec4f (size: 0, offs: <+0>, cast: inline)
.field <?>: mat4f.<?> (size: 64, offs: <+0>, cast: variable(val))
.field xx: float32 (size: 0, offs: <+0>, cast: inline)
.field xy: float32 (size: 0, offs: <+0>, cast: inline)
.field xz: float32 (size: 0, offs: <+0>, cast: inline)
.field xw: float32 (size: 0, offs: <+0>, cast: inline)
.field yx: float32 (size: 0, offs: <+0>, cast: inline)
.field yy: float32 (size: 0, offs: <+0>, cast: inline)
.field yz: float32 (size: 0, offs: <+0>, cast: inline)
.field yw: float32 (size: 0, offs: <+0>, cast: inline)
.field zx: float32 (size: 0, offs: <+0>, cast: inline)
.field zy: float32 (size: 0, offs: <+0>, cast: inline)
.field zz: float32 (size: 0, offs: <+0>, cast: inline)
.field zw: float32 (size: 0, offs: <+0>, cast: inline)
.field wx: float32 (size: 0, offs: <+0>, cast: inline)
.field wy: float32 (size: 0, offs: <+0>, cast: inline)
.field wz: float32 (size: 0, offs: <+0>, cast: inline)
.field ww: float32 (size: 0, offs: <+0>, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:111: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.offset: <+0>
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.offset: <+0>
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field x: vec4f (size: 16, offs: <+0>, cast: variable(val))
.field y: vec4f (size: 16, offs: <+16>, cast: variable(val))
.field z: vec4f (size: 16, offs: <+32>, cast: variable(val))
.field w: vec4f (size: 16, offs: <+48>, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+16>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+32>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:118: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.offset: <+48>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:155: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:119: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: '@public'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: '@public'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: '@public'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.offset: <+0>
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: '@public'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:182'
.owner: mat4f
.field xx: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field xy: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field xz: float32 (size: 4, offs: <+8>, cast: variable(f32))
.field xw: float32 (size: 4, offs: <+12>, cast: variable(f32))
.field yx: float32 (size: 4, offs: <+16>, cast: variable(f32))
.field yy: float32 (size: 4, offs: <+20>, cast: variable(f32))
.field yz: float32 (size: 4, offs: <+24>, cast: variable(f32))
.field yw: float32 (size: 4, offs: <+28>, cast: variable(f32))
.field zx: float32 (size: 4, offs: <+32>, cast: variable(f32))
.field zy: float32 (size: 4, offs: <+36>, cast: variable(f32))
.field zz: float32 (size: 4, offs: <+40>, cast: variable(f32))
.field zw: float32 (size: 4, offs: <+44>, cast: variable(f32))
.field wx: float32 (size: 4, offs: <+48>, cast: variable(f32))
.field wy: float32 (size: 4, offs: <+52>, cast: variable(f32))
.field wz: float32 (size: 4, offs: <+56>, cast: variable(f32))
.field ww: float32 (size: 4, offs: <+60>, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:142: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+12>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+16>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+20>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+24>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:147: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+28>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+32>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+36>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+40>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:152: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+44>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+48>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+52>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+56>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+60>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: '@public'
.usages:
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: '@public'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: '@public'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: '@public'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: '@public'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: '@public'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: '@public'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: '@public'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: '@public'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: '@public'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: '@public'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: '@public'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: '@public'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: '@public'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: '@public'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: '@public'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.offset: <+0>
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: '@public'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@05f6d0>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param xx: float32 (size: 4, offs: <+68>, cast: variable(f32))
.param xy: float32 (size: 4, offs: <+72>, cast: variable(f32))
.param xz: float32 (size: 4, offs: <+76>, cast: variable(f32))
.param xw: float32 (size: 4, offs: <+80>, cast: variable(f32))
.param yx: float32 (size: 4, offs: <+84>, cast: variable(f32))
.param yy: float32 (size: 4, offs: <+88>, cast: variable(f32))
.param yz: float32 (size: 4, offs: <+92>, cast: variable(f32))
.param yw: float32 (size: 4, offs: <+96>, cast: variable(f32))
.param zx: float32 (size: 4, offs: <+100>, cast: variable(f32))
.param zy: float32 (size: 4, offs: <+104>, cast: variable(f32))
.param zz: float32 (size: 4, offs: <+108>, cast: variable(f32))
.param zw: float32 (size: 4, offs: <+112>, cast: variable(f32))
.param wx: float32 (size: 4, offs: <+116>, cast: variable(f32))
.param wy: float32 (size: 4, offs: <+120>, cast: variable(f32))
.param wz: float32 (size: 4, offs: <+124>, cast: variable(f32))
.param ww: float32 (size: 4, offs: <+128>, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
}
.instructions: (49 bytes: <mat4f @05f6d0> - <mat4f+49 @05f701>)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes: <mat4f @05f6d0> - <mat4f+49 @05f701>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f @05f6d0> - <mat4f+3 @05f6d3>): .result.xx := xx;
	<mat4f @05f6d0>      : 16 11 10                   mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+3 @05f6d3> - <mat4f+6 @05f6d6>): .result.xy := xy;
	<mat4f+3 @05f6d3>    : 16 12 0f                   mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+6 @05f6d6> - <mat4f+9 @05f6d9>): .result.xz := xz;
	<mat4f+6 @05f6d6>    : 16 13 0e                   mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes: <mat4f+9 @05f6d9> - <mat4f+12 @05f6dc>): .result.xw := xw;
	<mat4f+9 @05f6d9>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+12 @05f6dc> - <mat4f+15 @05f6df>): .result.yx := yx;
	<mat4f+12 @05f6dc>   : 16 15 0c                   mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+15 @05f6df> - <mat4f+18 @05f6e2>): .result.yy := yy;
	<mat4f+15 @05f6df>   : 16 16 0b                   mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+18 @05f6e2> - <mat4f+21 @05f6e5>): .result.yz := yz;
	<mat4f+18 @05f6e2>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes: <mat4f+21 @05f6e5> - <mat4f+24 @05f6e8>): .result.yw := yw;
	<mat4f+21 @05f6e5>   : 16 18 09                   mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+24 @05f6e8> - <mat4f+27 @05f6eb>): .result.zx := zx;
	<mat4f+24 @05f6e8>   : 16 19 08                   mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+27 @05f6eb> - <mat4f+30 @05f6ee>): .result.zy := zy;
	<mat4f+27 @05f6eb>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+30 @05f6ee> - <mat4f+33 @05f6f1>): .result.zz := zz;
	<mat4f+30 @05f6ee>   : 16 1b 06                   mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes: <mat4f+33 @05f6f1> - <mat4f+36 @05f6f4>): .result.zw := zw;
	<mat4f+33 @05f6f1>   : 16 1c 05                   mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+36 @05f6f4> - <mat4f+39 @05f6f7>): .result.wx := wx;
	<mat4f+36 @05f6f4>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+39 @05f6f7> - <mat4f+42 @05f6fa>): .result.wy := wy;
	<mat4f+39 @05f6f7>   : 16 1e 03                   mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+42 @05f6fa> - <mat4f+45 @05f6fd>): .result.wz := wz;
	<mat4f+42 @05f6fa>   : 16 1f 02                   mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes: <mat4f+45 @05f6fd> - <mat4f+48 @05f700>): .result.ww := ww;
	<mat4f+45 @05f6fd>   : 16 20 01                   mov.x32 sp(32, 1)
	<mat4f+48 @05f700>   : 03                         ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.offset: <@05f708>
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param x: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param y: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param z: vec4f (size: 4, offs: <+76>, cast: const variable(ref))
.param w: vec4f (size: 4, offs: <+80>, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
}
.instructions: (21 bytes: <mat4f @05f708> - <mat4f+21 @05f71d>)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes: <mat4f @05f708> - <mat4f+21 @05f71d>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f @05f708> - <mat4f+5 @05f70d>): .result.x := x;
	<mat4f @05f708>      : 10 04                      dup.x32 sp(4)
	<mat4f+2 @05f70a>    : 2a                         load.i128
	<mat4f+3 @05f70b>    : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+5 @05f70d> - <mat4f+10 @05f712>): .result.y := y;
	<mat4f+5 @05f70d>    : 10 03                      dup.x32 sp(3)
	<mat4f+7 @05f70f>    : 2a                         load.i128
	<mat4f+8 @05f710>    : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+10 @05f712> - <mat4f+15 @05f717>): .result.z := z;
	<mat4f+10 @05f712>   : 10 02                      dup.x32 sp(2)
	<mat4f+12 @05f714>   : 2a                         load.i128
	<mat4f+13 @05f715>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes: <mat4f+15 @05f717> - <mat4f+20 @05f71c>): .result.w := w;
	<mat4f+15 @05f717>   : 10 01                      dup.x32 sp(1)
	<mat4f+17 @05f719>   : 2a                         load.i128
	<mat4f+18 @05f71a>   : 15 15                      set.x128 sp(21)
	<mat4f+20 @05f71c>   : 03                         ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000))
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, offs: <+0>, cast: val)
.param mat: mat4f (size: 4, offs: <+4>, cast: const variable(ref))
.param vec: vec4f (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Multiply with vector: dot product'
.value: vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.offset: <@05f720>
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param mat: mat4f (size: 64, offs: <+128>, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
}
.instructions: (49 bytes: <transpose @05f720> - <transpose+49 @05f751>)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes: <transpose @05f720> - <transpose+49 @05f751>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose @05f720> - <transpose+3 @05f723>): .result.xx := mat.xx;
	<transpose @05f720>      : 16 11 01                   mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+3 @05f723> - <transpose+6 @05f726>): .result.xy := mat.yx;
	<transpose+3 @05f723>    : 16 12 05                   mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+6 @05f726> - <transpose+9 @05f729>): .result.xz := mat.zx;
	<transpose+6 @05f726>    : 16 13 09                   mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes: <transpose+9 @05f729> - <transpose+12 @05f72c>): .result.xw := mat.wx;
	<transpose+9 @05f729>    : 16 14 0d                   mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+12 @05f72c> - <transpose+15 @05f72f>): .result.yx := mat.xy;
	<transpose+12 @05f72c>   : 16 15 02                   mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+15 @05f72f> - <transpose+18 @05f732>): .result.yy := mat.yy;
	<transpose+15 @05f72f>   : 16 16 06                   mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+18 @05f732> - <transpose+21 @05f735>): .result.yz := mat.zy;
	<transpose+18 @05f732>   : 16 17 0a                   mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes: <transpose+21 @05f735> - <transpose+24 @05f738>): .result.yw := mat.wy;
	<transpose+21 @05f735>   : 16 18 0e                   mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+24 @05f738> - <transpose+27 @05f73b>): .result.zx := mat.xz;
	<transpose+24 @05f738>   : 16 19 03                   mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+27 @05f73b> - <transpose+30 @05f73e>): .result.zy := mat.yz;
	<transpose+27 @05f73b>   : 16 1a 07                   mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+30 @05f73e> - <transpose+33 @05f741>): .result.zz := mat.zz;
	<transpose+30 @05f73e>   : 16 1b 0b                   mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes: <transpose+33 @05f741> - <transpose+36 @05f744>): .result.zw := mat.wz;
	<transpose+33 @05f741>   : 16 1c 0f                   mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+36 @05f744> - <transpose+39 @05f747>): .result.wx := mat.xw;
	<transpose+36 @05f744>   : 16 1d 04                   mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+39 @05f747> - <transpose+42 @05f74a>): .result.wy := mat.yw;
	<transpose+39 @05f747>   : 16 1e 08                   mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+42 @05f74a> - <transpose+45 @05f74d>): .result.wz := mat.zw;
	<transpose+42 @05f74a>   : 16 1f 0c                   mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes: <transpose+45 @05f74d> - <transpose+48 @05f750>): .result.ww := mat.ww;
	<transpose+45 @05f74d>   : 16 20 10                   mov.x32 sp(32, 16)
	<transpose+48 @05f750>   : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 245
.offset: <@05f758>
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param lhs: mat4f (size: 4, offs: <+68>, cast: const variable(ref))
.param rhs: mat4f (size: 4, offs: <+72>, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
}
.instructions: (245 bytes: <mul @05f758> - <mul+245 @05f84d>)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes: <mul @05f758> - <mul+28 @05f774>): transposed: mat4f := transpose(rhs)
	<mul @05f758>      : 09 40 00 00                inc.sp(+64)
	<mul+4 @05f75c>    : 10 11                      dup.x32 sp(17)
	<mul+6 @05f75e>    : 0a c4 ff ff                load.sp(-60)
	<mul+10 @05f762>   : 1e c0 ff ff                copy.mem -64
	<mul+14 @05f766>   : 09 40 00 00                inc.sp(+64)
	<mul+18 @05f76a>   : 1f 20 f7 05 00             load.ref <@05f720> ;transpose(mat: mat4f): mat4f
	<mul+23 @05f76f>   : 02                         call
	<mul+24 @05f770>   : 09 c0 ff ff                inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (217 bytes: <mul+28 @05f774> - <mul+245 @05f84d>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (50 bytes: <mul+28 @05f774> - <mul+78 @05f7a6>): .result.x := dp4(transposed, lhs.x);
	<mul+28 @05f774>   : 0a 00 00 00                load.sp(+0)
	<mul+32 @05f778>   : 10 13                      dup.x32 sp(19)
	<mul+34 @05f77a>   : 10 01                      dup.x32 sp(1)
	<mul+36 @05f77c>   : 0c 30 00 00                inc.i32(+48)
	<mul+40 @05f780>   : 2a                         load.i128
	<mul+41 @05f781>   : 10 04                      dup.x32 sp(4)
	<mul+43 @05f783>   : 2a                         load.i128
	<mul+44 @05f784>   : 9b                         dp4.v4f
	<mul+45 @05f785>   : 10 02                      dup.x32 sp(2)
	<mul+47 @05f787>   : 0c 20 00 00                inc.i32(+32)
	<mul+51 @05f78b>   : 2a                         load.i128
	<mul+52 @05f78c>   : 10 05                      dup.x32 sp(5)
	<mul+54 @05f78e>   : 2a                         load.i128
	<mul+55 @05f78f>   : 9b                         dp4.v4f
	<mul+56 @05f790>   : 10 03                      dup.x32 sp(3)
	<mul+58 @05f792>   : 0c 10 00 00                inc.i32(+16)
	<mul+62 @05f796>   : 2a                         load.i128
	<mul+63 @05f797>   : 10 06                      dup.x32 sp(6)
	<mul+65 @05f799>   : 2a                         load.i128
	<mul+66 @05f79a>   : 9b                         dp4.v4f
	<mul+67 @05f79b>   : 10 04                      dup.x32 sp(4)
	<mul+69 @05f79d>   : 2a                         load.i128
	<mul+70 @05f79e>   : 10 07                      dup.x32 sp(7)
	<mul+72 @05f7a0>   : 2a                         load.i128
	<mul+73 @05f7a1>   : 9b                         dp4.v4f
	<mul+74 @05f7a2>   : 15 02                      set.x128 sp(2)
	<mul+76 @05f7a4>   : 15 17                      set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (54 bytes: <mul+78 @05f7a6> - <mul+132 @05f7dc>): .result.y := dp4(transposed, lhs.y);
	<mul+78 @05f7a6>   : 0a 00 00 00                load.sp(+0)
	<mul+82 @05f7aa>   : 10 13                      dup.x32 sp(19)
	<mul+84 @05f7ac>   : 0c 10 00 00                inc.i32(+16)
	<mul+88 @05f7b0>   : 10 01                      dup.x32 sp(1)
	<mul+90 @05f7b2>   : 0c 30 00 00                inc.i32(+48)
	<mul+94 @05f7b6>   : 2a                         load.i128
	<mul+95 @05f7b7>   : 10 04                      dup.x32 sp(4)
	<mul+97 @05f7b9>   : 2a                         load.i128
	<mul+98 @05f7ba>   : 9b                         dp4.v4f
	<mul+99 @05f7bb>   : 10 02                      dup.x32 sp(2)
	<mul+101 @05f7bd>  : 0c 20 00 00                inc.i32(+32)
	<mul+105 @05f7c1>  : 2a                         load.i128
	<mul+106 @05f7c2>  : 10 05                      dup.x32 sp(5)
	<mul+108 @05f7c4>  : 2a                         load.i128
	<mul+109 @05f7c5>  : 9b                         dp4.v4f
	<mul+110 @05f7c6>  : 10 03                      dup.x32 sp(3)
	<mul+112 @05f7c8>  : 0c 10 00 00                inc.i32(+16)
	<mul+116 @05f7cc>  : 2a                         load.i128
	<mul+117 @05f7cd>  : 10 06                      dup.x32 sp(6)
	<mul+119 @05f7cf>  : 2a                         load.i128
	<mul+120 @05f7d0>  : 9b                         dp4.v4f
	<mul+121 @05f7d1>  : 10 04                      dup.x32 sp(4)
	<mul+123 @05f7d3>  : 2a                         load.i128
	<mul+124 @05f7d4>  : 10 07                      dup.x32 sp(7)
	<mul+126 @05f7d6>  : 2a                         load.i128
	<mul+127 @05f7d7>  : 9b                         dp4.v4f
	<mul+128 @05f7d8>  : 15 02                      set.x128 sp(2)
	<mul+130 @05f7da>  : 15 1b                      set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (54 bytes: <mul+132 @05f7dc> - <mul+186 @05f812>): .result.z := dp4(transposed, lhs.z);
	<mul+132 @05f7dc>  : 0a 00 00 00                load.sp(+0)
	<mul+136 @05f7e0>  : 10 13                      dup.x32 sp(19)
	<mul+138 @05f7e2>  : 0c 20 00 00                inc.i32(+32)
	<mul+142 @05f7e6>  : 10 01                      dup.x32 sp(1)
	<mul+144 @05f7e8>  : 0c 30 00 00                inc.i32(+48)
	<mul+148 @05f7ec>  : 2a                         load.i128
	<mul+149 @05f7ed>  : 10 04                      dup.x32 sp(4)
	<mul+151 @05f7ef>  : 2a                         load.i128
	<mul+152 @05f7f0>  : 9b                         dp4.v4f
	<mul+153 @05f7f1>  : 10 02                      dup.x32 sp(2)
	<mul+155 @05f7f3>  : 0c 20 00 00                inc.i32(+32)
	<mul+159 @05f7f7>  : 2a                         load.i128
	<mul+160 @05f7f8>  : 10 05                      dup.x32 sp(5)
	<mul+162 @05f7fa>  : 2a                         load.i128
	<mul+163 @05f7fb>  : 9b                         dp4.v4f
	<mul+164 @05f7fc>  : 10 03                      dup.x32 sp(3)
	<mul+166 @05f7fe>  : 0c 10 00 00                inc.i32(+16)
	<mul+170 @05f802>  : 2a                         load.i128
	<mul+171 @05f803>  : 10 06                      dup.x32 sp(6)
	<mul+173 @05f805>  : 2a                         load.i128
	<mul+174 @05f806>  : 9b                         dp4.v4f
	<mul+175 @05f807>  : 10 04                      dup.x32 sp(4)
	<mul+177 @05f809>  : 2a                         load.i128
	<mul+178 @05f80a>  : 10 07                      dup.x32 sp(7)
	<mul+180 @05f80c>  : 2a                         load.i128
	<mul+181 @05f80d>  : 9b                         dp4.v4f
	<mul+182 @05f80e>  : 15 02                      set.x128 sp(2)
	<mul+184 @05f810>  : 15 1f                      set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (54 bytes: <mul+186 @05f812> - <mul+240 @05f848>): .result.w := dp4(transposed, lhs.w);
	<mul+186 @05f812>  : 0a 00 00 00                load.sp(+0)
	<mul+190 @05f816>  : 10 13                      dup.x32 sp(19)
	<mul+192 @05f818>  : 0c 30 00 00                inc.i32(+48)
	<mul+196 @05f81c>  : 10 01                      dup.x32 sp(1)
	<mul+198 @05f81e>  : 0c 30 00 00                inc.i32(+48)
	<mul+202 @05f822>  : 2a                         load.i128
	<mul+203 @05f823>  : 10 04                      dup.x32 sp(4)
	<mul+205 @05f825>  : 2a                         load.i128
	<mul+206 @05f826>  : 9b                         dp4.v4f
	<mul+207 @05f827>  : 10 02                      dup.x32 sp(2)
	<mul+209 @05f829>  : 0c 20 00 00                inc.i32(+32)
	<mul+213 @05f82d>  : 2a                         load.i128
	<mul+214 @05f82e>  : 10 05                      dup.x32 sp(5)
	<mul+216 @05f830>  : 2a                         load.i128
	<mul+217 @05f831>  : 9b                         dp4.v4f
	<mul+218 @05f832>  : 10 03                      dup.x32 sp(3)
	<mul+220 @05f834>  : 0c 10 00 00                inc.i32(+16)
	<mul+224 @05f838>  : 2a                         load.i128
	<mul+225 @05f839>  : 10 06                      dup.x32 sp(6)
	<mul+227 @05f83b>  : 2a                         load.i128
	<mul+228 @05f83c>  : 9b                         dp4.v4f
	<mul+229 @05f83d>  : 10 04                      dup.x32 sp(4)
	<mul+231 @05f83f>  : 2a                         load.i128
	<mul+232 @05f840>  : 10 07                      dup.x32 sp(7)
	<mul+234 @05f842>  : 2a                         load.i128
	<mul+235 @05f843>  : 9b                         dp4.v4f
	<mul+236 @05f844>  : 15 02                      set.x128 sp(2)
	<mul+238 @05f846>  : 15 23                      set.x128 sp(35)
	<mul+240 @05f848>  : 09 c0 ff ff                inc.sp(-64)
	<mul+244 @05f84c>  : 03                         ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 454
.offset: <@05f850>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:111'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param center: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param direction: vec4f (size: 4, offs: <+72>, cast: const variable(ref))
.param angle: float32 (size: 4, offs: <+76>, cast: variable(f32))
.doc: 'Build a rotation matrix
adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas'
.value: {
	len: float32 := length(direction);
	if (bool((len) < 0.000000)) {
		trace(void("invalid direction of rotation", direction));
		return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
	}
	x: float32 := float32(direction.x / len);
	y: float32 := float32(direction.y / len);
	z: float32 := float32(direction.z / len);
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := float32(x * x);
	xy: float32 := float32(x * y);
	xz: float32 := float32(x * z);
	yy: float32 := float32(y * y);
	yz: float32 := float32(y * z);
	zz: float32 := float32(z * z);
	s: float32 := float32.sin(angle);
	c: float32 := float32.cos(angle);
	k: float32 := float32((1) - c);
	return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
}
.instructions: (454 bytes: <rotation @05f850> - <rotation+454 @05fa16>)
	cmplStd/lib/math/Matrix4f.ci:112: (18 bytes: <rotation @05f850> - <rotation+18 @05f862>): len: float32 := length(direction)
	<rotation @05f850>      : 10 02                      dup.x32 sp(2)
	<rotation+2 @05f852>    : 2a                         load.i128
	<rotation+3 @05f853>    : 12 00                      dup.x128 sp(0)
	<rotation+5 @05f855>    : 12 04                      dup.x128 sp(4)
	<rotation+7 @05f857>    : 9a                         dp3.v4f
	<rotation+8 @05f858>    : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<rotation+12 @05f85c>   : 13 04                      set.x32 sp(4)
	<rotation+14 @05f85e>   : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/math/Matrix4f.ci:113: (82 bytes: <rotation+18 @05f862> - <rotation+100 @05f8b4>): if ((len) < 0.000000)
	<rotation+18 @05f862>   : 10 00                      dup.x32 sp(0)
	<rotation+20 @05f864>   : 7d                         f32.2f64
	<rotation+21 @05f865>   : 8f 95 d6 26 e8 0b 2e 11 3e load.f64 0.000000
	<rotation+30 @05f86e>   : 88                         clt.f64
	<rotation+31 @05f86f>   : 06 45 00 00                jz <rotation+100 @05f8b4>
	cmplStd/lib/math/Matrix4f.ci:114: (36 bytes: <rotation+35 @05f873> - <rotation+71 @05f897>): trace("invalid direction of rotation", direction);
	<rotation+35 @05f873>   : 1f 30 7a 02 00             load.ref <@027a30> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+40 @05f878>   : 1c 72 00 00 00             load.c32 114
	<rotation+45 @05f87d>   : 1c 0e 00 00 00             load.c32 14
	<rotation+50 @05f882>   : 1c 80 00 00 00             load.c32 128
	<rotation+55 @05f887>   : 1f ed 7c 02 00             load.ref <@027ced> ;"invalid direction of rotation"
	<rotation+60 @05f88c>   : 1f e8 28 02 00             load.ref <@0228e8> ;vec4f
	<rotation+65 @05f891>   : 10 09                      dup.x32 sp(9)
	<rotation+67 @05f893>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/math/Matrix4f.ci:115: (29 bytes: <rotation+71 @05f897> - <rotation+100 @05f8b4>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes: <rotation+71 @05f897> - <rotation+77 @05f89d>): .result.x := vec4f(0, 0, 0, 0);
	<rotation+71 @05f897>   : 19                         load.z32
	<rotation+72 @05f898>   : 19                         load.z32
	<rotation+73 @05f899>   : 19                         load.z32
	<rotation+74 @05f89a>   : 19                         load.z32
	<rotation+75 @05f89b>   : 15 09                      set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes: <rotation+77 @05f89d> - <rotation+83 @05f8a3>): .result.y := vec4f(0, 0, 0, 0);
	<rotation+77 @05f89d>   : 19                         load.z32
	<rotation+78 @05f89e>   : 19                         load.z32
	<rotation+79 @05f89f>   : 19                         load.z32
	<rotation+80 @05f8a0>   : 19                         load.z32
	<rotation+81 @05f8a1>   : 15 0d                      set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:118: (6 bytes: <rotation+83 @05f8a3> - <rotation+89 @05f8a9>): .result.z := vec4f(0, 0, 0, 0);
	<rotation+83 @05f8a3>   : 19                         load.z32
	<rotation+84 @05f8a4>   : 19                         load.z32
	<rotation+85 @05f8a5>   : 19                         load.z32
	<rotation+86 @05f8a6>   : 19                         load.z32
	<rotation+87 @05f8a7>   : 15 11                      set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:119: (6 bytes: <rotation+89 @05f8a9> - <rotation+95 @05f8af>): .result.w := vec4f(0, 0, 0, 0);
	<rotation+89 @05f8a9>   : 19                         load.z32
	<rotation+90 @05f8aa>   : 19                         load.z32
	<rotation+91 @05f8ab>   : 19                         load.z32
	<rotation+92 @05f8ac>   : 19                         load.z32
	<rotation+93 @05f8ad>   : 15 15                      set.x128 sp(21)
	<rotation+95 @05f8af>   : 09 fc ff ff                inc.sp(-4)
	<rotation+99 @05f8b3>   : 03                         ret
	cmplStd/lib/math/Matrix4f.ci:122: (6 bytes: <rotation+100 @05f8b4> - <rotation+106 @05f8ba>): x: float32 := direction.x / len
	<rotation+100 @05f8b4>  : 10 03                      dup.x32 sp(3)
	<rotation+102 @05f8b6>  : 28                         load.i32
	<rotation+103 @05f8b7>  : 10 01                      dup.x32 sp(1)
	<rotation+105 @05f8b9>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (10 bytes: <rotation+106 @05f8ba> - <rotation+116 @05f8c4>): y: float32 := direction.y / len
	<rotation+106 @05f8ba>  : 10 04                      dup.x32 sp(4)
	<rotation+108 @05f8bc>  : 0c 04 00 00                inc.i32(+4)
	<rotation+112 @05f8c0>  : 28                         load.i32
	<rotation+113 @05f8c1>  : 10 02                      dup.x32 sp(2)
	<rotation+115 @05f8c3>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:124: (10 bytes: <rotation+116 @05f8c4> - <rotation+126 @05f8ce>): z: float32 := direction.z / len
	<rotation+116 @05f8c4>  : 10 05                      dup.x32 sp(5)
	<rotation+118 @05f8c6>  : 0c 08 00 00                inc.i32(+8)
	<rotation+122 @05f8ca>  : 28                         load.i32
	<rotation+123 @05f8cb>  : 10 03                      dup.x32 sp(3)
	<rotation+125 @05f8cd>  : 74                         div.f32
	cmplStd/lib/math/Matrix4f.ci:125: (3 bytes: <rotation+126 @05f8ce> - <rotation+129 @05f8d1>): cx: float32 := center.x
	<rotation+126 @05f8ce>  : 10 07                      dup.x32 sp(7)
	<rotation+128 @05f8d0>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (7 bytes: <rotation+129 @05f8d1> - <rotation+136 @05f8d8>): cy: float32 := center.y
	<rotation+129 @05f8d1>  : 10 08                      dup.x32 sp(8)
	<rotation+131 @05f8d3>  : 0c 04 00 00                inc.i32(+4)
	<rotation+135 @05f8d7>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:127: (7 bytes: <rotation+136 @05f8d8> - <rotation+143 @05f8df>): cz: float32 := center.z
	<rotation+136 @05f8d8>  : 10 09                      dup.x32 sp(9)
	<rotation+138 @05f8da>  : 0c 08 00 00                inc.i32(+8)
	<rotation+142 @05f8de>  : 28                         load.i32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes: <rotation+143 @05f8df> - <rotation+148 @05f8e4>): xx: float32 := x * x
	<rotation+143 @05f8df>  : 10 05                      dup.x32 sp(5)
	<rotation+145 @05f8e1>  : 10 06                      dup.x32 sp(6)
	<rotation+147 @05f8e3>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes: <rotation+148 @05f8e4> - <rotation+153 @05f8e9>): xy: float32 := x * y
	<rotation+148 @05f8e4>  : 10 06                      dup.x32 sp(6)
	<rotation+150 @05f8e6>  : 10 06                      dup.x32 sp(6)
	<rotation+152 @05f8e8>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes: <rotation+153 @05f8e9> - <rotation+158 @05f8ee>): xz: float32 := x * z
	<rotation+153 @05f8e9>  : 10 07                      dup.x32 sp(7)
	<rotation+155 @05f8eb>  : 10 06                      dup.x32 sp(6)
	<rotation+157 @05f8ed>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes: <rotation+158 @05f8ee> - <rotation+163 @05f8f3>): yy: float32 := y * y
	<rotation+158 @05f8ee>  : 10 07                      dup.x32 sp(7)
	<rotation+160 @05f8f0>  : 10 08                      dup.x32 sp(8)
	<rotation+162 @05f8f2>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:132: (5 bytes: <rotation+163 @05f8f3> - <rotation+168 @05f8f8>): yz: float32 := y * z
	<rotation+163 @05f8f3>  : 10 08                      dup.x32 sp(8)
	<rotation+165 @05f8f5>  : 10 08                      dup.x32 sp(8)
	<rotation+167 @05f8f7>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (5 bytes: <rotation+168 @05f8f8> - <rotation+173 @05f8fd>): zz: float32 := z * z
	<rotation+168 @05f8f8>  : 10 08                      dup.x32 sp(8)
	<rotation+170 @05f8fa>  : 10 09                      dup.x32 sp(9)
	<rotation+172 @05f8fc>  : 73                         mul.f32
	cmplStd/lib/math/Matrix4f.ci:135: (6 bytes: <rotation+173 @05f8fd> - <rotation+179 @05f903>): s: float32 := float32.sin(angle)
	<rotation+173 @05f8fd>  : 10 0e                      dup.x32 sp(14)
	<rotation+175 @05f8ff>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:136: (6 bytes: <rotation+179 @05f903> - <rotation+185 @05f909>): c: float32 := float32.cos(angle)
	<rotation+179 @05f903>  : 10 0f                      dup.x32 sp(15)
	<rotation+181 @05f905>  : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	cmplStd/lib/math/Matrix4f.ci:137: (8 bytes: <rotation+185 @05f909> - <rotation+193 @05f911>): k: float32 := (1) - c
	<rotation+185 @05f909>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+190 @05f90e>  : 10 01                      dup.x32 sp(1)
	<rotation+192 @05f910>  : 72                         sub.f32
	cmplStd/lib/math/Matrix4f.ci:139: (261 bytes: <rotation+193 @05f911> - <rotation+454 @05fa16>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes: <rotation+193 @05f911> - <rotation+206 @05f91e>): .result.xx := xx + (yy + zz) * c;
	<rotation+193 @05f911>  : 10 08                      dup.x32 sp(8)
	<rotation+195 @05f913>  : 10 06                      dup.x32 sp(6)
	<rotation+197 @05f915>  : 10 05                      dup.x32 sp(5)
	<rotation+199 @05f917>  : 71                         add.f32
	<rotation+200 @05f918>  : 10 03                      dup.x32 sp(3)
	<rotation+202 @05f91a>  : 73                         mul.f32
	<rotation+203 @05f91b>  : 71                         add.f32
	<rotation+204 @05f91c>  : 13 15                      set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:141: (13 bytes: <rotation+206 @05f91e> - <rotation+219 @05f92b>): .result.xy := xy * k - z * s;
	<rotation+206 @05f91e>  : 10 07                      dup.x32 sp(7)
	<rotation+208 @05f920>  : 10 01                      dup.x32 sp(1)
	<rotation+210 @05f922>  : 73                         mul.f32
	<rotation+211 @05f923>  : 10 0d                      dup.x32 sp(13)
	<rotation+213 @05f925>  : 10 04                      dup.x32 sp(4)
	<rotation+215 @05f927>  : 73                         mul.f32
	<rotation+216 @05f928>  : 72                         sub.f32
	<rotation+217 @05f929>  : 13 16                      set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:142: (13 bytes: <rotation+219 @05f92b> - <rotation+232 @05f938>): .result.xz := xz * k + y * s;
	<rotation+219 @05f92b>  : 10 06                      dup.x32 sp(6)
	<rotation+221 @05f92d>  : 10 01                      dup.x32 sp(1)
	<rotation+223 @05f92f>  : 73                         mul.f32
	<rotation+224 @05f930>  : 10 0e                      dup.x32 sp(14)
	<rotation+226 @05f932>  : 10 04                      dup.x32 sp(4)
	<rotation+228 @05f934>  : 73                         mul.f32
	<rotation+229 @05f935>  : 71                         add.f32
	<rotation+230 @05f936>  : 13 17                      set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:143: (43 bytes: <rotation+232 @05f938> - <rotation+275 @05f963>): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+232 @05f938>  : 10 0b                      dup.x32 sp(11)
	<rotation+234 @05f93a>  : 10 06                      dup.x32 sp(6)
	<rotation+236 @05f93c>  : 10 05                      dup.x32 sp(5)
	<rotation+238 @05f93e>  : 71                         add.f32
	<rotation+239 @05f93f>  : 73                         mul.f32
	<rotation+240 @05f940>  : 10 0f                      dup.x32 sp(15)
	<rotation+242 @05f942>  : 10 0c                      dup.x32 sp(12)
	<rotation+244 @05f944>  : 10 10                      dup.x32 sp(16)
	<rotation+246 @05f946>  : 73                         mul.f32
	<rotation+247 @05f947>  : 10 0c                      dup.x32 sp(12)
	<rotation+249 @05f949>  : 10 10                      dup.x32 sp(16)
	<rotation+251 @05f94b>  : 73                         mul.f32
	<rotation+252 @05f94c>  : 71                         add.f32
	<rotation+253 @05f94d>  : 73                         mul.f32
	<rotation+254 @05f94e>  : 72                         sub.f32
	<rotation+255 @05f94f>  : 10 01                      dup.x32 sp(1)
	<rotation+257 @05f951>  : 73                         mul.f32
	<rotation+258 @05f952>  : 10 0b                      dup.x32 sp(11)
	<rotation+260 @05f954>  : 10 0e                      dup.x32 sp(14)
	<rotation+262 @05f956>  : 73                         mul.f32
	<rotation+263 @05f957>  : 10 0b                      dup.x32 sp(11)
	<rotation+265 @05f959>  : 10 10                      dup.x32 sp(16)
	<rotation+267 @05f95b>  : 73                         mul.f32
	<rotation+268 @05f95c>  : 72                         sub.f32
	<rotation+269 @05f95d>  : 10 04                      dup.x32 sp(4)
	<rotation+271 @05f95f>  : 73                         mul.f32
	<rotation+272 @05f960>  : 71                         add.f32
	<rotation+273 @05f961>  : 13 18                      set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes: <rotation+275 @05f963> - <rotation+288 @05f970>): .result.yx := xy * k + z * s;
	<rotation+275 @05f963>  : 10 07                      dup.x32 sp(7)
	<rotation+277 @05f965>  : 10 01                      dup.x32 sp(1)
	<rotation+279 @05f967>  : 73                         mul.f32
	<rotation+280 @05f968>  : 10 0d                      dup.x32 sp(13)
	<rotation+282 @05f96a>  : 10 04                      dup.x32 sp(4)
	<rotation+284 @05f96c>  : 73                         mul.f32
	<rotation+285 @05f96d>  : 71                         add.f32
	<rotation+286 @05f96e>  : 13 19                      set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:146: (13 bytes: <rotation+288 @05f970> - <rotation+301 @05f97d>): .result.yy := yy + (xx + zz) * c;
	<rotation+288 @05f970>  : 10 05                      dup.x32 sp(5)
	<rotation+290 @05f972>  : 10 09                      dup.x32 sp(9)
	<rotation+292 @05f974>  : 10 05                      dup.x32 sp(5)
	<rotation+294 @05f976>  : 71                         add.f32
	<rotation+295 @05f977>  : 10 03                      dup.x32 sp(3)
	<rotation+297 @05f979>  : 73                         mul.f32
	<rotation+298 @05f97a>  : 71                         add.f32
	<rotation+299 @05f97b>  : 13 1a                      set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:147: (13 bytes: <rotation+301 @05f97d> - <rotation+314 @05f98a>): .result.yz := yz * k - x * s;
	<rotation+301 @05f97d>  : 10 04                      dup.x32 sp(4)
	<rotation+303 @05f97f>  : 10 01                      dup.x32 sp(1)
	<rotation+305 @05f981>  : 73                         mul.f32
	<rotation+306 @05f982>  : 10 0f                      dup.x32 sp(15)
	<rotation+308 @05f984>  : 10 04                      dup.x32 sp(4)
	<rotation+310 @05f986>  : 73                         mul.f32
	<rotation+311 @05f987>  : 72                         sub.f32
	<rotation+312 @05f988>  : 13 1b                      set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:148: (43 bytes: <rotation+314 @05f98a> - <rotation+357 @05f9b5>): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+314 @05f98a>  : 10 0a                      dup.x32 sp(10)
	<rotation+316 @05f98c>  : 10 09                      dup.x32 sp(9)
	<rotation+318 @05f98e>  : 10 05                      dup.x32 sp(5)
	<rotation+320 @05f990>  : 71                         add.f32
	<rotation+321 @05f991>  : 73                         mul.f32
	<rotation+322 @05f992>  : 10 0e                      dup.x32 sp(14)
	<rotation+324 @05f994>  : 10 0d                      dup.x32 sp(13)
	<rotation+326 @05f996>  : 10 11                      dup.x32 sp(17)
	<rotation+328 @05f998>  : 73                         mul.f32
	<rotation+329 @05f999>  : 10 0c                      dup.x32 sp(12)
	<rotation+331 @05f99b>  : 10 10                      dup.x32 sp(16)
	<rotation+333 @05f99d>  : 73                         mul.f32
	<rotation+334 @05f99e>  : 71                         add.f32
	<rotation+335 @05f99f>  : 73                         mul.f32
	<rotation+336 @05f9a0>  : 72                         sub.f32
	<rotation+337 @05f9a1>  : 10 01                      dup.x32 sp(1)
	<rotation+339 @05f9a3>  : 73                         mul.f32
	<rotation+340 @05f9a4>  : 10 0a                      dup.x32 sp(10)
	<rotation+342 @05f9a6>  : 10 10                      dup.x32 sp(16)
	<rotation+344 @05f9a8>  : 73                         mul.f32
	<rotation+345 @05f9a9>  : 10 0d                      dup.x32 sp(13)
	<rotation+347 @05f9ab>  : 10 0f                      dup.x32 sp(15)
	<rotation+349 @05f9ad>  : 73                         mul.f32
	<rotation+350 @05f9ae>  : 72                         sub.f32
	<rotation+351 @05f9af>  : 10 04                      dup.x32 sp(4)
	<rotation+353 @05f9b1>  : 73                         mul.f32
	<rotation+354 @05f9b2>  : 71                         add.f32
	<rotation+355 @05f9b3>  : 13 1c                      set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes: <rotation+357 @05f9b5> - <rotation+370 @05f9c2>): .result.zx := xz * k - y * s;
	<rotation+357 @05f9b5>  : 10 06                      dup.x32 sp(6)
	<rotation+359 @05f9b7>  : 10 01                      dup.x32 sp(1)
	<rotation+361 @05f9b9>  : 73                         mul.f32
	<rotation+362 @05f9ba>  : 10 0e                      dup.x32 sp(14)
	<rotation+364 @05f9bc>  : 10 04                      dup.x32 sp(4)
	<rotation+366 @05f9be>  : 73                         mul.f32
	<rotation+367 @05f9bf>  : 72                         sub.f32
	<rotation+368 @05f9c0>  : 13 1d                      set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:151: (13 bytes: <rotation+370 @05f9c2> - <rotation+383 @05f9cf>): .result.zy := yz * k + x * s;
	<rotation+370 @05f9c2>  : 10 04                      dup.x32 sp(4)
	<rotation+372 @05f9c4>  : 10 01                      dup.x32 sp(1)
	<rotation+374 @05f9c6>  : 73                         mul.f32
	<rotation+375 @05f9c7>  : 10 0f                      dup.x32 sp(15)
	<rotation+377 @05f9c9>  : 10 04                      dup.x32 sp(4)
	<rotation+379 @05f9cb>  : 73                         mul.f32
	<rotation+380 @05f9cc>  : 71                         add.f32
	<rotation+381 @05f9cd>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:152: (13 bytes: <rotation+383 @05f9cf> - <rotation+396 @05f9dc>): .result.zz := zz + (xx + yy) * c;
	<rotation+383 @05f9cf>  : 10 03                      dup.x32 sp(3)
	<rotation+385 @05f9d1>  : 10 09                      dup.x32 sp(9)
	<rotation+387 @05f9d3>  : 10 07                      dup.x32 sp(7)
	<rotation+389 @05f9d5>  : 71                         add.f32
	<rotation+390 @05f9d6>  : 10 03                      dup.x32 sp(3)
	<rotation+392 @05f9d8>  : 73                         mul.f32
	<rotation+393 @05f9d9>  : 71                         add.f32
	<rotation+394 @05f9da>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:153: (43 bytes: <rotation+396 @05f9dc> - <rotation+439 @05fa07>): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+396 @05f9dc>  : 10 09                      dup.x32 sp(9)
	<rotation+398 @05f9de>  : 10 09                      dup.x32 sp(9)
	<rotation+400 @05f9e0>  : 10 07                      dup.x32 sp(7)
	<rotation+402 @05f9e2>  : 71                         add.f32
	<rotation+403 @05f9e3>  : 73                         mul.f32
	<rotation+404 @05f9e4>  : 10 0d                      dup.x32 sp(13)
	<rotation+406 @05f9e6>  : 10 0d                      dup.x32 sp(13)
	<rotation+408 @05f9e8>  : 10 11                      dup.x32 sp(17)
	<rotation+410 @05f9ea>  : 73                         mul.f32
	<rotation+411 @05f9eb>  : 10 0d                      dup.x32 sp(13)
	<rotation+413 @05f9ed>  : 10 11                      dup.x32 sp(17)
	<rotation+415 @05f9ef>  : 73                         mul.f32
	<rotation+416 @05f9f0>  : 71                         add.f32
	<rotation+417 @05f9f1>  : 73                         mul.f32
	<rotation+418 @05f9f2>  : 72                         sub.f32
	<rotation+419 @05f9f3>  : 10 01                      dup.x32 sp(1)
	<rotation+421 @05f9f5>  : 73                         mul.f32
	<rotation+422 @05f9f6>  : 10 0c                      dup.x32 sp(12)
	<rotation+424 @05f9f8>  : 10 0f                      dup.x32 sp(15)
	<rotation+426 @05f9fa>  : 73                         mul.f32
	<rotation+427 @05f9fb>  : 10 0c                      dup.x32 sp(12)
	<rotation+429 @05f9fd>  : 10 11                      dup.x32 sp(17)
	<rotation+431 @05f9ff>  : 73                         mul.f32
	<rotation+432 @05fa00>  : 72                         sub.f32
	<rotation+433 @05fa01>  : 10 04                      dup.x32 sp(4)
	<rotation+435 @05fa03>  : 73                         mul.f32
	<rotation+436 @05fa04>  : 71                         add.f32
	<rotation+437 @05fa05>  : 13 20                      set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:155: (10 bytes: <rotation+439 @05fa07> - <rotation+449 @05fa11>): .result.w := vec4f(0, 0, 0, 1);
	<rotation+439 @05fa07>  : 7f 00 00 80 3f             load.f32 1.000000
	<rotation+444 @05fa0c>  : 19                         load.z32
	<rotation+445 @05fa0d>  : 19                         load.z32
	<rotation+446 @05fa0e>  : 19                         load.z32
	<rotation+447 @05fa0f>  : 15 24                      set.x128 sp(36)
	<rotation+449 @05fa11>  : 09 c0 ff ff                inc.sp(-64)
	<rotation+453 @05fa15>  : 03                         ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:160'
.param .result: mat4f (size: 64, offs: <+0>, cast: val)
.param direction: vec4f (size: 4, offs: <+4>, cast: const ref)
.param angle: float32 (size: 4, offs: <+8>, cast: f32)
.doc: 'Build a rotation matrix'
.value: rotation(void(void(vec4f(0), direction), angle))
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.offset: <@05fa18>
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:163'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (88 bytes: <translation @05fa18> - <translation+88 @05fa70>)
	cmplStd/lib/math/Matrix4f.ci:164: (88 bytes: <translation @05fa18> - <translation+88 @05fa70>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:165: (7 bytes: <translation @05fa18> - <translation+7 @05fa1f>): .result.xx := (1);
	<translation @05fa18>      : 7f 00 00 80 3f             load.f32 1.000000
	<translation+5 @05fa1d>    : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+7 @05fa1f> - <translation+10 @05fa22>): .result.xy := (0);
	<translation+7 @05fa1f>    : 19                         load.z32
	<translation+8 @05fa20>    : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:165: (3 bytes: <translation+10 @05fa22> - <translation+13 @05fa25>): .result.xz := (0);
	<translation+10 @05fa22>   : 19                         load.z32
	<translation+11 @05fa23>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:165: (8 bytes: <translation+13 @05fa25> - <translation+21 @05fa2d>): .result.xw := direction.x * amount;
	<translation+13 @05fa25>   : 10 02                      dup.x32 sp(2)
	<translation+15 @05fa27>   : 28                         load.i32
	<translation+16 @05fa28>   : 10 02                      dup.x32 sp(2)
	<translation+18 @05fa2a>   : 73                         mul.f32
	<translation+19 @05fa2b>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+21 @05fa2d> - <translation+24 @05fa30>): .result.yx := (0);
	<translation+21 @05fa2d>   : 19                         load.z32
	<translation+22 @05fa2e>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:166: (7 bytes: <translation+24 @05fa30> - <translation+31 @05fa37>): .result.yy := (1);
	<translation+24 @05fa30>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+29 @05fa35>   : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:166: (3 bytes: <translation+31 @05fa37> - <translation+34 @05fa3a>): .result.yz := (0);
	<translation+31 @05fa37>   : 19                         load.z32
	<translation+32 @05fa38>   : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:166: (12 bytes: <translation+34 @05fa3a> - <translation+46 @05fa46>): .result.yw := direction.y * amount;
	<translation+34 @05fa3a>   : 10 02                      dup.x32 sp(2)
	<translation+36 @05fa3c>   : 0c 04 00 00                inc.i32(+4)
	<translation+40 @05fa40>   : 28                         load.i32
	<translation+41 @05fa41>   : 10 02                      dup.x32 sp(2)
	<translation+43 @05fa43>   : 73                         mul.f32
	<translation+44 @05fa44>   : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+46 @05fa46> - <translation+49 @05fa49>): .result.zx := (0);
	<translation+46 @05fa46>   : 19                         load.z32
	<translation+47 @05fa47>   : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:167: (3 bytes: <translation+49 @05fa49> - <translation+52 @05fa4c>): .result.zy := (0);
	<translation+49 @05fa49>   : 19                         load.z32
	<translation+50 @05fa4a>   : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:167: (7 bytes: <translation+52 @05fa4c> - <translation+59 @05fa53>): .result.zz := (1);
	<translation+52 @05fa4c>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+57 @05fa51>   : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:167: (12 bytes: <translation+59 @05fa53> - <translation+71 @05fa5f>): .result.zw := direction.z * amount;
	<translation+59 @05fa53>   : 10 02                      dup.x32 sp(2)
	<translation+61 @05fa55>   : 0c 08 00 00                inc.i32(+8)
	<translation+65 @05fa59>   : 28                         load.i32
	<translation+66 @05fa5a>   : 10 02                      dup.x32 sp(2)
	<translation+68 @05fa5c>   : 73                         mul.f32
	<translation+69 @05fa5d>   : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+71 @05fa5f> - <translation+74 @05fa62>): .result.wx := (0);
	<translation+71 @05fa5f>   : 19                         load.z32
	<translation+72 @05fa60>   : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+74 @05fa62> - <translation+77 @05fa65>): .result.wy := (0);
	<translation+74 @05fa62>   : 19                         load.z32
	<translation+75 @05fa63>   : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:168: (3 bytes: <translation+77 @05fa65> - <translation+80 @05fa68>): .result.wz := (0);
	<translation+77 @05fa65>   : 19                         load.z32
	<translation+78 @05fa66>   : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:168: (7 bytes: <translation+80 @05fa68> - <translation+87 @05fa6f>): .result.ww := (1);
	<translation+80 @05fa68>   : 7f 00 00 80 3f             load.f32 1.000000
	<translation+85 @05fa6d>   : 13 13                      set.x32 sp(19)
	<translation+87 @05fa6f>   : 03                         ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.offset: <@05fa70>
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:173'
.param .result: mat4f (size: 64, offs: <+64>, cast: variable(val))
.param direction: vec4f (size: 4, offs: <+68>, cast: const variable(ref))
.param amount: float32 (size: 4, offs: <+72>, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
	return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
}
.instructions: (217 bytes: <scale @05fa70> - <scale+217 @05fb49>)
	cmplStd/lib/math/Matrix4f.ci:175: (217 bytes: <scale @05fa70> - <scale+217 @05fb49>): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:176: (55 bytes: <scale @05fa70> - <scale+55 @05faa7>): .result.xx := rcp(direction.x * amount);
	<scale @05fa70>      : 10 02                      dup.x32 sp(2)
	<scale+2 @05fa72>    : 28                         load.i32
	<scale+3 @05fa73>    : 10 02                      dup.x32 sp(2)
	<scale+5 @05fa75>    : 73                         mul.f32
	<scale+6 @05fa76>    : 10 00                      dup.x32 sp(0)
	<scale+8 @05fa78>    : 19                         load.z32
	<scale+9 @05fa79>    : 78                         clt.f32
	<scale+10 @05fa7a>   : 06 0b 00 00                jz <scale+21 @05fa85>
	<scale+14 @05fa7e>   : 10 00                      dup.x32 sp(0)
	<scale+16 @05fa80>   : 70                         neg.f32
	<scale+17 @05fa81>   : 04 06 00 00                jmp <scale+23 @05fa87>
	<scale+21 @05fa85>   : 10 00                      dup.x32 sp(0)
	<scale+23 @05fa87>   : 7d                         f32.2f64
	<scale+24 @05fa88>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+33 @05fa91>   : 88                         clt.f64
	<scale+34 @05fa92>   : 06 09 00 00                jz <scale+43 @05fa9b>
	<scale+38 @05fa96>   : 19                         load.z32
	<scale+39 @05fa97>   : 04 0c 00 00                jmp <scale+51 @05faa3>
	<scale+43 @05fa9b>   : 7f 00 00 80 3f             load.f32 1.000000
	<scale+48 @05faa0>   : 10 01                      dup.x32 sp(1)
	<scale+50 @05faa2>   : 74                         div.f32
	<scale+51 @05faa3>   : 13 01                      set.x32 sp(1)
	<scale+53 @05faa5>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+55 @05faa7> - <scale+58 @05faaa>): .result.xy := (0);
	<scale+55 @05faa7>   : 19                         load.z32
	<scale+56 @05faa8>   : 13 05                      set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+58 @05faaa> - <scale+61 @05faad>): .result.xz := (0);
	<scale+58 @05faaa>   : 19                         load.z32
	<scale+59 @05faab>   : 13 06                      set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:176: (3 bytes: <scale+61 @05faad> - <scale+64 @05fab0>): .result.xw := (0);
	<scale+61 @05faad>   : 19                         load.z32
	<scale+62 @05faae>   : 13 07                      set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+64 @05fab0> - <scale+67 @05fab3>): .result.yx := (0);
	<scale+64 @05fab0>   : 19                         load.z32
	<scale+65 @05fab1>   : 13 08                      set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:177: (59 bytes: <scale+67 @05fab3> - <scale+126 @05faee>): .result.yy := rcp(direction.y * amount);
	<scale+67 @05fab3>   : 10 02                      dup.x32 sp(2)
	<scale+69 @05fab5>   : 0c 04 00 00                inc.i32(+4)
	<scale+73 @05fab9>   : 28                         load.i32
	<scale+74 @05faba>   : 10 02                      dup.x32 sp(2)
	<scale+76 @05fabc>   : 73                         mul.f32
	<scale+77 @05fabd>   : 10 00                      dup.x32 sp(0)
	<scale+79 @05fabf>   : 19                         load.z32
	<scale+80 @05fac0>   : 78                         clt.f32
	<scale+81 @05fac1>   : 06 0b 00 00                jz <scale+92 @05facc>
	<scale+85 @05fac5>   : 10 00                      dup.x32 sp(0)
	<scale+87 @05fac7>   : 70                         neg.f32
	<scale+88 @05fac8>   : 04 06 00 00                jmp <scale+94 @05face>
	<scale+92 @05facc>   : 10 00                      dup.x32 sp(0)
	<scale+94 @05face>   : 7d                         f32.2f64
	<scale+95 @05facf>   : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+104 @05fad8>  : 88                         clt.f64
	<scale+105 @05fad9>  : 06 09 00 00                jz <scale+114 @05fae2>
	<scale+109 @05fadd>  : 19                         load.z32
	<scale+110 @05fade>  : 04 0c 00 00                jmp <scale+122 @05faea>
	<scale+114 @05fae2>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+119 @05fae7>  : 10 01                      dup.x32 sp(1)
	<scale+121 @05fae9>  : 74                         div.f32
	<scale+122 @05faea>  : 13 01                      set.x32 sp(1)
	<scale+124 @05faec>  : 13 09                      set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+126 @05faee> - <scale+129 @05faf1>): .result.yz := (0);
	<scale+126 @05faee>  : 19                         load.z32
	<scale+127 @05faef>  : 13 0a                      set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:177: (3 bytes: <scale+129 @05faf1> - <scale+132 @05faf4>): .result.yw := (0);
	<scale+129 @05faf1>  : 19                         load.z32
	<scale+130 @05faf2>  : 13 0b                      set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+132 @05faf4> - <scale+135 @05faf7>): .result.zx := (0);
	<scale+132 @05faf4>  : 19                         load.z32
	<scale+133 @05faf5>  : 13 0c                      set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+135 @05faf7> - <scale+138 @05fafa>): .result.zy := (0);
	<scale+135 @05faf7>  : 19                         load.z32
	<scale+136 @05faf8>  : 13 0d                      set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:178: (59 bytes: <scale+138 @05fafa> - <scale+197 @05fb35>): .result.zz := rcp(direction.z * amount);
	<scale+138 @05fafa>  : 10 02                      dup.x32 sp(2)
	<scale+140 @05fafc>  : 0c 08 00 00                inc.i32(+8)
	<scale+144 @05fb00>  : 28                         load.i32
	<scale+145 @05fb01>  : 10 02                      dup.x32 sp(2)
	<scale+147 @05fb03>  : 73                         mul.f32
	<scale+148 @05fb04>  : 10 00                      dup.x32 sp(0)
	<scale+150 @05fb06>  : 19                         load.z32
	<scale+151 @05fb07>  : 78                         clt.f32
	<scale+152 @05fb08>  : 06 0b 00 00                jz <scale+163 @05fb13>
	<scale+156 @05fb0c>  : 10 00                      dup.x32 sp(0)
	<scale+158 @05fb0e>  : 70                         neg.f32
	<scale+159 @05fb0f>  : 04 06 00 00                jmp <scale+165 @05fb15>
	<scale+163 @05fb13>  : 10 00                      dup.x32 sp(0)
	<scale+165 @05fb15>  : 7d                         f32.2f64
	<scale+166 @05fb16>  : 8f a0 c2 eb fe 4b 48 b4 39 load.f64 0.000000
	<scale+175 @05fb1f>  : 88                         clt.f64
	<scale+176 @05fb20>  : 06 09 00 00                jz <scale+185 @05fb29>
	<scale+180 @05fb24>  : 19                         load.z32
	<scale+181 @05fb25>  : 04 0c 00 00                jmp <scale+193 @05fb31>
	<scale+185 @05fb29>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+190 @05fb2e>  : 10 01                      dup.x32 sp(1)
	<scale+192 @05fb30>  : 74                         div.f32
	<scale+193 @05fb31>  : 13 01                      set.x32 sp(1)
	<scale+195 @05fb33>  : 13 0e                      set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:178: (3 bytes: <scale+197 @05fb35> - <scale+200 @05fb38>): .result.zw := (0);
	<scale+197 @05fb35>  : 19                         load.z32
	<scale+198 @05fb36>  : 13 0f                      set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+200 @05fb38> - <scale+203 @05fb3b>): .result.wx := (0);
	<scale+200 @05fb38>  : 19                         load.z32
	<scale+201 @05fb39>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+203 @05fb3b> - <scale+206 @05fb3e>): .result.wy := (0);
	<scale+203 @05fb3b>  : 19                         load.z32
	<scale+204 @05fb3c>  : 13 11                      set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes: <scale+206 @05fb3e> - <scale+209 @05fb41>): .result.wz := (0);
	<scale+206 @05fb3e>  : 19                         load.z32
	<scale+207 @05fb3f>  : 13 12                      set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:179: (7 bytes: <scale+209 @05fb41> - <scale+216 @05fb48>): .result.ww := (1);
	<scale+209 @05fb41>  : 7f 00 00 80 3f             load.f32 1.000000
	<scale+214 @05fb46>  : 13 13                      set.x32 sp(19)
	<scale+216 @05fb48>  : 03                         ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@02d260>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, offs: <+0>, cast: variable(val))
.field x: float64 (size: 0, offs: <+0>, cast: inline)
.field y: float64 (size: 0, offs: <+0>, cast: inline)
.field data: float64[2] (size: 16, offs: <+0>, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.offset: <+0>
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, offs: <+0>, cast: variable(f64))
.field y: float64 (size: 8, offs: <+8>, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.offset: <+0>
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.offset: <+0>
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.offset: <@05fb50>
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, offs: <+16>, cast: variable(val))
.param x: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param y: float64 (size: 8, offs: <+32>, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
}
.instructions: (7 bytes: <vec2d @05fb50> - <vec2d+7 @05fb57>)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes: <vec2d @05fb50> - <vec2d+7 @05fb57>): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes: <vec2d @05fb50> - <vec2d+3 @05fb53>): .result.x := x;
	<vec2d @05fb50>      : 17 05 03                   mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes: <vec2d+3 @05fb53> - <vec2d+6 @05fb56>): .result.y := y;
	<vec2d+3 @05fb53>    : 17 07 01                   mov.x64 sp(7, 1)
	<vec2d+6 @05fb56>    : 03                         ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), add.p2d)))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), div.p2d)))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), min.p2d)))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(void(void(struct(a), struct(b)), max.p2d)))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, offs: <+0>, cast: val)
.param a: vec2d (size: 16, offs: <+16>, cast: val)
.param b: vec2d (size: 16, offs: <+32>, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, offs: <+0>, cast: f64)
.param a: vec2d (size: 4, offs: <+4>, cast: const variable(ref))
.param b: vec2d (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: float64(float64(a.x * b.x) + float64(a.y * b.y))
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.offset: <@05fb58>
.name: 'length'
.file: 'cmplStd/lib/string.ci:4'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if (bool((str) == null)) {
		return int32(.result := 0);
	}
	result: int32 := 0;
	for ( ; str[result]; int32(result := int32(result + 1))) ;
	return int32(.result := result);
}
.instructions: (38 bytes: <length @05fb58> - <length+38 @05fb7e>)
	cmplStd/lib/string.ci:5: (16 bytes: <length @05fb58> - <length+16 @05fb68>): if ((str) == null)
	<length @05fb58>      : 10 01                      dup.x32 sp(1)
	<length+2 @05fb5a>    : 1f 00 00 00 00             load.ref <@000000> ;null
	<length+7 @05fb5f>    : 57                         ceq.i32
	<length+8 @05fb60>    : 06 08 00 00                jz <length+16 @05fb68>
	cmplStd/lib/string.ci:6: (4 bytes: <length+12 @05fb64> - <length+16 @05fb68>): return .result := 0;
	<length+12 @05fb64>   : 19                         load.z32
	<length+13 @05fb65>   : 13 03                      set.x32 sp(3)
	<length+15 @05fb67>   : 03                         ret
	cmplStd/lib/string.ci:8: (1 byte: <length+16 @05fb68> - <length+17 @05fb69>): result: int32 := 0
	<length+16 @05fb68>   : 19                         load.z32
	cmplStd/lib/string.ci:9: (18 bytes: <length+17 @05fb69> - <length+35 @05fb7b>): for ( ; str[result]; result := result + 1)
	<length+17 @05fb69>   : 04 08 00 00                jmp <length+25 @05fb71>
	cmplStd/lib/string.ci:9: (4 bytes: <length+21 @05fb6d> - <length+25 @05fb71>): result := result + 1
	<length+21 @05fb6d>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:9: (10 bytes: <length+25 @05fb71> - <length+35 @05fb7b>): str[result]
	<length+25 @05fb71>   : 10 02                      dup.x32 sp(2)
	<length+27 @05fb73>   : 10 01                      dup.x32 sp(1)
	<length+29 @05fb75>   : 51                         add.i32
	<length+30 @05fb76>   : 26                         load.i8
	<length+31 @05fb77>   : 05 f6 ff ff                jnz <length+21 @05fb6d>
	cmplStd/lib/string.ci:11: (3 bytes: <length+35 @05fb7b> - <length+38 @05fb7e>): return .result := result;
	<length+35 @05fb7b>   : 13 03                      set.x32 sp(3)
	<length+37 @05fb7d>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:48: referenced as `length`
	cmplStd/lib/string.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@05fb80>
.name: 'indexOf'
.file: 'cmplStd/lib/string.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			return int32(.result := i);
		}
	}
	return int32(.result := int32(-1));
}
.instructions: (50 bytes: <indexOf @05fb80> - <indexOf+50 @05fbb2>)
	cmplStd/lib/string.ci:16: (42 bytes: <indexOf @05fb80> - <indexOf+42 @05fbaa>): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf @05fb80>      : 19                         load.z32
	<indexOf+1 @05fb81>    : 04 1b 00 00                jmp <indexOf+28 @05fb9c>
	cmplStd/lib/string.ci:17: (19 bytes: <indexOf+5 @05fb85> - <indexOf+24 @05fb98>): if (str[i] == chr)
	<indexOf+5 @05fb85>    : 10 03                      dup.x32 sp(3)
	<indexOf+7 @05fb87>    : 10 01                      dup.x32 sp(1)
	<indexOf+9 @05fb89>    : 51                         add.i32
	<indexOf+10 @05fb8a>   : 26                         load.i8
	<indexOf+11 @05fb8b>   : 0a 0c 00 00                load.sp(+12)
	<indexOf+15 @05fb8f>   : 26                         load.i8
	<indexOf+16 @05fb90>   : 57                         ceq.i32
	<indexOf+17 @05fb91>   : 06 07 00 00                jz <indexOf+24 @05fb98>
	cmplStd/lib/string.ci:18: (3 bytes: <indexOf+21 @05fb95> - <indexOf+24 @05fb98>): return .result := i;
	<indexOf+21 @05fb95>   : 13 04                      set.x32 sp(4)
	<indexOf+23 @05fb97>   : 03                         ret
	cmplStd/lib/string.ci:16: (4 bytes: <indexOf+24 @05fb98> - <indexOf+28 @05fb9c>): i := i + 1
	<indexOf+24 @05fb98>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:16: (10 bytes: <indexOf+28 @05fb9c> - <indexOf+38 @05fba6>): str[i]
	<indexOf+28 @05fb9c>   : 10 03                      dup.x32 sp(3)
	<indexOf+30 @05fb9e>   : 10 01                      dup.x32 sp(1)
	<indexOf+32 @05fba0>   : 51                         add.i32
	<indexOf+33 @05fba1>   : 26                         load.i8
	<indexOf+34 @05fba2>   : 05 e3 ff ff                jnz <indexOf+5 @05fb85>
	<indexOf+38 @05fba6>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:21: (8 bytes: <indexOf+42 @05fbaa> - <indexOf+50 @05fbb2>): return .result := -1;
	<indexOf+42 @05fbaa>   : 1c ff ff ff ff             load.c32 -1
	<indexOf+47 @05fbaf>   : 13 04                      set.x32 sp(4)
	<indexOf+49 @05fbb1>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:98: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.offset: <@05fbb8>
.name: 'lastIndexOf'
.file: 'cmplStd/lib/string.ci:25'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param chr: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := int32(-1);
	for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
		if (bool(str[i] == chr)) {
			int32(result := i);
		}
	}
	return int32(.result := result);
}
.instructions: (50 bytes: <lastIndexOf @05fbb8> - <lastIndexOf+50 @05fbea>)
	cmplStd/lib/string.ci:26: (5 bytes: <lastIndexOf @05fbb8> - <lastIndexOf+5 @05fbbd>): result: int32 := -1
	<lastIndexOf @05fbb8>      : 1c ff ff ff ff             load.c32 -1
	cmplStd/lib/string.ci:27: (42 bytes: <lastIndexOf+5 @05fbbd> - <lastIndexOf+47 @05fbe7>): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+5 @05fbbd>    : 19                         load.z32
	<lastIndexOf+6 @05fbbe>    : 04 1b 00 00                jmp <lastIndexOf+33 @05fbd9>
	cmplStd/lib/string.ci:28: (19 bytes: <lastIndexOf+10 @05fbc2> - <lastIndexOf+29 @05fbd5>): if (str[i] == chr)
	<lastIndexOf+10 @05fbc2>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+12 @05fbc4>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+14 @05fbc6>   : 51                         add.i32
	<lastIndexOf+15 @05fbc7>   : 26                         load.i8
	<lastIndexOf+16 @05fbc8>   : 0a 10 00 00                load.sp(+16)
	<lastIndexOf+20 @05fbcc>   : 26                         load.i8
	<lastIndexOf+21 @05fbcd>   : 57                         ceq.i32
	<lastIndexOf+22 @05fbce>   : 06 07 00 00                jz <lastIndexOf+29 @05fbd5>
	cmplStd/lib/string.ci:29: (3 bytes: <lastIndexOf+26 @05fbd2> - <lastIndexOf+29 @05fbd5>): result := i;
	<lastIndexOf+26 @05fbd2>   : 16 01 00                   mov.x32 sp(1, 0)
	cmplStd/lib/string.ci:27: (4 bytes: <lastIndexOf+29 @05fbd5> - <lastIndexOf+33 @05fbd9>): i := i + 1
	<lastIndexOf+29 @05fbd5>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:27: (10 bytes: <lastIndexOf+33 @05fbd9> - <lastIndexOf+43 @05fbe3>): str[i]
	<lastIndexOf+33 @05fbd9>   : 10 04                      dup.x32 sp(4)
	<lastIndexOf+35 @05fbdb>   : 10 01                      dup.x32 sp(1)
	<lastIndexOf+37 @05fbdd>   : 51                         add.i32
	<lastIndexOf+38 @05fbde>   : 26                         load.i8
	<lastIndexOf+39 @05fbdf>   : 05 e3 ff ff                jnz <lastIndexOf+10 @05fbc2>
	<lastIndexOf+43 @05fbe3>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:32: (3 bytes: <lastIndexOf+47 @05fbe7> - <lastIndexOf+50 @05fbea>): return .result := result;
	<lastIndexOf+47 @05fbe7>   : 13 04                      set.x32 sp(4)
	<lastIndexOf+49 @05fbe9>   : 03                         ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.offset: <@05fbf0>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:36'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[i], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (73 bytes: <startsWith @05fbf0> - <startsWith+73 @05fc39>)
	cmplStd/lib/string.ci:37: (62 bytes: <startsWith @05fbf0> - <startsWith+62 @05fc2e>): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith @05fbf0>      : 19                         load.z32
	<startsWith+1 @05fbf1>    : 04 2d 00 00                jmp <startsWith+46 @05fc1e>
	cmplStd/lib/string.ci:38: (37 bytes: <startsWith+5 @05fbf5> - <startsWith+42 @05fc1a>): if (cmp(str[i], with[i]) != 0)
	<startsWith+5 @05fbf5>    : 19                         load.z32
	<startsWith+6 @05fbf6>    : 10 05                      dup.x32 sp(5)
	<startsWith+8 @05fbf8>    : 10 02                      dup.x32 sp(2)
	<startsWith+10 @05fbfa>   : 51                         add.i32
	<startsWith+11 @05fbfb>   : 26                         load.i8
	<startsWith+12 @05fbfc>   : 10 05                      dup.x32 sp(5)
	<startsWith+14 @05fbfe>   : 10 03                      dup.x32 sp(3)
	<startsWith+16 @05fc00>   : 51                         add.i32
	<startsWith+17 @05fc01>   : 26                         load.i8
	<startsWith+18 @05fc02>   : 10 05                      dup.x32 sp(5)
	<startsWith+20 @05fc04>   : 02                         call
	<startsWith+21 @05fc05>   : 09 f8 ff ff                inc.sp(-8)
	<startsWith+25 @05fc09>   : 19                         load.z32
	<startsWith+26 @05fc0a>   : 57                         ceq.i32
	<startsWith+27 @05fc0b>   : 05 0f 00 00                jnz <startsWith+42 @05fc1a>
	cmplStd/lib/string.ci:39: (11 bytes: <startsWith+31 @05fc0f> - <startsWith+42 @05fc1a>): return .result := false;
	<startsWith+31 @05fc0f>   : 19                         load.z32
	<startsWith+32 @05fc10>   : 0a 18 00 00                load.sp(+24)
	<startsWith+36 @05fc14>   : 2b                         store.i8
	<startsWith+37 @05fc15>   : 09 fc ff ff                inc.sp(-4)
	<startsWith+41 @05fc19>   : 03                         ret
	cmplStd/lib/string.ci:37: (4 bytes: <startsWith+42 @05fc1a> - <startsWith+46 @05fc1e>): i := i + 1
	<startsWith+42 @05fc1a>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:37: (12 bytes: <startsWith+46 @05fc1e> - <startsWith+58 @05fc2a>): (with[i]) != 0
	<startsWith+46 @05fc1e>   : 10 03                      dup.x32 sp(3)
	<startsWith+48 @05fc20>   : 10 01                      dup.x32 sp(1)
	<startsWith+50 @05fc22>   : 51                         add.i32
	<startsWith+51 @05fc23>   : 26                         load.i8
	<startsWith+52 @05fc24>   : 19                         load.z32
	<startsWith+53 @05fc25>   : 57                         ceq.i32
	<startsWith+54 @05fc26>   : 06 cf ff ff                jz <startsWith+5 @05fbf5>
	<startsWith+58 @05fc2a>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:42: (11 bytes: <startsWith+62 @05fc2e> - <startsWith+73 @05fc39>): return .result := true;
	<startsWith+62 @05fc2e>   : 1c 01 00 00 00             load.c32 1
	<startsWith+67 @05fc33>   : 0a 14 00 00                load.sp(+20)
	<startsWith+71 @05fc37>   : 2b                         store.i8
	<startsWith+72 @05fc38>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:92: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.offset: <@05fc40>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:46'
.param .result: bool (size: 4, offs: <+4>, cast: variable(bool))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (bool(strLen < withLen)) {
		return bool(.result := false);
	}
	for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
		if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
			return bool(.result := false);
		}
	}
	return bool(.result := true);
}
.instructions: (126 bytes: <endsWith @05fc40> - <endsWith+126 @05fcbe>)
	cmplStd/lib/string.ci:47: (13 bytes: <endsWith @05fc40> - <endsWith+13 @05fc4d>): withLen: int32 := length(with)
	<endsWith @05fc40>      : 19                         load.z32
	<endsWith+1 @05fc41>    : 10 03                      dup.x32 sp(3)
	<endsWith+3 @05fc43>    : 1f 58 fb 05 00             load.ref <@05fb58> ;length(str: char[*]): int32
	<endsWith+8 @05fc48>    : 02                         call
	<endsWith+9 @05fc49>    : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:48: (13 bytes: <endsWith+13 @05fc4d> - <endsWith+26 @05fc5a>): strLen: int32 := length(str)
	<endsWith+13 @05fc4d>   : 19                         load.z32
	<endsWith+14 @05fc4e>   : 10 05                      dup.x32 sp(5)
	<endsWith+16 @05fc50>   : 1f 58 fb 05 00             load.ref <@05fb58> ;length(str: char[*]): int32
	<endsWith+21 @05fc55>   : 02                         call
	<endsWith+22 @05fc56>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:49: (20 bytes: <endsWith+26 @05fc5a> - <endsWith+46 @05fc6e>): if (strLen < withLen)
	<endsWith+26 @05fc5a>   : 10 00                      dup.x32 sp(0)
	<endsWith+28 @05fc5c>   : 10 02                      dup.x32 sp(2)
	<endsWith+30 @05fc5e>   : 58                         clt.i32
	<endsWith+31 @05fc5f>   : 06 0f 00 00                jz <endsWith+46 @05fc6e>
	cmplStd/lib/string.ci:50: (11 bytes: <endsWith+35 @05fc63> - <endsWith+46 @05fc6e>): return .result := false;
	<endsWith+35 @05fc63>   : 19                         load.z32
	<endsWith+36 @05fc64>   : 0a 1c 00 00                load.sp(+28)
	<endsWith+40 @05fc68>   : 2b                         store.i8
	<endsWith+41 @05fc69>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+45 @05fc6d>   : 03                         ret
	cmplStd/lib/string.ci:52: (65 bytes: <endsWith+46 @05fc6e> - <endsWith+111 @05fcaf>): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+46 @05fc6e>   : 19                         load.z32
	<endsWith+47 @05fc6f>   : 04 33 00 00                jmp <endsWith+98 @05fca2>
	cmplStd/lib/string.ci:53: (43 bytes: <endsWith+51 @05fc73> - <endsWith+94 @05fc9e>): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+51 @05fc73>   : 19                         load.z32
	<endsWith+52 @05fc74>   : 10 07                      dup.x32 sp(7)
	<endsWith+54 @05fc76>   : 10 03                      dup.x32 sp(3)
	<endsWith+56 @05fc78>   : 10 05                      dup.x32 sp(5)
	<endsWith+58 @05fc7a>   : 52                         sub.i32
	<endsWith+59 @05fc7b>   : 10 03                      dup.x32 sp(3)
	<endsWith+61 @05fc7d>   : 51                         add.i32
	<endsWith+62 @05fc7e>   : 51                         add.i32
	<endsWith+63 @05fc7f>   : 26                         load.i8
	<endsWith+64 @05fc80>   : 10 07                      dup.x32 sp(7)
	<endsWith+66 @05fc82>   : 10 03                      dup.x32 sp(3)
	<endsWith+68 @05fc84>   : 51                         add.i32
	<endsWith+69 @05fc85>   : 26                         load.i8
	<endsWith+70 @05fc86>   : 10 07                      dup.x32 sp(7)
	<endsWith+72 @05fc88>   : 02                         call
	<endsWith+73 @05fc89>   : 09 f8 ff ff                inc.sp(-8)
	<endsWith+77 @05fc8d>   : 19                         load.z32
	<endsWith+78 @05fc8e>   : 57                         ceq.i32
	<endsWith+79 @05fc8f>   : 05 0f 00 00                jnz <endsWith+94 @05fc9e>
	cmplStd/lib/string.ci:54: (11 bytes: <endsWith+83 @05fc93> - <endsWith+94 @05fc9e>): return .result := false;
	<endsWith+83 @05fc93>   : 19                         load.z32
	<endsWith+84 @05fc94>   : 0a 20 00 00                load.sp(+32)
	<endsWith+88 @05fc98>   : 2b                         store.i8
	<endsWith+89 @05fc99>   : 09 f4 ff ff                inc.sp(-12)
	<endsWith+93 @05fc9d>   : 03                         ret
	cmplStd/lib/string.ci:52: (4 bytes: <endsWith+94 @05fc9e> - <endsWith+98 @05fca2>): i := i + 1
	<endsWith+94 @05fc9e>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:52: (9 bytes: <endsWith+98 @05fca2> - <endsWith+107 @05fcab>): i < withLen
	<endsWith+98 @05fca2>   : 10 00                      dup.x32 sp(0)
	<endsWith+100 @05fca4>  : 10 03                      dup.x32 sp(3)
	<endsWith+102 @05fca6>  : 58                         clt.i32
	<endsWith+103 @05fca7>  : 05 cc ff ff                jnz <endsWith+51 @05fc73>
	<endsWith+107 @05fcab>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:57: (15 bytes: <endsWith+111 @05fcaf> - <endsWith+126 @05fcbe>): return .result := true;
	<endsWith+111 @05fcaf>  : 1c 01 00 00 00             load.c32 1
	<endsWith+116 @05fcb4>  : 0a 1c 00 00                load.sp(+28)
	<endsWith+120 @05fcb8>  : 2b                         store.i8
	<endsWith+121 @05fcb9>  : 09 f8 ff ff                inc.sp(-8)
	<endsWith+125 @05fcbd>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:93: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@05fcc0>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:61'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param str: char[*] (size: 4, offs: <+8>, cast: const variable(ref))
.param with: char[*] (size: 4, offs: <+12>, cast: const variable(ref))
.param cmp: function (size: 4, offs: <+16>, cast: variable(ref))
.doc: 'Check if the two strings are equal, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
		int32(result := cmp(void(str[i], with[i])));
		if (bool((str[i]) == 0)) {
			break;
		}
	}
	return int32(.result := result);
}
.instructions: (63 bytes: <compare @05fcc0> - <compare+63 @05fcff>)
	cmplStd/lib/string.ci:62: (1 byte: <compare @05fcc0> - <compare+1 @05fcc1>): result: int32 := 0
	<compare @05fcc0>      : 19                         load.z32
	cmplStd/lib/string.ci:63: (59 bytes: <compare+1 @05fcc1> - <compare+60 @05fcfc>): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+1 @05fcc1>    : 19                         load.z32
	<compare+2 @05fcc2>    : 04 2e 00 00                jmp <compare+48 @05fcf0>
	cmplStd/lib/string.ci:64: (22 bytes: <compare+6 @05fcc6> - <compare+28 @05fcdc>): result := cmp(str[i], with[i]);
	<compare+6 @05fcc6>    : 19                         load.z32
	<compare+7 @05fcc7>    : 10 06                      dup.x32 sp(6)
	<compare+9 @05fcc9>    : 10 02                      dup.x32 sp(2)
	<compare+11 @05fccb>   : 51                         add.i32
	<compare+12 @05fccc>   : 26                         load.i8
	<compare+13 @05fccd>   : 10 06                      dup.x32 sp(6)
	<compare+15 @05fccf>   : 10 03                      dup.x32 sp(3)
	<compare+17 @05fcd1>   : 51                         add.i32
	<compare+18 @05fcd2>   : 26                         load.i8
	<compare+19 @05fcd3>   : 10 06                      dup.x32 sp(6)
	<compare+21 @05fcd5>   : 02                         call
	<compare+22 @05fcd6>   : 09 f8 ff ff                inc.sp(-8)
	<compare+26 @05fcda>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:65: (16 bytes: <compare+28 @05fcdc> - <compare+44 @05fcec>): if ((str[i]) == 0)
	<compare+28 @05fcdc>   : 10 05                      dup.x32 sp(5)
	<compare+30 @05fcde>   : 10 01                      dup.x32 sp(1)
	<compare+32 @05fce0>   : 51                         add.i32
	<compare+33 @05fce1>   : 26                         load.i8
	<compare+34 @05fce2>   : 19                         load.z32
	<compare+35 @05fce3>   : 57                         ceq.i32
	<compare+36 @05fce4>   : 06 08 00 00                jz <compare+44 @05fcec>
	cmplStd/lib/string.ci:66: (4 bytes: <compare+40 @05fce8> - <compare+44 @05fcec>): break;
	<compare+40 @05fce8>   : 04 10 00 00                jmp <compare+56 @05fcf8>
	cmplStd/lib/string.ci:63: (4 bytes: <compare+44 @05fcec> - <compare+48 @05fcf0>): i := i + 1
	<compare+44 @05fcec>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:63: (8 bytes: <compare+48 @05fcf0> - <compare+56 @05fcf8>): result == 0
	<compare+48 @05fcf0>   : 10 01                      dup.x32 sp(1)
	<compare+50 @05fcf2>   : 19                         load.z32
	<compare+51 @05fcf3>   : 57                         ceq.i32
	<compare+52 @05fcf4>   : 05 d2 ff ff                jnz <compare+6 @05fcc6>
	<compare+56 @05fcf8>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:69: (3 bytes: <compare+60 @05fcfc> - <compare+63 @05fcff>): return .result := result;
	<compare+60 @05fcfc>   : 13 05                      set.x32 sp(5)
	<compare+62 @05fcfe>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:95: referenced as `compare`
	cmplStd/lib/string.ci:94: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.offset: <@05fd48>
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/string.ci:73'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (bool(chr < 'A')) {
			return char(.result := chr);
		}
		if (bool(chr > 'Z')) {
			return char(.result := chr);
		}
		return char(.result := char(char(chr - 'A') + 'a'));
	};
	return char(.result := char(ignCase(chr) - ignCase(with)));
}
.instructions: (36 bytes: <ignCaseCmp @05fd48> - <ignCaseCmp+36 @05fd6c>)
	cmplStd/lib/string.ci:84: (36 bytes: <ignCaseCmp @05fd48> - <ignCaseCmp+36 @05fd6c>): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp @05fd48>      : 19                         load.z32
	<ignCaseCmp+1 @05fd49>    : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+5 @05fd4d>    : 26                         load.i8
	<ignCaseCmp+6 @05fd4e>    : 1f 00 fd 05 00             load.ref <@05fd00> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+11 @05fd53>   : 02                         call
	<ignCaseCmp+12 @05fd54>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+16 @05fd58>   : 19                         load.z32
	<ignCaseCmp+17 @05fd59>   : 0a 0c 00 00                load.sp(+12)
	<ignCaseCmp+21 @05fd5d>   : 26                         load.i8
	<ignCaseCmp+22 @05fd5e>   : 1f 00 fd 05 00             load.ref <@05fd00> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+27 @05fd63>   : 02                         call
	<ignCaseCmp+28 @05fd64>   : 09 fc ff ff                inc.sp(-4)
	<ignCaseCmp+32 @05fd68>   : 52                         sub.i32
	<ignCaseCmp+33 @05fd69>   : 13 04                      set.x32 sp(4)
	<ignCaseCmp+35 @05fd6b>   : 03                         ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.offset: <@05fd70>
.name: 'caseCmp'
.file: 'cmplStd/lib/string.ci:88'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param chr: char (size: 4, offs: <+8>, cast: variable(i32))
.param with: char (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return char(.result := char(chr - with));
}
.instructions: (14 bytes: <caseCmp @05fd70> - <caseCmp+14 @05fd7e>)
	cmplStd/lib/string.ci:89: (14 bytes: <caseCmp @05fd70> - <caseCmp+14 @05fd7e>): return .result := chr - with;
	<caseCmp @05fd70>      : 0a 08 00 00                load.sp(+8)
	<caseCmp+4 @05fd74>    : 26                         load.i8
	<caseCmp+5 @05fd75>    : 0a 08 00 00                load.sp(+8)
	<caseCmp+9 @05fd79>    : 26                         load.i8
	<caseCmp+10 @05fd7a>   : 52                         sub.i32
	<caseCmp+11 @05fd7b>   : 13 04                      set.x32 sp(4)
	<caseCmp+13 @05fd7d>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:95: referenced as `caseCmp`
	cmplStd/lib/string.ci:94: referenced as `caseCmp`
	cmplStd/lib/string.ci:93: referenced as `caseCmp`
	cmplStd/lib/string.ci:92: referenced as `caseCmp`
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'startsWith'
.file: 'cmplStd/lib/string.ci:92'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: startsWith(void(void(str, with), caseCmp))
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'endsWith'
.file: 'cmplStd/lib/string.ci:93'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: endsWith(void(void(str, with), caseCmp))
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'compare'
.file: 'cmplStd/lib/string.ci:94'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: compare(void(void(str, with), caseCmp))
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'equals'
.file: 'cmplStd/lib/string.ci:95'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param with: char[*] (size: 4, offs: <+8>, cast: const ref)
.value: bool(compare(void(void(str, with), caseCmp)) == 0)
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'contains'
.file: 'cmplStd/lib/string.ci:98'
.param .result: bool (size: 1, offs: <+0>, cast: bool)
.param str: char[*] (size: 4, offs: <+4>, cast: const ref)
.param chr: char (size: 4, offs: <+8>, cast: i32)
.doc: 'Check if a string contains the given character'
.value: bool(indexOf(void(str, chr)) >= 0)
.usages:
	cmplStd/lib/string.ci:182: referenced as `contains`
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@032d60>
.name: 'FormatFlags'
.file: 'cmplStd/lib/string.ci:112'
.field showSign: bool (size: 1, offs: <+0>, cast: const variable(bool))
.field precision: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field padChr: char (size: 1, offs: <+8>, cast: const variable(i32))
.field padLen: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/string.ci:263: referenced as `FormatFlags`
	cmplStd/lib/string.ci:259: referenced as `FormatFlags`
	cmplStd/lib/string.ci:241: referenced as `FormatFlags`
	cmplStd/lib/string.ci:235: referenced as `FormatFlags`
	cmplStd/lib/string.ci:234: referenced as `FormatFlags`
	cmplStd/lib/string.ci:231: referenced as `FormatFlags`
	cmplStd/lib/string.ci:229: referenced as `FormatFlags`
	cmplStd/lib/string.ci:227: referenced as `FormatFlags`
	cmplStd/lib/string.ci:225: referenced as `FormatFlags`
	cmplStd/lib/string.ci:223: referenced as `FormatFlags`
	cmplStd/lib/string.ci:221: referenced as `FormatFlags`
	cmplStd/lib/string.ci:219: referenced as `FormatFlags`
	cmplStd/lib/string.ci:217: referenced as `FormatFlags`
	cmplStd/lib/string.ci:144: referenced as `FormatFlags`
}
FormatFlags.showSign: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.offset: <+0>
.name: 'showSign'
.file: 'cmplStd/lib/string.ci:114'
.owner: FormatFlags
.doc: 'forced show sign'
.value: false
.usages:
	cmplStd/lib/string.ci:242: referenced as `showSign`
	cmplStd/lib/string.ci:236: referenced as `showSign`
	cmplStd/lib/string.ci:236: referenced as `showSign`
	cmplStd/lib/string.ci:151: referenced as `showSign`
	internal usages: 1
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'precision'
.file: 'cmplStd/lib/string.ci:117'
.owner: FormatFlags
.doc: 'precision or radix'
.value: 0
.usages:
	cmplStd/lib/string.ci:253: referenced as `precision`
	cmplStd/lib/string.ci:243: referenced as `precision`
	cmplStd/lib/string.ci:245: referenced as `precision`
	cmplStd/lib/string.ci:237: referenced as `precision`
	cmplStd/lib/string.ci:239: referenced as `precision`
	cmplStd/lib/string.ci:157: referenced as `precision`
	internal usages: 1
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.offset: <+8>
.name: 'padChr'
.file: 'cmplStd/lib/string.ci:120'
.owner: FormatFlags
.doc: 'padding character'
.value: 0
.usages:
	cmplStd/lib/string.ci:244: referenced as `padChr`
	cmplStd/lib/string.ci:238: referenced as `padChr`
	cmplStd/lib/string.ci:238: referenced as `padChr`
	cmplStd/lib/string.ci:174: referenced as `padChr`
	internal usages: 1
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'padLen'
.file: 'cmplStd/lib/string.ci:123'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/string.ci:245: referenced as `padLen`
	cmplStd/lib/string.ci:239: referenced as `padLen`
	cmplStd/lib/string.ci:239: referenced as `padLen`
	cmplStd/lib/string.ci:172: referenced as `padLen`
	internal usages: 1
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 84
.offset: <@05fd80>
.name: 'append'
.file: 'cmplStd/lib/string.ci:127'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: char[*] (size: 4, offs: <+20>, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
		if (bool(pos >= (output.length))) {
			break;
		}
		char(output[pos] := value[i]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (84 bytes: <append @05fd80> - <append+84 @05fdd4>)
	cmplStd/lib/string.ci:128: (56 bytes: <append @05fd80> - <append+56 @05fdb8>): for (i: int32 := 0; value[i]; i := i + 1)
	<append @05fd80>      : 19                         load.z32
	<append+1 @05fd81>    : 04 29 00 00                jmp <append+42 @05fdaa>
	cmplStd/lib/string.ci:129: (13 bytes: <append+5 @05fd85> - <append+18 @05fd92>): if (pos >= (output.length))
	<append+5 @05fd85>    : 10 03                      dup.x32 sp(3)
	<append+7 @05fd87>    : 10 06                      dup.x32 sp(6)
	<append+9 @05fd89>    : 58                         clt.i32
	<append+10 @05fd8a>   : 05 08 00 00                jnz <append+18 @05fd92>
	cmplStd/lib/string.ci:130: (4 bytes: <append+14 @05fd8e> - <append+18 @05fd92>): break;
	<append+14 @05fd8e>   : 04 26 00 00                jmp <append+52 @05fdb4>
	cmplStd/lib/string.ci:132: (12 bytes: <append+18 @05fd92> - <append+30 @05fd9e>): output[pos] := value[i];
	<append+18 @05fd92>   : 10 02                      dup.x32 sp(2)
	<append+20 @05fd94>   : 10 01                      dup.x32 sp(1)
	<append+22 @05fd96>   : 51                         add.i32
	<append+23 @05fd97>   : 26                         load.i8
	<append+24 @05fd98>   : 10 05                      dup.x32 sp(5)
	<append+26 @05fd9a>   : 10 05                      dup.x32 sp(5)
	<append+28 @05fd9c>   : 51                         add.i32
	<append+29 @05fd9d>   : 2b                         store.i8
	cmplStd/lib/string.ci:133: (8 bytes: <append+30 @05fd9e> - <append+38 @05fda6>): pos := pos + 1;
	<append+30 @05fd9e>   : 10 03                      dup.x32 sp(3)
	<append+32 @05fda0>   : 0c 01 00 00                inc.i32(+1)
	<append+36 @05fda4>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:128: (4 bytes: <append+38 @05fda6> - <append+42 @05fdaa>): i := i + 1
	<append+38 @05fda6>   : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:128: (10 bytes: <append+42 @05fdaa> - <append+52 @05fdb4>): value[i]
	<append+42 @05fdaa>   : 10 02                      dup.x32 sp(2)
	<append+44 @05fdac>   : 10 01                      dup.x32 sp(1)
	<append+46 @05fdae>   : 51                         add.i32
	<append+47 @05fdaf>   : 26                         load.i8
	<append+48 @05fdb0>   : 05 d5 ff ff                jnz <append+5 @05fd85>
	<append+52 @05fdb4>   : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:136: (17 bytes: <append+56 @05fdb8> - <append+73 @05fdc9>): if (pos >= (output.length))
	<append+56 @05fdb8>   : 10 02                      dup.x32 sp(2)
	<append+58 @05fdba>   : 10 05                      dup.x32 sp(5)
	<append+60 @05fdbc>   : 58                         clt.i32
	<append+61 @05fdbd>   : 05 0c 00 00                jnz <append+73 @05fdc9>
	cmplStd/lib/string.ci:137: (8 bytes: <append+65 @05fdc1> - <append+73 @05fdc9>): pos := (output.length - (1));
	<append+65 @05fdc1>   : 10 04                      dup.x32 sp(4)
	<append+67 @05fdc3>   : 0c ff ff ff                inc.i32(-1)
	<append+71 @05fdc7>   : 13 03                      set.x32 sp(3)
	cmplStd/lib/string.ci:139: (7 bytes: <append+73 @05fdc9> - <append+80 @05fdd0>): output[pos] := (0);
	<append+73 @05fdc9>   : 19                         load.z32
	<append+74 @05fdca>   : 10 04                      dup.x32 sp(4)
	<append+76 @05fdcc>   : 10 04                      dup.x32 sp(4)
	<append+78 @05fdce>   : 51                         add.i32
	<append+79 @05fdcf>   : 2b                         store.i8
	cmplStd/lib/string.ci:140: (4 bytes: <append+80 @05fdd0> - <append+84 @05fdd4>): return .result := pos;
	<append+80 @05fdd0>   : 16 05 02                   mov.x32 sp(5, 2)
	<append+83 @05fdd3>   : 03                         ret
.usages:
	cmplStd/lib/string.ci:252: referenced as `append`
}
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 707
.offset: <@05fde8>
.name: 'append'
.file: 'cmplStd/lib/string.ci:144'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param sign: char (size: 4, offs: <+20>, cast: variable(i32))
.param value: uint64 (size: 8, offs: <+28>, cast: variable(u64))
.param format: FormatFlags (size: 4, offs: <+32>, cast: const variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	if (format.showSign) {
		if (bool((sign) == 0)) {
			char(sign := '+');
		}
	}
	radix: int32 := format.precision;
	if (bool(radix == 0)) {
		int32(radix := 10);
	}
	assert(void(void(bool(radix > 1), "radix is too small"), radix));
	assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
	for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
		char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
	}
	if (bool(len == 0)) {
		char(digits[int32(len := int32(len + 1))] := '0');
	}
	maxLen: int32 := int32(format.padLen - len);
	padChr: char := format.padChr;
	if (bool(padChr == '')) {
		char(padChr := ' ');
	}
	if (bool((sign) != 0)) {
		int32(maxLen := int32(maxLen - 1));
		if (contains(void(whiteSpace, padChr))) {
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
		}
		assert(bool(pos < (output.length)));
		char(output[pos] := sign);
		int32(pos := int32(pos + 1));
	}
	for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
		assert(bool(pos < (output.length)));
		char(output[pos] := padChr);
		int32(pos := int32(pos + 1));
	}
	for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
		assert(bool(i < (output.length)));
		char(output[pos] := digits[int32(len - i)]);
		int32(pos := int32(pos + 1));
	}
	if (bool(pos >= (output.length))) {
		int32(pos := (uint32(output.length - (1))));
	}
	char(output[pos] := (0));
	return int32(.result := pos);
}
.instructions: (707 bytes: <append @05fde8> - <append+707 @0600ab>)
	cmplStd/lib/string.ci:148: (1 byte: <append @05fde8> - <append+1 @05fde9>): len: int32 := 0
	<append @05fde8>      : 19                         load.z32
	cmplStd/lib/string.ci:149: (4 bytes: <append+1 @05fde9> - <append+5 @05fded>): digits: char[80] := {...}
	<append+1 @05fde9>    : 09 50 00 00                inc.sp(+80)
	cmplStd/lib/string.ci:151: (28 bytes: <append+5 @05fded> - <append+33 @05fe09>): if (format.showSign)
	<append+5 @05fded>    : 10 16                      dup.x32 sp(22)
	<append+7 @05fdef>    : 26                         load.i8
	<append+8 @05fdf0>    : 06 19 00 00                jz <append+33 @05fe09>
	cmplStd/lib/string.ci:152: (21 bytes: <append+12 @05fdf4> - <append+33 @05fe09>): if ((sign) == 0)
	<append+12 @05fdf4>   : 0a 64 00 00                load.sp(+100)
	<append+16 @05fdf8>   : 26                         load.i8
	<append+17 @05fdf9>   : 19                         load.z32
	<append+18 @05fdfa>   : 57                         ceq.i32
	<append+19 @05fdfb>   : 06 0e 00 00                jz <append+33 @05fe09>
	cmplStd/lib/string.ci:153: (10 bytes: <append+23 @05fdff> - <append+33 @05fe09>): sign := '+';
	<append+23 @05fdff>   : 1c 2b 00 00 00             load.c32 43
	<append+28 @05fe04>   : 0a 68 00 00                load.sp(+104)
	<append+32 @05fe08>   : 2b                         store.i8
	cmplStd/lib/string.ci:157: (7 bytes: <append+33 @05fe09> - <append+40 @05fe10>): radix: int32 := format.precision
	<append+33 @05fe09>   : 10 16                      dup.x32 sp(22)
	<append+35 @05fe0b>   : 0c 04 00 00                inc.i32(+4)
	<append+39 @05fe0f>   : 28                         load.i32
	cmplStd/lib/string.ci:158: (15 bytes: <append+40 @05fe10> - <append+55 @05fe1f>): if (radix == 0)
	<append+40 @05fe10>   : 10 00                      dup.x32 sp(0)
	<append+42 @05fe12>   : 19                         load.z32
	<append+43 @05fe13>   : 57                         ceq.i32
	<append+44 @05fe14>   : 06 0b 00 00                jz <append+55 @05fe1f>
	cmplStd/lib/string.ci:159: (7 bytes: <append+48 @05fe18> - <append+55 @05fe1f>): radix := 10;
	<append+48 @05fe18>   : 1c 0a 00 00 00             load.c32 10
	<append+53 @05fe1d>   : 13 01                      set.x32 sp(1)
	cmplStd/lib/string.ci:161: (54 bytes: <append+55 @05fe1f> - <append+109 @05fe55>): assert(radix > 1, "radix is too small", radix);
	<append+55 @05fe1f>   : 10 00                      dup.x32 sp(0)
	<append+57 @05fe21>   : 1c 01 00 00 00             load.c32 1
	<append+62 @05fe26>   : 59                         cgt.i32
	<append+63 @05fe27>   : 06 08 00 00                jz <append+71 @05fe2f>
	<append+67 @05fe2b>   : 04 2a 00 00                jmp <append+109 @05fe55>
	<append+71 @05fe2f>   : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+76 @05fe34>   : 1c a1 00 00 00             load.c32 161
	<append+81 @05fe39>   : 1c fe ff ff ff             load.c32 -2
	<append+86 @05fe3e>   : 1c 80 00 00 00             load.c32 128
	<append+91 @05fe43>   : 1f 23 f2 02 00             load.ref <@02f223> ;"radix is too small"
	<append+96 @05fe48>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+101 @05fe4d>  : 0a 18 00 00                load.sp(+24)
	<append+105 @05fe51>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:162: (53 bytes: <append+109 @05fe55> - <append+162 @05fe8a>): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+109 @05fe55>  : 10 00                      dup.x32 sp(0)
	<append+111 @05fe57>  : 20 e4 fd 05                load.m32 <@05fde4> ;append.radixDigits+4
	<append+115 @05fe5b>  : 58                         clt.i32
	<append+116 @05fe5c>  : 06 08 00 00                jz <append+124 @05fe64>
	<append+120 @05fe60>  : 04 2a 00 00                jmp <append+162 @05fe8a>
	<append+124 @05fe64>  : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+129 @05fe69>  : 1c a2 00 00 00             load.c32 162
	<append+134 @05fe6e>  : 1c fe ff ff ff             load.c32 -2
	<append+139 @05fe73>  : 1c 80 00 00 00             load.c32 128
	<append+144 @05fe78>  : 1f 36 f2 02 00             load.ref <@02f236> ;"radix is too big"
	<append+149 @05fe7d>  : 1f 00 04 00 00             load.ref <@000400> ;int32
	<append+154 @05fe82>  : 0a 18 00 00                load.sp(+24)
	<append+158 @05fe86>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:165: (49 bytes: <append+162 @05fe8a> - <append+211 @05febb>): for ( ; value > (0); value := value / (radix))
	<append+162 @05fe8a>  : 04 29 00 00                jmp <append+203 @05feb3>
	cmplStd/lib/string.ci:166: (29 bytes: <append+166 @05fe8e> - <append+195 @05feab>): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+166 @05fe8e>  : 20 e0 fd 05                load.m32 <@05fde0> ;append.radixDigits
	<append+170 @05fe92>  : 11 19                      dup.x64 sp(25)
	<append+172 @05fe94>  : 10 03                      dup.x32 sp(3)
	<append+174 @05fe96>  : 5b                         i32.2i64
	<append+175 @05fe97>  : 45                         mod.u64
	<append+176 @05fe98>  : 6a                         i64.2i32
	<append+177 @05fe99>  : 51                         add.i32
	<append+178 @05fe9a>  : 26                         load.i8
	<append+179 @05fe9b>  : 0a 08 00 00                load.sp(+8)
	<append+183 @05fe9f>  : 10 17                      dup.x32 sp(23)
	<append+185 @05fea1>  : 0c 01 00 00                inc.i32(+1)
	<append+189 @05fea5>  : 10 00                      dup.x32 sp(0)
	<append+191 @05fea7>  : 13 19                      set.x32 sp(25)
	<append+193 @05fea9>  : 51                         add.i32
	<append+194 @05feaa>  : 2b                         store.i8
	cmplStd/lib/string.ci:165: (8 bytes: <append+195 @05feab> - <append+203 @05feb3>): value := value / (radix)
	<append+195 @05feab>  : 11 18                      dup.x64 sp(24)
	<append+197 @05fead>  : 10 02                      dup.x32 sp(2)
	<append+199 @05feaf>  : 5b                         i32.2i64
	<append+200 @05feb0>  : 44                         div.u64
	<append+201 @05feb1>  : 14 1a                      set.x64 sp(26)
	cmplStd/lib/string.ci:165: (8 bytes: <append+203 @05feb3> - <append+211 @05febb>): value > (0)
	<append+203 @05feb3>  : 11 18                      dup.x64 sp(24)
	<append+205 @05feb5>  : 1a                         load.z64
	<append+206 @05feb6>  : 49                         cgt.u64
	<append+207 @05feb7>  : 05 d7 ff ff                jnz <append+166 @05fe8e>
	cmplStd/lib/string.ci:168: (29 bytes: <append+211 @05febb> - <append+240 @05fed8>): if (len == 0)
	<append+211 @05febb>  : 10 15                      dup.x32 sp(21)
	<append+213 @05febd>  : 19                         load.z32
	<append+214 @05febe>  : 57                         ceq.i32
	<append+215 @05febf>  : 06 19 00 00                jz <append+240 @05fed8>
	cmplStd/lib/string.ci:169: (21 bytes: <append+219 @05fec3> - <append+240 @05fed8>): digits[len := len + 1] := '0';
	<append+219 @05fec3>  : 1c 30 00 00 00             load.c32 48
	<append+224 @05fec8>  : 0a 08 00 00                load.sp(+8)
	<append+228 @05fecc>  : 10 17                      dup.x32 sp(23)
	<append+230 @05fece>  : 0c 01 00 00                inc.i32(+1)
	<append+234 @05fed2>  : 10 00                      dup.x32 sp(0)
	<append+236 @05fed4>  : 13 19                      set.x32 sp(25)
	<append+238 @05fed6>  : 51                         add.i32
	<append+239 @05fed7>  : 2b                         store.i8
	cmplStd/lib/string.ci:172: (10 bytes: <append+240 @05fed8> - <append+250 @05fee2>): maxLen: int32 := format.padLen - len
	<append+240 @05fed8>  : 10 17                      dup.x32 sp(23)
	<append+242 @05feda>  : 0c 0c 00 00                inc.i32(+12)
	<append+246 @05fede>  : 28                         load.i32
	<append+247 @05fedf>  : 10 16                      dup.x32 sp(22)
	<append+249 @05fee1>  : 52                         sub.i32
	cmplStd/lib/string.ci:174: (7 bytes: <append+250 @05fee2> - <append+257 @05fee9>): padChr: char := format.padChr
	<append+250 @05fee2>  : 10 18                      dup.x32 sp(24)
	<append+252 @05fee4>  : 0c 08 00 00                inc.i32(+8)
	<append+256 @05fee8>  : 26                         load.i8
	cmplStd/lib/string.ci:175: (21 bytes: <append+257 @05fee9> - <append+278 @05fefe>): if (padChr == '')
	<append+257 @05fee9>  : 0a 00 00 00                load.sp(+0)
	<append+261 @05feed>  : 26                         load.i8
	<append+262 @05feee>  : 19                         load.z32
	<append+263 @05feef>  : 57                         ceq.i32
	<append+264 @05fef0>  : 06 0e 00 00                jz <append+278 @05fefe>
	cmplStd/lib/string.ci:176: (10 bytes: <append+268 @05fef4> - <append+278 @05fefe>): padChr := ' ';
	<append+268 @05fef4>  : 1c 20 00 00 00             load.c32 32
	<append+273 @05fef9>  : 0a 04 00 00                load.sp(+4)
	<append+277 @05fefd>  : 2b                         store.i8
	cmplStd/lib/string.ci:180: (207 bytes: <append+278 @05fefe> - <append+485 @05ffcd>): if ((sign) != 0)
	<append+278 @05fefe>  : 0a 70 00 00                load.sp(+112)
	<append+282 @05ff02>  : 26                         load.i8
	<append+283 @05ff03>  : 19                         load.z32
	<append+284 @05ff04>  : 57                         ceq.i32
	<append+285 @05ff05>  : 05 c8 00 00                jnz <append+485 @05ffcd>
	cmplStd/lib/string.ci:181: (8 bytes: <append+289 @05ff09> - <append+297 @05ff11>): maxLen := maxLen - 1;
	<append+289 @05ff09>  : 10 01                      dup.x32 sp(1)
	<append+291 @05ff0b>  : 0c ff ff ff                inc.i32(-1)
	<append+295 @05ff0f>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:182: (117 bytes: <append+297 @05ff11> - <append+414 @05ff86>): if (contains(whiteSpace, padChr))
	<append+297 @05ff11>  : 19                         load.z32
	<append+298 @05ff12>  : 20 d8 fd 05                load.m32 <@05fdd8> ;append.whiteSpace
	<append+302 @05ff16>  : 0a 08 00 00                load.sp(+8)
	<append+306 @05ff1a>  : 26                         load.i8
	<append+307 @05ff1b>  : 1f 80 fb 05 00             load.ref <@05fb80> ;indexOf(str: char[*], chr: char): int32
	<append+312 @05ff20>  : 02                         call
	<append+313 @05ff21>  : 09 f8 ff ff                inc.sp(-8)
	<append+317 @05ff25>  : 19                         load.z32
	<append+318 @05ff26>  : 58                         clt.i32
	<append+319 @05ff27>  : 05 5f 00 00                jnz <append+414 @05ff86>
	cmplStd/lib/string.ci:184: (91 bytes: <append+323 @05ff2b> - <append+414 @05ff86>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+323 @05ff2b>  : 04 53 00 00                jmp <append+406 @05ff7e>
	cmplStd/lib/string.ci:185: (52 bytes: <append+327 @05ff2f> - <append+379 @05ff63>): assert(pos < (output.length));
	<append+327 @05ff2f>  : 10 1d                      dup.x32 sp(29)
	<append+329 @05ff31>  : 10 20                      dup.x32 sp(32)
	<append+331 @05ff33>  : 58                         clt.i32
	<append+332 @05ff34>  : 06 08 00 00                jz <append+340 @05ff3c>
	<append+336 @05ff38>  : 04 2b 00 00                jmp <append+379 @05ff63>
	<append+340 @05ff3c>  : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+345 @05ff41>  : 1c b9 00 00 00             load.c32 185
	<append+350 @05ff46>  : 1c fe ff ff ff             load.c32 -2
	<append+355 @05ff4b>  : 1c 80 00 00 00             load.c32 128
	<append+360 @05ff50>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+365 @05ff55>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+370 @05ff5a>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+375 @05ff5f>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:186: (11 bytes: <append+379 @05ff63> - <append+390 @05ff6e>): output[pos] := padChr;
	<append+379 @05ff63>  : 0a 00 00 00                load.sp(+0)
	<append+383 @05ff67>  : 26                         load.i8
	<append+384 @05ff68>  : 10 1f                      dup.x32 sp(31)
	<append+386 @05ff6a>  : 10 1f                      dup.x32 sp(31)
	<append+388 @05ff6c>  : 51                         add.i32
	<append+389 @05ff6d>  : 2b                         store.i8
	cmplStd/lib/string.ci:187: (8 bytes: <append+390 @05ff6e> - <append+398 @05ff76>): pos := pos + 1;
	<append+390 @05ff6e>  : 10 1d                      dup.x32 sp(29)
	<append+392 @05ff70>  : 0c 01 00 00                inc.i32(+1)
	<append+396 @05ff74>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:184: (8 bytes: <append+398 @05ff76> - <append+406 @05ff7e>): maxLen := maxLen - 1
	<append+398 @05ff76>  : 10 01                      dup.x32 sp(1)
	<append+400 @05ff78>  : 0c ff ff ff                inc.i32(-1)
	<append+404 @05ff7c>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:184: (8 bytes: <append+406 @05ff7e> - <append+414 @05ff86>): maxLen > 0
	<append+406 @05ff7e>  : 10 01                      dup.x32 sp(1)
	<append+408 @05ff80>  : 19                         load.z32
	<append+409 @05ff81>  : 59                         cgt.i32
	<append+410 @05ff82>  : 05 ad ff ff                jnz <append+327 @05ff2f>
	cmplStd/lib/string.ci:190: (52 bytes: <append+414 @05ff86> - <append+466 @05ffba>): assert(pos < (output.length));
	<append+414 @05ff86>  : 10 1d                      dup.x32 sp(29)
	<append+416 @05ff88>  : 10 20                      dup.x32 sp(32)
	<append+418 @05ff8a>  : 58                         clt.i32
	<append+419 @05ff8b>  : 06 08 00 00                jz <append+427 @05ff93>
	<append+423 @05ff8f>  : 04 2b 00 00                jmp <append+466 @05ffba>
	<append+427 @05ff93>  : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+432 @05ff98>  : 1c be 00 00 00             load.c32 190
	<append+437 @05ff9d>  : 1c fe ff ff ff             load.c32 -2
	<append+442 @05ffa2>  : 1c 80 00 00 00             load.c32 128
	<append+447 @05ffa7>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+452 @05ffac>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+457 @05ffb1>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+462 @05ffb6>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:191: (11 bytes: <append+466 @05ffba> - <append+477 @05ffc5>): output[pos] := sign;
	<append+466 @05ffba>  : 0a 70 00 00                load.sp(+112)
	<append+470 @05ffbe>  : 26                         load.i8
	<append+471 @05ffbf>  : 10 1f                      dup.x32 sp(31)
	<append+473 @05ffc1>  : 10 1f                      dup.x32 sp(31)
	<append+475 @05ffc3>  : 51                         add.i32
	<append+476 @05ffc4>  : 2b                         store.i8
	cmplStd/lib/string.ci:192: (8 bytes: <append+477 @05ffc5> - <append+485 @05ffcd>): pos := pos + 1;
	<append+477 @05ffc5>  : 10 1d                      dup.x32 sp(29)
	<append+479 @05ffc7>  : 0c 01 00 00                inc.i32(+1)
	<append+483 @05ffcb>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:196: (91 bytes: <append+485 @05ffcd> - <append+576 @060028>): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+485 @05ffcd>  : 04 53 00 00                jmp <append+568 @060020>
	cmplStd/lib/string.ci:197: (52 bytes: <append+489 @05ffd1> - <append+541 @060005>): assert(pos < (output.length));
	<append+489 @05ffd1>  : 10 1d                      dup.x32 sp(29)
	<append+491 @05ffd3>  : 10 20                      dup.x32 sp(32)
	<append+493 @05ffd5>  : 58                         clt.i32
	<append+494 @05ffd6>  : 06 08 00 00                jz <append+502 @05ffde>
	<append+498 @05ffda>  : 04 2b 00 00                jmp <append+541 @060005>
	<append+502 @05ffde>  : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+507 @05ffe3>  : 1c c5 00 00 00             load.c32 197
	<append+512 @05ffe8>  : 1c fe ff ff ff             load.c32 -2
	<append+517 @05ffed>  : 1c 80 00 00 00             load.c32 128
	<append+522 @05fff2>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+527 @05fff7>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+532 @05fffc>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+537 @060001>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:198: (11 bytes: <append+541 @060005> - <append+552 @060010>): output[pos] := padChr;
	<append+541 @060005>  : 0a 00 00 00                load.sp(+0)
	<append+545 @060009>  : 26                         load.i8
	<append+546 @06000a>  : 10 1f                      dup.x32 sp(31)
	<append+548 @06000c>  : 10 1f                      dup.x32 sp(31)
	<append+550 @06000e>  : 51                         add.i32
	<append+551 @06000f>  : 2b                         store.i8
	cmplStd/lib/string.ci:199: (8 bytes: <append+552 @060010> - <append+560 @060018>): pos := pos + 1;
	<append+552 @060010>  : 10 1d                      dup.x32 sp(29)
	<append+554 @060012>  : 0c 01 00 00                inc.i32(+1)
	<append+558 @060016>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:196: (8 bytes: <append+560 @060018> - <append+568 @060020>): maxLen := maxLen - 1
	<append+560 @060018>  : 10 01                      dup.x32 sp(1)
	<append+562 @06001a>  : 0c ff ff ff                inc.i32(-1)
	<append+566 @06001e>  : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:196: (8 bytes: <append+568 @060020> - <append+576 @060028>): maxLen > 0
	<append+568 @060020>  : 10 01                      dup.x32 sp(1)
	<append+570 @060022>  : 19                         load.z32
	<append+571 @060023>  : 59                         cgt.i32
	<append+572 @060024>  : 05 ad ff ff                jnz <append+489 @05ffd1>
	cmplStd/lib/string.ci:203: (99 bytes: <append+576 @060028> - <append+675 @06008b>): for (i: int32 := 0; i < len; i := i + 1)
	<append+576 @060028>  : 19                         load.z32
	<append+577 @060029>  : 04 55 00 00                jmp <append+662 @06007e>
	cmplStd/lib/string.ci:204: (52 bytes: <append+581 @06002d> - <append+633 @060061>): assert(i < (output.length));
	<append+581 @06002d>  : 10 00                      dup.x32 sp(0)
	<append+583 @06002f>  : 10 21                      dup.x32 sp(33)
	<append+585 @060031>  : 58                         clt.i32
	<append+586 @060032>  : 06 08 00 00                jz <append+594 @06003a>
	<append+590 @060036>  : 04 2b 00 00                jmp <append+633 @060061>
	<append+594 @06003a>  : 1f 80 ee 02 00             load.ref <@02ee80> ;"cmplStd/lib/string.ci"
	<append+599 @06003f>  : 1c cc 00 00 00             load.c32 204
	<append+604 @060044>  : 1c fe ff ff ff             load.c32 -2
	<append+609 @060049>  : 1c 80 00 00 00             load.c32 128
	<append+614 @06004e>  : 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<append+619 @060053>  : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<append+624 @060058>  : 1f 00 00 00 00             load.ref <@000000> ;null
	<append+629 @06005d>  : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/lib/string.ci:205: (17 bytes: <append+633 @060061> - <append+650 @060072>): output[pos] := digits[len - i];
	<append+633 @060061>  : 0a 10 00 00                load.sp(+16)
	<append+637 @060065>  : 10 19                      dup.x32 sp(25)
	<append+639 @060067>  : 10 02                      dup.x32 sp(2)
	<append+641 @060069>  : 52                         sub.i32
	<append+642 @06006a>  : 51                         add.i32
	<append+643 @06006b>  : 26                         load.i8
	<append+644 @06006c>  : 10 20                      dup.x32 sp(32)
	<append+646 @06006e>  : 10 20                      dup.x32 sp(32)
	<append+648 @060070>  : 51                         add.i32
	<append+649 @060071>  : 2b                         store.i8
	cmplStd/lib/string.ci:206: (8 bytes: <append+650 @060072> - <append+658 @06007a>): pos := pos + 1;
	<append+650 @060072>  : 10 1e                      dup.x32 sp(30)
	<append+652 @060074>  : 0c 01 00 00                inc.i32(+1)
	<append+656 @060078>  : 13 1f                      set.x32 sp(31)
	cmplStd/lib/string.ci:203: (4 bytes: <append+658 @06007a> - <append+662 @06007e>): i := i + 1
	<append+658 @06007a>  : 0c 01 00 00                inc.i32(+1)
	cmplStd/lib/string.ci:203: (9 bytes: <append+662 @06007e> - <append+671 @060087>): i < len
	<append+662 @06007e>  : 10 00                      dup.x32 sp(0)
	<append+664 @060080>  : 10 19                      dup.x32 sp(25)
	<append+666 @060082>  : 58                         clt.i32
	<append+667 @060083>  : 05 aa ff ff                jnz <append+581 @06002d>
	<append+671 @060087>  : 09 fc ff ff                inc.sp(-4)
	cmplStd/lib/string.ci:209: (17 bytes: <append+675 @06008b> - <append+692 @06009c>): if (pos >= (output.length))
	<append+675 @06008b>  : 10 1d                      dup.x32 sp(29)
	<append+677 @06008d>  : 10 20                      dup.x32 sp(32)
	<append+679 @06008f>  : 58                         clt.i32
	<append+680 @060090>  : 05 0c 00 00                jnz <append+692 @06009c>
	cmplStd/lib/string.ci:210: (8 bytes: <append+684 @060094> - <append+692 @06009c>): pos := (output.length - (1));
	<append+684 @060094>  : 10 1f                      dup.x32 sp(31)
	<append+686 @060096>  : 0c ff ff ff                inc.i32(-1)
	<append+690 @06009a>  : 13 1e                      set.x32 sp(30)
	cmplStd/lib/string.ci:212: (7 bytes: <append+692 @06009c> - <append+699 @0600a3>): output[pos] := (0);
	<append+692 @06009c>  : 19                         load.z32
	<append+693 @06009d>  : 10 1f                      dup.x32 sp(31)
	<append+695 @06009f>  : 10 1f                      dup.x32 sp(31)
	<append+697 @0600a1>  : 51                         add.i32
	<append+698 @0600a2>  : 2b                         store.i8
	cmplStd/lib/string.ci:213: (8 bytes: <append+699 @0600a3> - <append+707 @0600ab>): return .result := pos;
	<append+699 @0600a3>  : 16 20 1d                   mov.x32 sp(32, 29)
	<append+702 @0600a6>  : 09 a0 ff ff                inc.sp(-96)
	<append+706 @0600aa>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:254: referenced as `append`
	cmplStd/lib/string.ci:250: referenced as `append`
	cmplStd/lib/string.ci:231: referenced as `append`
	cmplStd/lib/string.ci:229: referenced as `append`
	cmplStd/lib/string.ci:227: referenced as `append`
	cmplStd/lib/string.ci:225: referenced as `append`
	cmplStd/lib/string.ci:223: referenced as `append`
	cmplStd/lib/string.ci:221: referenced as `append`
	cmplStd/lib/string.ci:219: referenced as `append`
	cmplStd/lib/string.ci:217: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:217'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint64 (size: 8, offs: <+20>, cast: u64)
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:219'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint32 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:221'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint16 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:223'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: uint8 (size: 4, offs: <+16>, cast: u32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), 0), uint64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:225'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param format: FormatFlags (size: 4, offs: <+24>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:227'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format))
.usages:
	cmplStd/lib/string.ci:264: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:229'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int16 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:231'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: int8 (size: 4, offs: <+4>, cast: variable(i32))
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format))
.usages:
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 227
.offset: <@0600b0>
.name: 'append'
.file: 'cmplStd/lib/string.ci:234'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: float64 (size: 8, offs: <+24>, cast: variable(f64))
.param format: FormatFlags (size: 4, offs: <+28>, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		void(formatInt.showSign := format.showSign);
		void(formatInt.precision := 0);
		void(formatInt.padChr := format.padChr);
		void(formatInt.padLen := int32(format.padLen - format.precision));
	};
	formatDec: FormatFlags := {
		void(formatDec.showSign := false);
		void(formatDec.precision := 0);
		void(formatDec.padChr := '0');
		void(formatDec.padLen := format.precision);
	};
	sign: char := bool(value < (0)) ? ('-') : 0;
	fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
	int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
	int32(pos := append(void(output, void(pos, "."))));
	float64(fract := float64(fract * float64.pow(void(10, format.precision))));
	int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
	return int32(.result := pos);
}
.instructions: (227 bytes: <append @0600b0> - <append+227 @060193>)
	cmplStd/lib/string.ci:235: (44 bytes: <append @0600b0> - <append+44 @0600dc>): formatInt: FormatFlags := {...}
	<append @0600b0>      : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:236: (8 bytes: <append+4 @0600b4> - <append+12 @0600bc>): formatInt.showSign := format.showSign;
	<append+4 @0600b4>    : 10 05                      dup.x32 sp(5)
	<append+6 @0600b6>    : 26                         load.i8
	<append+7 @0600b7>    : 0a 04 00 00                load.sp(+4)
	<append+11 @0600bb>   : 2b                         store.i8
	cmplStd/lib/string.ci:237: (3 bytes: <append+12 @0600bc> - <append+15 @0600bf>): formatInt.precision := 0;
	<append+12 @0600bc>   : 19                         load.z32
	<append+13 @0600bd>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:238: (12 bytes: <append+15 @0600bf> - <append+27 @0600cb>): formatInt.padChr := format.padChr;
	<append+15 @0600bf>   : 10 05                      dup.x32 sp(5)
	<append+17 @0600c1>   : 0c 08 00 00                inc.i32(+8)
	<append+21 @0600c5>   : 26                         load.i8
	<append+22 @0600c6>   : 0a 0c 00 00                load.sp(+12)
	<append+26 @0600ca>   : 2b                         store.i8
	cmplStd/lib/string.ci:239: (17 bytes: <append+27 @0600cb> - <append+44 @0600dc>): formatInt.padLen := format.padLen - format.precision;
	<append+27 @0600cb>   : 10 05                      dup.x32 sp(5)
	<append+29 @0600cd>   : 0c 0c 00 00                inc.i32(+12)
	<append+33 @0600d1>   : 28                         load.i32
	<append+34 @0600d2>   : 10 06                      dup.x32 sp(6)
	<append+36 @0600d4>   : 0c 04 00 00                inc.i32(+4)
	<append+40 @0600d8>   : 28                         load.i32
	<append+41 @0600d9>   : 52                         sub.i32
	<append+42 @0600da>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:241: (32 bytes: <append+44 @0600dc> - <append+76 @0600fc>): formatDec: FormatFlags := {...}
	<append+44 @0600dc>   : 09 10 00 00                inc.sp(+16)
	cmplStd/lib/string.ci:242: (6 bytes: <append+48 @0600e0> - <append+54 @0600e6>): formatDec.showSign := false;
	<append+48 @0600e0>   : 19                         load.z32
	<append+49 @0600e1>   : 0a 04 00 00                load.sp(+4)
	<append+53 @0600e5>   : 2b                         store.i8
	cmplStd/lib/string.ci:243: (3 bytes: <append+54 @0600e6> - <append+57 @0600e9>): formatDec.precision := 0;
	<append+54 @0600e6>   : 19                         load.z32
	<append+55 @0600e7>   : 13 02                      set.x32 sp(2)
	cmplStd/lib/string.ci:244: (10 bytes: <append+57 @0600e9> - <append+67 @0600f3>): formatDec.padChr := '0';
	<append+57 @0600e9>   : 1c 30 00 00 00             load.c32 48
	<append+62 @0600ee>   : 0a 0c 00 00                load.sp(+12)
	<append+66 @0600f2>   : 2b                         store.i8
	cmplStd/lib/string.ci:245: (9 bytes: <append+67 @0600f3> - <append+76 @0600fc>): formatDec.padLen := format.precision;
	<append+67 @0600f3>   : 10 09                      dup.x32 sp(9)
	<append+69 @0600f5>   : 0c 04 00 00                inc.i32(+4)
	<append+73 @0600f9>   : 28                         load.i32
	<append+74 @0600fa>   : 13 04                      set.x32 sp(4)
	cmplStd/lib/string.ci:248: (18 bytes: <append+76 @0600fc> - <append+94 @06010e>): sign: char := value < (0) ? ('-') : 0
	<append+76 @0600fc>   : 11 0a                      dup.x64 sp(10)
	<append+78 @0600fe>   : 1a                         load.z64
	<append+79 @0600ff>   : 88                         clt.f64
	<append+80 @060100>   : 06 0d 00 00                jz <append+93 @06010d>
	<append+84 @060104>   : 1c 2d 00 00 00             load.c32 45
	<append+89 @060109>   : 04 05 00 00                jmp <append+94 @06010e>
	<append+93 @06010d>   : 19                         load.z32
	cmplStd/lib/string.ci:249: (27 bytes: <append+94 @06010e> - <append+121 @060129>): fract: float64 := Math.modf(Math.abs(value), &value)
	<append+94 @06010e>   : 1b                         load.z128
	<append+95 @06010f>   : 11 0f                      dup.x64 sp(15)
	<append+97 @060111>   : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<append+102 @060116>  : 02                         call
	<append+103 @060117>  : 09 f8 ff ff                inc.sp(-8)
	<append+107 @06011b>  : 0a 3c 00 00                load.sp(+60)
	<append+111 @06011f>  : 1f e0 ed 05 00             load.ref <@05ede0> ;Math.modf(x: float64, intPart: float64): float64
	<append+116 @060124>  : 02                         call
	<append+117 @060125>  : 09 f4 ff ff                inc.sp(-12)
	cmplStd/lib/string.ci:250: (29 bytes: <append+121 @060129> - <append+150 @060146>): pos := append(output, pos, sign, uint64(int64(value)), formatInt);
	<append+121 @060129>  : 19                         load.z32
	<append+122 @06012a>  : 11 11                      dup.x64 sp(17)
	<append+124 @06012c>  : 10 12                      dup.x32 sp(18)
	<append+126 @06012e>  : 0a 18 00 00                load.sp(+24)
	<append+130 @060132>  : 26                         load.i8
	<append+131 @060133>  : 11 12                      dup.x64 sp(18)
	<append+133 @060135>  : 8b                         f64.2i64
	<append+134 @060136>  : 0a 38 00 00                load.sp(+56)
	<append+138 @06013a>  : 1f e8 fd 05 00             load.ref <@05fde8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+143 @06013f>  : 02                         call
	<append+144 @060140>  : 09 e4 ff ff                inc.sp(-28)
	<append+148 @060144>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:252: (22 bytes: <append+150 @060146> - <append+172 @06015c>): pos := append(output, pos, ".");
	<append+150 @060146>  : 19                         load.z32
	<append+151 @060147>  : 11 11                      dup.x64 sp(17)
	<append+153 @060149>  : 10 12                      dup.x32 sp(18)
	<append+155 @06014b>  : 1f 9c f2 02 00             load.ref <@02f29c> ;"."
	<append+160 @060150>  : 1f 80 fd 05 00             load.ref <@05fd80> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+165 @060155>  : 02                         call
	<append+166 @060156>  : 09 f0 ff ff                inc.sp(-16)
	<append+170 @06015a>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:253: (22 bytes: <append+172 @06015c> - <append+194 @060172>): fract := fract * float64.pow(10, format.precision);
	<append+172 @06015c>  : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<append+181 @060165>  : 10 0e                      dup.x32 sp(14)
	<append+183 @060167>  : 0c 04 00 00                inc.i32(+4)
	<append+187 @06016b>  : 28                         load.i32
	<append+188 @06016c>  : 5d                         i32.2f64
	<append+189 @06016d>  : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<append+193 @060171>  : 83                         mul.f64
	cmplStd/lib/string.ci:254: (25 bytes: <append+194 @060172> - <append+219 @06018b>): pos := append(output, pos, 0, uint64(int64(fract)), formatDec);
	<append+194 @060172>  : 19                         load.z32
	<append+195 @060173>  : 11 11                      dup.x64 sp(17)
	<append+197 @060175>  : 10 12                      dup.x32 sp(18)
	<append+199 @060177>  : 19                         load.z32
	<append+200 @060178>  : 11 05                      dup.x64 sp(5)
	<append+202 @06017a>  : 8b                         f64.2i64
	<append+203 @06017b>  : 0a 28 00 00                load.sp(+40)
	<append+207 @06017f>  : 1f e8 fd 05 00             load.ref <@05fde8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+212 @060184>  : 02                         call
	<append+213 @060185>  : 09 e4 ff ff                inc.sp(-28)
	<append+217 @060189>  : 13 10                      set.x32 sp(16)
	cmplStd/lib/string.ci:255: (8 bytes: <append+219 @06018b> - <append+227 @060193>): return .result := pos;
	<append+219 @06018b>  : 16 12 0f                   mov.x32 sp(18, 15)
	<append+222 @06018e>  : 09 d4 ff ff                inc.sp(-44)
	<append+226 @060192>  : 03                         ret
.usages:
	cmplStd/lib/string.ci:259: referenced as `append`
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'append'
.file: 'cmplStd/lib/string.ci:259'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param output: char[] (size: 8, offs: <+8>, cast: arr)
.param pos: int32 (size: 4, offs: <+12>, cast: i32)
.param value: float32 (size: 4, offs: <+16>, cast: f32)
.param format: FormatFlags (size: 4, offs: <+20>, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(void(void(void(output, pos), float64(value)), format))
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@0601a8>
.name: 'append'
.file: 'cmplStd/lib/string.ci:262'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param output: char[] (size: 8, offs: <+12>, cast: variable(arr))
.param pos: int32 (size: 4, offs: <+16>, cast: variable(i32))
.param value: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		void(format.showSign := false);
		void(format.precision := 0);
		void(format.padChr := (0));
		void(format.padLen := 0);
	};
	return int32(.result := append(void(void(void(output, pos), value), format)));
}
.instructions: (63 bytes: <append @0601a8> - <append+63 @0601e7>)
	cmplStd/lib/string.ci:264: (63 bytes: <append @0601a8> - <append+63 @0601e7>): return .result := append(output, pos, value, format);
	<append @0601a8>      : 10 01                      dup.x32 sp(1)
	<append+2 @0601aa>    : 19                         load.z32
	<append+3 @0601ab>    : 11 05                      dup.x64 sp(5)
	<append+5 @0601ad>    : 10 06                      dup.x32 sp(6)
	<append+7 @0601af>    : 10 04                      dup.x32 sp(4)
	<append+9 @0601b1>    : 19                         load.z32
	<append+10 @0601b2>   : 58                         clt.i32
	<append+11 @0601b3>   : 06 0d 00 00                jz <append+24 @0601c0>
	<append+15 @0601b7>   : 1c 2d 00 00 00             load.c32 45
	<append+20 @0601bc>   : 04 05 00 00                jmp <append+25 @0601c1>
	<append+24 @0601c0>   : 19                         load.z32
	<append+25 @0601c1>   : 10 05                      dup.x32 sp(5)
	<append+27 @0601c3>   : 19                         load.z32
	<append+28 @0601c4>   : 58                         clt.i32
	<append+29 @0601c5>   : 06 0b 00 00                jz <append+40 @0601d0>
	<append+33 @0601c9>   : 10 05                      dup.x32 sp(5)
	<append+35 @0601cb>   : 50                         neg.i32
	<append+36 @0601cc>   : 04 06 00 00                jmp <append+42 @0601d2>
	<append+40 @0601d0>   : 10 05                      dup.x32 sp(5)
	<append+42 @0601d2>   : 5b                         i32.2i64
	<append+43 @0601d3>   : 1f 98 01 06 00             load.ref <@060198> ;append.format
	<append+48 @0601d8>   : 1f e8 fd 05 00             load.ref <@05fde8> ;append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
	<append+53 @0601dd>   : 02                         call
	<append+54 @0601de>   : 09 e4 ff ff                inc.sp(-28)
	<append+58 @0601e2>   : 13 01                      set.x32 sp(1)
	<append+60 @0601e4>   : 13 06                      set.x32 sp(6)
	<append+62 @0601e6>   : 03                         ret
.usages:
}
integer: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0601e8>
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0601f0>
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0601f8>
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060200>
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060208>
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(void(void(int32(emitA), int32(emitB)), add.i32))
.usages:
}
emitDivI32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060210>
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(void(void(int32(10), int32(5)), div.i32))
.usages:
}
emitNfcF32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060218>
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin))
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param value: float32 (size: 4, offs: <+4>, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, offs: <+0>, cast: i64)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060220>
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060228>
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060230>
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060238>
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@060240>
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:29'
.value: emit(void(int32(3), pointer("string")))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: int32(a + b)
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a < b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param b: int32 (size: 4, offs: <+8>, cast: variable(i32))
.value: bool(a > b) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060248>
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060250>
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060258>
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060260>
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060268>
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(void(3, 6))
.usages:
}
zeroVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060270>
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(void(i3, i6))
.usages:
}
zeroXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060278>
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(void(int32(i3 + 1), int32(i6 + 1)))
.usages:
}
lastVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060280>
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(void(3, 6))
.usages:
}
lastVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060288>
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(void(i3, i6))
.usages:
}
lastXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060290>
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sum2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060298>
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(void(3, 6))
.usages:
}
sum2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602a0>
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(void(i3, i6))
.usages:
}
sum2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602a8>
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2)
.usages:
}
any2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602b0>
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(void(3, 6))
.usages:
}
any2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602b8>
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(void(i3, i6))
.usages:
}
any2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602c0>
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
min2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602c8>
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(void(3, 6))
.usages:
}
min2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602d0>
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(void(i3, i6))
.usages:
}
min2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602d8>
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
max2Val: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602e0>
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(void(3, 6))
.usages:
}
max2Var: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602e8>
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(void(i3, i6))
.usages:
}
max2Xpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602f0>
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1)
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(a, sum(void(b, sum(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: sum(void(sum(void(sum(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0602f8>
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(void(void(void(3, 6), 2), 8))
.usages:
}
sumLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060300>
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(void(void(void(3, 6), 2), 8))
.usages:
}
sumRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060308>
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(void(void(void(i3, i6), i2), i8))
.usages:
}
sumLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060310>
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(void(void(void(i3, i6), i2), i8))
.usages:
}
sumRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060318>
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
sumLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060320>
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4)
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(a, any(void(b, any(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: any(void(any(void(any(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060328>
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(void(void(void(3, 6), 2), 8))
.usages:
}
anyLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060330>
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(void(void(void(3, 6), 2), 8))
.usages:
}
anyRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060338>
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(void(void(void(i3, i6), i2), i8))
.usages:
}
anyLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060340>
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(void(void(void(i3, i6), i2), i8))
.usages:
}
anyRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060348>
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
anyLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060350>
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(a, min(void(b, min(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: min(void(min(void(min(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060358>
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(void(void(void(3, 6), 2), 8))
.usages:
}
minLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060360>
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(void(void(void(3, 6), 2), 8))
.usages:
}
minRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060368>
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(void(void(void(i3, i6), i2), i8))
.usages:
}
minLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060370>
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(void(void(void(i3, i6), i2), i8))
.usages:
}
minRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060378>
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
minLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060380>
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(a, max(void(b, max(void(c, d))))))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.param c: int32 (size: 4, offs: <+12>, cast: i32)
.param d: int32 (size: 4, offs: <+16>, cast: i32)
.value: max(void(max(void(max(void(a, b)), c)), d))
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060388>
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(void(void(void(3, 6), 2), 8))
.usages:
}
maxLrVal: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060390>
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(void(void(void(3, 6), 2), 8))
.usages:
}
maxRlVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060398>
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(void(void(void(i3, i6), i2), i8))
.usages:
}
maxLrVar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0603a0>
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(void(void(void(i3, i6), i2), i8))
.usages:
}
maxRlXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0603a8>
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
maxLrXpr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0603b0>
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1)
.usages:
}
overload: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: float32 (size: 4, offs: <+4>, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param a: int32 (size: 4, offs: <+4>, cast: i32)
.param b: int32 (size: 4, offs: <+8>, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0603b8>
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0603c0>
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0603c8>
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0603d0>
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0603d8>
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(void(0, 0))
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03dbb0>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@03dcf0>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, offs: <+0>, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: float64 (size: 8, offs: <+8>, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, offs: <+0>, cast: val)
.param value: Fahrenheit (size: 8, offs: <+8>, cast: val)
.value: Celsius(float64((float64(value.degrees - (32))) / 1.800000))
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, offs: <+0>, cast: val)
.param value: Celsius (size: 8, offs: <+8>, cast: val)
.value: Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: static variable(val)
.base: `Celsius`
.size: 8
.offset: <@0603e0>
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: static variable(val)
.base: `Fahrenheit`
.size: 8
.offset: <@0603e8>
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
pi64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0603f0>
.name: 'pi64'
.file: 'cmplStd/test/std/number.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/std/number.ci:44: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:43: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:42: referenced as `pi64`
	cmplStd/test/std/number.ci:39: referenced as `pi64`
	cmplStd/test/std/number.ci:38: referenced as `pi64`
	cmplStd/test/std/number.ci:37: referenced as `pi64`
	cmplStd/test/std/number.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0603f8>
.name: 'e64'
.file: 'cmplStd/test/std/number.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:40: referenced as `e64`
	cmplStd/test/std/number.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060400>
.name: 'pi32'
.file: 'cmplStd/test/std/number.ci:6'
.value: pi64
.usages:
	cmplStd/test/std/number.ci:53: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:52: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:51: referenced as `pi32`
	cmplStd/test/std/number.ci:48: referenced as `pi32`
	cmplStd/test/std/number.ci:47: referenced as `pi32`
	cmplStd/test/std/number.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060408>
.name: 'e32'
.file: 'cmplStd/test/std/number.ci:7'
.value: e64
.usages:
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
	cmplStd/test/std/number.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb888'
.file: 'cmplStd/test/std/number.ci:10'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255))
.usages:
	cmplStd/test/std/number.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'rgb565'
.file: 'cmplStd/test/std/number.ci:12'
.param .result: int32 (size: 4, offs: <+0>, cast: i32)
.param r: int32 (size: 4, offs: <+4>, cast: i32)
.param g: int32 (size: 4, offs: <+8>, cast: i32)
.param b: int32 (size: 4, offs: <+12>, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31))
.usages:
	cmplStd/test/std/number.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060410>
.name: 'r_comp'
.file: 'cmplStd/test/std/number.ci:14'
.value: int32(14 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `r_comp`
	cmplStd/test/std/number.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060418>
.name: 'g_comp'
.file: 'cmplStd/test/std/number.ci:15'
.value: int32(63 << 2)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `g_comp`
	cmplStd/test/std/number.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060420>
.name: 'b_comp'
.file: 'cmplStd/test/std/number.ci:16'
.value: int32(31 << 3)
.usages:
	cmplStd/test/std/number.ci:19: referenced as `b_comp`
	cmplStd/test/std/number.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060428>
.name: 'r5g6b5'
.file: 'cmplStd/test/std/number.ci:18'
.value: rgb565(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:66: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:65: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:63: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:62: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:60: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:59: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:58: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:57: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:56: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:55: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:27: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:26: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:25: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:23: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:22: referenced as `r5g6b5`
	cmplStd/test/std/number.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060430>
.name: 'r8g8b8'
.file: 'cmplStd/test/std/number.ci:19'
.value: rgb888(void(void(r_comp, g_comp), b_comp))
.usages:
	cmplStd/test/std/number.ci:35: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:34: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:33: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:31: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:30: referenced as `r8g8b8`
	cmplStd/test/std/number.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060438>
.name: 'zxtR5'
.file: 'cmplStd/test/std/number.ci:21'
.value: uint32.zxt(void(void(r5g6b5, 11), 5))
.usages:
}
zxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060440>
.name: 'zxtG6'
.file: 'cmplStd/test/std/number.ci:22'
.value: uint32.zxt(void(void(r5g6b5, 5), 6))
.usages:
}
zxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060448>
.name: 'zxtB5'
.file: 'cmplStd/test/std/number.ci:23'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
sxtR5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060450>
.name: 'sxtR5'
.file: 'cmplStd/test/std/number.ci:25'
.value: uint32.sxt(void(void(r5g6b5, 11), 5))
.usages:
}
sxtG6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060458>
.name: 'sxtG6'
.file: 'cmplStd/test/std/number.ci:26'
.value: uint32.sxt(void(void(r5g6b5, 5), 6))
.usages:
}
sxtB5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060460>
.name: 'sxtB5'
.file: 'cmplStd/test/std/number.ci:27'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
zxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060468>
.name: 'zxtR8'
.file: 'cmplStd/test/std/number.ci:29'
.value: uint32.zxt(void(void(r8g8b8, 16), 8))
.usages:
}
zxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060470>
.name: 'zxtG8'
.file: 'cmplStd/test/std/number.ci:30'
.value: uint32.zxt(void(void(r8g8b8, 8), 8))
.usages:
}
zxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060478>
.name: 'zxtB8'
.file: 'cmplStd/test/std/number.ci:31'
.value: uint32.zxt(void(void(r8g8b8, 0), 8))
.usages:
}
sxtR8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060480>
.name: 'sxtR8'
.file: 'cmplStd/test/std/number.ci:33'
.value: uint32.sxt(void(void(r8g8b8, 16), 8))
.usages:
}
sxtG8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060488>
.name: 'sxtG8'
.file: 'cmplStd/test/std/number.ci:34'
.value: uint32.sxt(void(void(r8g8b8, 8), 8))
.usages:
}
sxtB8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060490>
.name: 'sxtB8'
.file: 'cmplStd/test/std/number.ci:35'
.value: uint32.sxt(void(void(r8g8b8, 0), 8))
.usages:
}
testSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@060498>
.name: 'testSin_f64'
.file: 'cmplStd/test/std/number.ci:37'
.value: float64.sin(float64(pi64 / (2)))
.usages:
}
testCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604a0>
.name: 'testCos_f64'
.file: 'cmplStd/test/std/number.ci:38'
.value: float64.cos(float64(pi64 / (2)))
.usages:
}
testTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604a8>
.name: 'testTan_f64'
.file: 'cmplStd/test/std/number.ci:39'
.value: float64.tan(float64(pi64 / (4)))
.usages:
}
testLog_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604b0>
.name: 'testLog_f64'
.file: 'cmplStd/test/std/number.ci:40'
.value: float64.log(float64(float64(e64 * e64) * e64))
.usages:
}
testExp_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604b8>
.name: 'testExp_f64'
.file: 'cmplStd/test/std/number.ci:41'
.value: float64.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604c0>
.name: 'testPow_f64'
.file: 'cmplStd/test/std/number.ci:42'
.value: float64.pow(void(float64(pi64 * pi64), 0.500000))
.usages:
}
testSqrt_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604c8>
.name: 'testSqrt_f64'
.file: 'cmplStd/test/std/number.ci:43'
.value: float64.sqrt(float64(pi64 * pi64))
.usages:
}
testAtan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0604d0>
.name: 'testAtan_f64'
.file: 'cmplStd/test/std/number.ci:44'
.value: float64.atan2(void(pi64, 1.000000))
.usages:
}
testSin_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0604d8>
.name: 'testSin_f32'
.file: 'cmplStd/test/std/number.ci:46'
.value: float32.sin(float32(pi32 / (2)))
.usages:
}
testCos_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0604e0>
.name: 'testCos_f32'
.file: 'cmplStd/test/std/number.ci:47'
.value: float32.cos(float32(pi32 / (2)))
.usages:
}
testTan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0604e8>
.name: 'testTan_f32'
.file: 'cmplStd/test/std/number.ci:48'
.value: float32.tan(float32(pi32 / (4)))
.usages:
}
testLog_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0604f0>
.name: 'testLog_f32'
.file: 'cmplStd/test/std/number.ci:49'
.value: float32.log(float32(float32(e32 * e32) * e32))
.usages:
}
testExp_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0604f8>
.name: 'testExp_f32'
.file: 'cmplStd/test/std/number.ci:50'
.value: float32.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060500>
.name: 'testPow_f32'
.file: 'cmplStd/test/std/number.ci:51'
.value: float32.pow(void(float32(pi32 * pi32), 0.500000))
.usages:
}
testSqrt_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060508>
.name: 'testSqrt_f32'
.file: 'cmplStd/test/std/number.ci:52'
.value: float32.sqrt(float32(pi32 * pi32))
.usages:
}
testAtan_f32: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@060510>
.name: 'testAtan_f32'
.file: 'cmplStd/test/std/number.ci:53'
.value: float32.atan2(void(pi32, 1.000000))
.usages:
}
testPopulation_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060518>
.name: 'testPopulation_u32'
.file: 'cmplStd/test/std/number.ci:55'
.value: uint32.pop(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@060520>
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/std/number.ci:56'
.value: uint32.swap(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060528>
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/std/number.ci:57'
.value: uint32.bsr(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060530>
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/std/number.ci:58'
.value: uint32.bsf(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060538>
.name: 'testHighBit_u32'
.file: 'cmplStd/test/std/number.ci:59'
.value: uint32.hib(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060540>
.name: 'testLowBit_u32'
.file: 'cmplStd/test/std/number.ci:60'
.value: uint32.lob(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060548>
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/std/number.ci:62'
.value: uint32.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060550>
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/std/number.ci:63'
.value: uint32.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
testZeroExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060558>
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/std/number.ci:65'
.value: uint64.zxt(void(void(r5g6b5, 0), 5))
.usages:
}
testSignExtend_u64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060560>
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/std/number.ci:66'
.value: uint64.sxt(void(void(r5g6b5, 0), 5))
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'realloc'
.file: 'cmplStd/test/std/memory.ci:3'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.param size: int32 (size: 4, offs: <+8>, cast: i32)
.value: pointer.alloc(void(data, size))
.usages:
}
malloc(size: int32): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'malloc'
.file: 'cmplStd/test/std/memory.ci:4'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param size: int32 (size: 4, offs: <+4>, cast: i32)
.value: pointer.alloc(void(null, size))
.usages:
	cmplStd/test/std/memory.ci:10: referenced as `malloc`
	cmplStd/test/std/memory.ci:9: referenced as `malloc`
	cmplStd/test/std/memory.ci:8: referenced as `malloc`
	cmplStd/test/std/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: static inline
.base: `function`
.size: 0
.offset: <@000000>
.name: 'free'
.file: 'cmplStd/test/std/memory.ci:5'
.param .result: pointer (size: 4, offs: <+0>, cast: ref)
.param data: pointer (size: 4, offs: <+4>, cast: ref)
.value: pointer.alloc(void(data, 0))
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `free`
	cmplStd/test/std/memory.ci:19: referenced as `free`
	cmplStd/test/std/memory.ci:18: referenced as `free`
	cmplStd/test/std/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060568>
.name: 'p1'
.file: 'cmplStd/test/std/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/std/memory.ci:17: referenced as `p1`
	cmplStd/test/std/memory.ci:14: referenced as `p1`
	cmplStd/test/std/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060570>
.name: 'p2'
.file: 'cmplStd/test/std/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/std/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060578>
.name: 'p3'
.file: 'cmplStd/test/std/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/std/memory.ci:19: referenced as `p3`
	cmplStd/test/std/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060580>
.name: 'p4'
.file: 'cmplStd/test/std/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/std/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060588>
.name: 'val1'
.file: 'cmplStd/test/std/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/std/memory.ci:32: referenced as `val1`
	cmplStd/test/std/memory.ci:30: referenced as `val1`
	cmplStd/test/std/memory.ci:29: referenced as `val1`
	cmplStd/test/std/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060590>
.name: 'val2'
.file: 'cmplStd/test/std/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/std/memory.ci:33: referenced as `val2`
	cmplStd/test/std/memory.ci:29: referenced as `val2`
	cmplStd/test/std/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@060598>
.name: 'noError'
.file: 'cmplStd/test/std/tryExec.ci:11'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
}
.instructions: (1 byte: <noError @060598> - <noError+1 @060599>)
	<noError @060598>      : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:47: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.offset: <@0605a0>
.name: 'stackOverflow'
.file: 'cmplStd/test/std/tryExec.ci:14'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param ptr: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes: <stackOverflow @0605a0> - <stackOverflow+24 @0605b8>)
	cmplStd/test/std/tryExec.ci:16: (4 bytes: <stackOverflow @0605a0> - <stackOverflow+4 @0605a4>): data: uint8[8192] := {...}
	<stackOverflow @0605a0>      : 09 00 20 00                inc.sp(+8192)
	cmplStd/test/std/tryExec.ci:17: (15 bytes: <stackOverflow+4 @0605a4> - <stackOverflow+19 @0605b3>): stackOverflow(ptr);
	<stackOverflow+4 @0605a4>    : 0a 04 20 00                load.sp(+8196)
	<stackOverflow+8 @0605a8>    : 28                         load.i32
	<stackOverflow+9 @0605a9>    : 1f a0 05 06 00             load.ref <@0605a0> ;stackOverflow(ptr: pointer): void
	<stackOverflow+14 @0605ae>   : 02                         call
	<stackOverflow+15 @0605af>   : 09 fc ff ff                inc.sp(-4)
	<stackOverflow+19 @0605b3>   : 09 00 e0 ff                inc.sp(-8192)
	<stackOverflow+23 @0605b7>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:49: referenced as `stackOverflow`
	cmplStd/test/std/tryExec.ci:17: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@0605b8>
.name: 'divisionByZero'
.file: 'cmplStd/test/std/tryExec.ci:20'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	value: int32 := int32(3 / 0);
}
.instructions: (12 bytes: <divisionByZero @0605b8> - <divisionByZero+12 @0605c4>)
	cmplStd/test/std/tryExec.ci:21: (7 bytes: <divisionByZero @0605b8> - <divisionByZero+7 @0605bf>): value: int32 := 3 / 0
	<divisionByZero @0605b8>      : 1c 03 00 00 00             load.c32 3
	<divisionByZero+5 @0605bd>    : 19                         load.z32
	<divisionByZero+6 @0605be>    : 54                         div.i32
	<divisionByZero+7 @0605bf>    : 09 fc ff ff                inc.sp(-4)
	<divisionByZero+11 @0605c3>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:50: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 68
.offset: <@0605c8>
.name: 'abortExecution'
.file: 'cmplStd/test/std/tryExec.ci:24'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		void(details.message := ("assertion failed"));
		void(details.expected := 97);
		void(details.returned := 77);
	};
	abort(void("fatal error", details));
}
.instructions: (68 bytes: <abortExecution @0605c8> - <abortExecution+68 @06060c>)
	cmplStd/test/std/tryExec.ci:30: (25 bytes: <abortExecution @0605c8> - <abortExecution+25 @0605e1>): details: NotEquals := {...}
	<abortExecution @0605c8>      : 09 10 00 00                inc.sp(+16)
	cmplStd/test/std/tryExec.ci:31: (7 bytes: <abortExecution+4 @0605cc> - <abortExecution+11 @0605d3>): details.message := ("assertion failed");
	<abortExecution+4 @0605cc>    : 1f d0 f1 00 00             load.ref <@00f1d0> ;"assertion failed"
	<abortExecution+9 @0605d1>    : 13 01                      set.x32 sp(1)
	cmplStd/test/std/tryExec.ci:32: (7 bytes: <abortExecution+11 @0605d3> - <abortExecution+18 @0605da>): details.expected := 97;
	<abortExecution+11 @0605d3>   : 1c 61 00 00 00             load.c32 97
	<abortExecution+16 @0605d8>   : 13 02                      set.x32 sp(2)
	cmplStd/test/std/tryExec.ci:33: (7 bytes: <abortExecution+18 @0605da> - <abortExecution+25 @0605e1>): details.returned := 77;
	<abortExecution+18 @0605da>   : 1c 4d 00 00 00             load.c32 77
	<abortExecution+23 @0605df>   : 13 03                      set.x32 sp(3)
	cmplStd/test/std/tryExec.ci:35: (38 bytes: <abortExecution+25 @0605e1> - <abortExecution+63 @060607>): abort("fatal error", details);
	<abortExecution+25 @0605e1>   : 1f 78 17 04 00             load.ref <@041778> ;"cmplStd/test/std/tryExec.ci"
	<abortExecution+30 @0605e6>   : 1c 23 00 00 00             load.c32 35
	<abortExecution+35 @0605eb>   : 1c fe ff ff ff             load.c32 -2
	<abortExecution+40 @0605f0>   : 1c 80 00 00 00             load.c32 128
	<abortExecution+45 @0605f5>   : 1f c8 17 04 00             load.ref <@0417c8> ;"fatal error"
	<abortExecution+50 @0605fa>   : 1f 60 22 04 00             load.ref <@042260> ;abortExecution.NotEquals
	<abortExecution+55 @0605ff>   : 0a 18 00 00                load.sp(+24)
	<abortExecution+59 @060603>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+63 @060607>   : 09 f0 ff ff                inc.sp(-16)
	<abortExecution+67 @06060b>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:53: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.offset: <@060610>
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/std/tryExec.ci:38'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes: <invalidMemoryAccess @060610> - <invalidMemoryAccess+13 @06061d>)
	cmplStd/test/std/tryExec.ci:39: (5 bytes: <invalidMemoryAccess @060610> - <invalidMemoryAccess+5 @060615>): i32Ref: int32 := null
	<invalidMemoryAccess @060610>      : 1f 00 00 00 00             load.ref <@000000> ;null
	cmplStd/test/std/tryExec.ci:40: (3 bytes: <invalidMemoryAccess+5 @060615> - <invalidMemoryAccess+8 @060618>): i32Val: int32 := i32Ref
	<invalidMemoryAccess+5 @060615>    : 10 00                      dup.x32 sp(0)
	<invalidMemoryAccess+7 @060617>    : 28                         load.i32
	<invalidMemoryAccess+8 @060618>    : 09 f8 ff ff                inc.sp(-8)
	<invalidMemoryAccess+12 @06061c>   : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:52: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.offset: <@060620>
.name: 'invalidInstruction'
.file: 'cmplStd/test/std/tryExec.ci:43'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param args: pointer (size: 4, offs: <+4>, cast: variable(ref))
.value: {
	emit(void(load.z32, ret));
}
.instructions: (2 bytes: <invalidInstruction @060620> - <invalidInstruction+2 @060622>)
	cmplStd/test/std/tryExec.ci:44: (2 bytes: <invalidInstruction @060620> - <invalidInstruction+2 @060622>): emit(load.z32, ret);
	<invalidInstruction @060620>      : 19                         load.z32
	<invalidInstruction+1 @060621>    : 03                         ret
.usages:
	cmplStd/test/std/tryExec.ci:51: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060628>
.name: 'tryExecErr0'
.file: 'cmplStd/test/std/tryExec.ci:47'
.value: tryExec(void(null, noError))
.usages:
}
tryExecErr1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060630>
.name: 'tryExecErr1'
.file: 'cmplStd/test/std/tryExec.ci:48'
.value: tryExec(void(null, null))
.usages:
}
tryExecErr2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060638>
.name: 'tryExecErr2'
.file: 'cmplStd/test/std/tryExec.ci:49'
.value: tryExec(void(null, stackOverflow))
.usages:
}
tryExecErr3: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060640>
.name: 'tryExecErr3'
.file: 'cmplStd/test/std/tryExec.ci:50'
.value: tryExec(void(null, divisionByZero))
.usages:
}
tryExecErr4: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060648>
.name: 'tryExecErr4'
.file: 'cmplStd/test/std/tryExec.ci:51'
.value: tryExec(void(null, invalidInstruction))
.usages:
}
tryExecErr5: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060650>
.name: 'tryExecErr5'
.file: 'cmplStd/test/std/tryExec.ci:52'
.value: tryExec(void(null, invalidMemoryAccess))
.usages:
}
tryExecErr6: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060658>
.name: 'tryExecErr6'
.file: 'cmplStd/test/std/tryExec.ci:53'
.value: tryExec(void(null, abortExecution))
.usages:
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060660>
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@060668>
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060670>
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060678>
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@060680>
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@060688>
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@060690>
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@060698>
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0606a0>
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0606a8>
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0606b0>
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@0606b8>
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@0606c0>
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0606c8>
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0606d0>
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0606d8>
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0606e0>
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0606e8>
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: static variable(ref)
.base: `int64`
.size: 4
.offset: <@0606f0>
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0606f8>
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060700>
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060708>
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060710>
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060718>
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060720>
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060728>
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060730>
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060738>
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060740>
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060748>
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060750>
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060758>
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060760>
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060768>
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060770>
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060778>
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060780>
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060788>
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060790>
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@060798>
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607a0>
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607a8>
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607b0>
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607b8>
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607c0>
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607c8>
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607d0>
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607d8>
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607e0>
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607e8>
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607f0>
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0607f8>
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060800>
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060808>
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060810>
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060818>
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060820>
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@060828>
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060830>
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060838>
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060840>
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060848>
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060850>
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060858>
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060860>
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060868>
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060870>
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060878>
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060880>
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060888>
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060890>
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060898>
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608a0>
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608a8>
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608b0>
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608b8>
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0608c0>
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0608c8>
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608d0>
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@0608d8>
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: static variable(var)
.base: `variant`
.size: 8
.offset: <@0608e0>
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0608e8>
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0608f0>
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@0608f8>
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@046b00>
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, offs: <+0>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+8>, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+0>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+8>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@046ce0>
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, offs: <+4>, cast: const variable(f64))
.field im: float64 (size: 8, offs: <+12>, cast: const variable(f64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+4>
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.offset: <+12>
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
valInitImplicit: ComplexVal {
.kind: static variable(val)
.base: `ComplexVal`
.size: 16
.offset: <@060900>
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	void(valInitImplicit.re := (8));
	void(valInitImplicit.im := (0));
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: static variable(ref)
.base: `ComplexObj`
.size: 4
.offset: <@060910>
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	void(objInitImplicit := create(ComplexObj));
	void(objInitImplicit.re := (8));
	void(objInitImplicit.im := (0));
}
.usages:
}
objInitExplicit: object {
.kind: static variable(ref)
.base: `object`
.size: 4
.offset: <@060918>
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	void(objInitExplicit := create(ComplexObj));
	void(objInitExplicit.re := (8));
	void(objInitExplicit.im := (0));
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.offset: <@060920>
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte: <empty @060920> - <empty+1 @060921>)
	<empty @060920>      : 03                         ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@060928>
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return int32(.result := int32(x + y));
}
.instructions: (8 bytes: <funAdd @060928> - <funAdd+8 @060930>)
	cmplStd/test/lang/function.ci:8: (8 bytes: <funAdd @060928> - <funAdd+8 @060930>): return .result := x + y;
	<funAdd @060928>      : 10 02                      dup.x32 sp(2)
	<funAdd+2 @06092a>    : 10 02                      dup.x32 sp(2)
	<funAdd+4 @06092c>    : 51                         add.i32
	<funAdd+5 @06092d>    : 13 04                      set.x32 sp(4)
	<funAdd+7 @06092f>    : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060930>
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(void(2, 7))
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@060938>
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060940>
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(void(2, 8))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@060948>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060950>
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(void(2, 6))
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@060958>
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060960>
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(void(2, 7))
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.offset: <@060968>
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param x: int32 (size: 4, offs: <+8>, cast: variable(i32))
.param y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return int32(.result := int32(x * y));
}
.instructions: (8 bytes: <funMul @060968> - <funMul+8 @060970>)
	cmplStd/test/lang/function.ci:34: (8 bytes: <funMul @060968> - <funMul+8 @060970>): return .result := x * y;
	<funMul @060968>      : 10 02                      dup.x32 sp(2)
	<funMul+2 @06096a>    : 10 02                      dup.x32 sp(2)
	<funMul+4 @06096c>    : 53                         mul.i32
	<funMul+5 @06096d>    : 13 04                      set.x32 sp(4)
	<funMul+7 @06096f>    : 03                         ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.offset: <@060970>
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, offs: <+4>, cast: variable(u32))
.param n: uint32 (size: 4, offs: <+8>, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (bool(n <= (1))) {
		return uint32(.result := n);
	}
	return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
}
.instructions: (54 bytes: <fib @060970> - <fib+54 @0609a6>)
	cmplStd/test/lang/function.ci:39: (16 bytes: <fib @060970> - <fib+16 @060980>): if (n <= (1))
	<fib @060970>      : 10 01                      dup.x32 sp(1)
	<fib+2 @060972>    : 1c 01 00 00 00             load.c32 1
	<fib+7 @060977>    : 39                         cgt.u32
	<fib+8 @060978>    : 05 08 00 00                jnz <fib+16 @060980>
	cmplStd/test/lang/function.ci:40: (4 bytes: <fib+12 @06097c> - <fib+16 @060980>): return .result := n;
	<fib+12 @06097c>   : 16 02 01                   mov.x32 sp(2, 1)
	<fib+15 @06097f>   : 03                         ret
	cmplStd/test/lang/function.ci:42: (38 bytes: <fib+16 @060980> - <fib+54 @0609a6>): return .result := fib(n - (1)) + fib(n - (2));
	<fib+16 @060980>   : 19                         load.z32
	<fib+17 @060981>   : 10 02                      dup.x32 sp(2)
	<fib+19 @060983>   : 0c ff ff ff                inc.i32(-1)
	<fib+23 @060987>   : 1f 70 09 06 00             load.ref <@060970> ;fib(n: uint32): uint32
	<fib+28 @06098c>   : 02                         call
	<fib+29 @06098d>   : 09 fc ff ff                inc.sp(-4)
	<fib+33 @060991>   : 19                         load.z32
	<fib+34 @060992>   : 10 03                      dup.x32 sp(3)
	<fib+36 @060994>   : 0c fe ff ff                inc.i32(-2)
	<fib+40 @060998>   : 1f 70 09 06 00             load.ref <@060970> ;fib(n: uint32): uint32
	<fib+45 @06099d>   : 02                         call
	<fib+46 @06099e>   : 09 fc ff ff                inc.sp(-4)
	<fib+50 @0609a2>   : 51                         add.i32
	<fib+51 @0609a3>   : 13 03                      set.x32 sp(3)
	<fib+53 @0609a5>   : 03                         ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0609a8>
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609b0>
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609b8>
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609c0>
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609c8>
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609d0>
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609d8>
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609e0>
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609e8>
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609f0>
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@0609f8>
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a00>
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a08>
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a10>
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a18>
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a20>
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a28>
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a30>
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a38>
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.offset: <@0492b0>
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.offset: <@0493f0>
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, offs: <+12>, cast: variable(i32))
.field x: int64 (size: 8, offs: <+4>, cast: variable(i64))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.offset: <+4>
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
typeofRecord: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060a40>
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@060a48>
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a50>
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a58>
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: sizeof(typeofRecord)
.usages:
}
fileOfRecord: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@060a60>
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a68>
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060a70>
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@060a78>
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a80>
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a88>
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: sizeof(typeofBase)
.usages:
}
fileOfBase: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@060a90>
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060a98>
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060aa0>
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060aa8>
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ab0>
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: static variable(ref)
.base: `typename`
.size: 4
.offset: <@060ab8>
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ac0>
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ac8>
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@04a3f0>
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, offs: <@04a490>, cast: static const typename(val))
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.field memberInit: int32 (size: 4, offs: <+8>, cast: variable(i32))
.field constantInit: int32 (size: 4, offs: <+12>, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, offs: <+16>, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, offs: <+24>, cast: const variable(val))
.field global: int32 (size: 4, offs: <@060ad0>, cast: static variable(i32))
.field globalInit: int32 (size: 4, offs: <@060ad8>, cast: static variable(i32))
.field globalConstant: int32 (size: 4, offs: <@060ae0>, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, offs: <@060ae8>, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, offs: <@060af0>, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, offs: <@060af8>, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04a490>
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, offs: <+0>, cast: variable(i32))
.field constant: int32 (size: 4, offs: <+4>, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+0>
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+4>
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.offset: <+8>
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.offset: <+12>
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+16>
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <+24>
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ad0>
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060ad8>
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.offset: <@060ae0>
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@060ae8>
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	void(globalRec.constant := 4);
	void(globalRec.member := (0));
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@060af0>
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	void(globalRecInit.member := 4);
	void(globalRecInit.constant := 5);
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.offset: <@060af8>
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	void(globalConstantRec.member := 6);
	void(globalConstantRec.constant := 7);
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: static variable(val)
.base: `RecordMemberTest`
.size: 32
.offset: <@060b00>
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	void(recordMemberTest.member := 10);
	void(recordMemberTest.constant := 11);
	void(recordMemberTest.memberInit := 12);
	void(recordMemberTest.constantInit := 13);
	void(recordMemberTest.memberRec.member := 14);
	void(recordMemberTest.memberRec.constant := 15);
	void(recordMemberTest.constantRec.member := 16);
	void(recordMemberTest.constantRec.constant := 17);
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04b308>
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 39, offs: <@060b20>, cast: static function)
.field forwardMethod: function (size: 4, offs: <@060b48>, cast: static variable(ref))
.field abstractMethod: function (size: 4, offs: <+0>, cast: variable(ref))
.field delegateMethod: function (size: 4, offs: <+4>, cast: variable(ref))
.field virtualMethod: function (size: 39, offs: <@060b50>, cast: static function)
.field virtualMethod: function (size: 4, offs: <+8>, cast: const variable(ref))
.field forwardMethod: function (size: 39, offs: <@060b78>, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@060b20>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace(void("staticMethod", x));
}
.instructions: (39 bytes: <staticMethod @060b20> - <staticMethod+39 @060b47>)
	cmplStd/test/lang/init.method.ci:11: (38 bytes: <staticMethod @060b20> - <staticMethod+38 @060b46>): trace("staticMethod", x);
	<staticMethod @060b20>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @060b25>    : 1c 0b 00 00 00             load.c32 11
	<staticMethod+10 @060b2a>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @060b2f>   : 1c 80 00 00 00             load.c32 128
	<staticMethod+20 @060b34>   : 1f 3a af 04 00             load.ref <@04af3a> ;"staticMethod"
	<staticMethod+25 @060b39>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<staticMethod+30 @060b3e>   : 0a 28 00 00                load.sp(+40)
	<staticMethod+34 @060b42>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<staticMethod+38 @060b46>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.offset: <@060b48>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+0>
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.offset: <+4>
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 0, offs: <+0>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@060b50>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.value: {
	trace(void("virtualMethod", x));
}
.instructions: (39 bytes: <virtualMethod @060b50> - <virtualMethod+39 @060b77>)
	cmplStd/test/lang/init.method.ci:41: (38 bytes: <virtualMethod @060b50> - <virtualMethod+38 @060b76>): trace("virtualMethod", x);
	<virtualMethod @060b50>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @060b55>    : 1c 29 00 00 00             load.c32 41
	<virtualMethod+10 @060b5a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @060b5f>   : 1c 80 00 00 00             load.c32 128
	<virtualMethod+20 @060b64>   : 1f 26 b2 04 00             load.ref <@04b226> ;"virtualMethod"
	<virtualMethod+25 @060b69>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<virtualMethod+30 @060b6e>   : 0a 28 00 00                load.sp(+40)
	<virtualMethod+34 @060b72>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<virtualMethod+38 @060b76>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.offset: <+8>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@060b78>
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+4>, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace(void("forwardMethod", x));
}
.instructions: (39 bytes: <forwardMethod @060b78> - <forwardMethod+39 @060b9f>)
	cmplStd/test/lang/init.method.ci:48: (38 bytes: <forwardMethod @060b78> - <forwardMethod+38 @060b9e>): trace("forwardMethod", x);
	<forwardMethod @060b78>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+5 @060b7d>    : 1c 30 00 00 00             load.c32 48
	<forwardMethod+10 @060b82>   : 1c 0e 00 00 00             load.c32 14
	<forwardMethod+15 @060b87>   : 1c 80 00 00 00             load.c32 128
	<forwardMethod+20 @060b8c>   : 1f ad af 04 00             load.ref <@04afad> ;"forwardMethod"
	<forwardMethod+25 @060b91>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<forwardMethod+30 @060b96>   : 0a 28 00 00                load.sp(+40)
	<forwardMethod+34 @060b9a>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<forwardMethod+38 @060b9e>   : 03                         ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 39
.offset: <@060ba0>
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	trace(void("globalFunction", x));
}
.instructions: (39 bytes: <globalFunction @060ba0> - <globalFunction+39 @060bc7>)
	cmplStd/test/lang/init.method.ci:58: (38 bytes: <globalFunction @060ba0> - <globalFunction+38 @060bc6>): trace("globalFunction", x);
	<globalFunction @060ba0>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+5 @060ba5>    : 1c 3a 00 00 00             load.c32 58
	<globalFunction+10 @060baa>   : 1c 0e 00 00 00             load.c32 14
	<globalFunction+15 @060baf>   : 1c 80 00 00 00             load.c32 128
	<globalFunction+20 @060bb4>   : 1f 59 b2 04 00             load.ref <@04b259> ;"globalFunction"
	<globalFunction+25 @060bb9>   : 1f 00 04 00 00             load.ref <@000400> ;int32
	<globalFunction+30 @060bbe>   : 0a 1c 00 00                load.sp(+28)
	<globalFunction+34 @060bc2>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<globalFunction+38 @060bc6>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: static variable(val)
.base: `RecordMethodTest`
.size: 16
.offset: <@060bc8>
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	void(recordMethodTest.abstractMethod := globalFunction);
	void(recordMethodTest.delegateMethod := forwardMethod);
	void(recordMethodTest.virtualMethod := virtualMethod);
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 66
.offset: <@060bd8>
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if (bool((this) != null)) {
		RecordMethodTest.staticMethod(void(this, x));
	}
}
.instructions: (66 bytes: <staticMethod @060bd8> - <staticMethod+66 @060c1a>)
	cmplStd/test/lang/init.method.ci:85: (35 bytes: <staticMethod @060bd8> - <staticMethod+35 @060bfb>): debug("extension.staticMethod");
	<staticMethod @060bd8>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+5 @060bdd>    : 1c 55 00 00 00             load.c32 85
	<staticMethod+10 @060be2>   : 1c 0e 00 00 00             load.c32 14
	<staticMethod+15 @060be7>   : 19                         load.z32
	<staticMethod+16 @060be8>   : 1f d5 b2 04 00             load.ref <@04b2d5> ;"extension.staticMethod"
	<staticMethod+21 @060bed>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<staticMethod+26 @060bf2>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+31 @060bf7>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:86: (30 bytes: <staticMethod+35 @060bfb> - <staticMethod+65 @060c19>): if ((this) != null)
	<staticMethod+35 @060bfb>   : 0a 08 00 00                load.sp(+8)
	<staticMethod+39 @060bff>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<staticMethod+44 @060c04>   : 57                         ceq.i32
	<staticMethod+45 @060c05>   : 05 14 00 00                jnz <staticMethod+65 @060c19>
	cmplStd/test/lang/init.method.ci:87: (16 bytes: <staticMethod+49 @060c09> - <staticMethod+65 @060c19>): RecordMethodTest.staticMethod(this, x);
	<staticMethod+49 @060c09>   : 12 02                      dup.x128 sp(2)
	<staticMethod+51 @060c0b>   : 10 05                      dup.x32 sp(5)
	<staticMethod+53 @060c0d>   : 13 04                      set.x32 sp(4)
	<staticMethod+55 @060c0f>   : 1f 20 0b 06 00             load.ref <@060b20> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+60 @060c14>   : 02                         call
	<staticMethod+61 @060c15>   : 09 f0 ff ff                inc.sp(-16)
	<staticMethod+65 @060c19>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 63
.offset: <@060c20>
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, offs: <+0>, cast: variable(void))
.param this: RecordMethodTest (size: 16, offs: <+16>, cast: variable(val))
.param x: int32 (size: 4, offs: <+20>, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if (bool((this) != null)) {
		this.virtualMethod(void(this, x));
	}
}
.instructions: (63 bytes: <virtualMethod @060c20> - <virtualMethod+63 @060c5f>)
	cmplStd/test/lang/init.method.ci:91: (35 bytes: <virtualMethod @060c20> - <virtualMethod+35 @060c43>): debug("extension.virtualMethod");
	<virtualMethod @060c20>      : 1f 90 ae 04 00             load.ref <@04ae90> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+5 @060c25>    : 1c 5b 00 00 00             load.c32 91
	<virtualMethod+10 @060c2a>   : 1c 0e 00 00 00             load.c32 14
	<virtualMethod+15 @060c2f>   : 19                         load.z32
	<virtualMethod+16 @060c30>   : 1f ec b2 04 00             load.ref <@04b2ec> ;"extension.virtualMethod"
	<virtualMethod+21 @060c35>   : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<virtualMethod+26 @060c3a>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+31 @060c3f>   : 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:92: (27 bytes: <virtualMethod+35 @060c43> - <virtualMethod+62 @060c5e>): if ((this) != null)
	<virtualMethod+35 @060c43>   : 0a 08 00 00                load.sp(+8)
	<virtualMethod+39 @060c47>   : 1f 00 00 00 00             load.ref <@000000> ;null
	<virtualMethod+44 @060c4c>   : 57                         ceq.i32
	<virtualMethod+45 @060c4d>   : 05 11 00 00                jnz <virtualMethod+62 @060c5e>
	cmplStd/test/lang/init.method.ci:93: (13 bytes: <virtualMethod+49 @060c51> - <virtualMethod+62 @060c5e>): this.virtualMethod(this, x);
	<virtualMethod+49 @060c51>   : 12 02                      dup.x128 sp(2)
	<virtualMethod+51 @060c53>   : 10 05                      dup.x32 sp(5)
	<virtualMethod+53 @060c55>   : 13 04                      set.x32 sp(4)
	<virtualMethod+55 @060c57>   : 10 08                      dup.x32 sp(8)
	<virtualMethod+57 @060c59>   : 02                         call
	<virtualMethod+58 @060c5a>   : 09 f0 ff ff                inc.sp(-16)
	<virtualMethod+62 @060c5e>   : 03                         ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
arrFixedInit: int64[7] {
.kind: static variable(val)
.base: `int64[7]`
.size: 56
.offset: <@060c60>
.name: 'arrFixedInit'
.file: 'cmplStd/test/lang/init.array.ci:11'
.value: {
	void(arrFixedInit[0] := (42));
	void(arrFixedInit[1] := (43));
	void(arrFixedInit[2] := (44));
	void(arrFixedInit[3] := (45));
	void(arrFixedInit[4] := (46));
	void(arrFixedInit[5] := (47));
	void(arrFixedInit[6] := (48));
}
.usages:
	cmplStd/test/lang/init.array.ci:80: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:76: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:72: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:68: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:66: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:64: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:63: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:62: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:62: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:58: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:57: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:56: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:49: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:23: referenced as `arrFixedInit`
	cmplStd/test/lang/init.array.ci:22: referenced as `arrFixedInit`
}
arrArrayInitNull: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@060c98>
.name: 'arrArrayInitNull'
.file: 'cmplStd/test/lang/init.array.ci:18'
.value: null
.usages:
}
arrSliceInitNull: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@060ca0>
.name: 'arrSliceInitNull'
.file: 'cmplStd/test/lang/init.array.ci:19'
.value: null
.usages:
	cmplStd/test/lang/init.array.ci:61: referenced as `arrSliceInitNull`
	cmplStd/test/lang/init.array.ci:48: referenced as `arrSliceInitNull`
}
arrArrayInitFixed: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@060ca8>
.name: 'arrArrayInitFixed'
.file: 'cmplStd/test/lang/init.array.ci:22'
.value: arrFixedInit
.usages:
	cmplStd/test/lang/init.array.ci:77: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:73: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:69: referenced as `arrArrayInitFixed`
	cmplStd/test/lang/init.array.ci:30: referenced as `arrArrayInitFixed`
}
arrSliceInitFixed: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@060cb0>
.name: 'arrSliceInitFixed'
.file: 'cmplStd/test/lang/init.array.ci:23'
.value: arrFixedInit
.usages:
	cmplStd/test/lang/init.array.ci:82: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:78: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:74: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:70: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:63: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:57: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:27: referenced as `arrSliceInitFixed`
	cmplStd/test/lang/init.array.ci:26: referenced as `arrSliceInitFixed`
}
arrArrayInitSlice: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@060cb8>
.name: 'arrArrayInitSlice'
.file: 'cmplStd/test/lang/init.array.ci:26'
.value: arrSliceInitFixed
.usages:
}
arrSliceInitSlice: int64[] {
.kind: static variable(arr)
.base: `int64[]`
.size: 8
.offset: <@060cc0>
.name: 'arrSliceInitSlice'
.file: 'cmplStd/test/lang/init.array.ci:27'
.value: arrSliceInitFixed
.usages:
	cmplStd/test/lang/init.array.ci:84: referenced as `arrSliceInitSlice`
	cmplStd/test/lang/init.array.ci:64: referenced as `arrSliceInitSlice`
	cmplStd/test/lang/init.array.ci:58: referenced as `arrSliceInitSlice`
}
arrArrayInitPtr: int64[*] {
.kind: static variable(ref)
.base: `int64[*]`
.size: 4
.offset: <@060cc8>
.name: 'arrArrayInitPtr'
.file: 'cmplStd/test/lang/init.array.ci:30'
.value: arrArrayInitFixed
.usages:
}
strFixed: char[7] {
.kind: static variable(val)
.base: `char[7]`
.size: 7
.offset: <@060cd0>
.name: 'strFixed'
.file: 'cmplStd/test/lang/init.array.ci:34'
.value: {
	void(strFixed[0] := 's');
	void(strFixed[1] := 't');
	void(strFixed[2] := 'r');
	void(strFixed[3] := 'i');
	void(strFixed[4] := 'n');
	void(strFixed[5] := 'g');
	void(strFixed[6] := (0));
}
.usages:
	cmplStd/test/lang/init.array.ci:35: referenced as `strFixed`
}
strArray: char[*] {
.kind: static variable(ref)
.base: `char[*]`
.size: 4
.offset: <@060cd8>
.name: 'strArray'
.file: 'cmplStd/test/lang/init.array.ci:37'
.value: "string"
.usages:
	cmplStd/test/lang/init.array.ci:38: referenced as `strArray`
}
strSlice: char[] {
.kind: static variable(arr)
.base: `char[]`
.size: 8
.offset: <@060ce0>
.name: 'strSlice'
.file: 'cmplStd/test/lang/init.array.ci:40'
.value: "string"
.usages:
	cmplStd/test/lang/init.array.ci:41: referenced as `strSlice`
}
lenSlice(values: int64[]): int32: function {
.kind: static function
.base: `function`
.size: 4
.offset: <@060ce8>
.name: 'lenSlice'
.file: 'cmplStd/test/lang/init.array.ci:51'
.param .result: int32 (size: 4, offs: <+4>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+12>, cast: const variable(arr))
.value: {
	return uint32(.result := values.length);
}
.instructions: (4 bytes: <lenSlice @060ce8> - <lenSlice+4 @060cec>)
	cmplStd/test/lang/init.array.ci:51: (4 bytes: <lenSlice @060ce8> - <lenSlice+4 @060cec>): return .result := values.length;
	<lenSlice @060ce8>      : 16 03 02                   mov.x32 sp(3, 2)
	<lenSlice+3 @060ceb>    : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:64: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:63: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:62: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:61: referenced as `lenSlice`
	cmplStd/test/lang/init.array.ci:60: referenced as `lenSlice`
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@060cf0>
.name: 'nthFixed'
.file: 'cmplStd/test/lang/init.array.ci:52'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[7] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthFixed @060cf0> - <nthFixed+12 @060cfc>)
	cmplStd/test/lang/init.array.ci:52: (12 bytes: <nthFixed @060cf0> - <nthFixed+12 @060cfc>): return .result := values[idx];
	<nthFixed @060cf0>      : 10 01                      dup.x32 sp(1)
	<nthFixed+2 @060cf2>    : 10 03                      dup.x32 sp(3)
	<nthFixed+4 @060cf4>    : 0d 08 00 00                mad.u32 8
	<nthFixed+8 @060cf8>    : 29                         load.i64
	<nthFixed+9 @060cf9>    : 14 05                      set.x64 sp(5)
	<nthFixed+11 @060cfb>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:74: referenced as `nthFixed`
	cmplStd/test/lang/init.array.ci:73: referenced as `nthFixed`
	cmplStd/test/lang/init.array.ci:72: referenced as `nthFixed`
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@060d00>
.name: 'nthArray'
.file: 'cmplStd/test/lang/init.array.ci:53'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[*] (size: 4, offs: <+16>, cast: const variable(ref))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthArray @060d00> - <nthArray+12 @060d0c>)
	cmplStd/test/lang/init.array.ci:53: (12 bytes: <nthArray @060d00> - <nthArray+12 @060d0c>): return .result := values[idx];
	<nthArray @060d00>      : 10 01                      dup.x32 sp(1)
	<nthArray+2 @060d02>    : 10 03                      dup.x32 sp(3)
	<nthArray+4 @060d04>    : 0d 08 00 00                mad.u32 8
	<nthArray+8 @060d08>    : 29                         load.i64
	<nthArray+9 @060d09>    : 14 05                      set.x64 sp(5)
	<nthArray+11 @060d0b>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:78: referenced as `nthArray`
	cmplStd/test/lang/init.array.ci:77: referenced as `nthArray`
	cmplStd/test/lang/init.array.ci:76: referenced as `nthArray`
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static function
.base: `function`
.size: 12
.offset: <@060d10>
.name: 'nthSlice'
.file: 'cmplStd/test/lang/init.array.ci:54'
.param .result: int64 (size: 8, offs: <+8>, cast: variable(i64))
.param idx: int32 (size: 4, offs: <+12>, cast: variable(i32))
.param values: int64[] (size: 8, offs: <+20>, cast: const variable(arr))
.value: {
	return int64(.result := values[idx]);
}
.instructions: (12 bytes: <nthSlice @060d10> - <nthSlice+12 @060d1c>)
	cmplStd/test/lang/init.array.ci:54: (12 bytes: <nthSlice @060d10> - <nthSlice+12 @060d1c>): return .result := values[idx];
	<nthSlice @060d10>      : 10 01                      dup.x32 sp(1)
	<nthSlice+2 @060d12>    : 10 04                      dup.x32 sp(4)
	<nthSlice+4 @060d14>    : 0d 08 00 00                mad.u32 8
	<nthSlice+8 @060d18>    : 29                         load.i64
	<nthSlice+9 @060d19>    : 14 06                      set.x64 sp(6)
	<nthSlice+11 @060d1b>   : 03                         ret
.usages:
	cmplStd/test/lang/init.array.ci:82: referenced as `nthSlice`
	cmplStd/test/lang/init.array.ci:80: referenced as `nthSlice`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.offset: <@04ea30>
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, offs: <+0>, cast: variable(f32))
.field g: float32 (size: 4, offs: <+4>, cast: variable(f32))
.field b: float32 (size: 4, offs: <+8>, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+0>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+4>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.offset: <+8>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.offset: <@04ecb0>
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field g: uint8 (size: 1, offs: <+1>, cast: variable(u32))
.field r: uint8 (size: 1, offs: <+2>, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+1>
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+2>
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.offset: <@04ef30>
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field rgb: rgbU8 (size: 3, offs: <+0>, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.offset: <+0>
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.offset: <@04f110>
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, offs: <+4>, cast: variable(val))
.field .type: typename (size: 4, offs: <+0>, cast: const variable(ref))
.field create: function (size: 0, offs: <@006e08>, cast: static const inline)
.field as: function (size: 0, offs: <@0070c0>, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.offset: <+4>
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.offset: <+0>
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@006e08>
.name: 'create'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param type: typename (size: 4, offs: <+4>, cast: variable(ref))
.value: nfc(6)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.offset: <@0070c0>
.name: 'as'
.owner: object
.param .result: pointer (size: 4, offs: <+4>, cast: inline)
.param this: object (size: 4, offs: <+4>, cast: variable(ref))
.param type: typename (size: 4, offs: <+8>, cast: variable(ref))
.value: nfc(7)
.usages:
}
black: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@060d20>
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	void(black.r := (0));
	void(black.g := (0));
	void(black.b := (0));
}
.usages:
}
green: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@060d28>
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	void(green.r := (0));
	void(green.g := (255));
	void(green.b := (0));
}
.usages:
}
white: rgbU8 {
.kind: static variable(val)
.base: `rgbU8`
.size: 3
.offset: <@060d30>
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	void(white.r := (255));
	void(white.g := (255));
	void(white.b := (255));
}
.usages:
}
cyan: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@060d38>
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	void(cyan.col := (65535));
}
.usages:
}
blue: color {
.kind: static variable(val)
.base: `color`
.size: 4
.offset: <@060d40>
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	void(blue.rgb.r := (0));
	void(blue.rgb.g := (0));
	void(blue.rgb.b := (255));
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.offset: <@04f5f0>
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+0>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+0>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+0>, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+0>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+0>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+0>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.offset: <@04fa50>
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+1>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+9>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+10>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+14>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+15>, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+1>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+9>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+10>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+14>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+15>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.offset: <@04feb0>
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+2>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+10>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+12>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+18>, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+2>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+10>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+12>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+18>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.offset: <@050310>
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+4>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+12>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+16>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+20>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+22>, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+4>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+12>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+16>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+20>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+22>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@050770>
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.offset: <@050bd0>
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, offs: <+0>, cast: variable(u32))
.field a: uint64 (size: 8, offs: <+8>, cast: variable(u64))
.field _1: uint8 (size: 1, offs: <+16>, cast: variable(u32))
.field b: uint32 (size: 4, offs: <+20>, cast: variable(u32))
.field _2: uint8 (size: 1, offs: <+24>, cast: variable(u32))
.field c: uint16 (size: 2, offs: <+26>, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+0>
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.offset: <+8>
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+16>
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.offset: <+20>
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.offset: <+24>
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.offset: <+26>
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: static inline
.base: `typename`
.size: 0
.offset: <@000000>
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@060d48>
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d50>
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d58>
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: bool(!false)
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d60>
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: bool(boolA & boolB)
.usages:
}
boolIor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d68>
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: bool(boolA | boolB)
.usages:
}
boolXor: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d70>
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: bool(boolA ^ boolB)
.usages:
}
boolNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d78>
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: bool(!boolB)
.usages:
}
boolCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d80>
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: bool(boolA == boolB)
.usages:
}
boolCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d88>
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: bool(boolA != boolB)
.usages:
}
boolClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d90>
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: bool(boolA < boolB)
.usages:
}
boolCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060d98>
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: bool(boolA <= boolB)
.usages:
}
boolCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060da0>
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: bool(boolA > boolB)
.usages:
}
boolCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060da8>
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: bool(boolA >= boolB)
.usages:
}
chrA: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060db0>
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060db8>
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060dc0>
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: char(+chrB)
.usages:
}
chrNeg: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060dc8>
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: char(-chrB)
.usages:
}
chrCmt: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060dd0>
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: char(~chrB)
.usages:
}
chrAdd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060dd8>
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: char(chrA + chrB)
.usages:
}
chrSub: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060de0>
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: char(chrA - chrB)
.usages:
}
chrMul: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060de8>
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: char(chrA * chrB)
.usages:
}
chrDiv: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060df0>
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: char(chrA / chrB)
.usages:
}
chrMod: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060df8>
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: char(chrA % chrB)
.usages:
}
chrAnd: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060e00>
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: char(chrA & chrB)
.usages:
}
chrIor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060e08>
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: char(chrA | chrB)
.usages:
}
chrXor: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060e10>
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: char(chrA ^ chrB)
.usages:
}
chrShl: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060e18>
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: int32((chrA) << shift)
.usages:
}
chrShr: char {
.kind: static variable(i32)
.base: `char`
.size: 1
.offset: <@060e20>
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: int32((chrA) >> shift)
.usages:
}
chrNot: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e28>
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: bool(!(chrB))
.usages:
}
chrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e30>
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: bool(chrA == chrB)
.usages:
}
chrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e38>
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: bool(chrA != chrB)
.usages:
}
chrClt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e40>
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: bool(chrA < chrB)
.usages:
}
chrCle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e48>
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: bool(chrA <= chrB)
.usages:
}
chrCgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e50>
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: bool(chrA > chrB)
.usages:
}
chrCge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060e58>
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: bool(chrA >= chrB)
.usages:
}
i8A: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e60>
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e68>
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e70>
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: int8(+i8B)
.usages:
}
i8Neg: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e78>
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: int8(-i8B)
.usages:
}
i8Cmt: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e80>
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: int8(~i8B)
.usages:
}
i8Add: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e88>
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: int8(i8A + i8B)
.usages:
}
i8Sub: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e90>
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: int8(i8A - i8B)
.usages:
}
i8Mul: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060e98>
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: int8(i8A * i8B)
.usages:
}
i8Div: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060ea0>
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: int8(i8A / i8B)
.usages:
}
i8Mod: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060ea8>
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: int8(i8A % i8B)
.usages:
}
i8And: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060eb0>
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: int8(i8A & i8B)
.usages:
}
i8Ior: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060eb8>
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: int8(i8A | i8B)
.usages:
}
i8Xor: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060ec0>
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: int8(i8A ^ i8B)
.usages:
}
i8Shl: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060ec8>
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: int32((i8A) << shift)
.usages:
}
i8Shr: int8 {
.kind: static variable(i32)
.base: `int8`
.size: 1
.offset: <@060ed0>
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: int32((i8A) >> shift)
.usages:
}
i8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060ed8>
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: bool(!(i8B))
.usages:
}
i8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060ee0>
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: bool(i8A == i8B)
.usages:
}
i8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060ee8>
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: bool(i8A != i8B)
.usages:
}
i8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060ef0>
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: bool(i8A < i8B)
.usages:
}
i8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060ef8>
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: bool(i8A <= i8B)
.usages:
}
i8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060f00>
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: bool(i8A > i8B)
.usages:
}
i8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060f08>
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: bool(i8A >= i8B)
.usages:
}
u8A: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f10>
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f18>
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f20>
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: uint8(+u8B)
.usages:
}
u8Neg: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f28>
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: uint8(-u8B)
.usages:
}
u8Cmt: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f30>
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: uint8(~u8B)
.usages:
}
u8Add: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f38>
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: uint8(u8A + u8B)
.usages:
}
u8Sub: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f40>
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: uint8(u8A - u8B)
.usages:
}
u8Mul: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f48>
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: uint8(u8A * u8B)
.usages:
}
u8Div: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f50>
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: uint8(u8A / u8B)
.usages:
}
u8Mod: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f58>
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: uint8(u8A % u8B)
.usages:
}
u8And: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f60>
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: uint8(u8A & u8B)
.usages:
}
u8Ior: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f68>
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: uint8(u8A | u8B)
.usages:
}
u8Xor: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f70>
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: uint8(u8A ^ u8B)
.usages:
}
u8Shl: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f78>
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: int32((u8A) << shift)
.usages:
}
u8Shr: uint8 {
.kind: static variable(u32)
.base: `uint8`
.size: 1
.offset: <@060f80>
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: int32((u8A) >> shift)
.usages:
}
u8Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060f88>
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: bool(!(u8B))
.usages:
}
u8Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060f90>
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: bool(u8A == u8B)
.usages:
}
u8Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060f98>
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: bool(u8A != u8B)
.usages:
}
u8Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060fa0>
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: bool(u8A < u8B)
.usages:
}
u8Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060fa8>
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: bool(u8A <= u8B)
.usages:
}
u8Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060fb0>
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: bool(u8A > u8B)
.usages:
}
u8Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@060fb8>
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: bool(u8A >= u8B)
.usages:
}
i16A: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fc0>
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fc8>
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fd0>
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: int16(+i16B)
.usages:
}
i16Neg: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fd8>
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: int16(-i16B)
.usages:
}
i16Cmt: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fe0>
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: int16(~i16B)
.usages:
}
i16Add: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060fe8>
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: int16(i16A + i16B)
.usages:
}
i16Sub: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060ff0>
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: int16(i16A - i16B)
.usages:
}
i16Mul: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@060ff8>
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: int16(i16A * i16B)
.usages:
}
i16Div: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061000>
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: int16(i16A / i16B)
.usages:
}
i16Mod: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061008>
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: int16(i16A % i16B)
.usages:
}
i16And: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061010>
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: int16(i16A & i16B)
.usages:
}
i16Ior: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061018>
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: int16(i16A | i16B)
.usages:
}
i16Xor: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061020>
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: int16(i16A ^ i16B)
.usages:
}
i16Shl: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061028>
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: int32((i16A) << shift)
.usages:
}
i16Shr: int16 {
.kind: static variable(i32)
.base: `int16`
.size: 2
.offset: <@061030>
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: int32((i16A) >> shift)
.usages:
}
i16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061038>
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: bool(!(i16B))
.usages:
}
i16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061040>
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: bool(i16A == i16B)
.usages:
}
i16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061048>
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: bool(i16A != i16B)
.usages:
}
i16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061050>
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: bool(i16A < i16B)
.usages:
}
i16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061058>
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: bool(i16A <= i16B)
.usages:
}
i16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061060>
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: bool(i16A > i16B)
.usages:
}
i16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061068>
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: bool(i16A >= i16B)
.usages:
}
u16A: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061070>
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061078>
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061080>
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: uint16(+u16B)
.usages:
}
u16Neg: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061088>
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: uint16(-u16B)
.usages:
}
u16Cmt: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061090>
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: uint16(~u16B)
.usages:
}
u16Add: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@061098>
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: uint16(u16A + u16B)
.usages:
}
u16Sub: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610a0>
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: uint16(u16A - u16B)
.usages:
}
u16Mul: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610a8>
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: uint16(u16A * u16B)
.usages:
}
u16Div: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610b0>
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: uint16(u16A / u16B)
.usages:
}
u16Mod: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610b8>
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: uint16(u16A % u16B)
.usages:
}
u16And: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610c0>
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: uint16(u16A & u16B)
.usages:
}
u16Ior: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610c8>
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: uint16(u16A | u16B)
.usages:
}
u16Xor: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610d0>
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: uint16(u16A ^ u16B)
.usages:
}
u16Shl: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610d8>
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: int32((u16A) << shift)
.usages:
}
u16Shr: uint16 {
.kind: static variable(u32)
.base: `uint16`
.size: 2
.offset: <@0610e0>
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: int32((u16A) >> shift)
.usages:
}
u16Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0610e8>
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: bool(!(u16B))
.usages:
}
u16Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0610f0>
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: bool(u16A == u16B)
.usages:
}
u16Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0610f8>
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: bool(u16A != u16B)
.usages:
}
u16Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061100>
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: bool(u16A < u16B)
.usages:
}
u16Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061108>
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: bool(u16A <= u16B)
.usages:
}
u16Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061110>
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: bool(u16A > u16B)
.usages:
}
u16Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061118>
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: bool(u16A >= u16B)
.usages:
}
i32A: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061120>
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061128>
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061130>
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: int32(+i32B)
.usages:
}
i32Neg: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061138>
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: int32(-i32B)
.usages:
}
i32Cmt: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061140>
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: int32(~i32B)
.usages:
}
i32Add: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061148>
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: int32(i32A + i32B)
.usages:
}
i32Sub: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061150>
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: int32(i32A - i32B)
.usages:
}
i32Mul: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061158>
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: int32(i32A * i32B)
.usages:
}
i32Div: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061160>
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: int32(i32A / i32B)
.usages:
}
i32Mod: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061168>
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: int32(i32A % i32B)
.usages:
}
i32And: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061170>
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: int32(i32A & i32B)
.usages:
}
i32Ior: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061178>
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: int32(i32A | i32B)
.usages:
}
i32Xor: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061180>
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: int32(i32A ^ i32B)
.usages:
}
i32Shl: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061188>
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: int32(i32A << shift)
.usages:
}
i32Shr: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061190>
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: int32(i32A >> shift)
.usages:
}
i32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061198>
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: bool(!(i32B))
.usages:
}
i32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611a0>
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: bool(i32A == i32B)
.usages:
}
i32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611a8>
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: bool(i32A != i32B)
.usages:
}
i32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611b0>
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: bool(i32A < i32B)
.usages:
}
i32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611b8>
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: bool(i32A <= i32B)
.usages:
}
i32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611c0>
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: bool(i32A > i32B)
.usages:
}
i32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0611c8>
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: bool(i32A >= i32B)
.usages:
}
u32A: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611d0>
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611d8>
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611e0>
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: uint32(+u32B)
.usages:
}
u32Neg: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611e8>
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: uint32(-u32B)
.usages:
}
u32Cmt: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611f0>
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: uint32(~u32B)
.usages:
}
u32Add: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@0611f8>
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: uint32(u32A + u32B)
.usages:
}
u32Sub: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061200>
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: uint32(u32A - u32B)
.usages:
}
u32Mul: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061208>
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: uint32(u32A * u32B)
.usages:
}
u32Div: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061210>
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: uint32(u32A / u32B)
.usages:
}
u32Mod: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061218>
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: uint32(u32A % u32B)
.usages:
}
u32And: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061220>
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: uint32(u32A & u32B)
.usages:
}
u32Ior: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061228>
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: uint32(u32A | u32B)
.usages:
}
u32Xor: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061230>
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: uint32(u32A ^ u32B)
.usages:
}
u32Shl: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061238>
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: uint32(u32A << shift)
.usages:
}
u32Shr: uint32 {
.kind: static variable(u32)
.base: `uint32`
.size: 4
.offset: <@061240>
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: uint32(u32A >> shift)
.usages:
}
u32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061248>
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: bool(!(u32B))
.usages:
}
u32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061250>
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: bool(u32A == u32B)
.usages:
}
u32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061258>
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: bool(u32A != u32B)
.usages:
}
u32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061260>
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: bool(u32A < u32B)
.usages:
}
u32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061268>
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: bool(u32A <= u32B)
.usages:
}
u32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061270>
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: bool(u32A > u32B)
.usages:
}
u32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061278>
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: bool(u32A >= u32B)
.usages:
}
i64A: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061280>
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061288>
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061290>
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: int64(+i64B)
.usages:
}
i64Neg: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@061298>
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: int64(-i64B)
.usages:
}
i64Cmt: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612a0>
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: int64(~i64B)
.usages:
}
i64Add: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612a8>
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: int64(i64A + i64B)
.usages:
}
i64Sub: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612b0>
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: int64(i64A - i64B)
.usages:
}
i64Mul: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612b8>
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: int64(i64A * i64B)
.usages:
}
i64Div: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612c0>
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: int64(i64A / i64B)
.usages:
}
i64Mod: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612c8>
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: int64(i64A % i64B)
.usages:
}
i64And: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612d0>
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: int64(i64A & i64B)
.usages:
}
i64Ior: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612d8>
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: int64(i64A | i64B)
.usages:
}
i64Xor: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612e0>
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: int64(i64A ^ i64B)
.usages:
}
i64Shl: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612e8>
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: int64(i64A << shift)
.usages:
}
i64Shr: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.offset: <@0612f0>
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: int64(i64A >> shift)
.usages:
}
i64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0612f8>
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: bool(!(i64B))
.usages:
}
i64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061300>
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: bool(i64A == i64B)
.usages:
}
i64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061308>
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: bool(i64A != i64B)
.usages:
}
i64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061310>
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: bool(i64A < i64B)
.usages:
}
i64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061318>
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: bool(i64A <= i64B)
.usages:
}
i64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061320>
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: bool(i64A > i64B)
.usages:
}
i64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061328>
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: bool(i64A >= i64B)
.usages:
}
u64A: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061330>
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061338>
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061340>
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: uint64(+u64B)
.usages:
}
u64Neg: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061348>
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: uint64(-u64B)
.usages:
}
u64Cmt: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061350>
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: uint64(~u64B)
.usages:
}
u64Add: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061358>
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: uint64(u64A + u64B)
.usages:
}
u64Sub: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061360>
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: uint64(u64A - u64B)
.usages:
}
u64Mul: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061368>
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: uint64(u64A * u64B)
.usages:
}
u64Div: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061370>
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: uint64(u64A / u64B)
.usages:
}
u64Mod: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061378>
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: uint64(u64A % u64B)
.usages:
}
u64And: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061380>
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: uint64(u64A & u64B)
.usages:
}
u64Ior: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061388>
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: uint64(u64A | u64B)
.usages:
}
u64Xor: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061390>
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: uint64(u64A ^ u64B)
.usages:
}
u64Shl: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@061398>
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: uint64(u64A << shift)
.usages:
}
u64Shr: uint64 {
.kind: static variable(u64)
.base: `uint64`
.size: 8
.offset: <@0613a0>
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: uint64(u64A >> shift)
.usages:
}
u64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613a8>
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: bool(!(u64B))
.usages:
}
u64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613b0>
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: bool(u64A == u64B)
.usages:
}
u64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613b8>
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: bool(u64A != u64B)
.usages:
}
u64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613c0>
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: bool(u64A < u64B)
.usages:
}
u64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613c8>
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: bool(u64A <= u64B)
.usages:
}
u64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613d0>
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: bool(u64A > u64B)
.usages:
}
u64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0613d8>
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: bool(u64A >= u64B)
.usages:
}
f32A: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0613e0>
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0613e8>
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0613f0>
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: float32(+f32B)
.usages:
}
f32Neg: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@0613f8>
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: float32(-f32B)
.usages:
}
f32Add: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061400>
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: float32(f32A + f32B)
.usages:
}
f32Sub: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061408>
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: float32(f32A - f32B)
.usages:
}
f32Mul: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061410>
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: float32(f32A * f32B)
.usages:
}
f32Div: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061418>
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: float32(f32A / f32B)
.usages:
}
f32Mod: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061420>
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: float32(f32A % f32B)
.usages:
}
f32Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061428>
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: bool(!(f32B))
.usages:
}
f32Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061430>
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: bool(f32A == f32B)
.usages:
}
f32Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061438>
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: bool(f32A != f32B)
.usages:
}
f32Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061440>
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: bool(f32A < f32B)
.usages:
}
f32Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061448>
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: bool(f32A <= f32B)
.usages:
}
f32Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061450>
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: bool(f32A > f32B)
.usages:
}
f32Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@061458>
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: bool(f32A >= f32B)
.usages:
}
f64A: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061460>
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061468>
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061470>
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: float64(+f64B)
.usages:
}
f64Neg: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061478>
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: float64(-f64B)
.usages:
}
f64Add: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061480>
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: float64(f64A + f64B)
.usages:
}
f64Sub: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061488>
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: float64(f64A - f64B)
.usages:
}
f64Mul: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061490>
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: float64(f64A * f64B)
.usages:
}
f64Div: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061498>
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: float64(f64A / f64B)
.usages:
}
f64Mod: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0614a0>
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: float64(f64A % f64B)
.usages:
}
f64Not: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614a8>
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: bool(!(f64B))
.usages:
}
f64Ceq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614b0>
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: bool(f64A == f64B)
.usages:
}
f64Cne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614b8>
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: bool(f64A != f64B)
.usages:
}
f64Clt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614c0>
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: bool(f64A < f64B)
.usages:
}
f64Cle: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614c8>
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: bool(f64A <= f64B)
.usages:
}
f64Cgt: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614d0>
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: bool(f64A > f64B)
.usages:
}
f64Cge: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614d8>
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: bool(f64A >= f64B)
.usages:
}
ptrA: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0614e0>
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: static variable(ref)
.base: `pointer`
.size: 4
.offset: <@0614e8>
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614f0>
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: bool(ptrA == ptrB)
.usages:
}
ptrCne: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0614f8>
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: bool(ptrA != ptrB)
.usages:
}
t: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061500>
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.offset: <@061508>
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
testMathFloor_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061510>
.name: 'testMathFloor_1'
.file: 'cmplStd/test/std/test.math.ci:3'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061518>
.name: 'testMathFloor_2'
.file: 'cmplStd/test/std/test.math.ci:4'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061520>
.name: 'testMathFloor_3'
.file: 'cmplStd/test/std/test.math.ci:5'
.value: Math.floor(3.600000)
.usages:
}
testMathFloor_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061528>
.name: 'testMathFloor_4'
.file: 'cmplStd/test/std/test.math.ci:6'
.value: Math.floor(float64(-3.200000))
.usages:
}
testMathFloor_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061530>
.name: 'testMathFloor_5'
.file: 'cmplStd/test/std/test.math.ci:7'
.value: Math.floor(float64(-3.500000))
.usages:
}
testMathFloor_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061538>
.name: 'testMathFloor_6'
.file: 'cmplStd/test/std/test.math.ci:8'
.value: Math.floor(float64(-3.600000))
.usages:
}
testMathSign_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061540>
.name: 'testMathSign_1F'
.file: 'cmplStd/test/std/test.math.ci:10'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061548>
.name: 'testMathSign_2F'
.file: 'cmplStd/test/std/test.math.ci:11'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061550>
.name: 'testMathSign_3F'
.file: 'cmplStd/test/std/test.math.ci:12'
.value: Math.sign(float64(-0.900000))
.usages:
}
testMathSign_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061558>
.name: 'testMathSign_1f'
.file: 'cmplStd/test/std/test.math.ci:13'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061560>
.name: 'testMathSign_2f'
.file: 'cmplStd/test/std/test.math.ci:14'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061568>
.name: 'testMathSign_3f'
.file: 'cmplStd/test/std/test.math.ci:15'
.value: Math.sign(float32(-0.900000))
.usages:
}
testMathAbs_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061570>
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/std/test.math.ci:17'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061578>
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/std/test.math.ci:18'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061580>
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/std/test.math.ci:19'
.value: Math.abs(float64(-0.900000))
.usages:
}
testMathAbs_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061588>
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/std/test.math.ci:20'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061590>
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/std/test.math.ci:21'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061598>
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/std/test.math.ci:22'
.value: Math.abs(float32(-0.900000))
.usages:
}
testMathMin_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615a0>
.name: 'testMathMin_1f'
.file: 'cmplStd/test/std/test.math.ci:24'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615a8>
.name: 'testMathMax_2f'
.file: 'cmplStd/test/std/test.math.ci:25'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathMin_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615b0>
.name: 'testMathMin_1F'
.file: 'cmplStd/test/std/test.math.ci:26'
.value: Math.min(void(1.000000, 2.000000))
.usages:
}
testMathMax_2F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615b8>
.name: 'testMathMax_2F'
.file: 'cmplStd/test/std/test.math.ci:27'
.value: Math.max(void(1.000000, 2.000000))
.usages:
}
testMathClamp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615c0>
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/std/test.math.ci:29'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathClamp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615c8>
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/std/test.math.ci:30'
.value: Math.clamp(void(void(10.000000, 0.000000), 1.000000))
.usages:
}
testMathLerp_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615d0>
.name: 'testMathLerp_1f'
.file: 'cmplStd/test/std/test.math.ci:32'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathLerp_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615d8>
.name: 'testMathLerp_1F'
.file: 'cmplStd/test/std/test.math.ci:33'
.value: Math.lerp(void(void(0.500000, 0.000000), 2.000000))
.usages:
}
testMathSmooth_1f: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615e0>
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/std/test.math.ci:35'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathSmooth_1F: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615e8>
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/std/test.math.ci:36'
.value: Math.smooth(void(void(1.000000, 0.000000), 1.000000))
.usages:
}
testMathMin_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615f0>
.name: 'testMathMin_nan'
.file: 'cmplStd/test/std/test.math.ci:38'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0615f8>
.name: 'testMathMin_1'
.file: 'cmplStd/test/std/test.math.ci:39'
.value: Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathMax_nan: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061600>
.name: 'testMathMax_nan'
.file: 'cmplStd/test/std/test.math.ci:40'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061608>
.name: 'testMathMax_9'
.file: 'cmplStd/test/std/test.math.ci:41'
.value: Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6))
.usages:
}
testMathSum_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061610>
.name: 'testMathSum_0'
.file: 'cmplStd/test/std/test.math.ci:43'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061618>
.name: 'testMathSum_1'
.file: 'cmplStd/test/std/test.math.ci:44'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061620>
.name: 'testMathSum_3'
.file: 'cmplStd/test/std/test.math.ci:45'
.value: Math.sum(void(1, 2))
.usages:
}
testMathSum_55: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061628>
.name: 'testMathSum_55'
.file: 'cmplStd/test/std/test.math.ci:46'
.value: Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10))
.usages:
}
testMathEval_x: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061630>
.name: 'testMathEval_x'
.file: 'cmplStd/test/std/test.math.ci:48'
.value: 10
.usages:
	cmplStd/test/std/test.math.ci:55: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:54: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:53: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:52: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:51: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:50: referenced as `testMathEval_x`
	cmplStd/test/std/test.math.ci:49: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061638>
.name: 'testMathEval_0'
.file: 'cmplStd/test/std/test.math.ci:49'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061640>
.name: 'testMathEval_1'
.file: 'cmplStd/test/std/test.math.ci:50'
.value: Math.eval(void(testMathEval_x, 1.000000))
.usages:
}
testMathEval_2: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061648>
.name: 'testMathEval_2'
.file: 'cmplStd/test/std/test.math.ci:51'
.value: Math.eval(void(void(testMathEval_x, 1.000000), 1.000000))
.usages:
}
testMathEval_3: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061650>
.name: 'testMathEval_3'
.file: 'cmplStd/test/std/test.math.ci:52'
.value: Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_4: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061658>
.name: 'testMathEval_4'
.file: 'cmplStd/test/std/test.math.ci:53'
.value: Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_5: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061660>
.name: 'testMathEval_5'
.file: 'cmplStd/test/std/test.math.ci:54'
.value: Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathEval_6: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061668>
.name: 'testMathEval_6'
.file: 'cmplStd/test/std/test.math.ci:55'
.value: Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000))
.usages:
}
testMathSin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061670>
.name: 'testMathSin_f64'
.file: 'cmplStd/test/std/test.math.ci:57'
.value: Math.sin(float64(Math.pi / (2)))
.usages:
}
testMathCos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061678>
.name: 'testMathCos_f64'
.file: 'cmplStd/test/std/test.math.ci:58'
.value: Math.cos(float64(Math.pi / (2)))
.usages:
}
testMathTan_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061680>
.name: 'testMathTan_f64'
.file: 'cmplStd/test/std/test.math.ci:59'
.value: Math.tan(float64(Math.pi / (4)))
.usages:
}
testMathSinh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061688>
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/std/test.math.ci:60'
.value: Math.sinh(float64(Math.pi / (2)))
.usages:
}
testMathCosh_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061690>
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/std/test.math.ci:61'
.value: Math.cosh(float64(Math.pi / (2)))
.usages:
}
testMathAsin_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061698>
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/std/test.math.ci:63'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616a0>
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/std/test.math.ci:64'
.value: Math.acos(0.200000)
.usages:
}
testMathCmp_f32: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0616a8>
.name: 'testMathCmp_f32'
.file: 'cmplStd/test/std/test.math.ci:67'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathCmp_f64: bool {
.kind: static variable(bool)
.base: `bool`
.size: 1
.offset: <@0616b0>
.name: 'testMathCmp_f64'
.file: 'cmplStd/test/std/test.math.ci:68'
.value: bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616b8>
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/std/test.math.ci:70'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616c0>
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/std/test.math.ci:71'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616c8>
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/std/test.math.ci:72'
.value: Math.absMod(void(float64(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616d0>
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/std/test.math.ci:74'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616d8>
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/std/test.math.ci:75'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616e0>
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/std/test.math.ci:76'
.value: Math.absMod(void(float64(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616e8>
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/std/test.math.ci:77'
.value: Math.absMod(void(float64(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616f0>
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/std/test.math.ci:79'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@0616f8>
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/std/test.math.ci:80'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061700>
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/std/test.math.ci:81'
.value: Math.absMod(void(float64(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: static variable(f64)
.base: `float64`
.size: 8
.offset: <@061708>
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/std/test.math.ci:82'
.value: Math.absMod(void(float64(-12.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061710>
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/std/test.math.ci:84'
.value: Math.absMod(void(10.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061718>
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/std/test.math.ci:85'
.value: Math.absMod(void(0.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061720>
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/std/test.math.ci:86'
.value: Math.absMod(void(float32(-10.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061728>
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/std/test.math.ci:88'
.value: Math.absMod(void(19.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061730>
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/std/test.math.ci:89'
.value: Math.absMod(void(9.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061738>
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/std/test.math.ci:90'
.value: Math.absMod(void(float32(-1.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061740>
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/std/test.math.ci:91'
.value: Math.absMod(void(float32(-11.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061748>
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/std/test.math.ci:93'
.value: Math.absMod(void(18.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061750>
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/std/test.math.ci:94'
.value: Math.absMod(void(8.000000, 10.000000))
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061758>
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/std/test.math.ci:95'
.value: Math.absMod(void(float32(-2.000000), 10.000000))
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: static variable(f32)
.base: `float32`
.size: 4
.offset: <@061760>
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/std/test.math.ci:96'
.value: Math.absMod(void(float32(-12.000000), 10.000000))
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 14720
.offset: <@061764>
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, offs: <@000008>, cast: static const typename(ref))
.field void: typename (size: 0, offs: <@0000b8>, cast: static const typename(void))
.field bool: typename (size: 1, offs: <@000160>, cast: static const typename(bool))
.field char: typename (size: 1, offs: <@000208>, cast: static const typename(i32))
.field int8: typename (size: 1, offs: <@0002b0>, cast: static const typename(i32))
.field int16: typename (size: 2, offs: <@000358>, cast: static const typename(i32))
.field int32: typename (size: 4, offs: <@000400>, cast: static const typename(i32))
.field int64: typename (size: 8, offs: <@0004a8>, cast: static const typename(i64))
.field uint8: typename (size: 1, offs: <@000550>, cast: static const typename(u32))
.field uint16: typename (size: 2, offs: <@0005f8>, cast: static const typename(u32))
.field uint32: typename (size: 4, offs: <@0006a0>, cast: static const typename(u32))
.field uint64: typename (size: 8, offs: <@000748>, cast: static const typename(u64))
.field float32: typename (size: 4, offs: <@0007f0>, cast: static const typename(f32))
.field float64: typename (size: 8, offs: <@000898>, cast: static const typename(f64))
.field pointer: typename (size: 4, offs: <@000940>, cast: static const typename(ref))
.field variant: typename (size: 8, offs: <@0009e8>, cast: static const typename(var))
.field function: typename (size: 4, offs: <@000a90>, cast: static const typename(ref))
.field object: typename (size: 4, offs: <@000b40>, cast: static const typename(ref))
.field null: pointer (size: 0, offs: <@000000>, cast: static const inline)
.field int: typename (size: 0, offs: <@000000>, cast: static const inline)
.field .cstr: char (size: 4, offs: <@000de0>, cast: static const typename(arr))
.field emit: function (size: 0, offs: <@000e88>, cast: static const typename(void))
.field halt: function (size: 0, offs: <@005ed8>, cast: static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field RAND_MAX: int64 (size: 0, offs: <@000000>, cast: static const i64)
.field raise: function (size: 0, offs: <@0078e0>, cast: static const inline)
.field tryExec: function (size: 0, offs: <@008230>, cast: static const inline)
.field System: typename (size: 0, offs: <@008f38>, cast: static const typename(void))
.field true: bool (size: 0, offs: <@000000>, cast: static const val)
.field false: bool (size: 0, offs: <@000000>, cast: static const val)
.field byte: typename (size: 0, offs: <@000000>, cast: static inline)
.field float: typename (size: 0, offs: <@000000>, cast: static inline)
.field double: typename (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field signed: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field unsigned: function (size: 0, offs: <@000000>, cast: static inline)
.field sizeof: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field verbose: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field debug: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field trace: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field info: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field warn: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field error: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field abort: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field assert: function (size: 0, offs: <@000000>, cast: static inline)
.field NotEquals: typename (size: 24, offs: <@012348>, cast: static const typename(val))
.field assertEq: function (size: 103, offs: <@05ed78>, cast: static function)
.field assertEq: function (size: 0, offs: <@000000>, cast: static inline)
.field Math: typename (size: 0, offs: <@0135e0>, cast: static const typename(void))
.field Complex: typename (size: 16, offs: <@01cda0>, cast: static const typename(val))
.field Complex: function (size: 7, offs: <@05f5b8>, cast: static function)
.field Complex: function (size: 7, offs: <@05f5c0>, cast: static function)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 123, offs: <@05f5c8>, cast: static function)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field abs: function (size: 0, offs: <@000000>, cast: static inline)
.field arg: function (size: 0, offs: <@000000>, cast: static inline)
.field inv: function (size: 31, offs: <@05f648>, cast: static function)
.field conj: function (size: 0, offs: <@000000>, cast: static inline)
.field exp: function (size: 0, offs: <@000000>, cast: static inline)
.field log: function (size: 0, offs: <@000000>, cast: static inline)
.field pow: function (size: 100, offs: <@05f668>, cast: static function)
.field pow: function (size: 0, offs: <@000000>, cast: static inline)
.field sin: function (size: 0, offs: <@000000>, cast: static inline)
.field cos: function (size: 0, offs: <@000000>, cast: static inline)
.field tan: function (size: 0, offs: <@000000>, cast: static inline)
.field cot: function (size: 0, offs: <@000000>, cast: static inline)
.field sinh: function (size: 0, offs: <@000000>, cast: static inline)
.field cosh: function (size: 0, offs: <@000000>, cast: static inline)
.field tanh: function (size: 0, offs: <@000000>, cast: static inline)
.field coth: function (size: 0, offs: <@000000>, cast: static inline)
.field sec: function (size: 0, offs: <@000000>, cast: static inline)
.field csc: function (size: 0, offs: <@000000>, cast: static inline)
.field sech: function (size: 0, offs: <@000000>, cast: static inline)
.field csch: function (size: 0, offs: <@000000>, cast: static inline)
.field toCartesian: function (size: 0, offs: <@000000>, cast: static inline)
.field toPolar: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: typename (size: 16, offs: <@0228e8>, cast: static const typename(val))
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field vec4f: function (size: 0, offs: <@000000>, cast: static inline)
.field neg: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field clamp: function (size: 0, offs: <@000000>, cast: static inline)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field cross: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 0, offs: <@000000>, cast: static inline)
.field normalize: function (size: 0, offs: <@000000>, cast: static inline)
.field eval: function (size: 0, offs: <@000000>, cast: static inline)
.field mat4f: typename (size: 64, offs: <@027d80>, cast: static const typename(val))
.field mat4f: function (size: 49, offs: <@05f6d0>, cast: static function)
.field mat4f: function (size: 21, offs: <@05f708>, cast: static function)
.field dp3: function (size: 0, offs: <@000000>, cast: static inline)
.field dph: function (size: 0, offs: <@000000>, cast: static inline)
.field dp4: function (size: 0, offs: <@000000>, cast: static inline)
.field transpose: function (size: 49, offs: <@05f720>, cast: static function)
.field mul: function (size: 245, offs: <@05f758>, cast: static function)
.field rotation: function (size: 454, offs: <@05f850>, cast: static function)
.field rotation: function (size: 0, offs: <@000000>, cast: static inline)
.field translation: function (size: 88, offs: <@05fa18>, cast: static function)
.field scale: function (size: 217, offs: <@05fa70>, cast: static function)
.field vec2d: typename (size: 16, offs: <@02d260>, cast: static const typename(val))
.field vec2d: function (size: 7, offs: <@05fb50>, cast: static function)
.field add: function (size: 0, offs: <@000000>, cast: static inline)
.field sub: function (size: 0, offs: <@000000>, cast: static inline)
.field mul: function (size: 0, offs: <@000000>, cast: static inline)
.field div: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field ceq: function (size: 0, offs: <@000000>, cast: static inline)
.field dot: function (size: 0, offs: <@000000>, cast: static inline)
.field length: function (size: 38, offs: <@05fb58>, cast: static function)
.field indexOf: function (size: 50, offs: <@05fb80>, cast: static function)
.field lastIndexOf: function (size: 50, offs: <@05fbb8>, cast: static function)
.field startsWith: function (size: 73, offs: <@05fbf0>, cast: static function)
.field endsWith: function (size: 126, offs: <@05fc40>, cast: static function)
.field compare: function (size: 63, offs: <@05fcc0>, cast: static function)
.field ignCaseCmp: function (size: 36, offs: <@05fd48>, cast: static function)
.field caseCmp: function (size: 14, offs: <@05fd70>, cast: static function)
.field startsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field endsWith: function (size: 0, offs: <@000000>, cast: static inline)
.field compare: function (size: 0, offs: <@000000>, cast: static inline)
.field equals: function (size: 0, offs: <@000000>, cast: static inline)
.field contains: function (size: 0, offs: <@000000>, cast: static inline)
.field FormatFlags: typename (size: 16, offs: <@032d60>, cast: static const typename(val))
.field append: function (size: 84, offs: <@05fd80>, cast: static function)
.field append: function (size: 707, offs: <@05fde8>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 227, offs: <@0600b0>, cast: static function)
.field append: function (size: 0, offs: <@000000>, cast: static inline)
.field append: function (size: 63, offs: <@0601a8>, cast: static function)
.field integer: typename (size: 0, offs: <@000000>, cast: static inline)
.field emitldz32: int32 (size: 4, offs: <@0601e8>, cast: static variable(i32))
.field emitldz64: int64 (size: 8, offs: <@0601f0>, cast: static variable(i64))
.field emitA: int32 (size: 4, offs: <@0601f8>, cast: static variable(i32))
.field emitB: int32 (size: 4, offs: <@060200>, cast: static variable(i32))
.field emitAddI32: int32 (size: 4, offs: <@060208>, cast: static variable(i32))
.field emitDivI32: int32 (size: 4, offs: <@060210>, cast: static variable(i32))
.field emitNfcF32: float32 (size: 4, offs: <@060218>, cast: static variable(f32))
.field floatAsInt32: function (size: 0, offs: <@000000>, cast: static inline)
.field floatAsInt64: function (size: 0, offs: <@000000>, cast: static inline)
.field emitFloatAsInt1: int32 (size: 4, offs: <@060220>, cast: static variable(i32))
.field emitFloatAsInt2: int64 (size: 8, offs: <@060228>, cast: static variable(i64))
.field emitFloatAsInt3: int32 (size: 4, offs: <@060230>, cast: static variable(i32))
.field emitFloatAsInt4: int64 (size: 8, offs: <@060238>, cast: static variable(i64))
.field emitSlice: char[] (size: 8, offs: <@060240>, cast: static variable(arr))
.field zero: function (size: 0, offs: <@000000>, cast: static inline)
.field last: function (size: 0, offs: <@000000>, cast: static inline)
.field sum: function (size: 0, offs: <@000000>, cast: static inline)
.field any: function (size: 0, offs: <@000000>, cast: static inline)
.field min: function (size: 0, offs: <@000000>, cast: static inline)
.field max: function (size: 0, offs: <@000000>, cast: static inline)
.field i3: int32 (size: 4, offs: <@060248>, cast: static variable(i32))
.field i6: int32 (size: 4, offs: <@060250>, cast: static variable(i32))
.field i2: int32 (size: 4, offs: <@060258>, cast: static variable(i32))
.field i8: int32 (size: 4, offs: <@060260>, cast: static variable(i32))
.field zeroVal: int32 (size: 4, offs: <@060268>, cast: static variable(i32))
.field zeroVar: int32 (size: 4, offs: <@060270>, cast: static variable(i32))
.field zeroXpr: int32 (size: 4, offs: <@060278>, cast: static variable(i32))
.field lastVal: int32 (size: 4, offs: <@060280>, cast: static variable(i32))
.field lastVar: int32 (size: 4, offs: <@060288>, cast: static variable(i32))
.field lastXpr: int32 (size: 4, offs: <@060290>, cast: static variable(i32))
.field sum2Val: int32 (size: 4, offs: <@060298>, cast: static variable(i32))
.field sum2Var: int32 (size: 4, offs: <@0602a0>, cast: static variable(i32))
.field sum2Xpr: int32 (size: 4, offs: <@0602a8>, cast: static variable(i32))
.field any2Val: int32 (size: 4, offs: <@0602b0>, cast: static variable(i32))
.field any2Var: int32 (size: 4, offs: <@0602b8>, cast: static variable(i32))
.field any2Xpr: int32 (size: 4, offs: <@0602c0>, cast: static variable(i32))
.field min2Val: int32 (size: 4, offs: <@0602c8>, cast: static variable(i32))
.field min2Var: int32 (size: 4, offs: <@0602d0>, cast: static variable(i32))
.field min2Xpr: int32 (size: 4, offs: <@0602d8>, cast: static variable(i32))
.field max2Val: int32 (size: 4, offs: <@0602e0>, cast: static variable(i32))
.field max2Var: int32 (size: 4, offs: <@0602e8>, cast: static variable(i32))
.field max2Xpr: int32 (size: 4, offs: <@0602f0>, cast: static variable(i32))
.field sumLr: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRl: function (size: 0, offs: <@000000>, cast: static inline)
.field sumRlVal: int32 (size: 4, offs: <@0602f8>, cast: static variable(i32))
.field sumLrVal: int32 (size: 4, offs: <@060300>, cast: static variable(i32))
.field sumRlVar: int32 (size: 4, offs: <@060308>, cast: static variable(i32))
.field sumLrVar: int32 (size: 4, offs: <@060310>, cast: static variable(i32))
.field sumRlXpr: int32 (size: 4, offs: <@060318>, cast: static variable(i32))
.field sumLrXpr: int32 (size: 4, offs: <@060320>, cast: static variable(i32))
.field anyLr: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRl: function (size: 0, offs: <@000000>, cast: static inline)
.field anyRlVal: int32 (size: 4, offs: <@060328>, cast: static variable(i32))
.field anyLrVal: int32 (size: 4, offs: <@060330>, cast: static variable(i32))
.field anyRlVar: int32 (size: 4, offs: <@060338>, cast: static variable(i32))
.field anyLrVar: int32 (size: 4, offs: <@060340>, cast: static variable(i32))
.field anyRlXpr: int32 (size: 4, offs: <@060348>, cast: static variable(i32))
.field anyLrXpr: int32 (size: 4, offs: <@060350>, cast: static variable(i32))
.field minLr: function (size: 0, offs: <@000000>, cast: static inline)
.field minRl: function (size: 0, offs: <@000000>, cast: static inline)
.field minRlVal: int32 (size: 4, offs: <@060358>, cast: static variable(i32))
.field minLrVal: int32 (size: 4, offs: <@060360>, cast: static variable(i32))
.field minRlVar: int32 (size: 4, offs: <@060368>, cast: static variable(i32))
.field minLrVar: int32 (size: 4, offs: <@060370>, cast: static variable(i32))
.field minRlXpr: int32 (size: 4, offs: <@060378>, cast: static variable(i32))
.field minLrXpr: int32 (size: 4, offs: <@060380>, cast: static variable(i32))
.field maxLr: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRl: function (size: 0, offs: <@000000>, cast: static inline)
.field maxRlVal: int32 (size: 4, offs: <@060388>, cast: static variable(i32))
.field maxLrVal: int32 (size: 4, offs: <@060390>, cast: static variable(i32))
.field maxRlVar: int32 (size: 4, offs: <@060398>, cast: static variable(i32))
.field maxLrVar: int32 (size: 4, offs: <@0603a0>, cast: static variable(i32))
.field maxRlXpr: int32 (size: 4, offs: <@0603a8>, cast: static variable(i32))
.field maxLrXpr: int32 (size: 4, offs: <@0603b0>, cast: static variable(i32))
.field overload: typename (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload: function (size: 0, offs: <@000000>, cast: static inline)
.field overload1: float32 (size: 4, offs: <@0603b8>, cast: static variable(f32))
.field overload2: float32 (size: 4, offs: <@0603c0>, cast: static variable(f32))
.field overload3: float32 (size: 4, offs: <@0603c8>, cast: static variable(f32))
.field overload4: float32 (size: 4, offs: <@0603d0>, cast: static variable(f32))
.field overload5: float32 (size: 4, offs: <@0603d8>, cast: static variable(f32))
.field Celsius: typename (size: 8, offs: <@03dbb0>, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, offs: <@03dcf0>, cast: static const typename(val))
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field Celsius: function (size: 0, offs: <@000000>, cast: static inline)
.field Fahrenheit: function (size: 0, offs: <@000000>, cast: static inline)
.field boilC: Celsius (size: 8, offs: <@0603e0>, cast: static variable(val))
.field boilF: Fahrenheit (size: 8, offs: <@0603e8>, cast: static variable(val))
.field pi64: float64 (size: 8, offs: <@0603f0>, cast: static variable(f64))
.field e64: float64 (size: 8, offs: <@0603f8>, cast: static variable(f64))
.field pi32: float32 (size: 4, offs: <@060400>, cast: static variable(f32))
.field e32: float32 (size: 4, offs: <@060408>, cast: static variable(f32))
.field rgb888: function (size: 0, offs: <@000000>, cast: static inline)
.field rgb565: function (size: 0, offs: <@000000>, cast: static inline)
.field r_comp: int32 (size: 4, offs: <@060410>, cast: static variable(i32))
.field g_comp: int32 (size: 4, offs: <@060418>, cast: static variable(i32))
.field b_comp: int32 (size: 4, offs: <@060420>, cast: static variable(i32))
.field r5g6b5: int32 (size: 4, offs: <@060428>, cast: static variable(i32))
.field r8g8b8: int32 (size: 4, offs: <@060430>, cast: static variable(i32))
.field zxtR5: int32 (size: 4, offs: <@060438>, cast: static variable(i32))
.field zxtG6: int32 (size: 4, offs: <@060440>, cast: static variable(i32))
.field zxtB5: int32 (size: 4, offs: <@060448>, cast: static variable(i32))
.field sxtR5: int32 (size: 4, offs: <@060450>, cast: static variable(i32))
.field sxtG6: int32 (size: 4, offs: <@060458>, cast: static variable(i32))
.field sxtB5: int32 (size: 4, offs: <@060460>, cast: static variable(i32))
.field zxtR8: int32 (size: 4, offs: <@060468>, cast: static variable(i32))
.field zxtG8: int32 (size: 4, offs: <@060470>, cast: static variable(i32))
.field zxtB8: int32 (size: 4, offs: <@060478>, cast: static variable(i32))
.field sxtR8: int32 (size: 4, offs: <@060480>, cast: static variable(i32))
.field sxtG8: int32 (size: 4, offs: <@060488>, cast: static variable(i32))
.field sxtB8: int32 (size: 4, offs: <@060490>, cast: static variable(i32))
.field testSin_f64: float64 (size: 8, offs: <@060498>, cast: static variable(f64))
.field testCos_f64: float64 (size: 8, offs: <@0604a0>, cast: static variable(f64))
.field testTan_f64: float64 (size: 8, offs: <@0604a8>, cast: static variable(f64))
.field testLog_f64: float64 (size: 8, offs: <@0604b0>, cast: static variable(f64))
.field testExp_f64: float64 (size: 8, offs: <@0604b8>, cast: static variable(f64))
.field testPow_f64: float64 (size: 8, offs: <@0604c0>, cast: static variable(f64))
.field testSqrt_f64: float64 (size: 8, offs: <@0604c8>, cast: static variable(f64))
.field testAtan_f64: float64 (size: 8, offs: <@0604d0>, cast: static variable(f64))
.field testSin_f32: float32 (size: 4, offs: <@0604d8>, cast: static variable(f32))
.field testCos_f32: float32 (size: 4, offs: <@0604e0>, cast: static variable(f32))
.field testTan_f32: float32 (size: 4, offs: <@0604e8>, cast: static variable(f32))
.field testLog_f32: float32 (size: 4, offs: <@0604f0>, cast: static variable(f32))
.field testExp_f32: float32 (size: 4, offs: <@0604f8>, cast: static variable(f32))
.field testPow_f32: float32 (size: 4, offs: <@060500>, cast: static variable(f32))
.field testSqrt_f32: float32 (size: 4, offs: <@060508>, cast: static variable(f32))
.field testAtan_f32: float32 (size: 4, offs: <@060510>, cast: static variable(f32))
.field testPopulation_u32: int32 (size: 4, offs: <@060518>, cast: static variable(i32))
.field testSwapBits_u32: uint32 (size: 4, offs: <@060520>, cast: static variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, offs: <@060528>, cast: static variable(i32))
.field testBitScanForward_u32: int32 (size: 4, offs: <@060530>, cast: static variable(i32))
.field testHighBit_u32: int32 (size: 4, offs: <@060538>, cast: static variable(i32))
.field testLowBit_u32: int32 (size: 4, offs: <@060540>, cast: static variable(i32))
.field testZeroExtend_u32: int32 (size: 4, offs: <@060548>, cast: static variable(i32))
.field testSignExtend_u32: int32 (size: 4, offs: <@060550>, cast: static variable(i32))
.field testZeroExtend_u64: int32 (size: 4, offs: <@060558>, cast: static variable(i32))
.field testSignExtend_u64: int32 (size: 4, offs: <@060560>, cast: static variable(i32))
.field realloc: function (size: 0, offs: <@000000>, cast: static inline)
.field malloc: function (size: 0, offs: <@000000>, cast: static inline)
.field free: function (size: 0, offs: <@000000>, cast: static inline)
.field p1: pointer (size: 4, offs: <@060568>, cast: static variable(ref))
.field p2: pointer (size: 4, offs: <@060570>, cast: static variable(ref))
.field p3: pointer (size: 4, offs: <@060578>, cast: static variable(ref))
.field p4: pointer (size: 4, offs: <@060580>, cast: static variable(ref))
.field val1: int64 (size: 8, offs: <@060588>, cast: static variable(i64))
.field val2: int64 (size: 8, offs: <@060590>, cast: static variable(i64))
.field noError: function (size: 1, offs: <@060598>, cast: static function)
.field stackOverflow: function (size: 24, offs: <@0605a0>, cast: static function)
.field divisionByZero: function (size: 12, offs: <@0605b8>, cast: static function)
.field abortExecution: function (size: 68, offs: <@0605c8>, cast: static function)
.field invalidMemoryAccess: function (size: 13, offs: <@060610>, cast: static function)
.field invalidInstruction: function (size: 2, offs: <@060620>, cast: static function)
.field tryExecErr0: int32 (size: 4, offs: <@060628>, cast: static variable(i32))
.field tryExecErr1: int32 (size: 4, offs: <@060630>, cast: static variable(i32))
.field tryExecErr2: int32 (size: 4, offs: <@060638>, cast: static variable(i32))
.field tryExecErr3: int32 (size: 4, offs: <@060640>, cast: static variable(i32))
.field tryExecErr4: int32 (size: 4, offs: <@060648>, cast: static variable(i32))
.field tryExecErr5: int32 (size: 4, offs: <@060650>, cast: static variable(i32))
.field tryExecErr6: int32 (size: 4, offs: <@060658>, cast: static variable(i32))
.field value: int64 (size: 8, offs: <@060660>, cast: static variable(i64))
.field valueRef: int64 (size: 4, offs: <@060668>, cast: static variable(ref))
.field valuePtr: pointer (size: 4, offs: <@060670>, cast: static variable(ref))
.field valueVar: variant (size: 8, offs: <@060678>, cast: static variable(var))
.field fromRef: int64 (size: 8, offs: <@060680>, cast: static variable(i64))
.field fromPtr: int64 (size: 4, offs: <@060688>, cast: static variable(ref))
.field fromVar: int64 (size: 4, offs: <@060690>, cast: static variable(ref))
.field nullRef: int64 (size: 4, offs: <@060698>, cast: static variable(ref))
.field nullPtr: pointer (size: 4, offs: <@0606a0>, cast: static variable(ref))
.field nullVar: variant (size: 8, offs: <@0606a8>, cast: static variable(var))
.field nullTyp: typename (size: 4, offs: <@0606b0>, cast: static variable(ref))
.field nullFun: function (size: 4, offs: <@0606b8>, cast: static variable(ref))
.field nullObj: object (size: 4, offs: <@0606c0>, cast: static variable(ref))
.field typePtr: pointer (size: 4, offs: <@0606c8>, cast: static variable(ref))
.field typeVar: variant (size: 8, offs: <@0606d0>, cast: static variable(var))
.field typeTyp: typename (size: 4, offs: <@0606d8>, cast: static variable(ref))
.field local: int64 (size: 8, offs: <@0606e0>, cast: static variable(i64))
.field copyVal: int64 (size: 8, offs: <@0606e8>, cast: static variable(i64))
.field copyRef: int64 (size: 4, offs: <@0606f0>, cast: static variable(ref))
.field copyPtr: pointer (size: 4, offs: <@0606f8>, cast: static variable(ref))
.field copyVar: variant (size: 8, offs: <@060700>, cast: static variable(var))
.field copyTyp: typename (size: 4, offs: <@060708>, cast: static variable(ref))
.field ptrVoid: pointer (size: 4, offs: <@060710>, cast: static variable(ref))
.field ptrBool: pointer (size: 4, offs: <@060718>, cast: static variable(ref))
.field ptrChar: pointer (size: 4, offs: <@060720>, cast: static variable(ref))
.field ptrInt8: pointer (size: 4, offs: <@060728>, cast: static variable(ref))
.field ptrInt16: pointer (size: 4, offs: <@060730>, cast: static variable(ref))
.field ptrInt32: pointer (size: 4, offs: <@060738>, cast: static variable(ref))
.field ptrInt64: pointer (size: 4, offs: <@060740>, cast: static variable(ref))
.field ptrUint8: pointer (size: 4, offs: <@060748>, cast: static variable(ref))
.field ptrUint16: pointer (size: 4, offs: <@060750>, cast: static variable(ref))
.field ptrUint32: pointer (size: 4, offs: <@060758>, cast: static variable(ref))
.field ptrUint64: pointer (size: 4, offs: <@060760>, cast: static variable(ref))
.field ptrFloat32: pointer (size: 4, offs: <@060768>, cast: static variable(ref))
.field ptrFloat64: pointer (size: 4, offs: <@060770>, cast: static variable(ref))
.field ptrTypename: pointer (size: 4, offs: <@060778>, cast: static variable(ref))
.field ptrFunction: pointer (size: 4, offs: <@060780>, cast: static variable(ref))
.field ptrPointer: pointer (size: 4, offs: <@060788>, cast: static variable(ref))
.field ptrVariant: pointer (size: 4, offs: <@060790>, cast: static variable(ref))
.field ptrObject: pointer (size: 4, offs: <@060798>, cast: static variable(ref))
.field varVoid: variant (size: 8, offs: <@0607a0>, cast: static variable(var))
.field varBool: variant (size: 8, offs: <@0607a8>, cast: static variable(var))
.field varChar: variant (size: 8, offs: <@0607b0>, cast: static variable(var))
.field varInt8: variant (size: 8, offs: <@0607b8>, cast: static variable(var))
.field varInt16: variant (size: 8, offs: <@0607c0>, cast: static variable(var))
.field varInt32: variant (size: 8, offs: <@0607c8>, cast: static variable(var))
.field varInt64: variant (size: 8, offs: <@0607d0>, cast: static variable(var))
.field varUint8: variant (size: 8, offs: <@0607d8>, cast: static variable(var))
.field varUint16: variant (size: 8, offs: <@0607e0>, cast: static variable(var))
.field varUint32: variant (size: 8, offs: <@0607e8>, cast: static variable(var))
.field varUint64: variant (size: 8, offs: <@0607f0>, cast: static variable(var))
.field varFloat32: variant (size: 8, offs: <@0607f8>, cast: static variable(var))
.field varFloat64: variant (size: 8, offs: <@060800>, cast: static variable(var))
.field varTypename: variant (size: 8, offs: <@060808>, cast: static variable(var))
.field varFunction: variant (size: 8, offs: <@060810>, cast: static variable(var))
.field varPointer: variant (size: 8, offs: <@060818>, cast: static variable(var))
.field varVariant: variant (size: 8, offs: <@060820>, cast: static variable(var))
.field varObject: variant (size: 8, offs: <@060828>, cast: static variable(var))
.field typVoid: typename (size: 4, offs: <@060830>, cast: static variable(ref))
.field typBool: typename (size: 4, offs: <@060838>, cast: static variable(ref))
.field typChar: typename (size: 4, offs: <@060840>, cast: static variable(ref))
.field typInt8: typename (size: 4, offs: <@060848>, cast: static variable(ref))
.field typInt16: typename (size: 4, offs: <@060850>, cast: static variable(ref))
.field typInt32: typename (size: 4, offs: <@060858>, cast: static variable(ref))
.field typInt64: typename (size: 4, offs: <@060860>, cast: static variable(ref))
.field typUint8: typename (size: 4, offs: <@060868>, cast: static variable(ref))
.field typUint16: typename (size: 4, offs: <@060870>, cast: static variable(ref))
.field typUint32: typename (size: 4, offs: <@060878>, cast: static variable(ref))
.field typUint64: typename (size: 4, offs: <@060880>, cast: static variable(ref))
.field typFloat32: typename (size: 4, offs: <@060888>, cast: static variable(ref))
.field typFloat64: typename (size: 4, offs: <@060890>, cast: static variable(ref))
.field typTypename: typename (size: 4, offs: <@060898>, cast: static variable(ref))
.field typFunction: typename (size: 4, offs: <@0608a0>, cast: static variable(ref))
.field typPointer: typename (size: 4, offs: <@0608a8>, cast: static variable(ref))
.field typVariant: typename (size: 4, offs: <@0608b0>, cast: static variable(ref))
.field typObject: typename (size: 4, offs: <@0608b8>, cast: static variable(ref))
.field valueOfPtr: pointer (size: 4, offs: <@0608c0>, cast: static variable(ref))
.field valueOfVar: variant (size: 8, offs: <@0608c8>, cast: static variable(var))
.field valueOfTyp: typename (size: 4, offs: <@0608d0>, cast: static variable(ref))
.field typeOfValue: typename (size: 4, offs: <@0608d8>, cast: static variable(ref))
.field copyPtrFloat64: variant (size: 8, offs: <@0608e0>, cast: static variable(var))
.field copyVarFloat64: pointer (size: 4, offs: <@0608e8>, cast: static variable(ref))
.field variable: int32 (size: 4, offs: <@0608f0>, cast: static variable(i32))
.field constant: int32 (size: 4, offs: <@0608f8>, cast: static const variable(i32))
.field ComplexVal: typename (size: 16, offs: <@046b00>, cast: static const typename(val))
.field ComplexObj: object (size: 20, offs: <@046ce0>, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, offs: <@060900>, cast: static variable(val))
.field objInitImplicit: ComplexObj (size: 4, offs: <@060910>, cast: static variable(ref))
.field objInitExplicit: object (size: 4, offs: <@060918>, cast: static variable(ref))
.field empty: function (size: 1, offs: <@060920>, cast: static function)
.field funAdd: function (size: 8, offs: <@060928>, cast: static function)
.field funAddResult: int32 (size: 4, offs: <@060930>, cast: static variable(i32))
.field funAddRef: function (size: 4, offs: <@060938>, cast: static variable(ref))
.field funAddRefResult: int32 (size: 4, offs: <@060940>, cast: static variable(i32))
.field funMul: function (size: 4, offs: <@060948>, cast: static variable(ref))
.field funMulResult: int32 (size: 4, offs: <@060950>, cast: static variable(i32))
.field funMulRef: function (size: 4, offs: <@060958>, cast: static variable(ref))
.field funMulRefResult: int32 (size: 4, offs: <@060960>, cast: static variable(i32))
.field funMul: function (size: 8, offs: <@060968>, cast: static function)
.field fib: function (size: 54, offs: <@060970>, cast: static function)
.field fibonacci_13: uint32 (size: 4, offs: <@0609a8>, cast: static variable(u32))
.field sizeofVoid: int32 (size: 4, offs: <@0609b0>, cast: static variable(i32))
.field sizeofBool: int32 (size: 4, offs: <@0609b8>, cast: static variable(i32))
.field sizeofChar: int32 (size: 4, offs: <@0609c0>, cast: static variable(i32))
.field sizeofInt8: int32 (size: 4, offs: <@0609c8>, cast: static variable(i32))
.field sizeofInt16: int32 (size: 4, offs: <@0609d0>, cast: static variable(i32))
.field sizeofInt32: int32 (size: 4, offs: <@0609d8>, cast: static variable(i32))
.field sizeofInt64: int32 (size: 4, offs: <@0609e0>, cast: static variable(i32))
.field sizeofUint8: int32 (size: 4, offs: <@0609e8>, cast: static variable(i32))
.field sizeofUint16: int32 (size: 4, offs: <@0609f0>, cast: static variable(i32))
.field sizeofUint32: int32 (size: 4, offs: <@0609f8>, cast: static variable(i32))
.field sizeofUint64: int32 (size: 4, offs: <@060a00>, cast: static variable(i32))
.field sizeofFloat32: int32 (size: 4, offs: <@060a08>, cast: static variable(i32))
.field sizeofFloat64: int32 (size: 4, offs: <@060a10>, cast: static variable(i32))
.field sizeofPointer: int32 (size: 4, offs: <@060a18>, cast: static variable(i32))
.field sizeofVariant: int32 (size: 4, offs: <@060a20>, cast: static variable(i32))
.field sizeofTypename: int32 (size: 4, offs: <@060a28>, cast: static variable(i32))
.field sizeofFunction: int32 (size: 4, offs: <@060a30>, cast: static variable(i32))
.field sizeofObject: int32 (size: 4, offs: <@060a38>, cast: static variable(i32))
.field RecordSizeof: object (size: 12, offs: <@0492b0>, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, offs: <@0493f0>, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, offs: <@060a40>, cast: static variable(ref))
.field nameOfRecord: char[*] (size: 4, offs: <@060a48>, cast: static variable(ref))
.field offsetOfRecord: int32 (size: 4, offs: <@060a50>, cast: static variable(i32))
.field sizeOfRecord: int32 (size: 4, offs: <@060a58>, cast: static variable(i32))
.field fileOfRecord: char[*] (size: 4, offs: <@060a60>, cast: static variable(ref))
.field lineOfRecord: int32 (size: 4, offs: <@060a68>, cast: static variable(i32))
.field typeofBase: typename (size: 4, offs: <@060a70>, cast: static variable(ref))
.field nameOfBase: char[*] (size: 4, offs: <@060a78>, cast: static variable(ref))
.field offsetOfBase: int32 (size: 4, offs: <@060a80>, cast: static variable(i32))
.field sizeOfBase: int32 (size: 4, offs: <@060a88>, cast: static variable(i32))
.field fileOfBase: char[*] (size: 4, offs: <@060a90>, cast: static variable(ref))
.field lineOfBase: int32 (size: 4, offs: <@060a98>, cast: static variable(i32))
.field typeofBase1: typename (size: 4, offs: <@060aa0>, cast: static variable(ref))
.field offsetOfBase1: int32 (size: 4, offs: <@060aa8>, cast: static variable(i32))
.field sizeOfBase1: int32 (size: 4, offs: <@060ab0>, cast: static variable(i32))
.field typeofBase2: typename (size: 4, offs: <@060ab8>, cast: static variable(ref))
.field offsetOfBase2: int32 (size: 4, offs: <@060ac0>, cast: static variable(i32))
.field sizeOfBase2: int32 (size: 4, offs: <@060ac8>, cast: static variable(i32))
.field RecordMemberTest: typename (size: 32, offs: <@04a3f0>, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, offs: <@060b00>, cast: static variable(val))
.field RecordMethodTest: typename (size: 16, offs: <@04b308>, cast: static const typename(val))
.field globalFunction: function (size: 39, offs: <@060ba0>, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, offs: <@060bc8>, cast: static variable(val))
.field staticMethod: function (size: 66, offs: <@060bd8>, cast: static function)
.field virtualMethod: function (size: 63, offs: <@060c20>, cast: static function)
.field arrFixedInit: int64[7] (size: 56, offs: <@060c60>, cast: static variable(val))
.field arrArrayInitNull: int64[*] (size: 4, offs: <@060c98>, cast: static variable(ref))
.field arrSliceInitNull: int64[] (size: 8, offs: <@060ca0>, cast: static variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4, offs: <@060ca8>, cast: static variable(ref))
.field arrSliceInitFixed: int64[] (size: 8, offs: <@060cb0>, cast: static variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4, offs: <@060cb8>, cast: static variable(ref))
.field arrSliceInitSlice: int64[] (size: 8, offs: <@060cc0>, cast: static variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4, offs: <@060cc8>, cast: static variable(ref))
.field strFixed: char[7] (size: 7, offs: <@060cd0>, cast: static variable(val))
.field strArray: char[*] (size: 4, offs: <@060cd8>, cast: static variable(ref))
.field strSlice: char[] (size: 8, offs: <@060ce0>, cast: static variable(arr))
.field lenSlice: function (size: 4, offs: <@060ce8>, cast: static function)
.field nthFixed: function (size: 12, offs: <@060cf0>, cast: static function)
.field nthArray: function (size: 12, offs: <@060d00>, cast: static function)
.field nthSlice: function (size: 12, offs: <@060d10>, cast: static function)
.field rgbF32: typename (size: 16, offs: <@04ea30>, cast: static const typename(val))
.field rgbU8: typename (size: 3, offs: <@04ecb0>, cast: static const typename(val))
.field color: typename (size: 4, offs: <@04ef30>, cast: static const typename(val))
.field Color: object (size: 20, offs: <@04f110>, cast: static const typename(ref))
.field black: rgbU8 (size: 3, offs: <@060d20>, cast: static variable(val))
.field green: rgbU8 (size: 3, offs: <@060d28>, cast: static variable(val))
.field white: rgbU8 (size: 3, offs: <@060d30>, cast: static variable(val))
.field cyan: color (size: 4, offs: <@060d38>, cast: static variable(val))
.field blue: color (size: 4, offs: <@060d40>, cast: static variable(val))
.field record_pack0: typename (size: 8, offs: <@04f5f0>, cast: static const typename(val))
.field record_pack1: typename (size: 17, offs: <@04fa50>, cast: static const typename(val))
.field record_pack2: typename (size: 20, offs: <@04feb0>, cast: static const typename(val))
.field record_pack4: typename (size: 24, offs: <@050310>, cast: static const typename(val))
.field record_pack8: typename (size: 32, offs: <@050770>, cast: static const typename(val))
.field record_packDef: typename (size: 32, offs: <@050bd0>, cast: static const typename(val))
.field a: typename (size: 0, offs: <@000000>, cast: static inline)
.field b: typename (size: 0, offs: <@000000>, cast: static inline)
.field shift: int32 (size: 4, offs: <@060d48>, cast: static variable(i32))
.field boolA: bool (size: 1, offs: <@060d50>, cast: static variable(bool))
.field boolB: bool (size: 1, offs: <@060d58>, cast: static variable(bool))
.field boolAnd: bool (size: 1, offs: <@060d60>, cast: static variable(bool))
.field boolIor: bool (size: 1, offs: <@060d68>, cast: static variable(bool))
.field boolXor: bool (size: 1, offs: <@060d70>, cast: static variable(bool))
.field boolNot: bool (size: 1, offs: <@060d78>, cast: static variable(bool))
.field boolCeq: bool (size: 1, offs: <@060d80>, cast: static variable(bool))
.field boolCne: bool (size: 1, offs: <@060d88>, cast: static variable(bool))
.field boolClt: bool (size: 1, offs: <@060d90>, cast: static variable(bool))
.field boolCle: bool (size: 1, offs: <@060d98>, cast: static variable(bool))
.field boolCgt: bool (size: 1, offs: <@060da0>, cast: static variable(bool))
.field boolCge: bool (size: 1, offs: <@060da8>, cast: static variable(bool))
.field chrA: char (size: 1, offs: <@060db0>, cast: static variable(i32))
.field chrB: char (size: 1, offs: <@060db8>, cast: static variable(i32))
.field chrPls: char (size: 1, offs: <@060dc0>, cast: static variable(i32))
.field chrNeg: char (size: 1, offs: <@060dc8>, cast: static variable(i32))
.field chrCmt: char (size: 1, offs: <@060dd0>, cast: static variable(i32))
.field chrAdd: char (size: 1, offs: <@060dd8>, cast: static variable(i32))
.field chrSub: char (size: 1, offs: <@060de0>, cast: static variable(i32))
.field chrMul: char (size: 1, offs: <@060de8>, cast: static variable(i32))
.field chrDiv: char (size: 1, offs: <@060df0>, cast: static variable(i32))
.field chrMod: char (size: 1, offs: <@060df8>, cast: static variable(i32))
.field chrAnd: char (size: 1, offs: <@060e00>, cast: static variable(i32))
.field chrIor: char (size: 1, offs: <@060e08>, cast: static variable(i32))
.field chrXor: char (size: 1, offs: <@060e10>, cast: static variable(i32))
.field chrShl: char (size: 1, offs: <@060e18>, cast: static variable(i32))
.field chrShr: char (size: 1, offs: <@060e20>, cast: static variable(i32))
.field chrNot: bool (size: 1, offs: <@060e28>, cast: static variable(bool))
.field chrCeq: bool (size: 1, offs: <@060e30>, cast: static variable(bool))
.field chrCne: bool (size: 1, offs: <@060e38>, cast: static variable(bool))
.field chrClt: bool (size: 1, offs: <@060e40>, cast: static variable(bool))
.field chrCle: bool (size: 1, offs: <@060e48>, cast: static variable(bool))
.field chrCgt: bool (size: 1, offs: <@060e50>, cast: static variable(bool))
.field chrCge: bool (size: 1, offs: <@060e58>, cast: static variable(bool))
.field i8A: int8 (size: 1, offs: <@060e60>, cast: static variable(i32))
.field i8B: int8 (size: 1, offs: <@060e68>, cast: static variable(i32))
.field i8Pls: int8 (size: 1, offs: <@060e70>, cast: static variable(i32))
.field i8Neg: int8 (size: 1, offs: <@060e78>, cast: static variable(i32))
.field i8Cmt: int8 (size: 1, offs: <@060e80>, cast: static variable(i32))
.field i8Add: int8 (size: 1, offs: <@060e88>, cast: static variable(i32))
.field i8Sub: int8 (size: 1, offs: <@060e90>, cast: static variable(i32))
.field i8Mul: int8 (size: 1, offs: <@060e98>, cast: static variable(i32))
.field i8Div: int8 (size: 1, offs: <@060ea0>, cast: static variable(i32))
.field i8Mod: int8 (size: 1, offs: <@060ea8>, cast: static variable(i32))
.field i8And: int8 (size: 1, offs: <@060eb0>, cast: static variable(i32))
.field i8Ior: int8 (size: 1, offs: <@060eb8>, cast: static variable(i32))
.field i8Xor: int8 (size: 1, offs: <@060ec0>, cast: static variable(i32))
.field i8Shl: int8 (size: 1, offs: <@060ec8>, cast: static variable(i32))
.field i8Shr: int8 (size: 1, offs: <@060ed0>, cast: static variable(i32))
.field i8Not: bool (size: 1, offs: <@060ed8>, cast: static variable(bool))
.field i8Ceq: bool (size: 1, offs: <@060ee0>, cast: static variable(bool))
.field i8Cne: bool (size: 1, offs: <@060ee8>, cast: static variable(bool))
.field i8Clt: bool (size: 1, offs: <@060ef0>, cast: static variable(bool))
.field i8Cle: bool (size: 1, offs: <@060ef8>, cast: static variable(bool))
.field i8Cgt: bool (size: 1, offs: <@060f00>, cast: static variable(bool))
.field i8Cge: bool (size: 1, offs: <@060f08>, cast: static variable(bool))
.field u8A: uint8 (size: 1, offs: <@060f10>, cast: static variable(u32))
.field u8B: uint8 (size: 1, offs: <@060f18>, cast: static variable(u32))
.field u8Pls: uint8 (size: 1, offs: <@060f20>, cast: static variable(u32))
.field u8Neg: uint8 (size: 1, offs: <@060f28>, cast: static variable(u32))
.field u8Cmt: uint8 (size: 1, offs: <@060f30>, cast: static variable(u32))
.field u8Add: uint8 (size: 1, offs: <@060f38>, cast: static variable(u32))
.field u8Sub: uint8 (size: 1, offs: <@060f40>, cast: static variable(u32))
.field u8Mul: uint8 (size: 1, offs: <@060f48>, cast: static variable(u32))
.field u8Div: uint8 (size: 1, offs: <@060f50>, cast: static variable(u32))
.field u8Mod: uint8 (size: 1, offs: <@060f58>, cast: static variable(u32))
.field u8And: uint8 (size: 1, offs: <@060f60>, cast: static variable(u32))
.field u8Ior: uint8 (size: 1, offs: <@060f68>, cast: static variable(u32))
.field u8Xor: uint8 (size: 1, offs: <@060f70>, cast: static variable(u32))
.field u8Shl: uint8 (size: 1, offs: <@060f78>, cast: static variable(u32))
.field u8Shr: uint8 (size: 1, offs: <@060f80>, cast: static variable(u32))
.field u8Not: bool (size: 1, offs: <@060f88>, cast: static variable(bool))
.field u8Ceq: bool (size: 1, offs: <@060f90>, cast: static variable(bool))
.field u8Cne: bool (size: 1, offs: <@060f98>, cast: static variable(bool))
.field u8Clt: bool (size: 1, offs: <@060fa0>, cast: static variable(bool))
.field u8Cle: bool (size: 1, offs: <@060fa8>, cast: static variable(bool))
.field u8Cgt: bool (size: 1, offs: <@060fb0>, cast: static variable(bool))
.field u8Cge: bool (size: 1, offs: <@060fb8>, cast: static variable(bool))
.field i16A: int16 (size: 2, offs: <@060fc0>, cast: static variable(i32))
.field i16B: int16 (size: 2, offs: <@060fc8>, cast: static variable(i32))
.field i16Pls: int16 (size: 2, offs: <@060fd0>, cast: static variable(i32))
.field i16Neg: int16 (size: 2, offs: <@060fd8>, cast: static variable(i32))
.field i16Cmt: int16 (size: 2, offs: <@060fe0>, cast: static variable(i32))
.field i16Add: int16 (size: 2, offs: <@060fe8>, cast: static variable(i32))
.field i16Sub: int16 (size: 2, offs: <@060ff0>, cast: static variable(i32))
.field i16Mul: int16 (size: 2, offs: <@060ff8>, cast: static variable(i32))
.field i16Div: int16 (size: 2, offs: <@061000>, cast: static variable(i32))
.field i16Mod: int16 (size: 2, offs: <@061008>, cast: static variable(i32))
.field i16And: int16 (size: 2, offs: <@061010>, cast: static variable(i32))
.field i16Ior: int16 (size: 2, offs: <@061018>, cast: static variable(i32))
.field i16Xor: int16 (size: 2, offs: <@061020>, cast: static variable(i32))
.field i16Shl: int16 (size: 2, offs: <@061028>, cast: static variable(i32))
.field i16Shr: int16 (size: 2, offs: <@061030>, cast: static variable(i32))
.field i16Not: bool (size: 1, offs: <@061038>, cast: static variable(bool))
.field i16Ceq: bool (size: 1, offs: <@061040>, cast: static variable(bool))
.field i16Cne: bool (size: 1, offs: <@061048>, cast: static variable(bool))
.field i16Clt: bool (size: 1, offs: <@061050>, cast: static variable(bool))
.field i16Cle: bool (size: 1, offs: <@061058>, cast: static variable(bool))
.field i16Cgt: bool (size: 1, offs: <@061060>, cast: static variable(bool))
.field i16Cge: bool (size: 1, offs: <@061068>, cast: static variable(bool))
.field u16A: uint16 (size: 2, offs: <@061070>, cast: static variable(u32))
.field u16B: uint16 (size: 2, offs: <@061078>, cast: static variable(u32))
.field u16Pls: uint16 (size: 2, offs: <@061080>, cast: static variable(u32))
.field u16Neg: uint16 (size: 2, offs: <@061088>, cast: static variable(u32))
.field u16Cmt: uint16 (size: 2, offs: <@061090>, cast: static variable(u32))
.field u16Add: uint16 (size: 2, offs: <@061098>, cast: static variable(u32))
.field u16Sub: uint16 (size: 2, offs: <@0610a0>, cast: static variable(u32))
.field u16Mul: uint16 (size: 2, offs: <@0610a8>, cast: static variable(u32))
.field u16Div: uint16 (size: 2, offs: <@0610b0>, cast: static variable(u32))
.field u16Mod: uint16 (size: 2, offs: <@0610b8>, cast: static variable(u32))
.field u16And: uint16 (size: 2, offs: <@0610c0>, cast: static variable(u32))
.field u16Ior: uint16 (size: 2, offs: <@0610c8>, cast: static variable(u32))
.field u16Xor: uint16 (size: 2, offs: <@0610d0>, cast: static variable(u32))
.field u16Shl: uint16 (size: 2, offs: <@0610d8>, cast: static variable(u32))
.field u16Shr: uint16 (size: 2, offs: <@0610e0>, cast: static variable(u32))
.field u16Not: bool (size: 1, offs: <@0610e8>, cast: static variable(bool))
.field u16Ceq: bool (size: 1, offs: <@0610f0>, cast: static variable(bool))
.field u16Cne: bool (size: 1, offs: <@0610f8>, cast: static variable(bool))
.field u16Clt: bool (size: 1, offs: <@061100>, cast: static variable(bool))
.field u16Cle: bool (size: 1, offs: <@061108>, cast: static variable(bool))
.field u16Cgt: bool (size: 1, offs: <@061110>, cast: static variable(bool))
.field u16Cge: bool (size: 1, offs: <@061118>, cast: static variable(bool))
.field i32A: int32 (size: 4, offs: <@061120>, cast: static variable(i32))
.field i32B: int32 (size: 4, offs: <@061128>, cast: static variable(i32))
.field i32Pls: int32 (size: 4, offs: <@061130>, cast: static variable(i32))
.field i32Neg: int32 (size: 4, offs: <@061138>, cast: static variable(i32))
.field i32Cmt: int32 (size: 4, offs: <@061140>, cast: static variable(i32))
.field i32Add: int32 (size: 4, offs: <@061148>, cast: static variable(i32))
.field i32Sub: int32 (size: 4, offs: <@061150>, cast: static variable(i32))
.field i32Mul: int32 (size: 4, offs: <@061158>, cast: static variable(i32))
.field i32Div: int32 (size: 4, offs: <@061160>, cast: static variable(i32))
.field i32Mod: int32 (size: 4, offs: <@061168>, cast: static variable(i32))
.field i32And: int32 (size: 4, offs: <@061170>, cast: static variable(i32))
.field i32Ior: int32 (size: 4, offs: <@061178>, cast: static variable(i32))
.field i32Xor: int32 (size: 4, offs: <@061180>, cast: static variable(i32))
.field i32Shl: int32 (size: 4, offs: <@061188>, cast: static variable(i32))
.field i32Shr: int32 (size: 4, offs: <@061190>, cast: static variable(i32))
.field i32Not: bool (size: 1, offs: <@061198>, cast: static variable(bool))
.field i32Ceq: bool (size: 1, offs: <@0611a0>, cast: static variable(bool))
.field i32Cne: bool (size: 1, offs: <@0611a8>, cast: static variable(bool))
.field i32Clt: bool (size: 1, offs: <@0611b0>, cast: static variable(bool))
.field i32Cle: bool (size: 1, offs: <@0611b8>, cast: static variable(bool))
.field i32Cgt: bool (size: 1, offs: <@0611c0>, cast: static variable(bool))
.field i32Cge: bool (size: 1, offs: <@0611c8>, cast: static variable(bool))
.field u32A: uint32 (size: 4, offs: <@0611d0>, cast: static variable(u32))
.field u32B: uint32 (size: 4, offs: <@0611d8>, cast: static variable(u32))
.field u32Pls: uint32 (size: 4, offs: <@0611e0>, cast: static variable(u32))
.field u32Neg: uint32 (size: 4, offs: <@0611e8>, cast: static variable(u32))
.field u32Cmt: uint32 (size: 4, offs: <@0611f0>, cast: static variable(u32))
.field u32Add: uint32 (size: 4, offs: <@0611f8>, cast: static variable(u32))
.field u32Sub: uint32 (size: 4, offs: <@061200>, cast: static variable(u32))
.field u32Mul: uint32 (size: 4, offs: <@061208>, cast: static variable(u32))
.field u32Div: uint32 (size: 4, offs: <@061210>, cast: static variable(u32))
.field u32Mod: uint32 (size: 4, offs: <@061218>, cast: static variable(u32))
.field u32And: uint32 (size: 4, offs: <@061220>, cast: static variable(u32))
.field u32Ior: uint32 (size: 4, offs: <@061228>, cast: static variable(u32))
.field u32Xor: uint32 (size: 4, offs: <@061230>, cast: static variable(u32))
.field u32Shl: uint32 (size: 4, offs: <@061238>, cast: static variable(u32))
.field u32Shr: uint32 (size: 4, offs: <@061240>, cast: static variable(u32))
.field u32Not: bool (size: 1, offs: <@061248>, cast: static variable(bool))
.field u32Ceq: bool (size: 1, offs: <@061250>, cast: static variable(bool))
.field u32Cne: bool (size: 1, offs: <@061258>, cast: static variable(bool))
.field u32Clt: bool (size: 1, offs: <@061260>, cast: static variable(bool))
.field u32Cle: bool (size: 1, offs: <@061268>, cast: static variable(bool))
.field u32Cgt: bool (size: 1, offs: <@061270>, cast: static variable(bool))
.field u32Cge: bool (size: 1, offs: <@061278>, cast: static variable(bool))
.field i64A: int64 (size: 8, offs: <@061280>, cast: static variable(i64))
.field i64B: int64 (size: 8, offs: <@061288>, cast: static variable(i64))
.field i64Pls: int64 (size: 8, offs: <@061290>, cast: static variable(i64))
.field i64Neg: int64 (size: 8, offs: <@061298>, cast: static variable(i64))
.field i64Cmt: int64 (size: 8, offs: <@0612a0>, cast: static variable(i64))
.field i64Add: int64 (size: 8, offs: <@0612a8>, cast: static variable(i64))
.field i64Sub: int64 (size: 8, offs: <@0612b0>, cast: static variable(i64))
.field i64Mul: int64 (size: 8, offs: <@0612b8>, cast: static variable(i64))
.field i64Div: int64 (size: 8, offs: <@0612c0>, cast: static variable(i64))
.field i64Mod: int64 (size: 8, offs: <@0612c8>, cast: static variable(i64))
.field i64And: int64 (size: 8, offs: <@0612d0>, cast: static variable(i64))
.field i64Ior: int64 (size: 8, offs: <@0612d8>, cast: static variable(i64))
.field i64Xor: int64 (size: 8, offs: <@0612e0>, cast: static variable(i64))
.field i64Shl: int64 (size: 8, offs: <@0612e8>, cast: static variable(i64))
.field i64Shr: int64 (size: 8, offs: <@0612f0>, cast: static variable(i64))
.field i64Not: bool (size: 1, offs: <@0612f8>, cast: static variable(bool))
.field i64Ceq: bool (size: 1, offs: <@061300>, cast: static variable(bool))
.field i64Cne: bool (size: 1, offs: <@061308>, cast: static variable(bool))
.field i64Clt: bool (size: 1, offs: <@061310>, cast: static variable(bool))
.field i64Cle: bool (size: 1, offs: <@061318>, cast: static variable(bool))
.field i64Cgt: bool (size: 1, offs: <@061320>, cast: static variable(bool))
.field i64Cge: bool (size: 1, offs: <@061328>, cast: static variable(bool))
.field u64A: uint64 (size: 8, offs: <@061330>, cast: static variable(u64))
.field u64B: uint64 (size: 8, offs: <@061338>, cast: static variable(u64))
.field u64Pls: uint64 (size: 8, offs: <@061340>, cast: static variable(u64))
.field u64Neg: uint64 (size: 8, offs: <@061348>, cast: static variable(u64))
.field u64Cmt: uint64 (size: 8, offs: <@061350>, cast: static variable(u64))
.field u64Add: uint64 (size: 8, offs: <@061358>, cast: static variable(u64))
.field u64Sub: uint64 (size: 8, offs: <@061360>, cast: static variable(u64))
.field u64Mul: uint64 (size: 8, offs: <@061368>, cast: static variable(u64))
.field u64Div: uint64 (size: 8, offs: <@061370>, cast: static variable(u64))
.field u64Mod: uint64 (size: 8, offs: <@061378>, cast: static variable(u64))
.field u64And: uint64 (size: 8, offs: <@061380>, cast: static variable(u64))
.field u64Ior: uint64 (size: 8, offs: <@061388>, cast: static variable(u64))
.field u64Xor: uint64 (size: 8, offs: <@061390>, cast: static variable(u64))
.field u64Shl: uint64 (size: 8, offs: <@061398>, cast: static variable(u64))
.field u64Shr: uint64 (size: 8, offs: <@0613a0>, cast: static variable(u64))
.field u64Not: bool (size: 1, offs: <@0613a8>, cast: static variable(bool))
.field u64Ceq: bool (size: 1, offs: <@0613b0>, cast: static variable(bool))
.field u64Cne: bool (size: 1, offs: <@0613b8>, cast: static variable(bool))
.field u64Clt: bool (size: 1, offs: <@0613c0>, cast: static variable(bool))
.field u64Cle: bool (size: 1, offs: <@0613c8>, cast: static variable(bool))
.field u64Cgt: bool (size: 1, offs: <@0613d0>, cast: static variable(bool))
.field u64Cge: bool (size: 1, offs: <@0613d8>, cast: static variable(bool))
.field f32A: float32 (size: 4, offs: <@0613e0>, cast: static variable(f32))
.field f32B: float32 (size: 4, offs: <@0613e8>, cast: static variable(f32))
.field f32Pls: float32 (size: 4, offs: <@0613f0>, cast: static variable(f32))
.field f32Neg: float32 (size: 4, offs: <@0613f8>, cast: static variable(f32))
.field f32Add: float32 (size: 4, offs: <@061400>, cast: static variable(f32))
.field f32Sub: float32 (size: 4, offs: <@061408>, cast: static variable(f32))
.field f32Mul: float32 (size: 4, offs: <@061410>, cast: static variable(f32))
.field f32Div: float32 (size: 4, offs: <@061418>, cast: static variable(f32))
.field f32Mod: float32 (size: 4, offs: <@061420>, cast: static variable(f32))
.field f32Not: bool (size: 1, offs: <@061428>, cast: static variable(bool))
.field f32Ceq: bool (size: 1, offs: <@061430>, cast: static variable(bool))
.field f32Cne: bool (size: 1, offs: <@061438>, cast: static variable(bool))
.field f32Clt: bool (size: 1, offs: <@061440>, cast: static variable(bool))
.field f32Cle: bool (size: 1, offs: <@061448>, cast: static variable(bool))
.field f32Cgt: bool (size: 1, offs: <@061450>, cast: static variable(bool))
.field f32Cge: bool (size: 1, offs: <@061458>, cast: static variable(bool))
.field f64A: float64 (size: 8, offs: <@061460>, cast: static variable(f64))
.field f64B: float64 (size: 8, offs: <@061468>, cast: static variable(f64))
.field f64Pls: float64 (size: 8, offs: <@061470>, cast: static variable(f64))
.field f64Neg: float64 (size: 8, offs: <@061478>, cast: static variable(f64))
.field f64Add: float64 (size: 8, offs: <@061480>, cast: static variable(f64))
.field f64Sub: float64 (size: 8, offs: <@061488>, cast: static variable(f64))
.field f64Mul: float64 (size: 8, offs: <@061490>, cast: static variable(f64))
.field f64Div: float64 (size: 8, offs: <@061498>, cast: static variable(f64))
.field f64Mod: float64 (size: 8, offs: <@0614a0>, cast: static variable(f64))
.field f64Not: bool (size: 1, offs: <@0614a8>, cast: static variable(bool))
.field f64Ceq: bool (size: 1, offs: <@0614b0>, cast: static variable(bool))
.field f64Cne: bool (size: 1, offs: <@0614b8>, cast: static variable(bool))
.field f64Clt: bool (size: 1, offs: <@0614c0>, cast: static variable(bool))
.field f64Cle: bool (size: 1, offs: <@0614c8>, cast: static variable(bool))
.field f64Cgt: bool (size: 1, offs: <@0614d0>, cast: static variable(bool))
.field f64Cge: bool (size: 1, offs: <@0614d8>, cast: static variable(bool))
.field ptrA: pointer (size: 4, offs: <@0614e0>, cast: static variable(ref))
.field ptrB: pointer (size: 4, offs: <@0614e8>, cast: static variable(ref))
.field ptrCeq: bool (size: 1, offs: <@0614f0>, cast: static variable(bool))
.field ptrCne: bool (size: 1, offs: <@0614f8>, cast: static variable(bool))
.field t: int32 (size: 4, offs: <@061500>, cast: static variable(i32))
.field forIdx: int32 (size: 4, offs: <@061508>, cast: static variable(i32))
.field testMathFloor_1: float64 (size: 8, offs: <@061510>, cast: static variable(f64))
.field testMathFloor_2: float64 (size: 8, offs: <@061518>, cast: static variable(f64))
.field testMathFloor_3: float64 (size: 8, offs: <@061520>, cast: static variable(f64))
.field testMathFloor_4: float64 (size: 8, offs: <@061528>, cast: static variable(f64))
.field testMathFloor_5: float64 (size: 8, offs: <@061530>, cast: static variable(f64))
.field testMathFloor_6: float64 (size: 8, offs: <@061538>, cast: static variable(f64))
.field testMathSign_1F: float64 (size: 8, offs: <@061540>, cast: static variable(f64))
.field testMathSign_2F: float64 (size: 8, offs: <@061548>, cast: static variable(f64))
.field testMathSign_3F: float64 (size: 8, offs: <@061550>, cast: static variable(f64))
.field testMathSign_1f: float64 (size: 8, offs: <@061558>, cast: static variable(f64))
.field testMathSign_2f: float64 (size: 8, offs: <@061560>, cast: static variable(f64))
.field testMathSign_3f: float64 (size: 8, offs: <@061568>, cast: static variable(f64))
.field testMathAbs_1F: float64 (size: 8, offs: <@061570>, cast: static variable(f64))
.field testMathAbs_2F: float64 (size: 8, offs: <@061578>, cast: static variable(f64))
.field testMathAbs_3F: float64 (size: 8, offs: <@061580>, cast: static variable(f64))
.field testMathAbs_1f: float64 (size: 8, offs: <@061588>, cast: static variable(f64))
.field testMathAbs_2f: float64 (size: 8, offs: <@061590>, cast: static variable(f64))
.field testMathAbs_3f: float64 (size: 8, offs: <@061598>, cast: static variable(f64))
.field testMathMin_1f: float64 (size: 8, offs: <@0615a0>, cast: static variable(f64))
.field testMathMax_2f: float64 (size: 8, offs: <@0615a8>, cast: static variable(f64))
.field testMathMin_1F: float64 (size: 8, offs: <@0615b0>, cast: static variable(f64))
.field testMathMax_2F: float64 (size: 8, offs: <@0615b8>, cast: static variable(f64))
.field testMathClamp_1f: float64 (size: 8, offs: <@0615c0>, cast: static variable(f64))
.field testMathClamp_1F: float64 (size: 8, offs: <@0615c8>, cast: static variable(f64))
.field testMathLerp_1f: float64 (size: 8, offs: <@0615d0>, cast: static variable(f64))
.field testMathLerp_1F: float64 (size: 8, offs: <@0615d8>, cast: static variable(f64))
.field testMathSmooth_1f: float64 (size: 8, offs: <@0615e0>, cast: static variable(f64))
.field testMathSmooth_1F: float64 (size: 8, offs: <@0615e8>, cast: static variable(f64))
.field testMathMin_nan: float64 (size: 8, offs: <@0615f0>, cast: static variable(f64))
.field testMathMin_1: float64 (size: 8, offs: <@0615f8>, cast: static variable(f64))
.field testMathMax_nan: float64 (size: 8, offs: <@061600>, cast: static variable(f64))
.field testMathMax_9: float64 (size: 8, offs: <@061608>, cast: static variable(f64))
.field testMathSum_0: float64 (size: 8, offs: <@061610>, cast: static variable(f64))
.field testMathSum_1: float64 (size: 8, offs: <@061618>, cast: static variable(f64))
.field testMathSum_3: float64 (size: 8, offs: <@061620>, cast: static variable(f64))
.field testMathSum_55: float64 (size: 8, offs: <@061628>, cast: static variable(f64))
.field testMathEval_x: float64 (size: 8, offs: <@061630>, cast: static variable(f64))
.field testMathEval_0: float64 (size: 8, offs: <@061638>, cast: static variable(f64))
.field testMathEval_1: float64 (size: 8, offs: <@061640>, cast: static variable(f64))
.field testMathEval_2: float64 (size: 8, offs: <@061648>, cast: static variable(f64))
.field testMathEval_3: float64 (size: 8, offs: <@061650>, cast: static variable(f64))
.field testMathEval_4: float64 (size: 8, offs: <@061658>, cast: static variable(f64))
.field testMathEval_5: float64 (size: 8, offs: <@061660>, cast: static variable(f64))
.field testMathEval_6: float64 (size: 8, offs: <@061668>, cast: static variable(f64))
.field testMathSin_f64: float64 (size: 8, offs: <@061670>, cast: static variable(f64))
.field testMathCos_f64: float64 (size: 8, offs: <@061678>, cast: static variable(f64))
.field testMathTan_f64: float64 (size: 8, offs: <@061680>, cast: static variable(f64))
.field testMathSinh_f64: float64 (size: 8, offs: <@061688>, cast: static variable(f64))
.field testMathCosh_f64: float64 (size: 8, offs: <@061690>, cast: static variable(f64))
.field testMathAsin_f64: float64 (size: 8, offs: <@061698>, cast: static variable(f64))
.field testMathAcos_f64: float64 (size: 8, offs: <@0616a0>, cast: static variable(f64))
.field testMathCmp_f32: bool (size: 1, offs: <@0616a8>, cast: static variable(bool))
.field testMathCmp_f64: bool (size: 1, offs: <@0616b0>, cast: static variable(bool))
.field testMathAbsMod_f64_0a: float64 (size: 8, offs: <@0616b8>, cast: static variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, offs: <@0616c0>, cast: static variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, offs: <@0616c8>, cast: static variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, offs: <@0616d0>, cast: static variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, offs: <@0616d8>, cast: static variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, offs: <@0616e0>, cast: static variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, offs: <@0616e8>, cast: static variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, offs: <@0616f0>, cast: static variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, offs: <@0616f8>, cast: static variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, offs: <@061700>, cast: static variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, offs: <@061708>, cast: static variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, offs: <@061710>, cast: static variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, offs: <@061718>, cast: static variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, offs: <@061720>, cast: static variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, offs: <@061728>, cast: static variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, offs: <@061730>, cast: static variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, offs: <@061738>, cast: static variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, offs: <@061740>, cast: static variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, offs: <@061748>, cast: static variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, offs: <@061750>, cast: static variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, offs: <@061758>, cast: static variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, offs: <@061760>, cast: static variable(f32))
.field .main: function (size: 14720, offs: <@061764>, cast: static function)
.value: {
	{
		static byte: typename := uint8;
		static float: typename := float32;
		static double: typename := float64;
		static signed(value: uint8): int8 := int8(value);
		static signed(value: uint16): int16 := int16(value);
		static signed(value: uint32): int32 := int32(value);
		static signed(value: uint64): int64 := int64(value);
		static unsigned(value: int8): uint8 := uint8(value);
		static unsigned(value: int16): uint16 := uint16(value);
		static unsigned(value: int32): uint32 := uint32(value);
		static unsigned(value: int64): uint64 := uint64(value);
		static sizeof(type: typename): int32 := int32(type.size);
		static if (bool(typename(raise) == function)) {
			static verbose(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.verbose, raise.noTrace), message), inspect));
			static verbose(const message: char[*]): void := raise(void(void(void(raise.verbose, raise.noTrace), message), null));
			static debug(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.noTrace), message), inspect));
			static debug(const message: char[*]): void := raise(void(void(void(raise.debug, raise.noTrace), message), null));
			static trace(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.debug, raise.defTrace), message), inspect));
			static trace(const message: char[*]): void := raise(void(void(void(raise.debug, raise.defTrace), message), null));
			static info(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.info, raise.noTrace), message), inspect));
			static info(const message: char[*]): void := raise(void(void(void(raise.info, raise.noTrace), message), null));
			static warn(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.warn, raise.noTrace), message), inspect));
			static warn(const message: char[*]): void := raise(void(void(void(raise.warn, raise.noTrace), message), null));
			static error(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.error, raise.defTrace), message), inspect));
			static error(const message: char[*]): void := raise(void(void(void(raise.error, raise.defTrace), message), null));
			static abort(const message: char[*], const inspect: variant): void := raise(void(void(void(raise.abort, raise.defTrace), message), inspect));
			static abort(const message: char[*]): void := raise(void(void(void(raise.abort, raise.defTrace), message), null));
			static abort(): void := raise(void(void(void(raise.abort, raise.defTrace), "execution aborted!"), null));
			static assert(condition: bool, const message: char[*], const inspect: variant): void := void(condition ? void(0) : abort(void(message, inspect)));
			static assert(condition: bool, const message: char[*]): void := void(condition ? void(0) : abort(message));
			static assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[] := null;
			};
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (bool(returned == expected)) {
					return;
				}
				extras: variant[1] := {
					void(extras[0] := (message));
				};
				details: NotEquals := {
					void(details.expected := (expected));
					void(details.returned := (returned));
					void(details.extras := (extras));
				};
				raise(void(void(void(raise.abort, raise.defTrace), "assertion failed"), details));
			};
			static assertEq(expected: int32, returned: int32): void := assertEq(void(void(expected, returned), null));
		}
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static modf(x: float64, intPart: float64): float64 := {
				if (bool(x < (1))) {
					if (bool(x < (0))) {
						result: float64 := float64(-modf(void(float64(-x), float64(&intPart))));
						float64(intPart := float64(-intPart));
						return float64(.result := result);
					}
					float64(intPart := (0));
					return float64(.result := x);
				}
				result: float64 := float64(x % (1));
				float64(intPart := float64(x - result));
				return float64(.result := result);
			};
			static floor(x: float64): float64 := {
				result: float64;
				modf(void(x, float64(&result)));
				return float64(.result := result);
			};
			static ceil(x: float64): float64 := float64(-floor(float64(-x)));
			static round(x: float64): float64 := floor(float64(x + 0.500000));
			static sign(x: float32): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static sign(x: float64): int32 := int32(int32(bool(x > (0))) - int32(bool(x < (0))));
			static abs(x: float32): float32 := {
				if (bool(x < (0))) {
					return float32(.result := float32(-x));
				}
				return float32(.result := x);
			};
			static abs(x: float64): float64 := {
				if (bool(x < (0))) {
					return float64(.result := float64(-x));
				}
				return float64(.result := x);
			};
			static absMod(val: float32, mod: float32): float32 := {
				if (bool((float32(val := float32(val % mod))) < (0))) {
					return float32(.result := float32(val + mod));
				}
				return float32(.result := val);
			};
			static absMod(val: float64, mod: float64): float64 := {
				if (bool((float64(val := float64(val % mod))) < (0))) {
					return float64(.result := float64(val + mod));
				}
				return float64(.result := val);
			};
			static min(a: float32, b: float32): float32 := {
				if (bool(a < b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static min(a: float64, b: float64): float64 := {
				if (bool(a < b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static max(a: float32, b: float32): float32 := {
				if (bool(a > b)) {
					return float32(.result := a);
				}
				return float32(.result := b);
			};
			static max(a: float64, b: float64): float64 := {
				if (bool(a > b)) {
					return float64(.result := a);
				}
				return float64(.result := b);
			};
			static clamp(t: float32, a: float32, b: float32): float32 := {
				if (bool(t < a)) {
					return float32(.result := a);
				}
				if (bool(t > b)) {
					return float32(.result := b);
				}
				return float32(.result := t);
			};
			static clamp(t: float64, a: float64, b: float64): float64 := {
				if (bool(t < a)) {
					return float64(.result := a);
				}
				if (bool(t > b)) {
					return float64(.result := b);
				}
				return float64(.result := t);
			};
			static lerp(t: float32, a: float32, b: float32): float32 := float32(a + float32(t * (float32(b - a))));
			static lerp(t: float64, a: float64, b: float64): float64 := float64(a + float64(t * (float64(b - a))));
			static smooth(t: float32): float32 := float32(float32(t * t) * (float32((3) - float32((2) * t))));
			static smooth(t: float64): float64 := float64(float64(t * t) * (float64((3) - float64((2) * t))));
			static smooth(t: float32, a: float32, b: float32): float32 := smooth(clamp(void(void(float32((float32(t - a)) / (float32(b - a))), float32(0)), float32(1))));
			static smooth(t: float64, a: float64, b: float64): float64 := smooth(clamp(void(void(float64((float64(t - a)) / (float64(b - a))), float64(0)), float64(1))));
			static min(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result > data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static max(data: float64[]): float64 := {
				if (bool(data.length == (0))) {
					return float64(.result := nan);
				}
				result: float64 := data[0];
				for (i: int32 := 1; bool(i < (data.length)); int32(i := int32(i + 1))) {
					if (bool(result < data[i])) {
						float64(result := data[i]);
					}
				}
				return float64(.result := result);
			};
			static sum(data: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; bool(i < (data.length)); int32(i := int32(i + 1))) {
					float64(result := float64(result + data[i]));
				}
				return float64(.result := result);
			};
			static mean(data: float64[]): float64 := {
				return float64(.result := float64(sum(float64[](...data)) / (signed(data.length))));
			};
			static eval(x: float64, a0: float64): float64 := (a0);
			static eval(x: float64, a0: float64, a1: float64): float64 := (float64(a0 + float64(x * a1)));
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := (float64(a0 + float64(x * eval(void(void(x, a1), a2)))));
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := (float64(a0 + float64(x * eval(void(void(void(x, a1), a2), a3)))));
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := uint32(polynomial.length - (1)); bool(i >= 0); int32(i := int32(i - 1))) {
					float64(result := float64(float64(result * x) + polynomial[i]));
				}
				return float64(.result := result);
			};
			static cmp(a: float32, b: float32, eps: float32): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float32(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float32(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static cmp(a: float64, b: float64, eps: float64): int32 := {
				if (bool(a < b)) {
					if (bool(eps < (float64(b - a)))) {
						return int32(.result := int32(-1));
					}
				}
				else if (bool(eps < (float64(a - b)))) {
					return int32(.result := int32(+1));
				}
				return int32(.result := 0);
			};
			static sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					int32(quad := int32(quad + 2));
				}
				y: float64;
				float64(x := float64(x * float64((1) / PIO2)));
				if (bool(x > (32764))) {
					e: float64;
					float64(y := modf(void(x, float64(&e))));
					float64(e := float64(e + (quad)));
					f: float64;
					modf(void(float64(0.250000 * e), float64(&f)));
					int32(quad := (float64(e - float64((4) * f))));
				}
				else {
					k: int32 := x;
					float64(y := float64(x - (k)));
					int32(quad := int32(quad + k));
					int32(quad := int32(quad & 3));
				}
				if (int32(quad & 1)) {
					float64(y := float64((1) - y));
				}
				if (bool(quad > 1)) {
					float64(y := float64(-y));
				}
				ysq: float64 := float64(y * y);
				temp1: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * ysq) + p3)) * ysq) + p2)) * ysq) + p1)) * ysq) + p0)) * y);
				temp2: float64 := (float64(float64((float64(float64((float64(float64((float64(ysq + q3)) * ysq) + q2)) * ysq) + q1)) * ysq) + q0));
				return float64(.result := float64(temp1 / temp2));
			};
			static sin(arg: float64): float64 := sinCos(void(arg, 0));
			static cos(arg: float64): float64 := sinCos(void(abs(arg), 1));
			static tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (bool(arg < (0))) {
					float64(arg := float64(-arg));
					bool(negate := true);
				}
				float64(arg := float64(float64((2) * arg) / PIO2));
				e: float64;
				x: float64 := modf(void(arg, float64(&e)));
				i: int32 := int32(int32(e) % 4);
				if (bool(i == 0)) ;
				else if (bool(i == 1)) {
					float64(x := float64((1) - x));
					bool(complement := true);
				}
				else if (bool(i == 2)) {
					bool(negate := bool(!negate));
					bool(complement := true);
				}
				else if (bool(i == 3)) {
					float64(x := float64((1) - x));
					bool(negate := bool(!negate));
				}
				xsq: float64 := float64(x * x);
				result: float64 := float64((float64(float64((float64(float64((float64(float64((float64(float64(p4 * xsq) + p3)) * xsq) + p2)) * xsq) + p1)) * xsq) + p0)) * x);
				float64(result := float64(result / float64(float64((float64(float64((float64(xsq + q2)) * xsq) + q1)) * xsq) + q0)));
				if (complement) {
					if (bool(result == (0))) {
						return float64(.result := nan);
					}
					float64(result := float64((1) / result));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static sinh(x: float64): float64 := {
				negate: bool := false;
				if (bool(x < (0))) {
					float64(x := float64(-x));
					bool(negate := true);
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				result: float64;
				if (bool(x > 0.500000)) {
					float64(result := float64((float64(float64.exp(x) - float64.exp(float64(-x)))) / (2)));
				}
				else {
					sq: float64 := float64(x * x);
					float64(result := float64((float64(float64((float64(float64((float64(float64(P3 * sq) + P2)) * sq) + P1)) * sq) + P0)) * x));
					float64(result := float64(result / float64(float64((float64(float64((float64(sq + Q2)) * sq) + Q1)) * sq) + Q0)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static cosh(x: float64): float64 := {
				if (bool(x < (0))) {
					float64(x := float64(-x));
				}
				if (bool(x > (21))) {
					return float64(.result := float64(float64.exp(x) / (2)));
				}
				return float64(.result := float64((float64(float64.exp(x) + float64.exp(float64(-x)))) / (2)));
			};
			static asin(x: float64): float64 := {
				if (bool(x == (0))) {
					return float64(.result := x);
				}
				negate: bool := false;
				if (bool(x < (0))) {
					bool(negate := true);
					float64(x := float64(-x));
				}
				if (bool(x > (1))) {
					return float64(.result := nan);
				}
				result: float64 := float64.sqrt(float64((1) - float64(x * x)));
				if (bool(x > 0.700000)) {
					float64(result := float64(float64(pi / (2)) - float64.atan2(void(result, x))));
				}
				else {
					float64(result := float64.atan2(void(x, result)));
				}
				if (negate) {
					return float64(.result := float64(-result));
				}
				return float64(.result := result);
			};
			static acos(x: float64): float64 := (float64(float64(pi / (2)) - asin(x)));
			static radians(degrees: float64): float64 := float64(float64(float64(degrees * pi) / (180)));
			static degrees(radians: float64): float64 := float64(float64(float64(radians * (180)) / pi));
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(re: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := (0));
		});
		};
		static Complex(re: float64, im: float64): Complex := {
			return void(.result := {
			void(.result.re := re);
			void(.result.im := im);
		});
		};
		static neg(a: Complex): Complex := Complex(emit(void(struct(a), neg.p2d)));
		static add(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), add.p2d)));
		static add(a: Complex, b: float64): Complex := Complex(void(float64(a.re + b), a.im));
		static add(a: float64, b: Complex): Complex := Complex(void(float64(a + b.re), b.im));
		static sub(a: Complex, b: Complex): Complex := Complex(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static sub(a: Complex, b: float64): Complex := Complex(void(float64(a.re - b), a.im));
		static sub(a: float64, b: Complex): Complex := Complex(void(float64(a - b.re), b.im));
		static mul(a: Complex, b: Complex): Complex := Complex(emit(void(void(void(void(void(void(void(void(void(struct(a), struct(b)), swz.x2), mul.p2d), add.f64), struct(a)), struct(b)), mul.p2d), swz.x2), sub.f64)));
		static mul(a: Complex, b: float64): Complex := Complex(void(float64(a.re * b), float64(a.im * b)));
		static mul(a: float64, b: Complex): Complex := Complex(void(float64(a * b.re), float64(a * b.im)));
		static div(a: Complex, b: Complex): Complex := {
			if (bool(Math.abs(b.re) >= Math.abs(b.im))) {
				r: float64 := float64(b.im / b.re);
				den: float64 := float64(b.re + float64(r * b.im));
				return void(.result := {
			void(.result.re := float64((float64(a.re + float64(r * a.im))) / den));
			void(.result.im := float64((float64(a.im - float64(r * a.re))) / den));
		});
			}
			r: float64 := float64(b.re / b.im);
			den: float64 := float64(b.im + float64(r * b.re));
			return void(.result := {
			void(.result.re := float64((float64(float64(a.re * r) + a.im)) / den));
			void(.result.im := float64((float64(float64(a.im * r) - a.re)) / den));
		});
		};
		static div(a: Complex, b: float64): Complex := div(void(a, Complex(b)));
		static div(a: float64, b: Complex): Complex := div(void(Complex(a), b));
		static abs(a: Complex): float64 := float64.sqrt(float64(float64(a.re * a.re) + float64(a.im * a.im)));
		static arg(a: Complex): float64 := float64.atan2(void(a.re, a.im));
		static inv(a: Complex): Complex := {
			d: float64 := float64(float64(a.re * a.re) + float64(a.im * a.im));
			return void(.result := {
			void(.result.re := float64(float64(+a.re) / d));
			void(.result.im := float64(float64(-a.im) / d));
		});
		};
		static conj(a: Complex): Complex := Complex(void(a.re, float64(-a.im)));
		static exp(a: Complex): Complex := Complex(void(float64(float64.exp(a.re) * float64.cos(a.im)), float64(float64.exp(a.re) * float64.sin(a.im))));
		static log(a: Complex): Complex := Complex(void(float64.log(abs(a)), arg(a)));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := float64(float64(b.re * t) + float64(b.im * float64.log(r)));
			v: float64 := float64(float64.pow(void(r, b.re)) * float64.exp(float64(float64(-b.im) * t)));
			return void(.result := {
			void(.result.re := float64(v * float64.cos(u)));
			void(.result.im := float64(v * float64.sin(u)));
		});
		};
		static pow(a: Complex, b: float64): Complex := pow(void(a, Complex(b)));
		static sin(a: Complex): Complex := Complex(void(float64(float64.sin(a.re) * Math.cosh(a.im)), float64(float64(+float64.cos(a.re)) * Math.sinh(a.im))));
		static cos(a: Complex): Complex := Complex(void(float64(float64.cos(a.re) * Math.cosh(a.im)), float64(float64(-float64.sin(a.re)) * Math.sinh(a.im))));
		static tan(a: Complex): Complex := div(void(sin(a), cos(a)));
		static cot(a: Complex): Complex := div(void(cos(a), sin(a)));
		static sinh(a: Complex): Complex := div(void(sub(void(exp(a), exp(neg(a)))), 2));
		static cosh(a: Complex): Complex := div(void(add(void(exp(a), exp(neg(a)))), 2));
		static tanh(a: Complex): Complex := div(void(sub(void(exp(mul(void(2, a))), 1)), add(void(exp(mul(void(2, a))), 1))));
		static coth(a: Complex): Complex := div(void(add(void(exp(mul(void(2, a))), 1)), sub(void(exp(mul(void(2, a))), 1))));
		static sec(a: Complex): Complex := inv(cos(a));
		static csc(a: Complex): Complex := inv(sin(a));
		static sech(a: Complex): Complex := inv(cosh(a));
		static csch(a: Complex): Complex := inv(sinh(a));
		static toCartesian(x: Complex): Complex := Complex(void(float64(x.re * float64.cos(x.im)), float64(x.re * float64.sin(x.im))));
		static toPolar(x: Complex): Complex := Complex(void(abs(x), arg(x)));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		static vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(void(void(void(struct(w), struct(z)), struct(y)), struct(x))));
		static vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(void(void(void(x, y), z), 1.000000));
		static vec4f(x: float32, y: float32): vec4f := vec4f(void(void(void(x, y), 0.000000), 1.000000));
		static vec4f(xyz: vec4f, w: float32): vec4f := vec4f(void(void(void(xyz.x, xyz.y), xyz.z), w));
		static vec4f(val: float32): vec4f := vec4f(void(void(void(val, val), val), val));
		static neg(rhs: vec4f): vec4f := vec4f(emit(void(struct(rhs), neg.p4f)));
		static add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), add.p4f)));
		static sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), sub.p4f)));
		static mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), mul.p4f)));
		static div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), div.p4f)));
		static add(a: float32, b: vec4f): vec4f := add(void(vec4f(a), b));
		static add(a: vec4f, b: float32): vec4f := add(void(a, vec4f(b)));
		static sub(a: float32, b: vec4f): vec4f := sub(void(vec4f(a), b));
		static sub(a: vec4f, b: float32): vec4f := sub(void(a, vec4f(b)));
		static mul(a: float32, b: vec4f): vec4f := mul(void(vec4f(a), b));
		static mul(a: vec4f, b: float32): vec4f := mul(void(a, vec4f(b)));
		static div(a: float32, b: vec4f): vec4f := div(void(vec4f(a), b));
		static div(a: vec4f, b: float32): vec4f := div(void(a, vec4f(b)));
		static min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), min.p4f)));
		static max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(void(void(struct(lhs), struct(rhs)), max.p4f)));
		static clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(void(max(void(vec, min)), max));
		static clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(void(void(vec, vec4f(min)), vec4f(max)));
		static dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp3)));
		static dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dph)));
		static dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(void(void(struct(lhs), struct(rhs)), p4x.dp4)));
		static cross(const a: vec4f, const b: vec4f): vec4f := vec4f(void(void(float32(float32(a.y * b.z) - float32(a.z * b.y)), float32(float32(a.z * b.x) - float32(a.x * b.z))), float32(float32(a.x * b.y) - float32(a.y * b.x))));
		static length(v: vec4f): float32 := float32.sqrt(dp3(void(v, v)));
		static normalize(const v: vec4f): vec4f := div(void(v, vec4f(length(v))));
		static eval(const v: vec4f, x: float32): float32 := float32(float32((float32((float32(float32((float32(float32(v.w * x) + v.z)) * x) + v.y)) * x)) + v.x));
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return void(.result := {
			void(.result.xx := xx);
			void(.result.xy := xy);
			void(.result.xz := xz);
			void(.result.xw := xw);
			void(.result.yx := yx);
			void(.result.yy := yy);
			void(.result.yz := yz);
			void(.result.yw := yw);
			void(.result.zx := zx);
			void(.result.zy := zy);
			void(.result.zz := zz);
			void(.result.zw := zw);
			void(.result.wx := wx);
			void(.result.wy := wy);
			void(.result.wz := wz);
			void(.result.ww := ww);
		});
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
			void(.result.z := z);
			void(.result.w := w);
		});
		};
		static dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp3(void(mat.x, vec)), dp3(void(mat.y, vec))), dp3(void(mat.z, vec))), 1.000000));
		static dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dph(void(mat.x, vec)), dph(void(mat.y, vec))), dph(void(mat.z, vec))), dph(void(mat.w, vec))));
		static dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(void(void(void(dp4(void(mat.x, vec)), dp4(void(mat.y, vec))), dp4(void(mat.z, vec))), dp4(void(mat.w, vec))));
		static transpose(const mat: mat4f): mat4f := {
			return void(.result := {
			void(.result.xx := mat.xx);
			void(.result.xy := mat.yx);
			void(.result.xz := mat.zx);
			void(.result.xw := mat.wx);
			void(.result.yx := mat.xy);
			void(.result.yy := mat.yy);
			void(.result.yz := mat.zy);
			void(.result.yw := mat.wy);
			void(.result.zx := mat.xz);
			void(.result.zy := mat.yz);
			void(.result.zz := mat.zz);
			void(.result.zw := mat.wz);
			void(.result.wx := mat.xw);
			void(.result.wy := mat.yw);
			void(.result.wz := mat.zw);
			void(.result.ww := mat.ww);
		});
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return void(.result := {
			void(.result.x := dp4(void(transposed, lhs.x)));
			void(.result.y := dp4(void(transposed, lhs.y)));
			void(.result.z := dp4(void(transposed, lhs.z)));
			void(.result.w := dp4(void(transposed, lhs.w)));
		});
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if (bool((len) < 0.000000)) {
				trace(void("invalid direction of rotation", direction));
				return void(.result := {
			void(.result.x := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.y := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.z := vec4f(void(void(void(0, 0), 0), 0)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 0)));
		});
			}
			x: float32 := float32(direction.x / len);
			y: float32 := float32(direction.y / len);
			z: float32 := float32(direction.z / len);
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := float32(x * x);
			xy: float32 := float32(x * y);
			xz: float32 := float32(x * z);
			yy: float32 := float32(y * y);
			yz: float32 := float32(y * z);
			zz: float32 := float32(z * z);
			s: float32 := float32.sin(angle);
			c: float32 := float32.cos(angle);
			k: float32 := float32((1) - c);
			return void(.result := {
			void(.result.xx := float32(xx + float32((float32(yy + zz)) * c)));
			void(.result.xy := float32(float32(xy * k) - float32(z * s)));
			void(.result.xz := float32(float32(xz * k) + float32(y * s)));
			void(.result.xw := float32(float32((float32(float32(cx * (float32(yy + zz))) - float32(x * (float32(float32(cy * y) + float32(cz * z)))))) * k) + float32((float32(float32(cy * z) - float32(cz * y))) * s)));
			void(.result.yx := float32(float32(xy * k) + float32(z * s)));
			void(.result.yy := float32(yy + float32((float32(xx + zz)) * c)));
			void(.result.yz := float32(float32(yz * k) - float32(x * s)));
			void(.result.yw := float32(float32((float32(float32(cy * (float32(xx + zz))) - float32(y * (float32(float32(cx * x) + float32(cz * z)))))) * k) + float32((float32(float32(cz * x) - float32(cx * z))) * s)));
			void(.result.zx := float32(float32(xz * k) - float32(y * s)));
			void(.result.zy := float32(float32(yz * k) + float32(x * s)));
			void(.result.zz := float32(zz + float32((float32(xx + yy)) * c)));
			void(.result.zw := float32(float32((float32(float32(cz * (float32(xx + yy))) - float32(z * (float32(float32(cx * x) + float32(cy * y)))))) * k) + float32((float32(float32(cx * y) - float32(cy * x))) * s)));
			void(.result.w := vec4f(void(void(void(0, 0), 0), 1)));
		});
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := rotation(void(void(vec4f(0), direction), angle));
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return void(.result := {
			void(.result.xx := (1));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := float32(direction.x * amount));
			void(.result.yx := (0));
			void(.result.yy := (1));
			void(.result.yz := (0));
			void(.result.yw := float32(direction.y * amount));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := (1));
			void(.result.zw := float32(direction.z * amount));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := bool(((bool(val < (0)) ? float32(-val) : val)) < 0.000000) ? (0) : float32((1) / val);
			return void(.result := {
			void(.result.xx := rcp(float32(direction.x * amount)));
			void(.result.xy := (0));
			void(.result.xz := (0));
			void(.result.xw := (0));
			void(.result.yx := (0));
			void(.result.yy := rcp(float32(direction.y * amount)));
			void(.result.yz := (0));
			void(.result.yw := (0));
			void(.result.zx := (0));
			void(.result.zy := (0));
			void(.result.zz := rcp(float32(direction.z * amount)));
			void(.result.zw := (0));
			void(.result.wx := (0));
			void(.result.wy := (0));
			void(.result.wz := (0));
			void(.result.ww := (1));
		});
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return void(.result := {
			void(.result.x := x);
			void(.result.y := y);
		});
		};
		static add(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), add.p2d)));
		static sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), sub.p2d)));
		static mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), mul.p2d)));
		static div(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), div.p2d)));
		static min(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), min.p2d)));
		static max(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), max.p2d)));
		static ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(void(void(struct(a), struct(b)), ceq.p2d)));
		static dot(const a: vec2d, const b: vec2d): float64 := float64(float64(a.x * b.x) + float64(a.y * b.y));
		static length(const str: char[*]): int32 := {
			if (bool((str) == null)) {
				return int32(.result := 0);
			}
			result: int32 := 0;
			for ( ; str[result]; int32(result := int32(result + 1))) ;
			return int32(.result := result);
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					return int32(.result := i);
				}
			}
			return int32(.result := int32(-1));
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := int32(-1);
			for (i: int32 := 0; str[i]; int32(i := int32(i + 1))) {
				if (bool(str[i] == chr)) {
					int32(result := i);
				}
			}
			return int32(.result := result);
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; bool((with[i]) != 0); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[i], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (bool(strLen < withLen)) {
				return bool(.result := false);
			}
			for (i: int32 := 0; bool(i < withLen); int32(i := int32(i + 1))) {
				if (bool(cmp(void(str[int32(int32(strLen - withLen) + i)], with[i])) != 0)) {
					return bool(.result := false);
				}
			}
			return bool(.result := true);
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; bool(result == 0); int32(i := int32(i + 1))) {
				int32(result := cmp(void(str[i], with[i])));
				if (bool((str[i]) == 0)) {
					break;
				}
			}
			return int32(.result := result);
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (bool(chr < 'A')) {
					return char(.result := chr);
				}
				if (bool(chr > 'Z')) {
					return char(.result := chr);
				}
				return char(.result := char(char(chr - 'A') + 'a'));
			};
			return char(.result := char(ignCase(chr) - ignCase(with)));
		};
		static caseCmp(chr: char, with: char): int32 := {
			return char(.result := char(chr - with));
		};
		static startsWith(const str: char[*], const with: char[*]): bool := startsWith(void(void(str, with), caseCmp));
		static endsWith(const str: char[*], const with: char[*]): bool := endsWith(void(void(str, with), caseCmp));
		static compare(const str: char[*], const with: char[*]): int32 := compare(void(void(str, with), caseCmp));
		static equals(const str: char[*], const with: char[*]): bool := bool(compare(void(void(str, with), caseCmp)) == 0);
		static contains(const str: char[*], chr: char): bool := bool(indexOf(void(str, chr)) >= 0);
		static const FormatFlags: struct {
			const showSign: bool := false;
			const precision: int32 := 0;
			const padChr: char := 0;
			const padLen: int32 := 0;
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; int32(i := int32(i + 1))) {
				if (bool(pos >= (output.length))) {
					break;
				}
				char(output[pos] := value[i]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, sign: char, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			if (format.showSign) {
				if (bool((sign) == 0)) {
					char(sign := '+');
				}
			}
			radix: int32 := format.precision;
			if (bool(radix == 0)) {
				int32(radix := 10);
			}
			assert(void(void(bool(radix > 1), "radix is too small"), radix));
			assert(void(void(bool(radix < (radixDigits.length)), "radix is too big"), radix));
			for ( ; bool(value > (0)); uint64(value := uint64(value / (radix)))) {
				char(digits[int32(len := int32(len + 1))] := radixDigits[uint64(value % (radix))]);
			}
			if (bool(len == 0)) {
				char(digits[int32(len := int32(len + 1))] := '0');
			}
			maxLen: int32 := int32(format.padLen - len);
			padChr: char := format.padChr;
			if (bool(padChr == '')) {
				char(padChr := ' ');
			}
			if (bool((sign) != 0)) {
				int32(maxLen := int32(maxLen - 1));
				if (contains(void(whiteSpace, padChr))) {
					for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
						assert(bool(pos < (output.length)));
						char(output[pos] := padChr);
						int32(pos := int32(pos + 1));
					}
				}
				assert(bool(pos < (output.length)));
				char(output[pos] := sign);
				int32(pos := int32(pos + 1));
			}
			for ( ; bool(maxLen > 0); int32(maxLen := int32(maxLen - 1))) {
				assert(bool(pos < (output.length)));
				char(output[pos] := padChr);
				int32(pos := int32(pos + 1));
			}
			for (i: int32 := 0; bool(i < len); int32(i := int32(i + 1))) {
				assert(bool(i < (output.length)));
				char(output[pos] := digits[int32(len - i)]);
				int32(pos := int32(pos + 1));
			}
			if (bool(pos >= (output.length))) {
				int32(pos := (uint32(output.length - (1))));
			}
			char(output[pos] := (0));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), 0), uint64(value)), format));
		static append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < (0)) ? ('-') : 0), uint64(bool(value < (0)) ? int64(-value) : value)), format));
		static append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool(value < 0) ? ('-') : 0), uint64(bool(value < 0) ? int32(-value) : value)), format));
		static append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int16(-value) : value)), format));
		static append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(void(void(void(void(output, pos), bool((value) < 0) ? ('-') : 0), uint64(bool((value) < 0) ? int8(-value) : value)), format));
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				void(formatInt.showSign := format.showSign);
				void(formatInt.precision := 0);
				void(formatInt.padChr := format.padChr);
				void(formatInt.padLen := int32(format.padLen - format.precision));
			};
			formatDec: FormatFlags := {
				void(formatDec.showSign := false);
				void(formatDec.precision := 0);
				void(formatDec.padChr := '0');
				void(formatDec.padLen := format.precision);
			};
			sign: char := bool(value < (0)) ? ('-') : 0;
			fract: float64 := Math.modf(void(Math.abs(value), float64(&value)));
			int32(pos := append(void(output, void(void(void(pos, sign), uint64(int64(value))), formatInt))));
			int32(pos := append(void(output, void(pos, "."))));
			float64(fract := float64(fract * float64.pow(void(10, format.precision))));
			int32(pos := append(void(output, void(void(void(pos, 0), uint64(int64(fract))), formatDec))));
			return int32(.result := pos);
		};
		static append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(void(void(void(output, pos), float64(value)), format));
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				void(format.showSign := false);
				void(format.precision := 0);
				void(format.padChr := (0));
				void(format.padLen := 0);
			};
			return int32(.result := append(void(void(void(output, pos), value), format)));
		};
	}
	{
		static integer: typename := int64;
		static emitldz32: int32 := emit(load.z32);
		static emitldz64: int64 := emit(load.z64);
		static emitA: int32 := 42;
		static emitB: int32 := 96;
		static emitAddI32: int32 := emit(void(void(int32(emitA), int32(emitB)), add.i32));
		static emitDivI32: int32 := emit(void(void(int32(10), int32(5)), div.i32));
		static emitNfcF32: float32 := emit(void(void(void(float32(3.140000), float32(2)), div.f32), float32.sin));
		static floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		static floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		static emitFloatAsInt1: int32 := floatAsInt32(500);
		static emitFloatAsInt2: int64 := floatAsInt32(500);
		static emitFloatAsInt3: int32 := floatAsInt64(500);
		static emitFloatAsInt4: int64 := floatAsInt64(500);
		static emitSlice: char[] := emit(void(int32(3), pointer("string")));
		static zero(a: int32, b: int32): int32 := 0;
		static last(a: int32, b: int32): int32 := b;
		static sum(a: int32, b: int32): int32 := int32(a + b);
		static any(a: int32, b: int32): int32 := (a) ? a : b;
		static min(a: int32, b: int32): int32 := bool(a < b) ? a : b;
		static max(a: int32, b: int32): int32 := bool(a > b) ? a : b;
		static i3: int32 := 3;
		static i6: int32 := 6;
		static i2: int32 := 2;
		static i8: int32 := 8;
		static zeroVal: int32 := zero(void(3, 6));
		static zeroVar: int32 := zero(void(i3, i6));
		static zeroXpr: int32 := zero(void(int32(i3 + 1), int32(i6 + 1)));
		static lastVal: int32 := last(void(3, 6));
		static lastVar: int32 := last(void(i3, i6));
		static lastXpr: int32 := int32(last(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sum2Val: int32 := sum(void(3, 6));
		static sum2Var: int32 := sum(void(i3, i6));
		static sum2Xpr: int32 := int32(sum(void(int32(i3 + 1), int32(i6 + 1))) - 2);
		static any2Val: int32 := any(void(3, 6));
		static any2Var: int32 := any(void(i3, i6));
		static any2Xpr: int32 := int32(any(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static min2Val: int32 := min(void(3, 6));
		static min2Var: int32 := min(void(i3, i6));
		static min2Xpr: int32 := int32(min(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static max2Val: int32 := max(void(3, 6));
		static max2Var: int32 := max(void(i3, i6));
		static max2Xpr: int32 := int32(max(void(int32(i3 + 1), int32(i6 + 1))) - 1);
		static sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(a, sum(void(b, sum(void(c, d))))));
		static sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(void(sum(void(sum(void(a, b)), c)), d));
		static sumRlVal: int32 := sumLr(void(void(void(3, 6), 2), 8));
		static sumLrVal: int32 := sumRl(void(void(void(3, 6), 2), 8));
		static sumRlVar: int32 := sumLr(void(void(void(i3, i6), i2), i8));
		static sumLrVar: int32 := sumRl(void(void(void(i3, i6), i2), i8));
		static sumRlXpr: int32 := int32(sumLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static sumLrXpr: int32 := int32(sumRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 4);
		static anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(void(a, any(void(b, any(void(c, d))))));
		static anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(void(any(void(any(void(a, b)), c)), d));
		static anyRlVal: int32 := anyLr(void(void(void(3, 6), 2), 8));
		static anyLrVal: int32 := anyRl(void(void(void(3, 6), 2), 8));
		static anyRlVar: int32 := anyLr(void(void(void(i3, i6), i2), i8));
		static anyLrVar: int32 := anyRl(void(void(void(i3, i6), i2), i8));
		static anyRlXpr: int32 := int32(anyLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static anyLrXpr: int32 := int32(anyRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(void(a, min(void(b, min(void(c, d))))));
		static minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(void(min(void(min(void(a, b)), c)), d));
		static minRlVal: int32 := minLr(void(void(void(3, 6), 2), 8));
		static minLrVal: int32 := minRl(void(void(void(3, 6), 2), 8));
		static minRlVar: int32 := minLr(void(void(void(i3, i6), i2), i8));
		static minLrVar: int32 := minRl(void(void(void(i3, i6), i2), i8));
		static minRlXpr: int32 := int32(minLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static minLrXpr: int32 := int32(minRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(void(a, max(void(b, max(void(c, d))))));
		static maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(void(max(void(max(void(a, b)), c)), d));
		static maxRlVal: int32 := maxLr(void(void(void(3, 6), 2), 8));
		static maxLrVal: int32 := maxRl(void(void(void(3, 6), 2), 8));
		static maxRlVar: int32 := maxLr(void(void(void(i3, i6), i2), i8));
		static maxLrVar: int32 := maxRl(void(void(void(i3, i6), i2), i8));
		static maxRlXpr: int32 := int32(maxLr(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static maxLrXpr: int32 := int32(maxRl(void(void(void(int32(i3 + 1), int32(i6 + 1)), int32(i2 + 1)), int32(i8 + 1))) - 1);
		static overload: typename := 1;
		static overload(): int32 := 2;
		static overload(a: int32): int32 := 3;
		static overload(a: float32): int32 := 4;
		static overload(a: int32, b: int32): int32 := 5;
		static overload1: float32 := overload;
		static overload2: float32 := overload();
		static overload3: float32 := overload(0);
		static overload4: float32 := overload(0.000000);
		static overload5: float32 := overload(void(0, 0));
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		static Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		static Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		static Celsius(value: Fahrenheit): Celsius := Celsius(float64((float64(value.degrees - (32))) / 1.800000));
		static Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(float64(float64(value.degrees * 1.800000) + (32)));
		static boilC: Celsius := Celsius(100.000000);
		static boilF: Fahrenheit := Fahrenheit(boilC);
		static pi64: float64 := 3.141593;
		static e64: float64 := 2.718282;
		static pi32: float32 := pi64;
		static e32: float32 := e64;
		static rgb888(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 16) & 16711680) | int32(int32(g << 8) & 65280)) | int32(b & 255));
		static rgb565(r: int32, g: int32, b: int32): int32 := int32(int32(int32(int32(r << 8) & 63488) | int32(int32(g << 3) & 2016)) | int32(int32(b >> 3) & 31));
		static r_comp: int32 := int32(14 << 3);
		static g_comp: int32 := int32(63 << 2);
		static b_comp: int32 := int32(31 << 3);
		static r5g6b5: int32 := rgb565(void(void(r_comp, g_comp), b_comp));
		static r8g8b8: int32 := rgb888(void(void(r_comp, g_comp), b_comp));
		static zxtR5: int32 := uint32.zxt(void(void(r5g6b5, 11), 5));
		static zxtG6: int32 := uint32.zxt(void(void(r5g6b5, 5), 6));
		static zxtB5: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static sxtR5: int32 := uint32.sxt(void(void(r5g6b5, 11), 5));
		static sxtG6: int32 := uint32.sxt(void(void(r5g6b5, 5), 6));
		static sxtB5: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static zxtR8: int32 := uint32.zxt(void(void(r8g8b8, 16), 8));
		static zxtG8: int32 := uint32.zxt(void(void(r8g8b8, 8), 8));
		static zxtB8: int32 := uint32.zxt(void(void(r8g8b8, 0), 8));
		static sxtR8: int32 := uint32.sxt(void(void(r8g8b8, 16), 8));
		static sxtG8: int32 := uint32.sxt(void(void(r8g8b8, 8), 8));
		static sxtB8: int32 := uint32.sxt(void(void(r8g8b8, 0), 8));
		static testSin_f64: float64 := float64.sin(float64(pi64 / (2)));
		static testCos_f64: float64 := float64.cos(float64(pi64 / (2)));
		static testTan_f64: float64 := float64.tan(float64(pi64 / (4)));
		static testLog_f64: float64 := float64.log(float64(float64(e64 * e64) * e64));
		static testExp_f64: float64 := float64.exp(1.000000);
		static testPow_f64: float64 := float64.pow(void(float64(pi64 * pi64), 0.500000));
		static testSqrt_f64: float64 := float64.sqrt(float64(pi64 * pi64));
		static testAtan_f64: float64 := float64.atan2(void(pi64, 1.000000));
		static testSin_f32: float32 := float32.sin(float32(pi32 / (2)));
		static testCos_f32: float32 := float32.cos(float32(pi32 / (2)));
		static testTan_f32: float32 := float32.tan(float32(pi32 / (4)));
		static testLog_f32: float32 := float32.log(float32(float32(e32 * e32) * e32));
		static testExp_f32: float32 := float32.exp(1.000000);
		static testPow_f32: float32 := float32.pow(void(float32(pi32 * pi32), 0.500000));
		static testSqrt_f32: float32 := float32.sqrt(float32(pi32 * pi32));
		static testAtan_f32: float32 := float32.atan2(void(pi32, 1.000000));
		static testPopulation_u32: int32 := uint32.pop(r5g6b5);
		static testSwapBits_u32: uint32 := uint32.swap(r5g6b5);
		static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5);
		static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5);
		static testHighBit_u32: int32 := uint32.hib(r5g6b5);
		static testLowBit_u32: int32 := uint32.lob(r5g6b5);
		static testZeroExtend_u32: int32 := uint32.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u32: int32 := uint32.sxt(void(void(r5g6b5, 0), 5));
		static testZeroExtend_u64: int32 := uint64.zxt(void(void(r5g6b5, 0), 5));
		static testSignExtend_u64: int32 := uint64.sxt(void(void(r5g6b5, 0), 5));
		static realloc(data: pointer, size: int32): pointer := pointer.alloc(void(data, size));
		static malloc(size: int32): pointer := pointer.alloc(void(null, size));
		static free(data: pointer): pointer := pointer.alloc(void(data, 0));
		static p1: pointer := malloc(1024);
		static p2: pointer := malloc(80);
		static p3: pointer := malloc(160);
		static p4: pointer := malloc(820);
		pointer.fill(void(void(p1, 0), 1024));
		pointer.copy(void(void(p1, p3), 160));
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		static val1: int64 := 42;
		static val2: int64 := 96;
		debug(void("val1", val1));
		debug(void("val2", val2));
		pointer.move(void(void(pointer(val2), pointer(val1)), sizeof(int64)));
		pointer.fill(void(void(pointer(val1), 0), sizeof(int64)));
		debug(void("val1", val1));
		debug(void("val2", val2));
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := int32(3 / 0);
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				void(details.message := ("assertion failed"));
				void(details.expected := 97);
				void(details.returned := 77);
			};
			abort(void("fatal error", details));
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(void(load.z32, ret));
		};
		static tryExecErr0: int32 := tryExec(void(null, noError));
		static tryExecErr1: int32 := tryExec(void(null, null));
		static tryExecErr2: int32 := tryExec(void(null, stackOverflow));
		static tryExecErr3: int32 := tryExec(void(null, divisionByZero));
		static tryExecErr4: int32 := tryExec(void(null, invalidInstruction));
		static tryExecErr5: int32 := tryExec(void(null, invalidMemoryAccess));
		static tryExecErr6: int32 := tryExec(void(null, abortExecution));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		static valueRef: int64 := value;
		static valuePtr: pointer := value;
		static valueVar: variant := value;
		static fromRef: int64 := valueRef;
		static fromPtr: int64 := valuePtr;
		static fromVar: int64 := valueVar;
		static nullRef: int64 := null;
		static nullPtr: pointer := null;
		static nullVar: variant := null;
		static nullTyp: typename := null;
		static nullFun: function := null;
		static nullObj: object := null;
		static typePtr: pointer := int64;
		static typeVar: variant := int64;
		static typeTyp: typename := int64;
		static local: int64 := value;
		static copyVal: int64 := local;
		static copyRef: int64 := valueRef;
		static copyPtr: pointer := valuePtr;
		static copyVar: variant := valueVar;
		static copyTyp: typename := typeTyp;
		static ptrVoid: pointer := void;
		static ptrBool: pointer := bool;
		static ptrChar: pointer := char;
		static ptrInt8: pointer := int8;
		static ptrInt16: pointer := int16;
		static ptrInt32: pointer := int32;
		static ptrInt64: pointer := int64;
		static ptrUint8: pointer := uint8;
		static ptrUint16: pointer := uint16;
		static ptrUint32: pointer := uint32;
		static ptrUint64: pointer := uint64;
		static ptrFloat32: pointer := float32;
		static ptrFloat64: pointer := float64;
		static ptrTypename: pointer := typename;
		static ptrFunction: pointer := function;
		static ptrPointer: pointer := pointer;
		static ptrVariant: pointer := variant;
		static ptrObject: pointer := object;
		static varVoid: variant := void;
		static varBool: variant := bool;
		static varChar: variant := char;
		static varInt8: variant := int8;
		static varInt16: variant := int16;
		static varInt32: variant := int32;
		static varInt64: variant := int64;
		static varUint8: variant := uint8;
		static varUint16: variant := uint16;
		static varUint32: variant := uint32;
		static varUint64: variant := uint64;
		static varFloat32: variant := float32;
		static varFloat64: variant := float64;
		static varTypename: variant := typename;
		static varFunction: variant := function;
		static varPointer: variant := pointer;
		static varVariant: variant := variant;
		static varObject: variant := object;
		static typVoid: typename := void;
		static typBool: typename := bool;
		static typChar: typename := char;
		static typInt8: typename := int8;
		static typInt16: typename := int16;
		static typInt32: typename := int32;
		static typInt64: typename := int64;
		static typUint8: typename := uint8;
		static typUint16: typename := uint16;
		static typUint32: typename := uint32;
		static typUint64: typename := uint64;
		static typFloat32: typename := float32;
		static typFloat64: typename := float64;
		static typTypename: typename := typename;
		static typFunction: typename := function;
		static typPointer: typename := pointer;
		static typVariant: typename := variant;
		static typObject: typename := object;
		static valueOfPtr: pointer := pointer(value);
		static valueOfVar: variant := variant(value);
		static valueOfTyp: typename := typename(value);
		static typeOfValue: typename := typename(value);
		static copyPtrFloat64: variant := ptrFloat64;
		static copyVarFloat64: pointer := varFloat64;
		static variable: int32;
		static const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static valInitImplicit: ComplexVal := {
			void(valInitImplicit.re := (8));
			void(valInitImplicit.im := (0));
		};
		static objInitImplicit: ComplexObj := {
			void(objInitImplicit := create(ComplexObj));
			void(objInitImplicit.re := (8));
			void(objInitImplicit.im := (0));
		};
		static objInitExplicit: object := {
			void(objInitExplicit := create(ComplexObj));
			void(objInitExplicit.re := (8));
			void(objInitExplicit.im := (0));
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return int32(.result := int32(x + y));
		};
		static funAddResult: int32 := funAdd(void(2, 7));
		static funAddRef(x: int32, y: int32): int32 := funAdd;
		static funAddRefResult: int32 := funAddRef(void(2, 8));
		static funMul(x: int32, y: int32): int32 := funMul;
		static funMulResult: int32 := funMul(void(2, 6));
		static funMulRef(x: int32, y: int32): int32 := funMul;
		static funMulRefResult: int32 := funMulRef(void(2, 7));
		static funMul(x: int32, y: int32): int32 := {
			return int32(.result := int32(x * y));
		};
		static fib(n: uint32): uint32 := {
			if (bool(n <= (1))) {
				return uint32(.result := n);
			}
			return uint32(.result := uint32(fib(uint32(n - (1))) + fib(uint32(n - (2)))));
		};
		static fibonacci_13: uint32 := fib(13);
		static sizeofVoid: int32 := sizeof(void);
		static sizeofBool: int32 := sizeof(bool);
		static sizeofChar: int32 := sizeof(char);
		static sizeofInt8: int32 := sizeof(int8);
		static sizeofInt16: int32 := sizeof(int16);
		static sizeofInt32: int32 := sizeof(int32);
		static sizeofInt64: int32 := sizeof(int64);
		static sizeofUint8: int32 := sizeof(uint8);
		static sizeofUint16: int32 := sizeof(uint16);
		static sizeofUint32: int32 := sizeof(uint32);
		static sizeofUint64: int32 := sizeof(uint64);
		static sizeofFloat32: int32 := sizeof(float32);
		static sizeofFloat64: int32 := sizeof(float64);
		static sizeofPointer: int32 := sizeof(pointer);
		static sizeofVariant: int32 := sizeof(variant);
		static sizeofTypename: int32 := sizeof(typename);
		static sizeofFunction: int32 := sizeof(function);
		static sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static typeofRecord: typename := RecordSizeofExt;
		static nameOfRecord: char[*] := typename.name(typeofRecord);
		static offsetOfRecord: int32 := typeofRecord.offset;
		static sizeOfRecord: int32 := sizeof(typeofRecord);
		static fileOfRecord: char[*] := typename.file(typeofRecord);
		static lineOfRecord: int32 := typename.line(typeofRecord);
		static typeofBase: typename := typename.base(typeofRecord);
		static nameOfBase: char[*] := typename.name(typeofBase);
		static offsetOfBase: int32 := typeofBase.offset;
		static sizeOfBase: int32 := sizeof(typeofBase);
		static fileOfBase: char[*] := typename.file(typeofBase);
		static lineOfBase: int32 := typename.line(typeofBase);
		static typeofBase1: typename := typename.base(typeofBase);
		static offsetOfBase1: int32 := typeofBase1.offset;
		static sizeOfBase1: int32 := typeofBase1.size;
		static typeofBase2: typename := typename.base(typeofBase1);
		static offsetOfBase2: int32 := typeofBase2.offset;
		static sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				void(globalRec.constant := 4);
				void(globalRec.member := (0));
			};
			static globalRecInit: Inner := {
				void(globalRecInit.member := 4);
				void(globalRecInit.constant := 5);
			};
			static const globalConstantRec: Inner := {
				void(globalConstantRec.member := 6);
				void(globalConstantRec.constant := 7);
			};
		};
		static recordMemberTest: RecordMemberTest := {
			void(recordMemberTest.member := 10);
			void(recordMemberTest.constant := 11);
			void(recordMemberTest.memberInit := 12);
			void(recordMemberTest.constantInit := 13);
			void(recordMemberTest.memberRec.member := 14);
			void(recordMemberTest.memberRec.constant := 15);
			void(recordMemberTest.constantRec.member := 16);
			void(recordMemberTest.constantRec.constant := 17);
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("staticMethod", x));
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("virtualMethod", x));
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace(void("forwardMethod", x));
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace(void("globalFunction", x));
		};
		static recordMethodTest: RecordMethodTest := {
			void(recordMethodTest.abstractMethod := globalFunction);
			void(recordMethodTest.delegateMethod := forwardMethod);
			void(recordMethodTest.virtualMethod := virtualMethod);
		};
		recordMethodTest.staticMethod(void(recordMethodTest, 1));
		recordMethodTest.virtualMethod(void(recordMethodTest, 1));
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if (bool((this) != null)) {
				RecordMethodTest.staticMethod(void(this, x));
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if (bool((this) != null)) {
				this.virtualMethod(void(this, x));
			}
		};
		staticMethod(void(recordMethodTest, 2));
		virtualMethod(void(recordMethodTest, 2));
		RecordMethodTest.staticMethod(void(recordMethodTest, 3));
		RecordMethodTest.virtualMethod(void(recordMethodTest, 3));
		recordMethodTest.virtualMethod(void(recordMethodTest, 3));
		static if (bool((typename(int64)) == null)) {
			integer: typename := int32;
		}
		static arrFixedInit: int64[7] := {
			void(arrFixedInit[0] := (42));
			void(arrFixedInit[1] := (43));
			void(arrFixedInit[2] := (44));
			void(arrFixedInit[3] := (45));
			void(arrFixedInit[4] := (46));
			void(arrFixedInit[5] := (47));
			void(arrFixedInit[6] := (48));
		};
		static arrArrayInitNull: int64[*] := null;
		static arrSliceInitNull: int64[] := null;
		static arrArrayInitFixed: int64[*] := arrFixedInit;
		static arrSliceInitFixed: int64[] := arrFixedInit;
		static arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		static arrSliceInitSlice: int64[] := arrSliceInitFixed;
		static arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		static strFixed: char[7] := {
			void(strFixed[0] := 's');
			void(strFixed[1] := 't');
			void(strFixed[2] := 'r');
			void(strFixed[3] := 'i');
			void(strFixed[4] := 'n');
			void(strFixed[5] := 'g');
			void(strFixed[6] := (0));
		};
		debug(void("string as variant", strFixed));
		static strArray: char[*] := "string";
		debug(void("string as variant", strArray));
		static strSlice: char[] := "string";
		debug(void("string as variant", strSlice));
		assert(bool(arrSliceInitNull.length == (0)));
		assert(bool(arrFixedInit[0] == (42)));
		static lenSlice(const values: int64[]): int32 := {
			return uint32(.result := values.length);
		};
		static nthFixed(idx: int32, const values: int64[7]): int64 := {
			return int64(.result := values[idx]);
		};
		static nthArray(idx: int32, const values: int64[*]): int64 := {
			return int64(.result := values[idx]);
		};
		static nthSlice(idx: int32, const values: int64[]): int64 := {
			return int64(.result := values[idx]);
		};
		assertEq(void(7, arrFixedInit.(length)));
		assertEq(void(arrFixedInit.(length), arrSliceInitFixed.length));
		assertEq(void(arrFixedInit.(length), arrSliceInitSlice.length));
		assertEq(void(0, lenSlice(null)));
		assertEq(void(0, lenSlice(arrSliceInitNull)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrFixedInit)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrSliceInitFixed)));
		assertEq(void(arrFixedInit.(length), lenSlice(arrSliceInitSlice)));
		for (i: int32 := 0; bool(i < arrFixedInit.(length)); int32(i := int32(i + 1))) {
			expected: int64 := int32(42 + i);
			assert(bool(expected == arrFixedInit[i]));
			assert(bool(expected == arrArrayInitFixed[i]));
			assert(bool(expected == arrSliceInitFixed[i]));
			assert(bool(expected == nthFixed(void(i, arrFixedInit))));
			assert(bool(expected == nthFixed(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthFixed(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthArray(void(i, arrFixedInit))));
			assert(bool(expected == nthArray(void(i, arrArrayInitFixed))));
			assert(bool(expected == nthArray(void(i, arrSliceInitFixed))));
			assert(bool(expected == nthSlice(void(i, arrFixedInit))));
			assert(bool(expected == nthSlice(void(i, arrSliceInitFixed))));
			assert(bool(expected == arrSliceInitSlice[i]));
		}
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(6);
			static const as(this: object, type: typename): pointer := nfc(7);
		};
		static black: rgbU8 := {
			void(black.r := (0));
			void(black.g := (0));
			void(black.b := (0));
		};
		static green: rgbU8 := {
			void(green.r := (0));
			void(green.g := (255));
			void(green.b := (0));
		};
		static white: rgbU8 := {
			void(white.r := (255));
			void(white.g := (255));
			void(white.b := (255));
		};
		static cyan: color := {
			void(cyan.col := (65535));
		};
		static blue: color := {
			void(blue.rgb.r := (0));
			void(blue.rgb.g := (0));
			void(blue.rgb.b := (255));
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static a: typename := 96.300000;
		static b: typename := 42.140000;
		static shift: int32 := 2;
		static boolA: bool := true;
		static boolB: bool := bool(!false);
		static boolAnd: bool := bool(boolA & boolB);
		static boolIor: bool := bool(boolA | boolB);
		static boolXor: bool := bool(boolA ^ boolB);
		static boolNot: bool := bool(!boolB);
		static boolCeq: bool := bool(boolA == boolB);
		static boolCne: bool := bool(boolA != boolB);
		static boolClt: bool := bool(boolA < boolB);
		static boolCle: bool := bool(boolA <= boolB);
		static boolCgt: bool := bool(boolA > boolB);
		static boolCge: bool := bool(boolA >= boolB);
		static chrA: char := 'a';
		static chrB: char := 'b';
		static chrPls: char := char(+chrB);
		static chrNeg: char := char(-chrB);
		static chrCmt: char := char(~chrB);
		static chrAdd: char := char(chrA + chrB);
		static chrSub: char := char(chrA - chrB);
		static chrMul: char := char(chrA * chrB);
		static chrDiv: char := char(chrA / chrB);
		static chrMod: char := char(chrA % chrB);
		static chrAnd: char := char(chrA & chrB);
		static chrIor: char := char(chrA | chrB);
		static chrXor: char := char(chrA ^ chrB);
		static chrShl: char := int32((chrA) << shift);
		static chrShr: char := int32((chrA) >> shift);
		static chrNot: bool := bool(!(chrB));
		static chrCeq: bool := bool(chrA == chrB);
		static chrCne: bool := bool(chrA != chrB);
		static chrClt: bool := bool(chrA < chrB);
		static chrCle: bool := bool(chrA <= chrB);
		static chrCgt: bool := bool(chrA > chrB);
		static chrCge: bool := bool(chrA >= chrB);
		static i8A: int8 := a;
		static i8B: int8 := b;
		static i8Pls: int8 := int8(+i8B);
		static i8Neg: int8 := int8(-i8B);
		static i8Cmt: int8 := int8(~i8B);
		static i8Add: int8 := int8(i8A + i8B);
		static i8Sub: int8 := int8(i8A - i8B);
		static i8Mul: int8 := int8(i8A * i8B);
		static i8Div: int8 := int8(i8A / i8B);
		static i8Mod: int8 := int8(i8A % i8B);
		static i8And: int8 := int8(i8A & i8B);
		static i8Ior: int8 := int8(i8A | i8B);
		static i8Xor: int8 := int8(i8A ^ i8B);
		static i8Shl: int8 := int32((i8A) << shift);
		static i8Shr: int8 := int32((i8A) >> shift);
		static i8Not: bool := bool(!(i8B));
		static i8Ceq: bool := bool(i8A == i8B);
		static i8Cne: bool := bool(i8A != i8B);
		static i8Clt: bool := bool(i8A < i8B);
		static i8Cle: bool := bool(i8A <= i8B);
		static i8Cgt: bool := bool(i8A > i8B);
		static i8Cge: bool := bool(i8A >= i8B);
		static u8A: uint8 := a;
		static u8B: uint8 := b;
		static u8Pls: uint8 := uint8(+u8B);
		static u8Neg: uint8 := uint8(-u8B);
		static u8Cmt: uint8 := uint8(~u8B);
		static u8Add: uint8 := uint8(u8A + u8B);
		static u8Sub: uint8 := uint8(u8A - u8B);
		static u8Mul: uint8 := uint8(u8A * u8B);
		static u8Div: uint8 := uint8(u8A / u8B);
		static u8Mod: uint8 := uint8(u8A % u8B);
		static u8And: uint8 := uint8(u8A & u8B);
		static u8Ior: uint8 := uint8(u8A | u8B);
		static u8Xor: uint8 := uint8(u8A ^ u8B);
		static u8Shl: uint8 := int32((u8A) << shift);
		static u8Shr: uint8 := int32((u8A) >> shift);
		static u8Not: bool := bool(!(u8B));
		static u8Ceq: bool := bool(u8A == u8B);
		static u8Cne: bool := bool(u8A != u8B);
		static u8Clt: bool := bool(u8A < u8B);
		static u8Cle: bool := bool(u8A <= u8B);
		static u8Cgt: bool := bool(u8A > u8B);
		static u8Cge: bool := bool(u8A >= u8B);
		static i16A: int16 := a;
		static i16B: int16 := b;
		static i16Pls: int16 := int16(+i16B);
		static i16Neg: int16 := int16(-i16B);
		static i16Cmt: int16 := int16(~i16B);
		static i16Add: int16 := int16(i16A + i16B);
		static i16Sub: int16 := int16(i16A - i16B);
		static i16Mul: int16 := int16(i16A * i16B);
		static i16Div: int16 := int16(i16A / i16B);
		static i16Mod: int16 := int16(i16A % i16B);
		static i16And: int16 := int16(i16A & i16B);
		static i16Ior: int16 := int16(i16A | i16B);
		static i16Xor: int16 := int16(i16A ^ i16B);
		static i16Shl: int16 := int32((i16A) << shift);
		static i16Shr: int16 := int32((i16A) >> shift);
		static i16Not: bool := bool(!(i16B));
		static i16Ceq: bool := bool(i16A == i16B);
		static i16Cne: bool := bool(i16A != i16B);
		static i16Clt: bool := bool(i16A < i16B);
		static i16Cle: bool := bool(i16A <= i16B);
		static i16Cgt: bool := bool(i16A > i16B);
		static i16Cge: bool := bool(i16A >= i16B);
		static u16A: uint16 := a;
		static u16B: uint16 := b;
		static u16Pls: uint16 := uint16(+u16B);
		static u16Neg: uint16 := uint16(-u16B);
		static u16Cmt: uint16 := uint16(~u16B);
		static u16Add: uint16 := uint16(u16A + u16B);
		static u16Sub: uint16 := uint16(u16A - u16B);
		static u16Mul: uint16 := uint16(u16A * u16B);
		static u16Div: uint16 := uint16(u16A / u16B);
		static u16Mod: uint16 := uint16(u16A % u16B);
		static u16And: uint16 := uint16(u16A & u16B);
		static u16Ior: uint16 := uint16(u16A | u16B);
		static u16Xor: uint16 := uint16(u16A ^ u16B);
		static u16Shl: uint16 := int32((u16A) << shift);
		static u16Shr: uint16 := int32((u16A) >> shift);
		static u16Not: bool := bool(!(u16B));
		static u16Ceq: bool := bool(u16A == u16B);
		static u16Cne: bool := bool(u16A != u16B);
		static u16Clt: bool := bool(u16A < u16B);
		static u16Cle: bool := bool(u16A <= u16B);
		static u16Cgt: bool := bool(u16A > u16B);
		static u16Cge: bool := bool(u16A >= u16B);
		static i32A: int32 := a;
		static i32B: int32 := b;
		static i32Pls: int32 := int32(+i32B);
		static i32Neg: int32 := int32(-i32B);
		static i32Cmt: int32 := int32(~i32B);
		static i32Add: int32 := int32(i32A + i32B);
		static i32Sub: int32 := int32(i32A - i32B);
		static i32Mul: int32 := int32(i32A * i32B);
		static i32Div: int32 := int32(i32A / i32B);
		static i32Mod: int32 := int32(i32A % i32B);
		static i32And: int32 := int32(i32A & i32B);
		static i32Ior: int32 := int32(i32A | i32B);
		static i32Xor: int32 := int32(i32A ^ i32B);
		static i32Shl: int32 := int32(i32A << shift);
		static i32Shr: int32 := int32(i32A >> shift);
		static i32Not: bool := bool(!(i32B));
		static i32Ceq: bool := bool(i32A == i32B);
		static i32Cne: bool := bool(i32A != i32B);
		static i32Clt: bool := bool(i32A < i32B);
		static i32Cle: bool := bool(i32A <= i32B);
		static i32Cgt: bool := bool(i32A > i32B);
		static i32Cge: bool := bool(i32A >= i32B);
		static u32A: uint32 := a;
		static u32B: uint32 := b;
		static u32Pls: uint32 := uint32(+u32B);
		static u32Neg: uint32 := uint32(-u32B);
		static u32Cmt: uint32 := uint32(~u32B);
		static u32Add: uint32 := uint32(u32A + u32B);
		static u32Sub: uint32 := uint32(u32A - u32B);
		static u32Mul: uint32 := uint32(u32A * u32B);
		static u32Div: uint32 := uint32(u32A / u32B);
		static u32Mod: uint32 := uint32(u32A % u32B);
		static u32And: uint32 := uint32(u32A & u32B);
		static u32Ior: uint32 := uint32(u32A | u32B);
		static u32Xor: uint32 := uint32(u32A ^ u32B);
		static u32Shl: uint32 := uint32(u32A << shift);
		static u32Shr: uint32 := uint32(u32A >> shift);
		static u32Not: bool := bool(!(u32B));
		static u32Ceq: bool := bool(u32A == u32B);
		static u32Cne: bool := bool(u32A != u32B);
		static u32Clt: bool := bool(u32A < u32B);
		static u32Cle: bool := bool(u32A <= u32B);
		static u32Cgt: bool := bool(u32A > u32B);
		static u32Cge: bool := bool(u32A >= u32B);
		static i64A: int64 := a;
		static i64B: int64 := b;
		static i64Pls: int64 := int64(+i64B);
		static i64Neg: int64 := int64(-i64B);
		static i64Cmt: int64 := int64(~i64B);
		static i64Add: int64 := int64(i64A + i64B);
		static i64Sub: int64 := int64(i64A - i64B);
		static i64Mul: int64 := int64(i64A * i64B);
		static i64Div: int64 := int64(i64A / i64B);
		static i64Mod: int64 := int64(i64A % i64B);
		static i64And: int64 := int64(i64A & i64B);
		static i64Ior: int64 := int64(i64A | i64B);
		static i64Xor: int64 := int64(i64A ^ i64B);
		static i64Shl: int64 := int64(i64A << shift);
		static i64Shr: int64 := int64(i64A >> shift);
		static i64Not: bool := bool(!(i64B));
		static i64Ceq: bool := bool(i64A == i64B);
		static i64Cne: bool := bool(i64A != i64B);
		static i64Clt: bool := bool(i64A < i64B);
		static i64Cle: bool := bool(i64A <= i64B);
		static i64Cgt: bool := bool(i64A > i64B);
		static i64Cge: bool := bool(i64A >= i64B);
		static u64A: uint64 := a;
		static u64B: uint64 := b;
		static u64Pls: uint64 := uint64(+u64B);
		static u64Neg: uint64 := uint64(-u64B);
		static u64Cmt: uint64 := uint64(~u64B);
		static u64Add: uint64 := uint64(u64A + u64B);
		static u64Sub: uint64 := uint64(u64A - u64B);
		static u64Mul: uint64 := uint64(u64A * u64B);
		static u64Div: uint64 := uint64(u64A / u64B);
		static u64Mod: uint64 := uint64(u64A % u64B);
		static u64And: uint64 := uint64(u64A & u64B);
		static u64Ior: uint64 := uint64(u64A | u64B);
		static u64Xor: uint64 := uint64(u64A ^ u64B);
		static u64Shl: uint64 := uint64(u64A << shift);
		static u64Shr: uint64 := uint64(u64A >> shift);
		static u64Not: bool := bool(!(u64B));
		static u64Ceq: bool := bool(u64A == u64B);
		static u64Cne: bool := bool(u64A != u64B);
		static u64Clt: bool := bool(u64A < u64B);
		static u64Cle: bool := bool(u64A <= u64B);
		static u64Cgt: bool := bool(u64A > u64B);
		static u64Cge: bool := bool(u64A >= u64B);
		static f32A: float32 := a;
		static f32B: float32 := b;
		static f32Pls: float32 := float32(+f32B);
		static f32Neg: float32 := float32(-f32B);
		static f32Add: float32 := float32(f32A + f32B);
		static f32Sub: float32 := float32(f32A - f32B);
		static f32Mul: float32 := float32(f32A * f32B);
		static f32Div: float32 := float32(f32A / f32B);
		static f32Mod: float32 := float32(f32A % f32B);
		static f32Not: bool := bool(!(f32B));
		static f32Ceq: bool := bool(f32A == f32B);
		static f32Cne: bool := bool(f32A != f32B);
		static f32Clt: bool := bool(f32A < f32B);
		static f32Cle: bool := bool(f32A <= f32B);
		static f32Cgt: bool := bool(f32A > f32B);
		static f32Cge: bool := bool(f32A >= f32B);
		static f64A: float64 := a;
		static f64B: float64 := b;
		static f64Pls: float64 := float64(+f64B);
		static f64Neg: float64 := float64(-f64B);
		static f64Add: float64 := float64(f64A + f64B);
		static f64Sub: float64 := float64(f64A - f64B);
		static f64Mul: float64 := float64(f64A * f64B);
		static f64Div: float64 := float64(f64A / f64B);
		static f64Mod: float64 := float64(f64A % f64B);
		static f64Not: bool := bool(!(f64B));
		static f64Ceq: bool := bool(f64A == f64B);
		static f64Cne: bool := bool(f64A != f64B);
		static f64Clt: bool := bool(f64A < f64B);
		static f64Cle: bool := bool(f64A <= f64B);
		static f64Cgt: bool := bool(f64A > f64B);
		static f64Cge: bool := bool(f64A >= f64B);
		static ptrA: pointer := null;
		static ptrB: pointer := pointer(shift);
		static ptrCeq: bool := bool(ptrA == ptrB);
		static ptrCne: bool := bool(ptrA != ptrB);
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 1), "0 == 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 2), "0 != 0"), null));
		}
		static if (bool(0 == 0)) {
			raise(void(void(void(raise.debug, 3), "0 == 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 4), "0 != 0"), null));
		}
		static if (bool(0 != 0)) {
			raise(void(void(void(raise.debug, 5), "0 != 0"), null));
		}
		else {
			raise(void(void(void(raise.debug, 6), "0 == 0"), null));
		}
		{
			static t: int32 := 0;
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 7), "t == 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 8), "t != 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t != 0"), t));
			}
			if (bool(t != 0)) {
				raise(void(void(void(raise.debug, 11), "t != 0"), t));
			}
			else {
				raise(void(void(void(raise.debug, 12), "t == 0"), t));
			}
			if (bool(t == 0)) {
				raise(void(void(void(raise.debug, 9), "t == 0"), t));
			}
			else if (bool(t == 1)) {
				raise(void(void(void(raise.debug, 10), "t == 1"), t));
			}
			else if (bool(t == 2)) {
				raise(void(void(void(raise.debug, 10), "t == 2"), t));
			}
			else if (bool(t == 3)) {
				raise(void(void(void(raise.debug, 10), "t == 3"), t));
			}
			else if (bool(t == 4)) {
				raise(void(void(void(raise.debug, 10), "t == 4"), t));
			}
			else if (bool(t == 5)) {
				raise(void(void(void(raise.debug, 10), "t == 5"), t));
			}
			else {
				raise(void(void(void(raise.debug, 10), "t not in (0, 1, 2, 3, 4, 5)"), t));
			}
		}
		static if (bool((typename(int64)) == null)) {
			error("integer is not declared");
		}
		static if (bool(typename(int64) != typename)) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; bool(i < 2); int32(i := int32(i + 1))) {
			debug(void("for (int i = 0; i < 2; i += 1)", i));
		}
		static forIdx: int32;
		for (int32(forIdx := 0); bool(forIdx < 2); int32(forIdx := int32(forIdx + 1))) {
			debug(void("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i < 2)) {
				continue;
			}
			debug(void("for with continue", i));
		}
		for (i: int32 := 0; bool(i < 7); int32(i := int32(i + 1))) {
			if (bool(i > 2)) {
				break;
			}
			debug(void("for with break", i));
		}
		static testMathFloor_1: float64 := Math.floor(3.200000);
		static testMathFloor_2: float64 := Math.floor(3.500000);
		static testMathFloor_3: float64 := Math.floor(3.600000);
		static testMathFloor_4: float64 := Math.floor(float64(-3.200000));
		static testMathFloor_5: float64 := Math.floor(float64(-3.500000));
		static testMathFloor_6: float64 := Math.floor(float64(-3.600000));
		static testMathSign_1F: float64 := Math.sign(0.200000);
		static testMathSign_2F: float64 := Math.sign(0.000000);
		static testMathSign_3F: float64 := Math.sign(float64(-0.900000));
		static testMathSign_1f: float64 := Math.sign(0.200000);
		static testMathSign_2f: float64 := Math.sign(0.000000);
		static testMathSign_3f: float64 := Math.sign(float32(-0.900000));
		static testMathAbs_1F: float64 := Math.abs(0.200000);
		static testMathAbs_2F: float64 := Math.abs(0.000000);
		static testMathAbs_3F: float64 := Math.abs(float64(-0.900000));
		static testMathAbs_1f: float64 := Math.abs(0.200000);
		static testMathAbs_2f: float64 := Math.abs(0.000000);
		static testMathAbs_3f: float64 := Math.abs(float32(-0.900000));
		static testMathMin_1f: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2f: float64 := Math.max(void(1.000000, 2.000000));
		static testMathMin_1F: float64 := Math.min(void(1.000000, 2.000000));
		static testMathMax_2F: float64 := Math.max(void(1.000000, 2.000000));
		static testMathClamp_1f: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathClamp_1F: float64 := Math.clamp(void(void(10.000000, 0.000000), 1.000000));
		static testMathLerp_1f: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathLerp_1F: float64 := Math.lerp(void(void(0.500000, 0.000000), 2.000000));
		static testMathSmooth_1f: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathSmooth_1F: float64 := Math.smooth(void(void(1.000000, 0.000000), 1.000000));
		static testMathMin_nan: float64 := Math.min();
		static testMathMin_1: float64 := Math.min(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathMax_nan: float64 := Math.max();
		static testMathMax_9: float64 := Math.max(void(void(void(void(void(void(void(void(6, 2), 5), 8), 2), 1), 9), 2), 6));
		static testMathSum_0: float64 := Math.sum();
		static testMathSum_1: float64 := Math.sum(1);
		static testMathSum_3: float64 := Math.sum(void(1, 2));
		static testMathSum_55: float64 := Math.sum(void(void(void(void(void(void(void(void(void(1, 2), 3), 4), 5), 6), 7), 8), 9), 10));
		static testMathEval_x: float64 := 10;
		static testMathEval_0: float64 := Math.eval(testMathEval_x);
		static testMathEval_1: float64 := Math.eval(void(testMathEval_x, 1.000000));
		static testMathEval_2: float64 := Math.eval(void(void(testMathEval_x, 1.000000), 1.000000));
		static testMathEval_3: float64 := Math.eval(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000));
		static testMathEval_4: float64 := Math.eval(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_5: float64 := Math.eval(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathEval_6: float64 := Math.eval(void(void(void(void(void(void(testMathEval_x, 1.000000), 1.000000), 1.000000), 1.000000), 1.000000), 1.000000));
		static testMathSin_f64: float64 := Math.sin(float64(Math.pi / (2)));
		static testMathCos_f64: float64 := Math.cos(float64(Math.pi / (2)));
		static testMathTan_f64: float64 := Math.tan(float64(Math.pi / (4)));
		static testMathSinh_f64: float64 := Math.sinh(float64(Math.pi / (2)));
		static testMathCosh_f64: float64 := Math.cosh(float64(Math.pi / (2)));
		static testMathAsin_f64: float64 := Math.asin(0.200000);
		static testMathAcos_f64: float64 := Math.acos(0.200000);
		static testMathCmp_f32: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathCmp_f64: bool := bool(Math.cmp(void(void(0.000010, 0.000012), 0.000010)) == 0);
		static testMathAbsMod_f64_0a: float64 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f64_0b: float64 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f64_0c: float64 := Math.absMod(void(float64(-10.000000), 10.000000));
		static testMathAbsMod_f64_9a: float64 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f64_9b: float64 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f64_9c: float64 := Math.absMod(void(float64(-1.000000), 10.000000));
		static testMathAbsMod_f64_9d: float64 := Math.absMod(void(float64(-11.000000), 10.000000));
		static testMathAbsMod_f64_8a: float64 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f64_8b: float64 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f64_8c: float64 := Math.absMod(void(float64(-2.000000), 10.000000));
		static testMathAbsMod_f64_8d: float64 := Math.absMod(void(float64(-12.000000), 10.000000));
		static testMathAbsMod_f32_0a: float32 := Math.absMod(void(10.000000, 10.000000));
		static testMathAbsMod_f32_0b: float32 := Math.absMod(void(0.000000, 10.000000));
		static testMathAbsMod_f32_0c: float32 := Math.absMod(void(float32(-10.000000), 10.000000));
		static testMathAbsMod_f32_9a: float32 := Math.absMod(void(19.000000, 10.000000));
		static testMathAbsMod_f32_9b: float32 := Math.absMod(void(9.000000, 10.000000));
		static testMathAbsMod_f32_9c: float32 := Math.absMod(void(float32(-1.000000), 10.000000));
		static testMathAbsMod_f32_9d: float32 := Math.absMod(void(float32(-11.000000), 10.000000));
		static testMathAbsMod_f32_8a: float32 := Math.absMod(void(18.000000, 10.000000));
		static testMathAbsMod_f32_8b: float32 := Math.absMod(void(8.000000, 10.000000));
		static testMathAbsMod_f32_8c: float32 := Math.absMod(void(float32(-2.000000), 10.000000));
		static testMathAbsMod_f32_8d: float32 := Math.absMod(void(float32(-12.000000), 10.000000));
	}
}
.instructions: (14720 bytes: <.main @061764> - <.main+14720 @0650e4>)
	cmplStd/lib/string.ci:145: (14 bytes: <.main @061764> - <.main+14 @061772>): static const whiteSpace: char[] := " \t\n\r"
	<.main @061764>      : 1c 04 00 00 00             load.c32 4
	<.main+5 @061769>    : 1f e0 f1 02 00             load.ref <@02f1e0> ;" \t\n\r"
	<.main+10 @06176e>   : 23 d8 fd 05                store.m64 <@05fdd8> ;append.whiteSpace
	cmplStd/lib/string.ci:146: (14 bytes: <.main+14 @061772> - <.main+28 @061780>): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+14 @061772>   : 1c 24 00 00 00             load.c32 36
	<.main+19 @061777>   : 1f f1 f1 02 00             load.ref <@02f1f1> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+24 @06177c>   : 23 e0 fd 05                store.m64 <@05fde0> ;append.radixDigits
	cmplStd/lib/string.ci:263: (24 bytes: <.main+28 @061780> - <.main+52 @061798>): static const format: FormatFlags := {...}
	:: (7 bytes: <.main+28 @061780> - <.main+35 @061787>): format.showSign := false;
	<.main+28 @061780>   : 19                         load.z32
	<.main+29 @061781>   : 1f 98 01 06 00             load.ref <@060198> ;append.format
	<.main+34 @061786>   : 2b                         store.i8
	:: (5 bytes: <.main+35 @061787> - <.main+40 @06178c>): format.precision := 0;
	<.main+35 @061787>   : 19                         load.z32
	<.main+36 @061788>   : 24 9c 01 06                store.m32 <@06019c> ;append.format+4
	:: (7 bytes: <.main+40 @06178c> - <.main+47 @061793>): format.padChr := (0);
	<.main+40 @06178c>   : 19                         load.z32
	<.main+41 @06178d>   : 1f a0 01 06 00             load.ref <@0601a0> ;append.format+8
	<.main+46 @061792>   : 2b                         store.i8
	:: (5 bytes: <.main+47 @061793> - <.main+52 @061798>): format.padLen := 0;
	<.main+47 @061793>   : 19                         load.z32
	<.main+48 @061794>   : 24 a4 01 06                store.m32 <@0601a4> ;append.format+12
	cmplStd/test/lang/emit.ci:3: (5 bytes: <.main+52 @061798> - <.main+57 @06179d>): static emitldz32: int32 := emit(load.z32)
	<.main+52 @061798>   : 19                         load.z32
	<.main+53 @061799>   : 24 e8 01 06                store.m32 <@0601e8> ;emitldz32
	cmplStd/test/lang/emit.ci:4: (5 bytes: <.main+57 @06179d> - <.main+62 @0617a2>): static emitldz64: int64 := emit(load.z64)
	<.main+57 @06179d>   : 1a                         load.z64
	<.main+58 @06179e>   : 23 f0 01 06                store.m64 <@0601f0> ;emitldz64
	cmplStd/test/lang/emit.ci:6: (9 bytes: <.main+62 @0617a2> - <.main+71 @0617ab>): static emitA: int32 := 42
	<.main+62 @0617a2>   : 1c 2a 00 00 00             load.c32 42
	<.main+67 @0617a7>   : 24 f8 01 06                store.m32 <@0601f8> ;emitA
	cmplStd/test/lang/emit.ci:7: (9 bytes: <.main+71 @0617ab> - <.main+80 @0617b4>): static emitB: int32 := 96
	<.main+71 @0617ab>   : 1c 60 00 00 00             load.c32 96
	<.main+76 @0617b0>   : 24 00 02 06                store.m32 <@060200> ;emitB
	cmplStd/test/lang/emit.ci:10: (13 bytes: <.main+80 @0617b4> - <.main+93 @0617c1>): static emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+80 @0617b4>   : 20 f8 01 06                load.m32 <@0601f8> ;emitA
	<.main+84 @0617b8>   : 20 00 02 06                load.m32 <@060200> ;emitB
	<.main+88 @0617bc>   : 51                         add.i32
	<.main+89 @0617bd>   : 24 08 02 06                store.m32 <@060208> ;emitAddI32
	cmplStd/test/lang/emit.ci:13: (15 bytes: <.main+93 @0617c1> - <.main+108 @0617d0>): static emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+93 @0617c1>   : 1c 0a 00 00 00             load.c32 10
	<.main+98 @0617c6>   : 1c 05 00 00 00             load.c32 5
	<.main+103 @0617cb>  : 54                         div.i32
	<.main+104 @0617cc>  : 24 10 02 06                store.m32 <@060210> ;emitDivI32
	cmplStd/test/lang/emit.ci:16: (19 bytes: <.main+108 @0617d0> - <.main+127 @0617e3>): static emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+108 @0617d0>  : 7f c3 f5 48 40             load.f32 3.140000
	<.main+113 @0617d5>  : 7f 00 00 00 40             load.f32 2.000000
	<.main+118 @0617da>  : 74                         div.f32
	<.main+119 @0617db>  : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+123 @0617df>  : 24 18 02 06                store.m32 <@060218> ;emitNfcF32
	cmplStd/test/lang/emit.ci:23: (9 bytes: <.main+127 @0617e3> - <.main+136 @0617ec>): static emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+127 @0617e3>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+132 @0617e8>  : 24 20 02 06                store.m32 <@060220> ;emitFloatAsInt1
	cmplStd/test/lang/emit.ci:24: (10 bytes: <.main+136 @0617ec> - <.main+146 @0617f6>): static emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+136 @0617ec>  : 7f 00 00 fa 43             load.f32 500.000000
	<.main+141 @0617f1>  : 5b                         i32.2i64
	<.main+142 @0617f2>  : 23 28 02 06                store.m64 <@060228> ;emitFloatAsInt2
	cmplStd/test/lang/emit.ci:25: (14 bytes: <.main+146 @0617f6> - <.main+160 @061804>): static emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+146 @0617f6>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+155 @0617ff>  : 6a                         i64.2i32
	<.main+156 @061800>  : 24 30 02 06                store.m32 <@060230> ;emitFloatAsInt3
	cmplStd/test/lang/emit.ci:26: (13 bytes: <.main+160 @061804> - <.main+173 @061811>): static emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+160 @061804>  : 8f 00 00 00 00 00 40 7f 40 load.f64 500.000000
	<.main+169 @06180d>  : 23 38 02 06                store.m64 <@060238> ;emitFloatAsInt4
	cmplStd/test/lang/emit.ci:29: (14 bytes: <.main+173 @061811> - <.main+187 @06181f>): static emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+173 @061811>  : 1c 03 00 00 00             load.c32 3
	<.main+178 @061816>  : 1f 6d 78 03 00             load.ref <@03786d> ;"string"
	<.main+183 @06181b>  : 23 40 02 06                store.m64 <@060240> ;emitSlice
	cmplStd/test/lang/inlineMacros.ci:10: (9 bytes: <.main+187 @06181f> - <.main+196 @061828>): static i3: int32 := 3
	<.main+187 @06181f>  : 1c 03 00 00 00             load.c32 3
	<.main+192 @061824>  : 24 48 02 06                store.m32 <@060248> ;i3
	cmplStd/test/lang/inlineMacros.ci:11: (9 bytes: <.main+196 @061828> - <.main+205 @061831>): static i6: int32 := 6
	<.main+196 @061828>  : 1c 06 00 00 00             load.c32 6
	<.main+201 @06182d>  : 24 50 02 06                store.m32 <@060250> ;i6
	cmplStd/test/lang/inlineMacros.ci:12: (9 bytes: <.main+205 @061831> - <.main+214 @06183a>): static i2: int32 := 2
	<.main+205 @061831>  : 1c 02 00 00 00             load.c32 2
	<.main+210 @061836>  : 24 58 02 06                store.m32 <@060258> ;i2
	cmplStd/test/lang/inlineMacros.ci:13: (9 bytes: <.main+214 @06183a> - <.main+223 @061843>): static i8: int32 := 8
	<.main+214 @06183a>  : 1c 08 00 00 00             load.c32 8
	<.main+219 @06183f>  : 24 60 02 06                store.m32 <@060260> ;i8
	cmplStd/test/lang/inlineMacros.ci:15: (5 bytes: <.main+223 @061843> - <.main+228 @061848>): static zeroVal: int32 := zero(3, 6)
	<.main+223 @061843>  : 19                         load.z32
	<.main+224 @061844>  : 24 68 02 06                store.m32 <@060268> ;zeroVal
	cmplStd/test/lang/inlineMacros.ci:16: (5 bytes: <.main+228 @061848> - <.main+233 @06184d>): static zeroVar: int32 := zero(i3, i6)
	<.main+228 @061848>  : 19                         load.z32
	<.main+229 @061849>  : 24 70 02 06                store.m32 <@060270> ;zeroVar
	cmplStd/test/lang/inlineMacros.ci:17: (5 bytes: <.main+233 @06184d> - <.main+238 @061852>): static zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+233 @06184d>  : 19                         load.z32
	<.main+234 @06184e>  : 24 78 02 06                store.m32 <@060278> ;zeroXpr
	cmplStd/test/lang/inlineMacros.ci:19: (9 bytes: <.main+238 @061852> - <.main+247 @06185b>): static lastVal: int32 := last(3, 6)
	<.main+238 @061852>  : 1c 06 00 00 00             load.c32 6
	<.main+243 @061857>  : 24 80 02 06                store.m32 <@060280> ;lastVal
	cmplStd/test/lang/inlineMacros.ci:20: (8 bytes: <.main+247 @06185b> - <.main+255 @061863>): static lastVar: int32 := last(i3, i6)
	<.main+247 @06185b>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+251 @06185f>  : 24 88 02 06                store.m32 <@060288> ;lastVar
	cmplStd/test/lang/inlineMacros.ci:21: (16 bytes: <.main+255 @061863> - <.main+271 @061873>): static lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+255 @061863>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+259 @061867>  : 0c 01 00 00                inc.i32(+1)
	<.main+263 @06186b>  : 0c ff ff ff                inc.i32(-1)
	<.main+267 @06186f>  : 24 90 02 06                store.m32 <@060290> ;lastXpr
	cmplStd/test/lang/inlineMacros.ci:23: (13 bytes: <.main+271 @061873> - <.main+284 @061880>): static sum2Val: int32 := sum(3, 6)
	<.main+271 @061873>  : 1c 03 00 00 00             load.c32 3
	<.main+276 @061878>  : 0c 06 00 00                inc.i32(+6)
	<.main+280 @06187c>  : 24 98 02 06                store.m32 <@060298> ;sum2Val
	cmplStd/test/lang/inlineMacros.ci:24: (13 bytes: <.main+284 @061880> - <.main+297 @06188d>): static sum2Var: int32 := sum(i3, i6)
	<.main+284 @061880>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+288 @061884>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+292 @061888>  : 51                         add.i32
	<.main+293 @061889>  : 24 a0 02 06                store.m32 <@0602a0> ;sum2Var
	cmplStd/test/lang/inlineMacros.ci:25: (25 bytes: <.main+297 @06188d> - <.main+322 @0618a6>): static sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+297 @06188d>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+301 @061891>  : 0c 01 00 00                inc.i32(+1)
	<.main+305 @061895>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+309 @061899>  : 0c 01 00 00                inc.i32(+1)
	<.main+313 @06189d>  : 51                         add.i32
	<.main+314 @06189e>  : 0c fe ff ff                inc.i32(-2)
	<.main+318 @0618a2>  : 24 a8 02 06                store.m32 <@0602a8> ;sum2Xpr
	cmplStd/test/lang/inlineMacros.ci:27: (28 bytes: <.main+322 @0618a6> - <.main+350 @0618c2>): static any2Val: int32 := any(3, 6)
	<.main+322 @0618a6>  : 1c 03 00 00 00             load.c32 3
	<.main+327 @0618ab>  : 10 00                      dup.x32 sp(0)
	<.main+329 @0618ad>  : 06 0a 00 00                jz <.main+339 @0618b7>
	<.main+333 @0618b1>  : 10 00                      dup.x32 sp(0)
	<.main+335 @0618b3>  : 04 09 00 00                jmp <.main+344 @0618bc>
	<.main+339 @0618b7>  : 1c 06 00 00 00             load.c32 6
	<.main+344 @0618bc>  : 13 01                      set.x32 sp(1)
	<.main+346 @0618be>  : 24 b0 02 06                store.m32 <@0602b0> ;any2Val
	cmplStd/test/lang/inlineMacros.ci:28: (26 bytes: <.main+350 @0618c2> - <.main+376 @0618dc>): static any2Var: int32 := any(i3, i6)
	<.main+350 @0618c2>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+354 @0618c6>  : 10 00                      dup.x32 sp(0)
	<.main+356 @0618c8>  : 06 0a 00 00                jz <.main+366 @0618d2>
	<.main+360 @0618cc>  : 10 00                      dup.x32 sp(0)
	<.main+362 @0618ce>  : 04 08 00 00                jmp <.main+370 @0618d6>
	<.main+366 @0618d2>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+370 @0618d6>  : 13 01                      set.x32 sp(1)
	<.main+372 @0618d8>  : 24 b8 02 06                store.m32 <@0602b8> ;any2Var
	cmplStd/test/lang/inlineMacros.ci:29: (38 bytes: <.main+376 @0618dc> - <.main+414 @061902>): static any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+376 @0618dc>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+380 @0618e0>  : 0c 01 00 00                inc.i32(+1)
	<.main+384 @0618e4>  : 10 00                      dup.x32 sp(0)
	<.main+386 @0618e6>  : 06 0a 00 00                jz <.main+396 @0618f0>
	<.main+390 @0618ea>  : 10 00                      dup.x32 sp(0)
	<.main+392 @0618ec>  : 04 0c 00 00                jmp <.main+404 @0618f8>
	<.main+396 @0618f0>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+400 @0618f4>  : 0c 01 00 00                inc.i32(+1)
	<.main+404 @0618f8>  : 13 01                      set.x32 sp(1)
	<.main+406 @0618fa>  : 0c ff ff ff                inc.i32(-1)
	<.main+410 @0618fe>  : 24 c0 02 06                store.m32 <@0602c0> ;any2Xpr
	cmplStd/test/lang/inlineMacros.ci:31: (37 bytes: <.main+414 @061902> - <.main+451 @061927>): static min2Val: int32 := min(3, 6)
	<.main+414 @061902>  : 1c 03 00 00 00             load.c32 3
	<.main+419 @061907>  : 1c 06 00 00 00             load.c32 6
	<.main+424 @06190c>  : 10 01                      dup.x32 sp(1)
	<.main+426 @06190e>  : 10 01                      dup.x32 sp(1)
	<.main+428 @061910>  : 58                         clt.i32
	<.main+429 @061911>  : 06 0a 00 00                jz <.main+439 @06191b>
	<.main+433 @061915>  : 10 01                      dup.x32 sp(1)
	<.main+435 @061917>  : 04 06 00 00                jmp <.main+441 @06191d>
	<.main+439 @06191b>  : 10 00                      dup.x32 sp(0)
	<.main+441 @06191d>  : 13 02                      set.x32 sp(2)
	<.main+443 @06191f>  : 09 fc ff ff                inc.sp(-4)
	<.main+447 @061923>  : 24 c8 02 06                store.m32 <@0602c8> ;min2Val
	cmplStd/test/lang/inlineMacros.ci:32: (35 bytes: <.main+451 @061927> - <.main+486 @06194a>): static min2Var: int32 := min(i3, i6)
	<.main+451 @061927>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+455 @06192b>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+459 @06192f>  : 10 01                      dup.x32 sp(1)
	<.main+461 @061931>  : 10 01                      dup.x32 sp(1)
	<.main+463 @061933>  : 58                         clt.i32
	<.main+464 @061934>  : 06 0a 00 00                jz <.main+474 @06193e>
	<.main+468 @061938>  : 10 01                      dup.x32 sp(1)
	<.main+470 @06193a>  : 04 06 00 00                jmp <.main+476 @061940>
	<.main+474 @06193e>  : 10 00                      dup.x32 sp(0)
	<.main+476 @061940>  : 13 02                      set.x32 sp(2)
	<.main+478 @061942>  : 09 fc ff ff                inc.sp(-4)
	<.main+482 @061946>  : 24 d0 02 06                store.m32 <@0602d0> ;min2Var
	cmplStd/test/lang/inlineMacros.ci:33: (47 bytes: <.main+486 @06194a> - <.main+533 @061979>): static min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+486 @06194a>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+490 @06194e>  : 0c 01 00 00                inc.i32(+1)
	<.main+494 @061952>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+498 @061956>  : 0c 01 00 00                inc.i32(+1)
	<.main+502 @06195a>  : 10 01                      dup.x32 sp(1)
	<.main+504 @06195c>  : 10 01                      dup.x32 sp(1)
	<.main+506 @06195e>  : 58                         clt.i32
	<.main+507 @06195f>  : 06 0a 00 00                jz <.main+517 @061969>
	<.main+511 @061963>  : 10 01                      dup.x32 sp(1)
	<.main+513 @061965>  : 04 06 00 00                jmp <.main+519 @06196b>
	<.main+517 @061969>  : 10 00                      dup.x32 sp(0)
	<.main+519 @06196b>  : 13 02                      set.x32 sp(2)
	<.main+521 @06196d>  : 09 fc ff ff                inc.sp(-4)
	<.main+525 @061971>  : 0c ff ff ff                inc.i32(-1)
	<.main+529 @061975>  : 24 d8 02 06                store.m32 <@0602d8> ;min2Xpr
	cmplStd/test/lang/inlineMacros.ci:35: (37 bytes: <.main+533 @061979> - <.main+570 @06199e>): static max2Val: int32 := max(3, 6)
	<.main+533 @061979>  : 1c 03 00 00 00             load.c32 3
	<.main+538 @06197e>  : 1c 06 00 00 00             load.c32 6
	<.main+543 @061983>  : 10 01                      dup.x32 sp(1)
	<.main+545 @061985>  : 10 01                      dup.x32 sp(1)
	<.main+547 @061987>  : 59                         cgt.i32
	<.main+548 @061988>  : 06 0a 00 00                jz <.main+558 @061992>
	<.main+552 @06198c>  : 10 01                      dup.x32 sp(1)
	<.main+554 @06198e>  : 04 06 00 00                jmp <.main+560 @061994>
	<.main+558 @061992>  : 10 00                      dup.x32 sp(0)
	<.main+560 @061994>  : 13 02                      set.x32 sp(2)
	<.main+562 @061996>  : 09 fc ff ff                inc.sp(-4)
	<.main+566 @06199a>  : 24 e0 02 06                store.m32 <@0602e0> ;max2Val
	cmplStd/test/lang/inlineMacros.ci:36: (35 bytes: <.main+570 @06199e> - <.main+605 @0619c1>): static max2Var: int32 := max(i3, i6)
	<.main+570 @06199e>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+574 @0619a2>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+578 @0619a6>  : 10 01                      dup.x32 sp(1)
	<.main+580 @0619a8>  : 10 01                      dup.x32 sp(1)
	<.main+582 @0619aa>  : 59                         cgt.i32
	<.main+583 @0619ab>  : 06 0a 00 00                jz <.main+593 @0619b5>
	<.main+587 @0619af>  : 10 01                      dup.x32 sp(1)
	<.main+589 @0619b1>  : 04 06 00 00                jmp <.main+595 @0619b7>
	<.main+593 @0619b5>  : 10 00                      dup.x32 sp(0)
	<.main+595 @0619b7>  : 13 02                      set.x32 sp(2)
	<.main+597 @0619b9>  : 09 fc ff ff                inc.sp(-4)
	<.main+601 @0619bd>  : 24 e8 02 06                store.m32 <@0602e8> ;max2Var
	cmplStd/test/lang/inlineMacros.ci:37: (47 bytes: <.main+605 @0619c1> - <.main+652 @0619f0>): static max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+605 @0619c1>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+609 @0619c5>  : 0c 01 00 00                inc.i32(+1)
	<.main+613 @0619c9>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+617 @0619cd>  : 0c 01 00 00                inc.i32(+1)
	<.main+621 @0619d1>  : 10 01                      dup.x32 sp(1)
	<.main+623 @0619d3>  : 10 01                      dup.x32 sp(1)
	<.main+625 @0619d5>  : 59                         cgt.i32
	<.main+626 @0619d6>  : 06 0a 00 00                jz <.main+636 @0619e0>
	<.main+630 @0619da>  : 10 01                      dup.x32 sp(1)
	<.main+632 @0619dc>  : 04 06 00 00                jmp <.main+638 @0619e2>
	<.main+636 @0619e0>  : 10 00                      dup.x32 sp(0)
	<.main+638 @0619e2>  : 13 02                      set.x32 sp(2)
	<.main+640 @0619e4>  : 09 fc ff ff                inc.sp(-4)
	<.main+644 @0619e8>  : 0c ff ff ff                inc.i32(-1)
	<.main+648 @0619ec>  : 24 f0 02 06                store.m32 <@0602f0> ;max2Xpr
	cmplStd/test/lang/inlineMacros.ci:41: (25 bytes: <.main+652 @0619f0> - <.main+677 @061a09>): static sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+652 @0619f0>  : 1c 03 00 00 00             load.c32 3
	<.main+657 @0619f5>  : 1c 06 00 00 00             load.c32 6
	<.main+662 @0619fa>  : 1c 02 00 00 00             load.c32 2
	<.main+667 @0619ff>  : 0c 08 00 00                inc.i32(+8)
	<.main+671 @061a03>  : 51                         add.i32
	<.main+672 @061a04>  : 51                         add.i32
	<.main+673 @061a05>  : 24 f8 02 06                store.m32 <@0602f8> ;sumRlVal
	cmplStd/test/lang/inlineMacros.ci:42: (21 bytes: <.main+677 @061a09> - <.main+698 @061a1e>): static sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+677 @061a09>  : 1c 03 00 00 00             load.c32 3
	<.main+682 @061a0e>  : 0c 06 00 00                inc.i32(+6)
	<.main+686 @061a12>  : 0c 02 00 00                inc.i32(+2)
	<.main+690 @061a16>  : 0c 08 00 00                inc.i32(+8)
	<.main+694 @061a1a>  : 24 00 03 06                store.m32 <@060300> ;sumLrVal
	cmplStd/test/lang/inlineMacros.ci:43: (23 bytes: <.main+698 @061a1e> - <.main+721 @061a35>): static sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+698 @061a1e>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+702 @061a22>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+706 @061a26>  : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+710 @061a2a>  : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+714 @061a2e>  : 51                         add.i32
	<.main+715 @061a2f>  : 51                         add.i32
	<.main+716 @061a30>  : 51                         add.i32
	<.main+717 @061a31>  : 24 08 03 06                store.m32 <@060308> ;sumRlVar
	cmplStd/test/lang/inlineMacros.ci:44: (23 bytes: <.main+721 @061a35> - <.main+744 @061a4c>): static sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+721 @061a35>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+725 @061a39>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+729 @061a3d>  : 51                         add.i32
	<.main+730 @061a3e>  : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+734 @061a42>  : 51                         add.i32
	<.main+735 @061a43>  : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+739 @061a47>  : 51                         add.i32
	<.main+740 @061a48>  : 24 10 03 06                store.m32 <@060310> ;sumLrVar
	cmplStd/test/lang/inlineMacros.ci:45: (43 bytes: <.main+744 @061a4c> - <.main+787 @061a77>): static sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+744 @061a4c>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+748 @061a50>  : 0c 01 00 00                inc.i32(+1)
	<.main+752 @061a54>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+756 @061a58>  : 0c 01 00 00                inc.i32(+1)
	<.main+760 @061a5c>  : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+764 @061a60>  : 0c 01 00 00                inc.i32(+1)
	<.main+768 @061a64>  : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+772 @061a68>  : 0c 01 00 00                inc.i32(+1)
	<.main+776 @061a6c>  : 51                         add.i32
	<.main+777 @061a6d>  : 51                         add.i32
	<.main+778 @061a6e>  : 51                         add.i32
	<.main+779 @061a6f>  : 0c fc ff ff                inc.i32(-4)
	<.main+783 @061a73>  : 24 18 03 06                store.m32 <@060318> ;sumRlXpr
	cmplStd/test/lang/inlineMacros.ci:46: (43 bytes: <.main+787 @061a77> - <.main+830 @061aa2>): static sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+787 @061a77>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+791 @061a7b>  : 0c 01 00 00                inc.i32(+1)
	<.main+795 @061a7f>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+799 @061a83>  : 0c 01 00 00                inc.i32(+1)
	<.main+803 @061a87>  : 51                         add.i32
	<.main+804 @061a88>  : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+808 @061a8c>  : 0c 01 00 00                inc.i32(+1)
	<.main+812 @061a90>  : 51                         add.i32
	<.main+813 @061a91>  : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+817 @061a95>  : 0c 01 00 00                inc.i32(+1)
	<.main+821 @061a99>  : 51                         add.i32
	<.main+822 @061a9a>  : 0c fc ff ff                inc.i32(-4)
	<.main+826 @061a9e>  : 24 20 03 06                store.m32 <@060320> ;sumLrXpr
	cmplStd/test/lang/inlineMacros.ci:50: (66 bytes: <.main+830 @061aa2> - <.main+896 @061ae4>): static anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+830 @061aa2>  : 1c 03 00 00 00             load.c32 3
	<.main+835 @061aa7>  : 10 00                      dup.x32 sp(0)
	<.main+837 @061aa9>  : 06 0a 00 00                jz <.main+847 @061ab3>
	<.main+841 @061aad>  : 10 00                      dup.x32 sp(0)
	<.main+843 @061aaf>  : 04 2f 00 00                jmp <.main+890 @061ade>
	<.main+847 @061ab3>  : 1c 06 00 00 00             load.c32 6
	<.main+852 @061ab8>  : 10 00                      dup.x32 sp(0)
	<.main+854 @061aba>  : 06 0a 00 00                jz <.main+864 @061ac4>
	<.main+858 @061abe>  : 10 00                      dup.x32 sp(0)
	<.main+860 @061ac0>  : 04 1c 00 00                jmp <.main+888 @061adc>
	<.main+864 @061ac4>  : 1c 02 00 00 00             load.c32 2
	<.main+869 @061ac9>  : 10 00                      dup.x32 sp(0)
	<.main+871 @061acb>  : 06 0a 00 00                jz <.main+881 @061ad5>
	<.main+875 @061acf>  : 10 00                      dup.x32 sp(0)
	<.main+877 @061ad1>  : 04 09 00 00                jmp <.main+886 @061ada>
	<.main+881 @061ad5>  : 1c 08 00 00 00             load.c32 8
	<.main+886 @061ada>  : 13 01                      set.x32 sp(1)
	<.main+888 @061adc>  : 13 01                      set.x32 sp(1)
	<.main+890 @061ade>  : 13 01                      set.x32 sp(1)
	<.main+892 @061ae0>  : 24 28 03 06                store.m32 <@060328> ;anyRlVal
	cmplStd/test/lang/inlineMacros.ci:51: (66 bytes: <.main+896 @061ae4> - <.main+962 @061b26>): static anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+896 @061ae4>  : 1c 03 00 00 00             load.c32 3
	<.main+901 @061ae9>  : 10 00                      dup.x32 sp(0)
	<.main+903 @061aeb>  : 06 0a 00 00                jz <.main+913 @061af5>
	<.main+907 @061aef>  : 10 00                      dup.x32 sp(0)
	<.main+909 @061af1>  : 04 09 00 00                jmp <.main+918 @061afa>
	<.main+913 @061af5>  : 1c 06 00 00 00             load.c32 6
	<.main+918 @061afa>  : 13 01                      set.x32 sp(1)
	<.main+920 @061afc>  : 10 00                      dup.x32 sp(0)
	<.main+922 @061afe>  : 06 0a 00 00                jz <.main+932 @061b08>
	<.main+926 @061b02>  : 10 00                      dup.x32 sp(0)
	<.main+928 @061b04>  : 04 09 00 00                jmp <.main+937 @061b0d>
	<.main+932 @061b08>  : 1c 02 00 00 00             load.c32 2
	<.main+937 @061b0d>  : 13 01                      set.x32 sp(1)
	<.main+939 @061b0f>  : 10 00                      dup.x32 sp(0)
	<.main+941 @061b11>  : 06 0a 00 00                jz <.main+951 @061b1b>
	<.main+945 @061b15>  : 10 00                      dup.x32 sp(0)
	<.main+947 @061b17>  : 04 09 00 00                jmp <.main+956 @061b20>
	<.main+951 @061b1b>  : 1c 08 00 00 00             load.c32 8
	<.main+956 @061b20>  : 13 01                      set.x32 sp(1)
	<.main+958 @061b22>  : 24 30 03 06                store.m32 <@060330> ;anyLrVal
	cmplStd/test/lang/inlineMacros.ci:52: (62 bytes: <.main+962 @061b26> - <.main+1024 @061b64>): static anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+962 @061b26>  : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+966 @061b2a>  : 10 00                      dup.x32 sp(0)
	<.main+968 @061b2c>  : 06 0a 00 00                jz <.main+978 @061b36>
	<.main+972 @061b30>  : 10 00                      dup.x32 sp(0)
	<.main+974 @061b32>  : 04 2c 00 00                jmp <.main+1018 @061b5e>
	<.main+978 @061b36>  : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+982 @061b3a>  : 10 00                      dup.x32 sp(0)
	<.main+984 @061b3c>  : 06 0a 00 00                jz <.main+994 @061b46>
	<.main+988 @061b40>  : 10 00                      dup.x32 sp(0)
	<.main+990 @061b42>  : 04 1a 00 00                jmp <.main+1016 @061b5c>
	<.main+994 @061b46>  : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+998 @061b4a>  : 10 00                      dup.x32 sp(0)
	<.main+1000 @061b4c> : 06 0a 00 00                jz <.main+1010 @061b56>
	<.main+1004 @061b50> : 10 00                      dup.x32 sp(0)
	<.main+1006 @061b52> : 04 08 00 00                jmp <.main+1014 @061b5a>
	<.main+1010 @061b56> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1014 @061b5a> : 13 01                      set.x32 sp(1)
	<.main+1016 @061b5c> : 13 01                      set.x32 sp(1)
	<.main+1018 @061b5e> : 13 01                      set.x32 sp(1)
	<.main+1020 @061b60> : 24 38 03 06                store.m32 <@060338> ;anyRlVar
	cmplStd/test/lang/inlineMacros.ci:53: (62 bytes: <.main+1024 @061b64> - <.main+1086 @061ba2>): static anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+1024 @061b64> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1028 @061b68> : 10 00                      dup.x32 sp(0)
	<.main+1030 @061b6a> : 06 0a 00 00                jz <.main+1040 @061b74>
	<.main+1034 @061b6e> : 10 00                      dup.x32 sp(0)
	<.main+1036 @061b70> : 04 08 00 00                jmp <.main+1044 @061b78>
	<.main+1040 @061b74> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1044 @061b78> : 13 01                      set.x32 sp(1)
	<.main+1046 @061b7a> : 10 00                      dup.x32 sp(0)
	<.main+1048 @061b7c> : 06 0a 00 00                jz <.main+1058 @061b86>
	<.main+1052 @061b80> : 10 00                      dup.x32 sp(0)
	<.main+1054 @061b82> : 04 08 00 00                jmp <.main+1062 @061b8a>
	<.main+1058 @061b86> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1062 @061b8a> : 13 01                      set.x32 sp(1)
	<.main+1064 @061b8c> : 10 00                      dup.x32 sp(0)
	<.main+1066 @061b8e> : 06 0a 00 00                jz <.main+1076 @061b98>
	<.main+1070 @061b92> : 10 00                      dup.x32 sp(0)
	<.main+1072 @061b94> : 04 08 00 00                jmp <.main+1080 @061b9c>
	<.main+1076 @061b98> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1080 @061b9c> : 13 01                      set.x32 sp(1)
	<.main+1082 @061b9e> : 24 40 03 06                store.m32 <@060340> ;anyLrVar
	cmplStd/test/lang/inlineMacros.ci:54: (82 bytes: <.main+1086 @061ba2> - <.main+1168 @061bf4>): static anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1086 @061ba2> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1090 @061ba6> : 0c 01 00 00                inc.i32(+1)
	<.main+1094 @061baa> : 10 00                      dup.x32 sp(0)
	<.main+1096 @061bac> : 06 0a 00 00                jz <.main+1106 @061bb6>
	<.main+1100 @061bb0> : 10 00                      dup.x32 sp(0)
	<.main+1102 @061bb2> : 04 38 00 00                jmp <.main+1158 @061bea>
	<.main+1106 @061bb6> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1110 @061bba> : 0c 01 00 00                inc.i32(+1)
	<.main+1114 @061bbe> : 10 00                      dup.x32 sp(0)
	<.main+1116 @061bc0> : 06 0a 00 00                jz <.main+1126 @061bca>
	<.main+1120 @061bc4> : 10 00                      dup.x32 sp(0)
	<.main+1122 @061bc6> : 04 22 00 00                jmp <.main+1156 @061be8>
	<.main+1126 @061bca> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1130 @061bce> : 0c 01 00 00                inc.i32(+1)
	<.main+1134 @061bd2> : 10 00                      dup.x32 sp(0)
	<.main+1136 @061bd4> : 06 0a 00 00                jz <.main+1146 @061bde>
	<.main+1140 @061bd8> : 10 00                      dup.x32 sp(0)
	<.main+1142 @061bda> : 04 0c 00 00                jmp <.main+1154 @061be6>
	<.main+1146 @061bde> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1150 @061be2> : 0c 01 00 00                inc.i32(+1)
	<.main+1154 @061be6> : 13 01                      set.x32 sp(1)
	<.main+1156 @061be8> : 13 01                      set.x32 sp(1)
	<.main+1158 @061bea> : 13 01                      set.x32 sp(1)
	<.main+1160 @061bec> : 0c ff ff ff                inc.i32(-1)
	<.main+1164 @061bf0> : 24 48 03 06                store.m32 <@060348> ;anyRlXpr
	cmplStd/test/lang/inlineMacros.ci:55: (82 bytes: <.main+1168 @061bf4> - <.main+1250 @061c46>): static anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1168 @061bf4> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1172 @061bf8> : 0c 01 00 00                inc.i32(+1)
	<.main+1176 @061bfc> : 10 00                      dup.x32 sp(0)
	<.main+1178 @061bfe> : 06 0a 00 00                jz <.main+1188 @061c08>
	<.main+1182 @061c02> : 10 00                      dup.x32 sp(0)
	<.main+1184 @061c04> : 04 0c 00 00                jmp <.main+1196 @061c10>
	<.main+1188 @061c08> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1192 @061c0c> : 0c 01 00 00                inc.i32(+1)
	<.main+1196 @061c10> : 13 01                      set.x32 sp(1)
	<.main+1198 @061c12> : 10 00                      dup.x32 sp(0)
	<.main+1200 @061c14> : 06 0a 00 00                jz <.main+1210 @061c1e>
	<.main+1204 @061c18> : 10 00                      dup.x32 sp(0)
	<.main+1206 @061c1a> : 04 0c 00 00                jmp <.main+1218 @061c26>
	<.main+1210 @061c1e> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1214 @061c22> : 0c 01 00 00                inc.i32(+1)
	<.main+1218 @061c26> : 13 01                      set.x32 sp(1)
	<.main+1220 @061c28> : 10 00                      dup.x32 sp(0)
	<.main+1222 @061c2a> : 06 0a 00 00                jz <.main+1232 @061c34>
	<.main+1226 @061c2e> : 10 00                      dup.x32 sp(0)
	<.main+1228 @061c30> : 04 0c 00 00                jmp <.main+1240 @061c3c>
	<.main+1232 @061c34> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1236 @061c38> : 0c 01 00 00                inc.i32(+1)
	<.main+1240 @061c3c> : 13 01                      set.x32 sp(1)
	<.main+1242 @061c3e> : 0c ff ff ff                inc.i32(-1)
	<.main+1246 @061c42> : 24 50 03 06                store.m32 <@060350> ;anyLrXpr
	cmplStd/test/lang/inlineMacros.ci:59: (93 bytes: <.main+1250 @061c46> - <.main+1343 @061ca3>): static minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+1250 @061c46> : 1c 03 00 00 00             load.c32 3
	<.main+1255 @061c4b> : 1c 06 00 00 00             load.c32 6
	<.main+1260 @061c50> : 1c 02 00 00 00             load.c32 2
	<.main+1265 @061c55> : 1c 08 00 00 00             load.c32 8
	<.main+1270 @061c5a> : 10 01                      dup.x32 sp(1)
	<.main+1272 @061c5c> : 10 01                      dup.x32 sp(1)
	<.main+1274 @061c5e> : 58                         clt.i32
	<.main+1275 @061c5f> : 06 0a 00 00                jz <.main+1285 @061c69>
	<.main+1279 @061c63> : 10 01                      dup.x32 sp(1)
	<.main+1281 @061c65> : 04 06 00 00                jmp <.main+1287 @061c6b>
	<.main+1285 @061c69> : 10 00                      dup.x32 sp(0)
	<.main+1287 @061c6b> : 13 02                      set.x32 sp(2)
	<.main+1289 @061c6d> : 09 fc ff ff                inc.sp(-4)
	<.main+1293 @061c71> : 10 01                      dup.x32 sp(1)
	<.main+1295 @061c73> : 10 01                      dup.x32 sp(1)
	<.main+1297 @061c75> : 58                         clt.i32
	<.main+1298 @061c76> : 06 0a 00 00                jz <.main+1308 @061c80>
	<.main+1302 @061c7a> : 10 01                      dup.x32 sp(1)
	<.main+1304 @061c7c> : 04 06 00 00                jmp <.main+1310 @061c82>
	<.main+1308 @061c80> : 10 00                      dup.x32 sp(0)
	<.main+1310 @061c82> : 13 02                      set.x32 sp(2)
	<.main+1312 @061c84> : 09 fc ff ff                inc.sp(-4)
	<.main+1316 @061c88> : 10 01                      dup.x32 sp(1)
	<.main+1318 @061c8a> : 10 01                      dup.x32 sp(1)
	<.main+1320 @061c8c> : 58                         clt.i32
	<.main+1321 @061c8d> : 06 0a 00 00                jz <.main+1331 @061c97>
	<.main+1325 @061c91> : 10 01                      dup.x32 sp(1)
	<.main+1327 @061c93> : 04 06 00 00                jmp <.main+1333 @061c99>
	<.main+1331 @061c97> : 10 00                      dup.x32 sp(0)
	<.main+1333 @061c99> : 13 02                      set.x32 sp(2)
	<.main+1335 @061c9b> : 09 fc ff ff                inc.sp(-4)
	<.main+1339 @061c9f> : 24 58 03 06                store.m32 <@060358> ;minRlVal
	cmplStd/test/lang/inlineMacros.ci:60: (93 bytes: <.main+1343 @061ca3> - <.main+1436 @061d00>): static minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+1343 @061ca3> : 1c 03 00 00 00             load.c32 3
	<.main+1348 @061ca8> : 1c 06 00 00 00             load.c32 6
	<.main+1353 @061cad> : 10 01                      dup.x32 sp(1)
	<.main+1355 @061caf> : 10 01                      dup.x32 sp(1)
	<.main+1357 @061cb1> : 58                         clt.i32
	<.main+1358 @061cb2> : 06 0a 00 00                jz <.main+1368 @061cbc>
	<.main+1362 @061cb6> : 10 01                      dup.x32 sp(1)
	<.main+1364 @061cb8> : 04 06 00 00                jmp <.main+1370 @061cbe>
	<.main+1368 @061cbc> : 10 00                      dup.x32 sp(0)
	<.main+1370 @061cbe> : 13 02                      set.x32 sp(2)
	<.main+1372 @061cc0> : 09 fc ff ff                inc.sp(-4)
	<.main+1376 @061cc4> : 1c 02 00 00 00             load.c32 2
	<.main+1381 @061cc9> : 10 01                      dup.x32 sp(1)
	<.main+1383 @061ccb> : 10 01                      dup.x32 sp(1)
	<.main+1385 @061ccd> : 58                         clt.i32
	<.main+1386 @061cce> : 06 0a 00 00                jz <.main+1396 @061cd8>
	<.main+1390 @061cd2> : 10 01                      dup.x32 sp(1)
	<.main+1392 @061cd4> : 04 06 00 00                jmp <.main+1398 @061cda>
	<.main+1396 @061cd8> : 10 00                      dup.x32 sp(0)
	<.main+1398 @061cda> : 13 02                      set.x32 sp(2)
	<.main+1400 @061cdc> : 09 fc ff ff                inc.sp(-4)
	<.main+1404 @061ce0> : 1c 08 00 00 00             load.c32 8
	<.main+1409 @061ce5> : 10 01                      dup.x32 sp(1)
	<.main+1411 @061ce7> : 10 01                      dup.x32 sp(1)
	<.main+1413 @061ce9> : 58                         clt.i32
	<.main+1414 @061cea> : 06 0a 00 00                jz <.main+1424 @061cf4>
	<.main+1418 @061cee> : 10 01                      dup.x32 sp(1)
	<.main+1420 @061cf0> : 04 06 00 00                jmp <.main+1426 @061cf6>
	<.main+1424 @061cf4> : 10 00                      dup.x32 sp(0)
	<.main+1426 @061cf6> : 13 02                      set.x32 sp(2)
	<.main+1428 @061cf8> : 09 fc ff ff                inc.sp(-4)
	<.main+1432 @061cfc> : 24 60 03 06                store.m32 <@060360> ;minLrVal
	cmplStd/test/lang/inlineMacros.ci:61: (89 bytes: <.main+1436 @061d00> - <.main+1525 @061d59>): static minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+1436 @061d00> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1440 @061d04> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1444 @061d08> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1448 @061d0c> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1452 @061d10> : 10 01                      dup.x32 sp(1)
	<.main+1454 @061d12> : 10 01                      dup.x32 sp(1)
	<.main+1456 @061d14> : 58                         clt.i32
	<.main+1457 @061d15> : 06 0a 00 00                jz <.main+1467 @061d1f>
	<.main+1461 @061d19> : 10 01                      dup.x32 sp(1)
	<.main+1463 @061d1b> : 04 06 00 00                jmp <.main+1469 @061d21>
	<.main+1467 @061d1f> : 10 00                      dup.x32 sp(0)
	<.main+1469 @061d21> : 13 02                      set.x32 sp(2)
	<.main+1471 @061d23> : 09 fc ff ff                inc.sp(-4)
	<.main+1475 @061d27> : 10 01                      dup.x32 sp(1)
	<.main+1477 @061d29> : 10 01                      dup.x32 sp(1)
	<.main+1479 @061d2b> : 58                         clt.i32
	<.main+1480 @061d2c> : 06 0a 00 00                jz <.main+1490 @061d36>
	<.main+1484 @061d30> : 10 01                      dup.x32 sp(1)
	<.main+1486 @061d32> : 04 06 00 00                jmp <.main+1492 @061d38>
	<.main+1490 @061d36> : 10 00                      dup.x32 sp(0)
	<.main+1492 @061d38> : 13 02                      set.x32 sp(2)
	<.main+1494 @061d3a> : 09 fc ff ff                inc.sp(-4)
	<.main+1498 @061d3e> : 10 01                      dup.x32 sp(1)
	<.main+1500 @061d40> : 10 01                      dup.x32 sp(1)
	<.main+1502 @061d42> : 58                         clt.i32
	<.main+1503 @061d43> : 06 0a 00 00                jz <.main+1513 @061d4d>
	<.main+1507 @061d47> : 10 01                      dup.x32 sp(1)
	<.main+1509 @061d49> : 04 06 00 00                jmp <.main+1515 @061d4f>
	<.main+1513 @061d4d> : 10 00                      dup.x32 sp(0)
	<.main+1515 @061d4f> : 13 02                      set.x32 sp(2)
	<.main+1517 @061d51> : 09 fc ff ff                inc.sp(-4)
	<.main+1521 @061d55> : 24 68 03 06                store.m32 <@060368> ;minRlVar
	cmplStd/test/lang/inlineMacros.ci:62: (89 bytes: <.main+1525 @061d59> - <.main+1614 @061db2>): static minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+1525 @061d59> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1529 @061d5d> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1533 @061d61> : 10 01                      dup.x32 sp(1)
	<.main+1535 @061d63> : 10 01                      dup.x32 sp(1)
	<.main+1537 @061d65> : 58                         clt.i32
	<.main+1538 @061d66> : 06 0a 00 00                jz <.main+1548 @061d70>
	<.main+1542 @061d6a> : 10 01                      dup.x32 sp(1)
	<.main+1544 @061d6c> : 04 06 00 00                jmp <.main+1550 @061d72>
	<.main+1548 @061d70> : 10 00                      dup.x32 sp(0)
	<.main+1550 @061d72> : 13 02                      set.x32 sp(2)
	<.main+1552 @061d74> : 09 fc ff ff                inc.sp(-4)
	<.main+1556 @061d78> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1560 @061d7c> : 10 01                      dup.x32 sp(1)
	<.main+1562 @061d7e> : 10 01                      dup.x32 sp(1)
	<.main+1564 @061d80> : 58                         clt.i32
	<.main+1565 @061d81> : 06 0a 00 00                jz <.main+1575 @061d8b>
	<.main+1569 @061d85> : 10 01                      dup.x32 sp(1)
	<.main+1571 @061d87> : 04 06 00 00                jmp <.main+1577 @061d8d>
	<.main+1575 @061d8b> : 10 00                      dup.x32 sp(0)
	<.main+1577 @061d8d> : 13 02                      set.x32 sp(2)
	<.main+1579 @061d8f> : 09 fc ff ff                inc.sp(-4)
	<.main+1583 @061d93> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1587 @061d97> : 10 01                      dup.x32 sp(1)
	<.main+1589 @061d99> : 10 01                      dup.x32 sp(1)
	<.main+1591 @061d9b> : 58                         clt.i32
	<.main+1592 @061d9c> : 06 0a 00 00                jz <.main+1602 @061da6>
	<.main+1596 @061da0> : 10 01                      dup.x32 sp(1)
	<.main+1598 @061da2> : 04 06 00 00                jmp <.main+1604 @061da8>
	<.main+1602 @061da6> : 10 00                      dup.x32 sp(0)
	<.main+1604 @061da8> : 13 02                      set.x32 sp(2)
	<.main+1606 @061daa> : 09 fc ff ff                inc.sp(-4)
	<.main+1610 @061dae> : 24 70 03 06                store.m32 <@060370> ;minLrVar
	cmplStd/test/lang/inlineMacros.ci:63: (109 bytes: <.main+1614 @061db2> - <.main+1723 @061e1f>): static minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1614 @061db2> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1618 @061db6> : 0c 01 00 00                inc.i32(+1)
	<.main+1622 @061dba> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1626 @061dbe> : 0c 01 00 00                inc.i32(+1)
	<.main+1630 @061dc2> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1634 @061dc6> : 0c 01 00 00                inc.i32(+1)
	<.main+1638 @061dca> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1642 @061dce> : 0c 01 00 00                inc.i32(+1)
	<.main+1646 @061dd2> : 10 01                      dup.x32 sp(1)
	<.main+1648 @061dd4> : 10 01                      dup.x32 sp(1)
	<.main+1650 @061dd6> : 58                         clt.i32
	<.main+1651 @061dd7> : 06 0a 00 00                jz <.main+1661 @061de1>
	<.main+1655 @061ddb> : 10 01                      dup.x32 sp(1)
	<.main+1657 @061ddd> : 04 06 00 00                jmp <.main+1663 @061de3>
	<.main+1661 @061de1> : 10 00                      dup.x32 sp(0)
	<.main+1663 @061de3> : 13 02                      set.x32 sp(2)
	<.main+1665 @061de5> : 09 fc ff ff                inc.sp(-4)
	<.main+1669 @061de9> : 10 01                      dup.x32 sp(1)
	<.main+1671 @061deb> : 10 01                      dup.x32 sp(1)
	<.main+1673 @061ded> : 58                         clt.i32
	<.main+1674 @061dee> : 06 0a 00 00                jz <.main+1684 @061df8>
	<.main+1678 @061df2> : 10 01                      dup.x32 sp(1)
	<.main+1680 @061df4> : 04 06 00 00                jmp <.main+1686 @061dfa>
	<.main+1684 @061df8> : 10 00                      dup.x32 sp(0)
	<.main+1686 @061dfa> : 13 02                      set.x32 sp(2)
	<.main+1688 @061dfc> : 09 fc ff ff                inc.sp(-4)
	<.main+1692 @061e00> : 10 01                      dup.x32 sp(1)
	<.main+1694 @061e02> : 10 01                      dup.x32 sp(1)
	<.main+1696 @061e04> : 58                         clt.i32
	<.main+1697 @061e05> : 06 0a 00 00                jz <.main+1707 @061e0f>
	<.main+1701 @061e09> : 10 01                      dup.x32 sp(1)
	<.main+1703 @061e0b> : 04 06 00 00                jmp <.main+1709 @061e11>
	<.main+1707 @061e0f> : 10 00                      dup.x32 sp(0)
	<.main+1709 @061e11> : 13 02                      set.x32 sp(2)
	<.main+1711 @061e13> : 09 fc ff ff                inc.sp(-4)
	<.main+1715 @061e17> : 0c ff ff ff                inc.i32(-1)
	<.main+1719 @061e1b> : 24 78 03 06                store.m32 <@060378> ;minRlXpr
	cmplStd/test/lang/inlineMacros.ci:64: (109 bytes: <.main+1723 @061e1f> - <.main+1832 @061e8c>): static minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+1723 @061e1f> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+1727 @061e23> : 0c 01 00 00                inc.i32(+1)
	<.main+1731 @061e27> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+1735 @061e2b> : 0c 01 00 00                inc.i32(+1)
	<.main+1739 @061e2f> : 10 01                      dup.x32 sp(1)
	<.main+1741 @061e31> : 10 01                      dup.x32 sp(1)
	<.main+1743 @061e33> : 58                         clt.i32
	<.main+1744 @061e34> : 06 0a 00 00                jz <.main+1754 @061e3e>
	<.main+1748 @061e38> : 10 01                      dup.x32 sp(1)
	<.main+1750 @061e3a> : 04 06 00 00                jmp <.main+1756 @061e40>
	<.main+1754 @061e3e> : 10 00                      dup.x32 sp(0)
	<.main+1756 @061e40> : 13 02                      set.x32 sp(2)
	<.main+1758 @061e42> : 09 fc ff ff                inc.sp(-4)
	<.main+1762 @061e46> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+1766 @061e4a> : 0c 01 00 00                inc.i32(+1)
	<.main+1770 @061e4e> : 10 01                      dup.x32 sp(1)
	<.main+1772 @061e50> : 10 01                      dup.x32 sp(1)
	<.main+1774 @061e52> : 58                         clt.i32
	<.main+1775 @061e53> : 06 0a 00 00                jz <.main+1785 @061e5d>
	<.main+1779 @061e57> : 10 01                      dup.x32 sp(1)
	<.main+1781 @061e59> : 04 06 00 00                jmp <.main+1787 @061e5f>
	<.main+1785 @061e5d> : 10 00                      dup.x32 sp(0)
	<.main+1787 @061e5f> : 13 02                      set.x32 sp(2)
	<.main+1789 @061e61> : 09 fc ff ff                inc.sp(-4)
	<.main+1793 @061e65> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+1797 @061e69> : 0c 01 00 00                inc.i32(+1)
	<.main+1801 @061e6d> : 10 01                      dup.x32 sp(1)
	<.main+1803 @061e6f> : 10 01                      dup.x32 sp(1)
	<.main+1805 @061e71> : 58                         clt.i32
	<.main+1806 @061e72> : 06 0a 00 00                jz <.main+1816 @061e7c>
	<.main+1810 @061e76> : 10 01                      dup.x32 sp(1)
	<.main+1812 @061e78> : 04 06 00 00                jmp <.main+1818 @061e7e>
	<.main+1816 @061e7c> : 10 00                      dup.x32 sp(0)
	<.main+1818 @061e7e> : 13 02                      set.x32 sp(2)
	<.main+1820 @061e80> : 09 fc ff ff                inc.sp(-4)
	<.main+1824 @061e84> : 0c ff ff ff                inc.i32(-1)
	<.main+1828 @061e88> : 24 80 03 06                store.m32 <@060380> ;minLrXpr
	cmplStd/test/lang/inlineMacros.ci:68: (93 bytes: <.main+1832 @061e8c> - <.main+1925 @061ee9>): static maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+1832 @061e8c> : 1c 03 00 00 00             load.c32 3
	<.main+1837 @061e91> : 1c 06 00 00 00             load.c32 6
	<.main+1842 @061e96> : 1c 02 00 00 00             load.c32 2
	<.main+1847 @061e9b> : 1c 08 00 00 00             load.c32 8
	<.main+1852 @061ea0> : 10 01                      dup.x32 sp(1)
	<.main+1854 @061ea2> : 10 01                      dup.x32 sp(1)
	<.main+1856 @061ea4> : 59                         cgt.i32
	<.main+1857 @061ea5> : 06 0a 00 00                jz <.main+1867 @061eaf>
	<.main+1861 @061ea9> : 10 01                      dup.x32 sp(1)
	<.main+1863 @061eab> : 04 06 00 00                jmp <.main+1869 @061eb1>
	<.main+1867 @061eaf> : 10 00                      dup.x32 sp(0)
	<.main+1869 @061eb1> : 13 02                      set.x32 sp(2)
	<.main+1871 @061eb3> : 09 fc ff ff                inc.sp(-4)
	<.main+1875 @061eb7> : 10 01                      dup.x32 sp(1)
	<.main+1877 @061eb9> : 10 01                      dup.x32 sp(1)
	<.main+1879 @061ebb> : 59                         cgt.i32
	<.main+1880 @061ebc> : 06 0a 00 00                jz <.main+1890 @061ec6>
	<.main+1884 @061ec0> : 10 01                      dup.x32 sp(1)
	<.main+1886 @061ec2> : 04 06 00 00                jmp <.main+1892 @061ec8>
	<.main+1890 @061ec6> : 10 00                      dup.x32 sp(0)
	<.main+1892 @061ec8> : 13 02                      set.x32 sp(2)
	<.main+1894 @061eca> : 09 fc ff ff                inc.sp(-4)
	<.main+1898 @061ece> : 10 01                      dup.x32 sp(1)
	<.main+1900 @061ed0> : 10 01                      dup.x32 sp(1)
	<.main+1902 @061ed2> : 59                         cgt.i32
	<.main+1903 @061ed3> : 06 0a 00 00                jz <.main+1913 @061edd>
	<.main+1907 @061ed7> : 10 01                      dup.x32 sp(1)
	<.main+1909 @061ed9> : 04 06 00 00                jmp <.main+1915 @061edf>
	<.main+1913 @061edd> : 10 00                      dup.x32 sp(0)
	<.main+1915 @061edf> : 13 02                      set.x32 sp(2)
	<.main+1917 @061ee1> : 09 fc ff ff                inc.sp(-4)
	<.main+1921 @061ee5> : 24 88 03 06                store.m32 <@060388> ;maxRlVal
	cmplStd/test/lang/inlineMacros.ci:69: (93 bytes: <.main+1925 @061ee9> - <.main+2018 @061f46>): static maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+1925 @061ee9> : 1c 03 00 00 00             load.c32 3
	<.main+1930 @061eee> : 1c 06 00 00 00             load.c32 6
	<.main+1935 @061ef3> : 10 01                      dup.x32 sp(1)
	<.main+1937 @061ef5> : 10 01                      dup.x32 sp(1)
	<.main+1939 @061ef7> : 59                         cgt.i32
	<.main+1940 @061ef8> : 06 0a 00 00                jz <.main+1950 @061f02>
	<.main+1944 @061efc> : 10 01                      dup.x32 sp(1)
	<.main+1946 @061efe> : 04 06 00 00                jmp <.main+1952 @061f04>
	<.main+1950 @061f02> : 10 00                      dup.x32 sp(0)
	<.main+1952 @061f04> : 13 02                      set.x32 sp(2)
	<.main+1954 @061f06> : 09 fc ff ff                inc.sp(-4)
	<.main+1958 @061f0a> : 1c 02 00 00 00             load.c32 2
	<.main+1963 @061f0f> : 10 01                      dup.x32 sp(1)
	<.main+1965 @061f11> : 10 01                      dup.x32 sp(1)
	<.main+1967 @061f13> : 59                         cgt.i32
	<.main+1968 @061f14> : 06 0a 00 00                jz <.main+1978 @061f1e>
	<.main+1972 @061f18> : 10 01                      dup.x32 sp(1)
	<.main+1974 @061f1a> : 04 06 00 00                jmp <.main+1980 @061f20>
	<.main+1978 @061f1e> : 10 00                      dup.x32 sp(0)
	<.main+1980 @061f20> : 13 02                      set.x32 sp(2)
	<.main+1982 @061f22> : 09 fc ff ff                inc.sp(-4)
	<.main+1986 @061f26> : 1c 08 00 00 00             load.c32 8
	<.main+1991 @061f2b> : 10 01                      dup.x32 sp(1)
	<.main+1993 @061f2d> : 10 01                      dup.x32 sp(1)
	<.main+1995 @061f2f> : 59                         cgt.i32
	<.main+1996 @061f30> : 06 0a 00 00                jz <.main+2006 @061f3a>
	<.main+2000 @061f34> : 10 01                      dup.x32 sp(1)
	<.main+2002 @061f36> : 04 06 00 00                jmp <.main+2008 @061f3c>
	<.main+2006 @061f3a> : 10 00                      dup.x32 sp(0)
	<.main+2008 @061f3c> : 13 02                      set.x32 sp(2)
	<.main+2010 @061f3e> : 09 fc ff ff                inc.sp(-4)
	<.main+2014 @061f42> : 24 90 03 06                store.m32 <@060390> ;maxLrVal
	cmplStd/test/lang/inlineMacros.ci:70: (89 bytes: <.main+2018 @061f46> - <.main+2107 @061f9f>): static maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+2018 @061f46> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+2022 @061f4a> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+2026 @061f4e> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+2030 @061f52> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+2034 @061f56> : 10 01                      dup.x32 sp(1)
	<.main+2036 @061f58> : 10 01                      dup.x32 sp(1)
	<.main+2038 @061f5a> : 59                         cgt.i32
	<.main+2039 @061f5b> : 06 0a 00 00                jz <.main+2049 @061f65>
	<.main+2043 @061f5f> : 10 01                      dup.x32 sp(1)
	<.main+2045 @061f61> : 04 06 00 00                jmp <.main+2051 @061f67>
	<.main+2049 @061f65> : 10 00                      dup.x32 sp(0)
	<.main+2051 @061f67> : 13 02                      set.x32 sp(2)
	<.main+2053 @061f69> : 09 fc ff ff                inc.sp(-4)
	<.main+2057 @061f6d> : 10 01                      dup.x32 sp(1)
	<.main+2059 @061f6f> : 10 01                      dup.x32 sp(1)
	<.main+2061 @061f71> : 59                         cgt.i32
	<.main+2062 @061f72> : 06 0a 00 00                jz <.main+2072 @061f7c>
	<.main+2066 @061f76> : 10 01                      dup.x32 sp(1)
	<.main+2068 @061f78> : 04 06 00 00                jmp <.main+2074 @061f7e>
	<.main+2072 @061f7c> : 10 00                      dup.x32 sp(0)
	<.main+2074 @061f7e> : 13 02                      set.x32 sp(2)
	<.main+2076 @061f80> : 09 fc ff ff                inc.sp(-4)
	<.main+2080 @061f84> : 10 01                      dup.x32 sp(1)
	<.main+2082 @061f86> : 10 01                      dup.x32 sp(1)
	<.main+2084 @061f88> : 59                         cgt.i32
	<.main+2085 @061f89> : 06 0a 00 00                jz <.main+2095 @061f93>
	<.main+2089 @061f8d> : 10 01                      dup.x32 sp(1)
	<.main+2091 @061f8f> : 04 06 00 00                jmp <.main+2097 @061f95>
	<.main+2095 @061f93> : 10 00                      dup.x32 sp(0)
	<.main+2097 @061f95> : 13 02                      set.x32 sp(2)
	<.main+2099 @061f97> : 09 fc ff ff                inc.sp(-4)
	<.main+2103 @061f9b> : 24 98 03 06                store.m32 <@060398> ;maxRlVar
	cmplStd/test/lang/inlineMacros.ci:71: (89 bytes: <.main+2107 @061f9f> - <.main+2196 @061ff8>): static maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+2107 @061f9f> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+2111 @061fa3> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+2115 @061fa7> : 10 01                      dup.x32 sp(1)
	<.main+2117 @061fa9> : 10 01                      dup.x32 sp(1)
	<.main+2119 @061fab> : 59                         cgt.i32
	<.main+2120 @061fac> : 06 0a 00 00                jz <.main+2130 @061fb6>
	<.main+2124 @061fb0> : 10 01                      dup.x32 sp(1)
	<.main+2126 @061fb2> : 04 06 00 00                jmp <.main+2132 @061fb8>
	<.main+2130 @061fb6> : 10 00                      dup.x32 sp(0)
	<.main+2132 @061fb8> : 13 02                      set.x32 sp(2)
	<.main+2134 @061fba> : 09 fc ff ff                inc.sp(-4)
	<.main+2138 @061fbe> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+2142 @061fc2> : 10 01                      dup.x32 sp(1)
	<.main+2144 @061fc4> : 10 01                      dup.x32 sp(1)
	<.main+2146 @061fc6> : 59                         cgt.i32
	<.main+2147 @061fc7> : 06 0a 00 00                jz <.main+2157 @061fd1>
	<.main+2151 @061fcb> : 10 01                      dup.x32 sp(1)
	<.main+2153 @061fcd> : 04 06 00 00                jmp <.main+2159 @061fd3>
	<.main+2157 @061fd1> : 10 00                      dup.x32 sp(0)
	<.main+2159 @061fd3> : 13 02                      set.x32 sp(2)
	<.main+2161 @061fd5> : 09 fc ff ff                inc.sp(-4)
	<.main+2165 @061fd9> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+2169 @061fdd> : 10 01                      dup.x32 sp(1)
	<.main+2171 @061fdf> : 10 01                      dup.x32 sp(1)
	<.main+2173 @061fe1> : 59                         cgt.i32
	<.main+2174 @061fe2> : 06 0a 00 00                jz <.main+2184 @061fec>
	<.main+2178 @061fe6> : 10 01                      dup.x32 sp(1)
	<.main+2180 @061fe8> : 04 06 00 00                jmp <.main+2186 @061fee>
	<.main+2184 @061fec> : 10 00                      dup.x32 sp(0)
	<.main+2186 @061fee> : 13 02                      set.x32 sp(2)
	<.main+2188 @061ff0> : 09 fc ff ff                inc.sp(-4)
	<.main+2192 @061ff4> : 24 a0 03 06                store.m32 <@0603a0> ;maxLrVar
	cmplStd/test/lang/inlineMacros.ci:72: (109 bytes: <.main+2196 @061ff8> - <.main+2305 @062065>): static maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2196 @061ff8> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+2200 @061ffc> : 0c 01 00 00                inc.i32(+1)
	<.main+2204 @062000> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+2208 @062004> : 0c 01 00 00                inc.i32(+1)
	<.main+2212 @062008> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+2216 @06200c> : 0c 01 00 00                inc.i32(+1)
	<.main+2220 @062010> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+2224 @062014> : 0c 01 00 00                inc.i32(+1)
	<.main+2228 @062018> : 10 01                      dup.x32 sp(1)
	<.main+2230 @06201a> : 10 01                      dup.x32 sp(1)
	<.main+2232 @06201c> : 59                         cgt.i32
	<.main+2233 @06201d> : 06 0a 00 00                jz <.main+2243 @062027>
	<.main+2237 @062021> : 10 01                      dup.x32 sp(1)
	<.main+2239 @062023> : 04 06 00 00                jmp <.main+2245 @062029>
	<.main+2243 @062027> : 10 00                      dup.x32 sp(0)
	<.main+2245 @062029> : 13 02                      set.x32 sp(2)
	<.main+2247 @06202b> : 09 fc ff ff                inc.sp(-4)
	<.main+2251 @06202f> : 10 01                      dup.x32 sp(1)
	<.main+2253 @062031> : 10 01                      dup.x32 sp(1)
	<.main+2255 @062033> : 59                         cgt.i32
	<.main+2256 @062034> : 06 0a 00 00                jz <.main+2266 @06203e>
	<.main+2260 @062038> : 10 01                      dup.x32 sp(1)
	<.main+2262 @06203a> : 04 06 00 00                jmp <.main+2268 @062040>
	<.main+2266 @06203e> : 10 00                      dup.x32 sp(0)
	<.main+2268 @062040> : 13 02                      set.x32 sp(2)
	<.main+2270 @062042> : 09 fc ff ff                inc.sp(-4)
	<.main+2274 @062046> : 10 01                      dup.x32 sp(1)
	<.main+2276 @062048> : 10 01                      dup.x32 sp(1)
	<.main+2278 @06204a> : 59                         cgt.i32
	<.main+2279 @06204b> : 06 0a 00 00                jz <.main+2289 @062055>
	<.main+2283 @06204f> : 10 01                      dup.x32 sp(1)
	<.main+2285 @062051> : 04 06 00 00                jmp <.main+2291 @062057>
	<.main+2289 @062055> : 10 00                      dup.x32 sp(0)
	<.main+2291 @062057> : 13 02                      set.x32 sp(2)
	<.main+2293 @062059> : 09 fc ff ff                inc.sp(-4)
	<.main+2297 @06205d> : 0c ff ff ff                inc.i32(-1)
	<.main+2301 @062061> : 24 a8 03 06                store.m32 <@0603a8> ;maxRlXpr
	cmplStd/test/lang/inlineMacros.ci:73: (109 bytes: <.main+2305 @062065> - <.main+2414 @0620d2>): static maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+2305 @062065> : 20 48 02 06                load.m32 <@060248> ;i3
	<.main+2309 @062069> : 0c 01 00 00                inc.i32(+1)
	<.main+2313 @06206d> : 20 50 02 06                load.m32 <@060250> ;i6
	<.main+2317 @062071> : 0c 01 00 00                inc.i32(+1)
	<.main+2321 @062075> : 10 01                      dup.x32 sp(1)
	<.main+2323 @062077> : 10 01                      dup.x32 sp(1)
	<.main+2325 @062079> : 59                         cgt.i32
	<.main+2326 @06207a> : 06 0a 00 00                jz <.main+2336 @062084>
	<.main+2330 @06207e> : 10 01                      dup.x32 sp(1)
	<.main+2332 @062080> : 04 06 00 00                jmp <.main+2338 @062086>
	<.main+2336 @062084> : 10 00                      dup.x32 sp(0)
	<.main+2338 @062086> : 13 02                      set.x32 sp(2)
	<.main+2340 @062088> : 09 fc ff ff                inc.sp(-4)
	<.main+2344 @06208c> : 20 58 02 06                load.m32 <@060258> ;i2
	<.main+2348 @062090> : 0c 01 00 00                inc.i32(+1)
	<.main+2352 @062094> : 10 01                      dup.x32 sp(1)
	<.main+2354 @062096> : 10 01                      dup.x32 sp(1)
	<.main+2356 @062098> : 59                         cgt.i32
	<.main+2357 @062099> : 06 0a 00 00                jz <.main+2367 @0620a3>
	<.main+2361 @06209d> : 10 01                      dup.x32 sp(1)
	<.main+2363 @06209f> : 04 06 00 00                jmp <.main+2369 @0620a5>
	<.main+2367 @0620a3> : 10 00                      dup.x32 sp(0)
	<.main+2369 @0620a5> : 13 02                      set.x32 sp(2)
	<.main+2371 @0620a7> : 09 fc ff ff                inc.sp(-4)
	<.main+2375 @0620ab> : 20 60 02 06                load.m32 <@060260> ;i8
	<.main+2379 @0620af> : 0c 01 00 00                inc.i32(+1)
	<.main+2383 @0620b3> : 10 01                      dup.x32 sp(1)
	<.main+2385 @0620b5> : 10 01                      dup.x32 sp(1)
	<.main+2387 @0620b7> : 59                         cgt.i32
	<.main+2388 @0620b8> : 06 0a 00 00                jz <.main+2398 @0620c2>
	<.main+2392 @0620bc> : 10 01                      dup.x32 sp(1)
	<.main+2394 @0620be> : 04 06 00 00                jmp <.main+2400 @0620c4>
	<.main+2398 @0620c2> : 10 00                      dup.x32 sp(0)
	<.main+2400 @0620c4> : 13 02                      set.x32 sp(2)
	<.main+2402 @0620c6> : 09 fc ff ff                inc.sp(-4)
	<.main+2406 @0620ca> : 0c ff ff ff                inc.i32(-1)
	<.main+2410 @0620ce> : 24 b0 03 06                store.m32 <@0603b0> ;maxLrXpr
	cmplStd/test/lang/overload.inline.ci:9: (9 bytes: <.main+2414 @0620d2> - <.main+2423 @0620db>): static overload1: float32 := overload
	<.main+2414 @0620d2> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+2419 @0620d7> : 24 b8 03 06                store.m32 <@0603b8> ;overload1
	cmplStd/test/lang/overload.inline.ci:10: (9 bytes: <.main+2423 @0620db> - <.main+2432 @0620e4>): static overload2: float32 := overload()
	<.main+2423 @0620db> : 7f 00 00 00 40             load.f32 2.000000
	<.main+2428 @0620e0> : 24 c0 03 06                store.m32 <@0603c0> ;overload2
	cmplStd/test/lang/overload.inline.ci:11: (9 bytes: <.main+2432 @0620e4> - <.main+2441 @0620ed>): static overload3: float32 := overload(0)
	<.main+2432 @0620e4> : 7f 00 00 40 40             load.f32 3.000000
	<.main+2437 @0620e9> : 24 c8 03 06                store.m32 <@0603c8> ;overload3
	cmplStd/test/lang/overload.inline.ci:12: (9 bytes: <.main+2441 @0620ed> - <.main+2450 @0620f6>): static overload4: float32 := overload(0.000000)
	<.main+2441 @0620ed> : 7f 00 00 80 40             load.f32 4.000000
	<.main+2446 @0620f2> : 24 d0 03 06                store.m32 <@0603d0> ;overload4
	cmplStd/test/lang/overload.inline.ci:13: (9 bytes: <.main+2450 @0620f6> - <.main+2459 @0620ff>): static overload5: float32 := overload(0, 0)
	<.main+2450 @0620f6> : 7f 00 00 a0 40             load.f32 5.000000
	<.main+2455 @0620fb> : 24 d8 03 06                store.m32 <@0603d8> ;overload5
	cmplStd/test/lang/overload.inline.ci:28: (13 bytes: <.main+2459 @0620ff> - <.main+2472 @06210c>): static boilC: Celsius := Celsius(100.000000)
	<.main+2459 @0620ff> : 8f 00 00 00 00 00 00 59 40 load.f64 100.000000
	<.main+2468 @062108> : 23 e0 03 06                store.m64 <@0603e0> ;boilC
	cmplStd/test/lang/overload.inline.ci:29: (28 bytes: <.main+2472 @06210c> - <.main+2500 @062128>): static boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+2472 @06210c> : 21 e0 03 06                load.m64 <@0603e0> ;boilC
	<.main+2476 @062110> : 8f cd cc cc cc cc cc fc 3f load.f64 1.800000
	<.main+2485 @062119> : 83                         mul.f64
	<.main+2486 @06211a> : 8f 00 00 00 00 00 00 40 40 load.f64 32.000000
	<.main+2495 @062123> : 81                         add.f64
	<.main+2496 @062124> : 23 e8 03 06                store.m64 <@0603e8> ;boilF
	cmplStd/test/std/number.ci:3: (13 bytes: <.main+2500 @062128> - <.main+2513 @062135>): static pi64: float64 := 3.141593
	<.main+2500 @062128> : 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+2509 @062131> : 23 f0 03 06                store.m64 <@0603f0> ;pi64
	cmplStd/test/std/number.ci:4: (13 bytes: <.main+2513 @062135> - <.main+2526 @062142>): static e64: float64 := 2.718282
	<.main+2513 @062135> : 8f 69 57 14 8b 0a bf 05 40 load.f64 2.718282
	<.main+2522 @06213e> : 23 f8 03 06                store.m64 <@0603f8> ;e64
	cmplStd/test/std/number.ci:6: (9 bytes: <.main+2526 @062142> - <.main+2535 @06214b>): static pi32: float32 := pi64
	<.main+2526 @062142> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+2530 @062146> : 8c                         f64.2f32
	<.main+2531 @062147> : 24 00 04 06                store.m32 <@060400> ;pi32
	cmplStd/test/std/number.ci:7: (9 bytes: <.main+2535 @06214b> - <.main+2544 @062154>): static e32: float32 := e64
	<.main+2535 @06214b> : 21 f8 03 06                load.m64 <@0603f8> ;e64
	<.main+2539 @06214f> : 8c                         f64.2f32
	<.main+2540 @062150> : 24 08 04 06                store.m32 <@060408> ;e32
	cmplStd/test/std/number.ci:14: (11 bytes: <.main+2544 @062154> - <.main+2555 @06215f>): static r_comp: int32 := 14 << 3
	<.main+2544 @062154> : 1c 0e 00 00 00             load.c32 14
	<.main+2549 @062159> : 3f 43                      b32.shl 0x003
	<.main+2551 @06215b> : 24 10 04 06                store.m32 <@060410> ;r_comp
	cmplStd/test/std/number.ci:15: (11 bytes: <.main+2555 @06215f> - <.main+2566 @06216a>): static g_comp: int32 := 63 << 2
	<.main+2555 @06215f> : 1c 3f 00 00 00             load.c32 63
	<.main+2560 @062164> : 3f 42                      b32.shl 0x002
	<.main+2562 @062166> : 24 18 04 06                store.m32 <@060418> ;g_comp
	cmplStd/test/std/number.ci:16: (11 bytes: <.main+2566 @06216a> - <.main+2577 @062175>): static b_comp: int32 := 31 << 3
	<.main+2566 @06216a> : 1c 1f 00 00 00             load.c32 31
	<.main+2571 @06216f> : 3f 43                      b32.shl 0x003
	<.main+2573 @062171> : 24 20 04 06                store.m32 <@060420> ;b_comp
	cmplStd/test/std/number.ci:18: (38 bytes: <.main+2577 @062175> - <.main+2615 @06219b>): static r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+2577 @062175> : 20 10 04 06                load.m32 <@060410> ;r_comp
	<.main+2581 @062179> : 3f 48                      b32.shl 0x008
	<.main+2583 @06217b> : 1c 00 f8 00 00             load.c32 63488
	<.main+2588 @062180> : 31                         and.b32
	<.main+2589 @062181> : 20 18 04 06                load.m32 <@060418> ;g_comp
	<.main+2593 @062185> : 3f 43                      b32.shl 0x003
	<.main+2595 @062187> : 1c e0 07 00 00             load.c32 2016
	<.main+2600 @06218c> : 31                         and.b32
	<.main+2601 @06218d> : 32                         or.b32
	<.main+2602 @06218e> : 20 20 04 06                load.m32 <@060420> ;b_comp
	<.main+2606 @062192> : 3f c3                      b32.sar 0x003
	<.main+2608 @062194> : 3f 05                      b32.and 0x01f
	<.main+2610 @062196> : 32                         or.b32
	<.main+2611 @062197> : 24 28 04 06                store.m32 <@060428> ;r5g6b5
	cmplStd/test/std/number.ci:19: (36 bytes: <.main+2615 @06219b> - <.main+2651 @0621bf>): static r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+2615 @06219b> : 20 10 04 06                load.m32 <@060410> ;r_comp
	<.main+2619 @06219f> : 3f 50                      b32.shl 0x010
	<.main+2621 @0621a1> : 1c 00 00 ff 00             load.c32 16711680
	<.main+2626 @0621a6> : 31                         and.b32
	<.main+2627 @0621a7> : 20 18 04 06                load.m32 <@060418> ;g_comp
	<.main+2631 @0621ab> : 3f 48                      b32.shl 0x008
	<.main+2633 @0621ad> : 1c 00 ff 00 00             load.c32 65280
	<.main+2638 @0621b2> : 31                         and.b32
	<.main+2639 @0621b3> : 32                         or.b32
	<.main+2640 @0621b4> : 20 20 04 06                load.m32 <@060420> ;b_comp
	<.main+2644 @0621b8> : 3f 08                      b32.and 0x0ff
	<.main+2646 @0621ba> : 32                         or.b32
	<.main+2647 @0621bb> : 24 30 04 06                store.m32 <@060430> ;r8g8b8
	cmplStd/test/std/number.ci:21: (22 bytes: <.main+2651 @0621bf> - <.main+2673 @0621d5>): static zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+2651 @0621bf> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2655 @0621c3> : 1c 0b 00 00 00             load.c32 11
	<.main+2660 @0621c8> : 1c 05 00 00 00             load.c32 5
	<.main+2665 @0621cd> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2669 @0621d1> : 24 38 04 06                store.m32 <@060438> ;zxtR5
	cmplStd/test/std/number.ci:22: (22 bytes: <.main+2673 @0621d5> - <.main+2695 @0621eb>): static zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+2673 @0621d5> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2677 @0621d9> : 1c 05 00 00 00             load.c32 5
	<.main+2682 @0621de> : 1c 06 00 00 00             load.c32 6
	<.main+2687 @0621e3> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2691 @0621e7> : 24 40 04 06                store.m32 <@060440> ;zxtG6
	cmplStd/test/std/number.ci:23: (18 bytes: <.main+2695 @0621eb> - <.main+2713 @0621fd>): static zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+2695 @0621eb> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2699 @0621ef> : 19                         load.z32
	<.main+2700 @0621f0> : 1c 05 00 00 00             load.c32 5
	<.main+2705 @0621f5> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2709 @0621f9> : 24 48 04 06                store.m32 <@060448> ;zxtB5
	cmplStd/test/std/number.ci:25: (22 bytes: <.main+2713 @0621fd> - <.main+2735 @062213>): static sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+2713 @0621fd> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2717 @062201> : 1c 0b 00 00 00             load.c32 11
	<.main+2722 @062206> : 1c 05 00 00 00             load.c32 5
	<.main+2727 @06220b> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2731 @06220f> : 24 50 04 06                store.m32 <@060450> ;sxtR5
	cmplStd/test/std/number.ci:26: (22 bytes: <.main+2735 @062213> - <.main+2757 @062229>): static sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+2735 @062213> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2739 @062217> : 1c 05 00 00 00             load.c32 5
	<.main+2744 @06221c> : 1c 06 00 00 00             load.c32 6
	<.main+2749 @062221> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2753 @062225> : 24 58 04 06                store.m32 <@060458> ;sxtG6
	cmplStd/test/std/number.ci:27: (18 bytes: <.main+2757 @062229> - <.main+2775 @06223b>): static sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+2757 @062229> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+2761 @06222d> : 19                         load.z32
	<.main+2762 @06222e> : 1c 05 00 00 00             load.c32 5
	<.main+2767 @062233> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2771 @062237> : 24 60 04 06                store.m32 <@060460> ;sxtB5
	cmplStd/test/std/number.ci:29: (22 bytes: <.main+2775 @06223b> - <.main+2797 @062251>): static zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+2775 @06223b> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2779 @06223f> : 1c 10 00 00 00             load.c32 16
	<.main+2784 @062244> : 1c 08 00 00 00             load.c32 8
	<.main+2789 @062249> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2793 @06224d> : 24 68 04 06                store.m32 <@060468> ;zxtR8
	cmplStd/test/std/number.ci:30: (22 bytes: <.main+2797 @062251> - <.main+2819 @062267>): static zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+2797 @062251> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2801 @062255> : 1c 08 00 00 00             load.c32 8
	<.main+2806 @06225a> : 1c 08 00 00 00             load.c32 8
	<.main+2811 @06225f> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2815 @062263> : 24 70 04 06                store.m32 <@060470> ;zxtG8
	cmplStd/test/std/number.ci:31: (18 bytes: <.main+2819 @062267> - <.main+2837 @062279>): static zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+2819 @062267> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2823 @06226b> : 19                         load.z32
	<.main+2824 @06226c> : 1c 08 00 00 00             load.c32 8
	<.main+2829 @062271> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+2833 @062275> : 24 78 04 06                store.m32 <@060478> ;zxtB8
	cmplStd/test/std/number.ci:33: (22 bytes: <.main+2837 @062279> - <.main+2859 @06228f>): static sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+2837 @062279> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2841 @06227d> : 1c 10 00 00 00             load.c32 16
	<.main+2846 @062282> : 1c 08 00 00 00             load.c32 8
	<.main+2851 @062287> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2855 @06228b> : 24 80 04 06                store.m32 <@060480> ;sxtR8
	cmplStd/test/std/number.ci:34: (22 bytes: <.main+2859 @06228f> - <.main+2881 @0622a5>): static sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+2859 @06228f> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2863 @062293> : 1c 08 00 00 00             load.c32 8
	<.main+2868 @062298> : 1c 08 00 00 00             load.c32 8
	<.main+2873 @06229d> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2877 @0622a1> : 24 88 04 06                store.m32 <@060488> ;sxtG8
	cmplStd/test/std/number.ci:35: (18 bytes: <.main+2881 @0622a5> - <.main+2899 @0622b7>): static sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+2881 @0622a5> : 20 30 04 06                load.m32 <@060430> ;r8g8b8
	<.main+2885 @0622a9> : 19                         load.z32
	<.main+2886 @0622aa> : 1c 08 00 00 00             load.c32 8
	<.main+2891 @0622af> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+2895 @0622b3> : 24 90 04 06                store.m32 <@060490> ;sxtB8
	cmplStd/test/std/number.ci:37: (22 bytes: <.main+2899 @0622b7> - <.main+2921 @0622cd>): static testSin_f64: float64 := float64.sin(pi64 / (2))
	<.main+2899 @0622b7> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+2903 @0622bb> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2912 @0622c4> : 84                         div.f64
	<.main+2913 @0622c5> : 01 27 00 00                nfc(39) ;float64.sin(x: float64): float64
	<.main+2917 @0622c9> : 23 98 04 06                store.m64 <@060498> ;testSin_f64
	cmplStd/test/std/number.ci:38: (22 bytes: <.main+2921 @0622cd> - <.main+2943 @0622e3>): static testCos_f64: float64 := float64.cos(pi64 / (2))
	<.main+2921 @0622cd> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+2925 @0622d1> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+2934 @0622da> : 84                         div.f64
	<.main+2935 @0622db> : 01 28 00 00                nfc(40) ;float64.cos(x: float64): float64
	<.main+2939 @0622df> : 23 a0 04 06                store.m64 <@0604a0> ;testCos_f64
	cmplStd/test/std/number.ci:39: (22 bytes: <.main+2943 @0622e3> - <.main+2965 @0622f9>): static testTan_f64: float64 := float64.tan(pi64 / (4))
	<.main+2943 @0622e3> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+2947 @0622e7> : 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+2956 @0622f0> : 84                         div.f64
	<.main+2957 @0622f1> : 01 29 00 00                nfc(41) ;float64.tan(x: float64): float64
	<.main+2961 @0622f5> : 23 a8 04 06                store.m64 <@0604a8> ;testTan_f64
	cmplStd/test/std/number.ci:40: (22 bytes: <.main+2965 @0622f9> - <.main+2987 @06230f>): static testLog_f64: float64 := float64.log(e64 * e64 * e64)
	<.main+2965 @0622f9> : 21 f8 03 06                load.m64 <@0603f8> ;e64
	<.main+2969 @0622fd> : 21 f8 03 06                load.m64 <@0603f8> ;e64
	<.main+2973 @062301> : 83                         mul.f64
	<.main+2974 @062302> : 21 f8 03 06                load.m64 <@0603f8> ;e64
	<.main+2978 @062306> : 83                         mul.f64
	<.main+2979 @062307> : 01 2a 00 00                nfc(42) ;float64.log(x: float64): float64
	<.main+2983 @06230b> : 23 b0 04 06                store.m64 <@0604b0> ;testLog_f64
	cmplStd/test/std/number.ci:41: (17 bytes: <.main+2987 @06230f> - <.main+3004 @062320>): static testExp_f64: float64 := float64.exp(1.000000)
	<.main+2987 @06230f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+2996 @062318> : 01 2b 00 00                nfc(43) ;float64.exp(x: float64): float64
	<.main+3000 @06231c> : 23 b8 04 06                store.m64 <@0604b8> ;testExp_f64
	cmplStd/test/std/number.ci:42: (26 bytes: <.main+3004 @062320> - <.main+3030 @06233a>): static testPow_f64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+3004 @062320> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+3008 @062324> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+3012 @062328> : 83                         mul.f64
	<.main+3013 @062329> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+3022 @062332> : 01 2c 00 00                nfc(44) ;float64.pow(x: float64, y: float64): float64
	<.main+3026 @062336> : 23 c0 04 06                store.m64 <@0604c0> ;testPow_f64
	cmplStd/test/std/number.ci:43: (17 bytes: <.main+3030 @06233a> - <.main+3047 @06234b>): static testSqrt_f64: float64 := float64.sqrt(pi64 * pi64)
	<.main+3030 @06233a> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+3034 @06233e> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+3038 @062342> : 83                         mul.f64
	<.main+3039 @062343> : 01 2d 00 00                nfc(45) ;float64.sqrt(x: float64): float64
	<.main+3043 @062347> : 23 c8 04 06                store.m64 <@0604c8> ;testSqrt_f64
	cmplStd/test/std/number.ci:44: (21 bytes: <.main+3047 @06234b> - <.main+3068 @062360>): static testAtan_f64: float64 := float64.atan2(pi64, 1.000000)
	<.main+3047 @06234b> : 21 f0 03 06                load.m64 <@0603f0> ;pi64
	<.main+3051 @06234f> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+3060 @062358> : 01 2e 00 00                nfc(46) ;float64.atan2(x: float64, y: float64): float64
	<.main+3064 @06235c> : 23 d0 04 06                store.m64 <@0604d0> ;testAtan_f64
	cmplStd/test/std/number.ci:46: (18 bytes: <.main+3068 @062360> - <.main+3086 @062372>): static testSin_f32: float32 := float32.sin(pi32 / (2))
	<.main+3068 @062360> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3072 @062364> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3077 @062369> : 74                         div.f32
	<.main+3078 @06236a> : 01 1f 00 00                nfc(31) ;float32.sin(x: float32): float32
	<.main+3082 @06236e> : 24 d8 04 06                store.m32 <@0604d8> ;testSin_f32
	cmplStd/test/std/number.ci:47: (18 bytes: <.main+3086 @062372> - <.main+3104 @062384>): static testCos_f32: float32 := float32.cos(pi32 / (2))
	<.main+3086 @062372> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3090 @062376> : 7f 00 00 00 40             load.f32 2.000000
	<.main+3095 @06237b> : 74                         div.f32
	<.main+3096 @06237c> : 01 20 00 00                nfc(32) ;float32.cos(x: float32): float32
	<.main+3100 @062380> : 24 e0 04 06                store.m32 <@0604e0> ;testCos_f32
	cmplStd/test/std/number.ci:48: (18 bytes: <.main+3104 @062384> - <.main+3122 @062396>): static testTan_f32: float32 := float32.tan(pi32 / (4))
	<.main+3104 @062384> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3108 @062388> : 7f 00 00 80 40             load.f32 4.000000
	<.main+3113 @06238d> : 74                         div.f32
	<.main+3114 @06238e> : 01 21 00 00                nfc(33) ;float32.tan(x: float32): float32
	<.main+3118 @062392> : 24 e8 04 06                store.m32 <@0604e8> ;testTan_f32
	cmplStd/test/std/number.ci:49: (22 bytes: <.main+3122 @062396> - <.main+3144 @0623ac>): static testLog_f32: float32 := float32.log(e32 * e32 * e32)
	<.main+3122 @062396> : 20 08 04 06                load.m32 <@060408> ;e32
	<.main+3126 @06239a> : 20 08 04 06                load.m32 <@060408> ;e32
	<.main+3130 @06239e> : 73                         mul.f32
	<.main+3131 @06239f> : 20 08 04 06                load.m32 <@060408> ;e32
	<.main+3135 @0623a3> : 73                         mul.f32
	<.main+3136 @0623a4> : 01 22 00 00                nfc(34) ;float32.log(x: float32): float32
	<.main+3140 @0623a8> : 24 f0 04 06                store.m32 <@0604f0> ;testLog_f32
	cmplStd/test/std/number.ci:50: (13 bytes: <.main+3144 @0623ac> - <.main+3157 @0623b9>): static testExp_f32: float32 := float32.exp(1.000000)
	<.main+3144 @0623ac> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3149 @0623b1> : 01 23 00 00                nfc(35) ;float32.exp(x: float32): float32
	<.main+3153 @0623b5> : 24 f8 04 06                store.m32 <@0604f8> ;testExp_f32
	cmplStd/test/std/number.ci:51: (22 bytes: <.main+3157 @0623b9> - <.main+3179 @0623cf>): static testPow_f32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+3157 @0623b9> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3161 @0623bd> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3165 @0623c1> : 73                         mul.f32
	<.main+3166 @0623c2> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+3171 @0623c7> : 01 24 00 00                nfc(36) ;float32.pow(x: float32, y: float32): float32
	<.main+3175 @0623cb> : 24 00 05 06                store.m32 <@060500> ;testPow_f32
	cmplStd/test/std/number.ci:52: (17 bytes: <.main+3179 @0623cf> - <.main+3196 @0623e0>): static testSqrt_f32: float32 := float32.sqrt(pi32 * pi32)
	<.main+3179 @0623cf> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3183 @0623d3> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3187 @0623d7> : 73                         mul.f32
	<.main+3188 @0623d8> : 01 25 00 00                nfc(37) ;float32.sqrt(x: float32): float32
	<.main+3192 @0623dc> : 24 08 05 06                store.m32 <@060508> ;testSqrt_f32
	cmplStd/test/std/number.ci:53: (17 bytes: <.main+3196 @0623e0> - <.main+3213 @0623f1>): static testAtan_f32: float32 := float32.atan2(pi32, 1.000000)
	<.main+3196 @0623e0> : 20 00 04 06                load.m32 <@060400> ;pi32
	<.main+3200 @0623e4> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+3205 @0623e9> : 01 26 00 00                nfc(38) ;float32.atan2(x: float32, y: float32): float32
	<.main+3209 @0623ed> : 24 10 05 06                store.m32 <@060510> ;testAtan_f32
	cmplStd/test/std/number.ci:55: (12 bytes: <.main+3213 @0623f1> - <.main+3225 @0623fd>): static testPopulation_u32: int32 := uint32.pop(r5g6b5)
	<.main+3213 @0623f1> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3217 @0623f5> : 01 17 00 00                nfc(23) ;uint32.pop(value: int32): int32
	<.main+3221 @0623f9> : 24 18 05 06                store.m32 <@060518> ;testPopulation_u32
	cmplStd/test/std/number.ci:56: (12 bytes: <.main+3225 @0623fd> - <.main+3237 @062409>): static testSwapBits_u32: uint32 := uint32.swap(r5g6b5)
	<.main+3225 @0623fd> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3229 @062401> : 01 18 00 00                nfc(24) ;uint32.swap(value: int32): int32
	<.main+3233 @062405> : 24 20 05 06                store.m32 <@060520> ;testSwapBits_u32
	cmplStd/test/std/number.ci:57: (12 bytes: <.main+3237 @062409> - <.main+3249 @062415>): static testBitScanReverse_u32: int32 := uint32.bsr(r5g6b5)
	<.main+3237 @062409> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3241 @06240d> : 01 19 00 00                nfc(25) ;uint32.bsr(value: int32): int32
	<.main+3245 @062411> : 24 28 05 06                store.m32 <@060528> ;testBitScanReverse_u32
	cmplStd/test/std/number.ci:58: (12 bytes: <.main+3249 @062415> - <.main+3261 @062421>): static testBitScanForward_u32: int32 := uint32.bsf(r5g6b5)
	<.main+3249 @062415> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3253 @062419> : 01 1a 00 00                nfc(26) ;uint32.bsf(value: int32): int32
	<.main+3257 @06241d> : 24 30 05 06                store.m32 <@060530> ;testBitScanForward_u32
	cmplStd/test/std/number.ci:59: (12 bytes: <.main+3261 @062421> - <.main+3273 @06242d>): static testHighBit_u32: int32 := uint32.hib(r5g6b5)
	<.main+3261 @062421> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3265 @062425> : 01 1b 00 00                nfc(27) ;uint32.hib(value: int32): int32
	<.main+3269 @062429> : 24 38 05 06                store.m32 <@060538> ;testHighBit_u32
	cmplStd/test/std/number.ci:60: (12 bytes: <.main+3273 @06242d> - <.main+3285 @062439>): static testLowBit_u32: int32 := uint32.lob(r5g6b5)
	<.main+3273 @06242d> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3277 @062431> : 01 1c 00 00                nfc(28) ;uint32.lob(value: int32): int32
	<.main+3281 @062435> : 24 40 05 06                store.m32 <@060540> ;testLowBit_u32
	cmplStd/test/std/number.ci:62: (18 bytes: <.main+3285 @062439> - <.main+3303 @06244b>): static testZeroExtend_u32: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+3285 @062439> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3289 @06243d> : 19                         load.z32
	<.main+3290 @06243e> : 1c 05 00 00 00             load.c32 5
	<.main+3295 @062443> : 01 15 00 00                nfc(21) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<.main+3299 @062447> : 24 48 05 06                store.m32 <@060548> ;testZeroExtend_u32
	cmplStd/test/std/number.ci:63: (18 bytes: <.main+3303 @06244b> - <.main+3321 @06245d>): static testSignExtend_u32: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+3303 @06244b> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3307 @06244f> : 19                         load.z32
	<.main+3308 @062450> : 1c 05 00 00 00             load.c32 5
	<.main+3313 @062455> : 01 16 00 00                nfc(22) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<.main+3317 @062459> : 24 50 05 06                store.m32 <@060550> ;testSignExtend_u32
	cmplStd/test/std/number.ci:65: (20 bytes: <.main+3321 @06245d> - <.main+3341 @062471>): static testZeroExtend_u64: int32 := uint64.zxt(r5g6b5, 0, 5)
	<.main+3321 @06245d> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3325 @062461> : 5b                         i32.2i64
	<.main+3326 @062462> : 19                         load.z32
	<.main+3327 @062463> : 1c 05 00 00 00             load.c32 5
	<.main+3332 @062468> : 01 1d 00 00                nfc(29) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<.main+3336 @06246c> : 6a                         i64.2i32
	<.main+3337 @06246d> : 24 58 05 06                store.m32 <@060558> ;testZeroExtend_u64
	cmplStd/test/std/number.ci:66: (20 bytes: <.main+3341 @062471> - <.main+3361 @062485>): static testSignExtend_u64: int32 := uint64.sxt(r5g6b5, 0, 5)
	<.main+3341 @062471> : 20 28 04 06                load.m32 <@060428> ;r5g6b5
	<.main+3345 @062475> : 5b                         i32.2i64
	<.main+3346 @062476> : 19                         load.z32
	<.main+3347 @062477> : 1c 05 00 00 00             load.c32 5
	<.main+3352 @06247c> : 01 1e 00 00                nfc(30) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<.main+3356 @062480> : 6a                         i64.2i32
	<.main+3357 @062481> : 24 60 05 06                store.m32 <@060560> ;testSignExtend_u64
	cmplStd/test/std/memory.ci:7: (18 bytes: <.main+3361 @062485> - <.main+3379 @062497>): static p1: pointer := malloc(1024)
	<.main+3361 @062485> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3366 @06248a> : 1c 00 04 00 00             load.c32 1024
	<.main+3371 @06248f> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3375 @062493> : 24 68 05 06                store.m32 <@060568> ;p1
	cmplStd/test/std/memory.ci:8: (18 bytes: <.main+3379 @062497> - <.main+3397 @0624a9>): static p2: pointer := malloc(80)
	<.main+3379 @062497> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3384 @06249c> : 1c 50 00 00 00             load.c32 80
	<.main+3389 @0624a1> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3393 @0624a5> : 24 70 05 06                store.m32 <@060570> ;p2
	cmplStd/test/std/memory.ci:9: (18 bytes: <.main+3397 @0624a9> - <.main+3415 @0624bb>): static p3: pointer := malloc(160)
	<.main+3397 @0624a9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3402 @0624ae> : 1c a0 00 00 00             load.c32 160
	<.main+3407 @0624b3> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3411 @0624b7> : 24 78 05 06                store.m32 <@060578> ;p3
	cmplStd/test/std/memory.ci:10: (18 bytes: <.main+3415 @0624bb> - <.main+3433 @0624cd>): static p4: pointer := malloc(820)
	<.main+3415 @0624bb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3420 @0624c0> : 1c 34 03 00 00             load.c32 820
	<.main+3425 @0624c5> : 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+3429 @0624c9> : 24 80 05 06                store.m32 <@060580> ;p4
	cmplStd/test/std/memory.ci:23: (13 bytes: <.main+3433 @0624cd> - <.main+3446 @0624da>): static val1: int64 := 42
	<.main+3433 @0624cd> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3442 @0624d6> : 23 88 05 06                store.m64 <@060588> ;val1
	cmplStd/test/std/memory.ci:24: (13 bytes: <.main+3446 @0624da> - <.main+3459 @0624e7>): static val2: int64 := 96
	<.main+3446 @0624da> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+3455 @0624e3> : 23 90 05 06                store.m64 <@060590> ;val2
	cmplStd/test/std/tryExec.ci:47: (18 bytes: <.main+3459 @0624e7> - <.main+3477 @0624f9>): static tryExecErr0: int32 := tryExec(null, noError)
	<.main+3459 @0624e7> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3464 @0624ec> : 1f 98 05 06 00             load.ref <@060598> ;noError(ptr: pointer): void
	<.main+3469 @0624f1> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3473 @0624f5> : 24 28 06 06                store.m32 <@060628> ;tryExecErr0
	cmplStd/test/std/tryExec.ci:48: (18 bytes: <.main+3477 @0624f9> - <.main+3495 @06250b>): static tryExecErr1: int32 := tryExec(null, null)
	<.main+3477 @0624f9> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3482 @0624fe> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3487 @062503> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3491 @062507> : 24 30 06 06                store.m32 <@060630> ;tryExecErr1
	cmplStd/test/std/tryExec.ci:49: (18 bytes: <.main+3495 @06250b> - <.main+3513 @06251d>): static tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+3495 @06250b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3500 @062510> : 1f a0 05 06 00             load.ref <@0605a0> ;stackOverflow(ptr: pointer): void
	<.main+3505 @062515> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3509 @062519> : 24 38 06 06                store.m32 <@060638> ;tryExecErr2
	cmplStd/test/std/tryExec.ci:50: (18 bytes: <.main+3513 @06251d> - <.main+3531 @06252f>): static tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+3513 @06251d> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3518 @062522> : 1f b8 05 06 00             load.ref <@0605b8> ;divisionByZero(args: pointer): void
	<.main+3523 @062527> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3527 @06252b> : 24 40 06 06                store.m32 <@060640> ;tryExecErr3
	cmplStd/test/std/tryExec.ci:51: (18 bytes: <.main+3531 @06252f> - <.main+3549 @062541>): static tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+3531 @06252f> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3536 @062534> : 1f 20 06 06 00             load.ref <@060620> ;invalidInstruction(args: pointer): void
	<.main+3541 @062539> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3545 @06253d> : 24 48 06 06                store.m32 <@060648> ;tryExecErr4
	cmplStd/test/std/tryExec.ci:52: (18 bytes: <.main+3549 @062541> - <.main+3567 @062553>): static tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+3549 @062541> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3554 @062546> : 1f 10 06 06 00             load.ref <@060610> ;invalidMemoryAccess(args: pointer): void
	<.main+3559 @06254b> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3563 @06254f> : 24 50 06 06                store.m32 <@060650> ;tryExecErr5
	cmplStd/test/std/tryExec.ci:53: (18 bytes: <.main+3567 @062553> - <.main+3585 @062565>): static tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+3567 @062553> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3572 @062558> : 1f c8 05 06 00             load.ref <@0605c8> ;abortExecution(args: pointer): void
	<.main+3577 @06255d> : 01 09 00 00                nfc(9) ;tryExec(args: pointer, action(args: pointer): void): int32
	<.main+3581 @062561> : 24 58 06 06                store.m32 <@060658> ;tryExecErr6
	cmplStd/test/lang/init.reference.ci:7: (13 bytes: <.main+3585 @062565> - <.main+3598 @062572>): static value: int64 := 42
	<.main+3585 @062565> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+3594 @06256e> : 23 60 06 06                store.m64 <@060660> ;value
	cmplStd/test/lang/init.reference.ci:8: (9 bytes: <.main+3598 @062572> - <.main+3607 @06257b>): static valueRef: int64 := value
	<.main+3598 @062572> : 1f 60 06 06 00             load.ref <@060660> ;value
	<.main+3603 @062577> : 24 68 06 06                store.m32 <@060668> ;valueRef
	cmplStd/test/lang/init.reference.ci:9: (9 bytes: <.main+3607 @06257b> - <.main+3616 @062584>): static valuePtr: pointer := value
	<.main+3607 @06257b> : 1f 60 06 06 00             load.ref <@060660> ;value
	<.main+3612 @062580> : 24 70 06 06                store.m32 <@060670> ;valuePtr
	cmplStd/test/lang/init.reference.ci:10: (14 bytes: <.main+3616 @062584> - <.main+3630 @062592>): static valueVar: variant := value
	<.main+3616 @062584> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3621 @062589> : 1f 60 06 06 00             load.ref <@060660> ;value
	<.main+3626 @06258e> : 23 78 06 06                store.m64 <@060678> ;valueVar
	cmplStd/test/lang/init.reference.ci:12: (9 bytes: <.main+3630 @062592> - <.main+3639 @06259b>): static fromRef: int64 := valueRef
	<.main+3630 @062592> : 20 68 06 06                load.m32 <@060668> ;valueRef
	<.main+3634 @062596> : 29                         load.i64
	<.main+3635 @062597> : 23 80 06 06                store.m64 <@060680> ;fromRef
	cmplStd/test/lang/init.reference.ci:13: (8 bytes: <.main+3639 @06259b> - <.main+3647 @0625a3>): static fromPtr: int64 := valuePtr
	<.main+3639 @06259b> : 20 70 06 06                load.m32 <@060670> ;valuePtr
	<.main+3643 @06259f> : 24 88 06 06                store.m32 <@060688> ;fromPtr
	cmplStd/test/lang/init.reference.ci:14: (8 bytes: <.main+3647 @0625a3> - <.main+3655 @0625ab>): static fromVar: int64 := valueVar
	<.main+3647 @0625a3> : 20 78 06 06                load.m32 <@060678> ;valueVar
	<.main+3651 @0625a7> : 24 90 06 06                store.m32 <@060690> ;fromVar
	cmplStd/test/lang/init.reference.ci:16: (9 bytes: <.main+3655 @0625ab> - <.main+3664 @0625b4>): static nullRef: int64 := null
	<.main+3655 @0625ab> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3660 @0625b0> : 24 98 06 06                store.m32 <@060698> ;nullRef
	cmplStd/test/lang/init.reference.ci:17: (9 bytes: <.main+3664 @0625b4> - <.main+3673 @0625bd>): static nullPtr: pointer := null
	<.main+3664 @0625b4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3669 @0625b9> : 24 a0 06 06                store.m32 <@0606a0> ;nullPtr
	cmplStd/test/lang/init.reference.ci:18: (14 bytes: <.main+3673 @0625bd> - <.main+3687 @0625cb>): static nullVar: variant := null
	<.main+3673 @0625bd> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3678 @0625c2> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3683 @0625c7> : 23 a8 06 06                store.m64 <@0606a8> ;nullVar
	cmplStd/test/lang/init.reference.ci:19: (9 bytes: <.main+3687 @0625cb> - <.main+3696 @0625d4>): static nullTyp: typename := null
	<.main+3687 @0625cb> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3692 @0625d0> : 24 b0 06 06                store.m32 <@0606b0> ;nullTyp
	cmplStd/test/lang/init.reference.ci:20: (9 bytes: <.main+3696 @0625d4> - <.main+3705 @0625dd>): static nullFun: function := null
	<.main+3696 @0625d4> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3701 @0625d9> : 24 b8 06 06                store.m32 <@0606b8> ;nullFun
	cmplStd/test/lang/init.reference.ci:21: (9 bytes: <.main+3705 @0625dd> - <.main+3714 @0625e6>): static nullObj: object := null
	<.main+3705 @0625dd> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+3710 @0625e2> : 24 c0 06 06                store.m32 <@0606c0> ;nullObj
	cmplStd/test/lang/init.reference.ci:23: (9 bytes: <.main+3714 @0625e6> - <.main+3723 @0625ef>): static typePtr: pointer := int64
	<.main+3714 @0625e6> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3719 @0625eb> : 24 c8 06 06                store.m32 <@0606c8> ;typePtr
	cmplStd/test/lang/init.reference.ci:24: (14 bytes: <.main+3723 @0625ef> - <.main+3737 @0625fd>): static typeVar: variant := int64
	<.main+3723 @0625ef> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3728 @0625f4> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3733 @0625f9> : 23 d0 06 06                store.m64 <@0606d0> ;typeVar
	cmplStd/test/lang/init.reference.ci:25: (9 bytes: <.main+3737 @0625fd> - <.main+3746 @062606>): static typeTyp: typename := int64
	<.main+3737 @0625fd> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3742 @062602> : 24 d8 06 06                store.m32 <@0606d8> ;typeTyp
	cmplStd/test/lang/init.reference.ci:27: (8 bytes: <.main+3746 @062606> - <.main+3754 @06260e>): static local: int64 := value
	<.main+3746 @062606> : 21 60 06 06                load.m64 <@060660> ;value
	<.main+3750 @06260a> : 23 e0 06 06                store.m64 <@0606e0> ;local
	cmplStd/test/lang/init.reference.ci:28: (8 bytes: <.main+3754 @06260e> - <.main+3762 @062616>): static copyVal: int64 := local
	<.main+3754 @06260e> : 21 e0 06 06                load.m64 <@0606e0> ;local
	<.main+3758 @062612> : 23 e8 06 06                store.m64 <@0606e8> ;copyVal
	cmplStd/test/lang/init.reference.ci:29: (8 bytes: <.main+3762 @062616> - <.main+3770 @06261e>): static copyRef: int64 := valueRef
	<.main+3762 @062616> : 20 68 06 06                load.m32 <@060668> ;valueRef
	<.main+3766 @06261a> : 24 f0 06 06                store.m32 <@0606f0> ;copyRef
	cmplStd/test/lang/init.reference.ci:30: (8 bytes: <.main+3770 @06261e> - <.main+3778 @062626>): static copyPtr: pointer := valuePtr
	<.main+3770 @06261e> : 20 70 06 06                load.m32 <@060670> ;valuePtr
	<.main+3774 @062622> : 24 f8 06 06                store.m32 <@0606f8> ;copyPtr
	cmplStd/test/lang/init.reference.ci:31: (8 bytes: <.main+3778 @062626> - <.main+3786 @06262e>): static copyVar: variant := valueVar
	<.main+3778 @062626> : 21 78 06 06                load.m64 <@060678> ;valueVar
	<.main+3782 @06262a> : 23 00 07 06                store.m64 <@060700> ;copyVar
	cmplStd/test/lang/init.reference.ci:32: (8 bytes: <.main+3786 @06262e> - <.main+3794 @062636>): static copyTyp: typename := typeTyp
	<.main+3786 @06262e> : 20 d8 06 06                load.m32 <@0606d8> ;typeTyp
	<.main+3790 @062632> : 24 08 07 06                store.m32 <@060708> ;copyTyp
	cmplStd/test/lang/init.reference.ci:35: (9 bytes: <.main+3794 @062636> - <.main+3803 @06263f>): static ptrVoid: pointer := void
	<.main+3794 @062636> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3799 @06263b> : 24 10 07 06                store.m32 <@060710> ;ptrVoid
	cmplStd/test/lang/init.reference.ci:36: (9 bytes: <.main+3803 @06263f> - <.main+3812 @062648>): static ptrBool: pointer := bool
	<.main+3803 @06263f> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3808 @062644> : 24 18 07 06                store.m32 <@060718> ;ptrBool
	cmplStd/test/lang/init.reference.ci:37: (9 bytes: <.main+3812 @062648> - <.main+3821 @062651>): static ptrChar: pointer := char
	<.main+3812 @062648> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3817 @06264d> : 24 20 07 06                store.m32 <@060720> ;ptrChar
	cmplStd/test/lang/init.reference.ci:38: (9 bytes: <.main+3821 @062651> - <.main+3830 @06265a>): static ptrInt8: pointer := int8
	<.main+3821 @062651> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+3826 @062656> : 24 28 07 06                store.m32 <@060728> ;ptrInt8
	cmplStd/test/lang/init.reference.ci:39: (9 bytes: <.main+3830 @06265a> - <.main+3839 @062663>): static ptrInt16: pointer := int16
	<.main+3830 @06265a> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+3835 @06265f> : 24 30 07 06                store.m32 <@060730> ;ptrInt16
	cmplStd/test/lang/init.reference.ci:40: (9 bytes: <.main+3839 @062663> - <.main+3848 @06266c>): static ptrInt32: pointer := int32
	<.main+3839 @062663> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+3844 @062668> : 24 38 07 06                store.m32 <@060738> ;ptrInt32
	cmplStd/test/lang/init.reference.ci:41: (9 bytes: <.main+3848 @06266c> - <.main+3857 @062675>): static ptrInt64: pointer := int64
	<.main+3848 @06266c> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+3853 @062671> : 24 40 07 06                store.m32 <@060740> ;ptrInt64
	cmplStd/test/lang/init.reference.ci:42: (9 bytes: <.main+3857 @062675> - <.main+3866 @06267e>): static ptrUint8: pointer := uint8
	<.main+3857 @062675> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+3862 @06267a> : 24 48 07 06                store.m32 <@060748> ;ptrUint8
	cmplStd/test/lang/init.reference.ci:43: (9 bytes: <.main+3866 @06267e> - <.main+3875 @062687>): static ptrUint16: pointer := uint16
	<.main+3866 @06267e> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+3871 @062683> : 24 50 07 06                store.m32 <@060750> ;ptrUint16
	cmplStd/test/lang/init.reference.ci:44: (9 bytes: <.main+3875 @062687> - <.main+3884 @062690>): static ptrUint32: pointer := uint32
	<.main+3875 @062687> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+3880 @06268c> : 24 58 07 06                store.m32 <@060758> ;ptrUint32
	cmplStd/test/lang/init.reference.ci:45: (9 bytes: <.main+3884 @062690> - <.main+3893 @062699>): static ptrUint64: pointer := uint64
	<.main+3884 @062690> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+3889 @062695> : 24 60 07 06                store.m32 <@060760> ;ptrUint64
	cmplStd/test/lang/init.reference.ci:46: (9 bytes: <.main+3893 @062699> - <.main+3902 @0626a2>): static ptrFloat32: pointer := float32
	<.main+3893 @062699> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+3898 @06269e> : 24 68 07 06                store.m32 <@060768> ;ptrFloat32
	cmplStd/test/lang/init.reference.ci:47: (9 bytes: <.main+3902 @0626a2> - <.main+3911 @0626ab>): static ptrFloat64: pointer := float64
	<.main+3902 @0626a2> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+3907 @0626a7> : 24 70 07 06                store.m32 <@060770> ;ptrFloat64
	cmplStd/test/lang/init.reference.ci:48: (9 bytes: <.main+3911 @0626ab> - <.main+3920 @0626b4>): static ptrTypename: pointer := typename
	<.main+3911 @0626ab> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3916 @0626b0> : 24 78 07 06                store.m32 <@060778> ;ptrTypename
	cmplStd/test/lang/init.reference.ci:49: (9 bytes: <.main+3920 @0626b4> - <.main+3929 @0626bd>): static ptrFunction: pointer := function
	<.main+3920 @0626b4> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+3925 @0626b9> : 24 80 07 06                store.m32 <@060780> ;ptrFunction
	cmplStd/test/lang/init.reference.ci:50: (9 bytes: <.main+3929 @0626bd> - <.main+3938 @0626c6>): static ptrPointer: pointer := pointer
	<.main+3929 @0626bd> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+3934 @0626c2> : 24 88 07 06                store.m32 <@060788> ;ptrPointer
	cmplStd/test/lang/init.reference.ci:51: (9 bytes: <.main+3938 @0626c6> - <.main+3947 @0626cf>): static ptrVariant: pointer := variant
	<.main+3938 @0626c6> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+3943 @0626cb> : 24 90 07 06                store.m32 <@060790> ;ptrVariant
	cmplStd/test/lang/init.reference.ci:52: (9 bytes: <.main+3947 @0626cf> - <.main+3956 @0626d8>): static ptrObject: pointer := object
	<.main+3947 @0626cf> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+3952 @0626d4> : 24 98 07 06                store.m32 <@060798> ;ptrObject
	cmplStd/test/lang/init.reference.ci:55: (14 bytes: <.main+3956 @0626d8> - <.main+3970 @0626e6>): static varVoid: variant := void
	<.main+3956 @0626d8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3961 @0626dd> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+3966 @0626e2> : 23 a0 07 06                store.m64 <@0607a0> ;varVoid
	cmplStd/test/lang/init.reference.ci:56: (14 bytes: <.main+3970 @0626e6> - <.main+3984 @0626f4>): static varBool: variant := bool
	<.main+3970 @0626e6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3975 @0626eb> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+3980 @0626f0> : 23 a8 07 06                store.m64 <@0607a8> ;varBool
	cmplStd/test/lang/init.reference.ci:57: (14 bytes: <.main+3984 @0626f4> - <.main+3998 @062702>): static varChar: variant := char
	<.main+3984 @0626f4> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+3989 @0626f9> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+3994 @0626fe> : 23 b0 07 06                store.m64 <@0607b0> ;varChar
	cmplStd/test/lang/init.reference.ci:58: (14 bytes: <.main+3998 @062702> - <.main+4012 @062710>): static varInt8: variant := int8
	<.main+3998 @062702> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4003 @062707> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4008 @06270c> : 23 b8 07 06                store.m64 <@0607b8> ;varInt8
	cmplStd/test/lang/init.reference.ci:59: (14 bytes: <.main+4012 @062710> - <.main+4026 @06271e>): static varInt16: variant := int16
	<.main+4012 @062710> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4017 @062715> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4022 @06271a> : 23 c0 07 06                store.m64 <@0607c0> ;varInt16
	cmplStd/test/lang/init.reference.ci:60: (14 bytes: <.main+4026 @06271e> - <.main+4040 @06272c>): static varInt32: variant := int32
	<.main+4026 @06271e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4031 @062723> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4036 @062728> : 23 c8 07 06                store.m64 <@0607c8> ;varInt32
	cmplStd/test/lang/init.reference.ci:61: (14 bytes: <.main+4040 @06272c> - <.main+4054 @06273a>): static varInt64: variant := int64
	<.main+4040 @06272c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4045 @062731> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4050 @062736> : 23 d0 07 06                store.m64 <@0607d0> ;varInt64
	cmplStd/test/lang/init.reference.ci:62: (14 bytes: <.main+4054 @06273a> - <.main+4068 @062748>): static varUint8: variant := uint8
	<.main+4054 @06273a> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4059 @06273f> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4064 @062744> : 23 d8 07 06                store.m64 <@0607d8> ;varUint8
	cmplStd/test/lang/init.reference.ci:63: (14 bytes: <.main+4068 @062748> - <.main+4082 @062756>): static varUint16: variant := uint16
	<.main+4068 @062748> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4073 @06274d> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4078 @062752> : 23 e0 07 06                store.m64 <@0607e0> ;varUint16
	cmplStd/test/lang/init.reference.ci:64: (14 bytes: <.main+4082 @062756> - <.main+4096 @062764>): static varUint32: variant := uint32
	<.main+4082 @062756> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4087 @06275b> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4092 @062760> : 23 e8 07 06                store.m64 <@0607e8> ;varUint32
	cmplStd/test/lang/init.reference.ci:65: (14 bytes: <.main+4096 @062764> - <.main+4110 @062772>): static varUint64: variant := uint64
	<.main+4096 @062764> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4101 @062769> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4106 @06276e> : 23 f0 07 06                store.m64 <@0607f0> ;varUint64
	cmplStd/test/lang/init.reference.ci:66: (14 bytes: <.main+4110 @062772> - <.main+4124 @062780>): static varFloat32: variant := float32
	<.main+4110 @062772> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4115 @062777> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4120 @06277c> : 23 f8 07 06                store.m64 <@0607f8> ;varFloat32
	cmplStd/test/lang/init.reference.ci:67: (14 bytes: <.main+4124 @062780> - <.main+4138 @06278e>): static varFloat64: variant := float64
	<.main+4124 @062780> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4129 @062785> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4134 @06278a> : 23 00 08 06                store.m64 <@060800> ;varFloat64
	cmplStd/test/lang/init.reference.ci:68: (14 bytes: <.main+4138 @06278e> - <.main+4152 @06279c>): static varTypename: variant := typename
	<.main+4138 @06278e> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4143 @062793> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4148 @062798> : 23 08 08 06                store.m64 <@060808> ;varTypename
	cmplStd/test/lang/init.reference.ci:69: (14 bytes: <.main+4152 @06279c> - <.main+4166 @0627aa>): static varFunction: variant := function
	<.main+4152 @06279c> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4157 @0627a1> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4162 @0627a6> : 23 10 08 06                store.m64 <@060810> ;varFunction
	cmplStd/test/lang/init.reference.ci:70: (14 bytes: <.main+4166 @0627aa> - <.main+4180 @0627b8>): static varPointer: variant := pointer
	<.main+4166 @0627aa> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4171 @0627af> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4176 @0627b4> : 23 18 08 06                store.m64 <@060818> ;varPointer
	cmplStd/test/lang/init.reference.ci:71: (14 bytes: <.main+4180 @0627b8> - <.main+4194 @0627c6>): static varVariant: variant := variant
	<.main+4180 @0627b8> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4185 @0627bd> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4190 @0627c2> : 23 20 08 06                store.m64 <@060820> ;varVariant
	cmplStd/test/lang/init.reference.ci:72: (14 bytes: <.main+4194 @0627c6> - <.main+4208 @0627d4>): static varObject: variant := object
	<.main+4194 @0627c6> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4199 @0627cb> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4204 @0627d0> : 23 28 08 06                store.m64 <@060828> ;varObject
	cmplStd/test/lang/init.reference.ci:75: (9 bytes: <.main+4208 @0627d4> - <.main+4217 @0627dd>): static typVoid: typename := void
	<.main+4208 @0627d4> : 1f b8 00 00 00             load.ref <@0000b8> ;void
	<.main+4213 @0627d9> : 24 30 08 06                store.m32 <@060830> ;typVoid
	cmplStd/test/lang/init.reference.ci:76: (9 bytes: <.main+4217 @0627dd> - <.main+4226 @0627e6>): static typBool: typename := bool
	<.main+4217 @0627dd> : 1f 60 01 00 00             load.ref <@000160> ;bool
	<.main+4222 @0627e2> : 24 38 08 06                store.m32 <@060838> ;typBool
	cmplStd/test/lang/init.reference.ci:77: (9 bytes: <.main+4226 @0627e6> - <.main+4235 @0627ef>): static typChar: typename := char
	<.main+4226 @0627e6> : 1f 08 02 00 00             load.ref <@000208> ;char
	<.main+4231 @0627eb> : 24 40 08 06                store.m32 <@060840> ;typChar
	cmplStd/test/lang/init.reference.ci:78: (9 bytes: <.main+4235 @0627ef> - <.main+4244 @0627f8>): static typInt8: typename := int8
	<.main+4235 @0627ef> : 1f b0 02 00 00             load.ref <@0002b0> ;int8
	<.main+4240 @0627f4> : 24 48 08 06                store.m32 <@060848> ;typInt8
	cmplStd/test/lang/init.reference.ci:79: (9 bytes: <.main+4244 @0627f8> - <.main+4253 @062801>): static typInt16: typename := int16
	<.main+4244 @0627f8> : 1f 58 03 00 00             load.ref <@000358> ;int16
	<.main+4249 @0627fd> : 24 50 08 06                store.m32 <@060850> ;typInt16
	cmplStd/test/lang/init.reference.ci:80: (9 bytes: <.main+4253 @062801> - <.main+4262 @06280a>): static typInt32: typename := int32
	<.main+4253 @062801> : 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+4258 @062806> : 24 58 08 06                store.m32 <@060858> ;typInt32
	cmplStd/test/lang/init.reference.ci:81: (9 bytes: <.main+4262 @06280a> - <.main+4271 @062813>): static typInt64: typename := int64
	<.main+4262 @06280a> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4267 @06280f> : 24 60 08 06                store.m32 <@060860> ;typInt64
	cmplStd/test/lang/init.reference.ci:82: (9 bytes: <.main+4271 @062813> - <.main+4280 @06281c>): static typUint8: typename := uint8
	<.main+4271 @062813> : 1f 50 05 00 00             load.ref <@000550> ;uint8
	<.main+4276 @062818> : 24 68 08 06                store.m32 <@060868> ;typUint8
	cmplStd/test/lang/init.reference.ci:83: (9 bytes: <.main+4280 @06281c> - <.main+4289 @062825>): static typUint16: typename := uint16
	<.main+4280 @06281c> : 1f f8 05 00 00             load.ref <@0005f8> ;uint16
	<.main+4285 @062821> : 24 70 08 06                store.m32 <@060870> ;typUint16
	cmplStd/test/lang/init.reference.ci:84: (9 bytes: <.main+4289 @062825> - <.main+4298 @06282e>): static typUint32: typename := uint32
	<.main+4289 @062825> : 1f a0 06 00 00             load.ref <@0006a0> ;uint32
	<.main+4294 @06282a> : 24 78 08 06                store.m32 <@060878> ;typUint32
	cmplStd/test/lang/init.reference.ci:85: (9 bytes: <.main+4298 @06282e> - <.main+4307 @062837>): static typUint64: typename := uint64
	<.main+4298 @06282e> : 1f 48 07 00 00             load.ref <@000748> ;uint64
	<.main+4303 @062833> : 24 80 08 06                store.m32 <@060880> ;typUint64
	cmplStd/test/lang/init.reference.ci:86: (9 bytes: <.main+4307 @062837> - <.main+4316 @062840>): static typFloat32: typename := float32
	<.main+4307 @062837> : 1f f0 07 00 00             load.ref <@0007f0> ;float32
	<.main+4312 @06283c> : 24 88 08 06                store.m32 <@060888> ;typFloat32
	cmplStd/test/lang/init.reference.ci:87: (9 bytes: <.main+4316 @062840> - <.main+4325 @062849>): static typFloat64: typename := float64
	<.main+4316 @062840> : 1f 98 08 00 00             load.ref <@000898> ;float64
	<.main+4321 @062845> : 24 90 08 06                store.m32 <@060890> ;typFloat64
	cmplStd/test/lang/init.reference.ci:88: (9 bytes: <.main+4325 @062849> - <.main+4334 @062852>): static typTypename: typename := typename
	<.main+4325 @062849> : 1f 08 00 00 00             load.ref <@000008> ;typename
	<.main+4330 @06284e> : 24 98 08 06                store.m32 <@060898> ;typTypename
	cmplStd/test/lang/init.reference.ci:89: (9 bytes: <.main+4334 @062852> - <.main+4343 @06285b>): static typFunction: typename := function
	<.main+4334 @062852> : 1f 90 0a 00 00             load.ref <@000a90> ;function
	<.main+4339 @062857> : 24 a0 08 06                store.m32 <@0608a0> ;typFunction
	cmplStd/test/lang/init.reference.ci:90: (9 bytes: <.main+4343 @06285b> - <.main+4352 @062864>): static typPointer: typename := pointer
	<.main+4343 @06285b> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4348 @062860> : 24 a8 08 06                store.m32 <@0608a8> ;typPointer
	cmplStd/test/lang/init.reference.ci:91: (9 bytes: <.main+4352 @062864> - <.main+4361 @06286d>): static typVariant: typename := variant
	<.main+4352 @062864> : 1f e8 09 00 00             load.ref <@0009e8> ;variant
	<.main+4357 @062869> : 24 b0 08 06                store.m32 <@0608b0> ;typVariant
	cmplStd/test/lang/init.reference.ci:92: (9 bytes: <.main+4361 @06286d> - <.main+4370 @062876>): static typObject: typename := object
	<.main+4361 @06286d> : 1f 40 0b 00 00             load.ref <@000b40> ;object
	<.main+4366 @062872> : 24 b8 08 06                store.m32 <@0608b8> ;typObject
	cmplStd/test/lang/init.reference.ci:95: (9 bytes: <.main+4370 @062876> - <.main+4379 @06287f>): static valueOfPtr: pointer := pointer(value)
	<.main+4370 @062876> : 1f 60 06 06 00             load.ref <@060660> ;value
	<.main+4375 @06287b> : 24 c0 08 06                store.m32 <@0608c0> ;valueOfPtr
	cmplStd/test/lang/init.reference.ci:96: (14 bytes: <.main+4379 @06287f> - <.main+4393 @06288d>): static valueOfVar: variant := variant(value)
	<.main+4379 @06287f> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4384 @062884> : 1f 60 06 06 00             load.ref <@060660> ;value
	<.main+4389 @062889> : 23 c8 08 06                store.m64 <@0608c8> ;valueOfVar
	cmplStd/test/lang/init.reference.ci:97: (9 bytes: <.main+4393 @06288d> - <.main+4402 @062896>): static valueOfTyp: typename := typename(value)
	<.main+4393 @06288d> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4398 @062892> : 24 d0 08 06                store.m32 <@0608d0> ;valueOfTyp
	cmplStd/test/lang/init.reference.ci:99: (9 bytes: <.main+4402 @062896> - <.main+4411 @06289f>): static typeOfValue: typename := typename(value)
	<.main+4402 @062896> : 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+4407 @06289b> : 24 d8 08 06                store.m32 <@0608d8> ;typeOfValue
	cmplStd/test/lang/init.reference.ci:105: (13 bytes: <.main+4411 @06289f> - <.main+4424 @0628ac>): static copyPtrFloat64: variant := ptrFloat64
	<.main+4411 @06289f> : 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+4416 @0628a4> : 20 70 07 06                load.m32 <@060770> ;ptrFloat64
	<.main+4420 @0628a8> : 23 e0 08 06                store.m64 <@0608e0> ;copyPtrFloat64
	cmplStd/test/lang/init.reference.ci:108: (8 bytes: <.main+4424 @0628ac> - <.main+4432 @0628b4>): static copyVarFloat64: pointer := varFloat64
	<.main+4424 @0628ac> : 20 00 08 06                load.m32 <@060800> ;varFloat64
	<.main+4428 @0628b0> : 24 e8 08 06                store.m32 <@0608e8> ;copyVarFloat64
	cmplStd/test/lang/init.variable.ci:3: (5 bytes: <.main+4432 @0628b4> - <.main+4437 @0628b9>): static variable: int32
	<.main+4432 @0628b4> : 19                         load.z32
	<.main+4433 @0628b5> : 24 f0 08 06                store.m32 <@0608f0> ;variable
	cmplStd/test/lang/init.variable.ci:7: (9 bytes: <.main+4437 @0628b9> - <.main+4446 @0628c2>): static const constant: int32 := 42
	<.main+4437 @0628b9> : 1c 2a 00 00 00             load.c32 42
	<.main+4442 @0628be> : 24 f8 08 06                store.m32 <@0608f8> ;constant
	cmplStd/test/lang/init.variable.ci:24: (18 bytes: <.main+4446 @0628c2> - <.main+4464 @0628d4>): static valInitImplicit: ComplexVal := {...}
	cmplStd/test/lang/init.variable.ci:24: (13 bytes: <.main+4446 @0628c2> - <.main+4459 @0628cf>): valInitImplicit.re := (8);
	<.main+4446 @0628c2> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4455 @0628cb> : 23 00 09 06                store.m64 <@060900> ;valInitImplicit
	:: (5 bytes: <.main+4459 @0628cf> - <.main+4464 @0628d4>): valInitImplicit.im := (0);
	<.main+4459 @0628cf> : 1a                         load.z64
	<.main+4460 @0628d0> : 23 08 09 06                store.m64 <@060908> ;valInitImplicit+8
	cmplStd/test/lang/init.variable.ci:33: (41 bytes: <.main+4464 @0628d4> - <.main+4505 @0628fd>): static objInitImplicit: ComplexObj := {...}
	cmplStd/test/lang/init.variable.ci:33: (13 bytes: <.main+4464 @0628d4> - <.main+4477 @0628e1>): objInitImplicit := create(ComplexObj);
	<.main+4464 @0628d4> : 1f e0 6c 04 00             load.ref <@046ce0> ;ComplexObj
	<.main+4469 @0628d9> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4473 @0628dd> : 24 10 09 06                store.m32 <@060910> ;objInitImplicit
	cmplStd/test/lang/init.variable.ci:33: (18 bytes: <.main+4477 @0628e1> - <.main+4495 @0628f3>): objInitImplicit.re := (8);
	<.main+4477 @0628e1> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4486 @0628ea> : 20 10 09 06                load.m32 <@060910> ;objInitImplicit
	<.main+4490 @0628ee> : 0c 04 00 00                inc.i32(+4)
	<.main+4494 @0628f2> : 2e                         store.i64
	:: (10 bytes: <.main+4495 @0628f3> - <.main+4505 @0628fd>): objInitImplicit.im := (0);
	<.main+4495 @0628f3> : 1a                         load.z64
	<.main+4496 @0628f4> : 20 10 09 06                load.m32 <@060910> ;objInitImplicit
	<.main+4500 @0628f8> : 0c 0c 00 00                inc.i32(+12)
	<.main+4504 @0628fc> : 2e                         store.i64
	cmplStd/test/lang/init.variable.ci:41: (41 bytes: <.main+4505 @0628fd> - <.main+4546 @062926>): static objInitExplicit: object := {...}
	cmplStd/test/lang/init.variable.ci:41: (13 bytes: <.main+4505 @0628fd> - <.main+4518 @06290a>): objInitExplicit := create(ComplexObj);
	<.main+4505 @0628fd> : 1f e0 6c 04 00             load.ref <@046ce0> ;ComplexObj
	<.main+4510 @062902> : 01 06 00 00                nfc(6) ;object.create(type: typename): pointer
	<.main+4514 @062906> : 24 18 09 06                store.m32 <@060918> ;objInitExplicit
	cmplStd/test/lang/init.variable.ci:41: (18 bytes: <.main+4518 @06290a> - <.main+4536 @06291c>): objInitExplicit.re := (8);
	<.main+4518 @06290a> : 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+4527 @062913> : 20 18 09 06                load.m32 <@060918> ;objInitExplicit
	<.main+4531 @062917> : 0c 04 00 00                inc.i32(+4)
	<.main+4535 @06291b> : 2e                         store.i64
	:: (10 bytes: <.main+4536 @06291c> - <.main+4546 @062926>): objInitExplicit.im := (0);
	<.main+4536 @06291c> : 1a                         load.z64
	<.main+4537 @06291d> : 20 18 09 06                load.m32 <@060918> ;objInitExplicit
	<.main+4541 @062921> : 0c 0c 00 00                inc.i32(+12)
	<.main+4545 @062925> : 2e                         store.i64
	cmplStd/test/lang/function.ci:12: (25 bytes: <.main+4546 @062926> - <.main+4571 @06293f>): static funAddResult: int32 := funAdd(2, 7)
	<.main+4546 @062926> : 19                         load.z32
	<.main+4547 @062927> : 1c 02 00 00 00             load.c32 2
	<.main+4552 @06292c> : 1c 07 00 00 00             load.c32 7
	<.main+4557 @062931> : 1f 28 09 06 00             load.ref <@060928> ;funAdd(x: int32, y: int32): int32
	<.main+4562 @062936> : 02                         call
	<.main+4563 @062937> : 09 f8 ff ff                inc.sp(-8)
	<.main+4567 @06293b> : 24 30 09 06                store.m32 <@060930> ;funAddResult
	cmplStd/test/lang/function.ci:15: (9 bytes: <.main+4571 @06293f> - <.main+4580 @062948>): static funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+4571 @06293f> : 1f 28 09 06 00             load.ref <@060928> ;funAdd(x: int32, y: int32): int32
	<.main+4576 @062944> : 24 38 09 06                store.m32 <@060938> ;funAddRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (24 bytes: <.main+4580 @062948> - <.main+4604 @062960>): static funAddRefResult: int32 := funAddRef(2, 8)
	<.main+4580 @062948> : 19                         load.z32
	<.main+4581 @062949> : 1c 02 00 00 00             load.c32 2
	<.main+4586 @06294e> : 1c 08 00 00 00             load.c32 8
	<.main+4591 @062953> : 20 38 09 06                load.m32 <@060938> ;funAddRef(x: int32, y: int32): int32
	<.main+4595 @062957> : 02                         call
	<.main+4596 @062958> : 09 f8 ff ff                inc.sp(-8)
	<.main+4600 @06295c> : 24 40 09 06                store.m32 <@060940> ;funAddRefResult
	cmplStd/test/lang/function.ci:21: (9 bytes: <.main+4604 @062960> - <.main+4613 @062969>): static funMul(x: int32, y: int32): int32 := funMul
	<.main+4604 @062960> : 1f 68 09 06 00             load.ref <@060968> ;funMul(x: int32, y: int32): int32
	<.main+4609 @062965> : 24 48 09 06                store.m32 <@060948> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (24 bytes: <.main+4613 @062969> - <.main+4637 @062981>): static funMulResult: int32 := funMul(2, 6)
	<.main+4613 @062969> : 19                         load.z32
	<.main+4614 @06296a> : 1c 02 00 00 00             load.c32 2
	<.main+4619 @06296f> : 1c 06 00 00 00             load.c32 6
	<.main+4624 @062974> : 20 48 09 06                load.m32 <@060948> ;funMul(x: int32, y: int32): int32
	<.main+4628 @062978> : 02                         call
	<.main+4629 @062979> : 09 f8 ff ff                inc.sp(-8)
	<.main+4633 @06297d> : 24 50 09 06                store.m32 <@060950> ;funMulResult
	cmplStd/test/lang/function.ci:27: (8 bytes: <.main+4637 @062981> - <.main+4645 @062989>): static funMulRef(x: int32, y: int32): int32 := funMul
	<.main+4637 @062981> : 20 48 09 06                load.m32 <@060948> ;funMul(x: int32, y: int32): int32
	<.main+4641 @062985> : 24 58 09 06                store.m32 <@060958> ;funMulRef(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:30: (24 bytes: <.main+4645 @062989> - <.main+4669 @0629a1>): static funMulRefResult: int32 := funMulRef(2, 7)
	<.main+4645 @062989> : 19                         load.z32
	<.main+4646 @06298a> : 1c 02 00 00 00             load.c32 2
	<.main+4651 @06298f> : 1c 07 00 00 00             load.c32 7
	<.main+4656 @062994> : 20 58 09 06                load.m32 <@060958> ;funMulRef(x: int32, y: int32): int32
	<.main+4660 @062998> : 02                         call
	<.main+4661 @062999> : 09 f8 ff ff                inc.sp(-8)
	<.main+4665 @06299d> : 24 60 09 06                store.m32 <@060960> ;funMulRefResult
	cmplStd/test/lang/function.ci:46: (20 bytes: <.main+4669 @0629a1> - <.main+4689 @0629b5>): static fibonacci_13: uint32 := fib(13)
	<.main+4669 @0629a1> : 19                         load.z32
	<.main+4670 @0629a2> : 1c 0d 00 00 00             load.c32 13
	<.main+4675 @0629a7> : 1f 70 09 06 00             load.ref <@060970> ;fib(n: uint32): uint32
	<.main+4680 @0629ac> : 02                         call
	<.main+4681 @0629ad> : 09 fc ff ff                inc.sp(-4)
	<.main+4685 @0629b1> : 24 a8 09 06                store.m32 <@0609a8> ;fibonacci_13
	cmplStd/test/lang/reflect.ci:3: (8 bytes: <.main+4689 @0629b5> - <.main+4697 @0629bd>): static sizeofVoid: int32 := sizeof(void)
	<.main+4689 @0629b5> : 20 d8 00 00                load.m32 <@0000d8> ;void+32
	<.main+4693 @0629b9> : 24 b0 09 06                store.m32 <@0609b0> ;sizeofVoid
	cmplStd/test/lang/reflect.ci:4: (8 bytes: <.main+4697 @0629bd> - <.main+4705 @0629c5>): static sizeofBool: int32 := sizeof(bool)
	<.main+4697 @0629bd> : 20 80 01 00                load.m32 <@000180> ;bool+32
	<.main+4701 @0629c1> : 24 b8 09 06                store.m32 <@0609b8> ;sizeofBool
	cmplStd/test/lang/reflect.ci:5: (8 bytes: <.main+4705 @0629c5> - <.main+4713 @0629cd>): static sizeofChar: int32 := sizeof(char)
	<.main+4705 @0629c5> : 20 28 02 00                load.m32 <@000228> ;char+32
	<.main+4709 @0629c9> : 24 c0 09 06                store.m32 <@0609c0> ;sizeofChar
	cmplStd/test/lang/reflect.ci:6: (8 bytes: <.main+4713 @0629cd> - <.main+4721 @0629d5>): static sizeofInt8: int32 := sizeof(int8)
	<.main+4713 @0629cd> : 20 d0 02 00                load.m32 <@0002d0> ;int8+32
	<.main+4717 @0629d1> : 24 c8 09 06                store.m32 <@0609c8> ;sizeofInt8
	cmplStd/test/lang/reflect.ci:7: (8 bytes: <.main+4721 @0629d5> - <.main+4729 @0629dd>): static sizeofInt16: int32 := sizeof(int16)
	<.main+4721 @0629d5> : 20 78 03 00                load.m32 <@000378> ;int16+32
	<.main+4725 @0629d9> : 24 d0 09 06                store.m32 <@0609d0> ;sizeofInt16
	cmplStd/test/lang/reflect.ci:8: (8 bytes: <.main+4729 @0629dd> - <.main+4737 @0629e5>): static sizeofInt32: int32 := sizeof(int32)
	<.main+4729 @0629dd> : 20 20 04 00                load.m32 <@000420> ;int32+32
	<.main+4733 @0629e1> : 24 d8 09 06                store.m32 <@0609d8> ;sizeofInt32
	cmplStd/test/lang/reflect.ci:9: (8 bytes: <.main+4737 @0629e5> - <.main+4745 @0629ed>): static sizeofInt64: int32 := sizeof(int64)
	<.main+4737 @0629e5> : 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+4741 @0629e9> : 24 e0 09 06                store.m32 <@0609e0> ;sizeofInt64
	cmplStd/test/lang/reflect.ci:10: (8 bytes: <.main+4745 @0629ed> - <.main+4753 @0629f5>): static sizeofUint8: int32 := sizeof(uint8)
	<.main+4745 @0629ed> : 20 70 05 00                load.m32 <@000570> ;uint8+32
	<.main+4749 @0629f1> : 24 e8 09 06                store.m32 <@0609e8> ;sizeofUint8
	cmplStd/test/lang/reflect.ci:11: (8 bytes: <.main+4753 @0629f5> - <.main+4761 @0629fd>): static sizeofUint16: int32 := sizeof(uint16)
	<.main+4753 @0629f5> : 20 18 06 00                load.m32 <@000618> ;uint16+32
	<.main+4757 @0629f9> : 24 f0 09 06                store.m32 <@0609f0> ;sizeofUint16
	cmplStd/test/lang/reflect.ci:12: (8 bytes: <.main+4761 @0629fd> - <.main+4769 @062a05>): static sizeofUint32: int32 := sizeof(uint32)
	<.main+4761 @0629fd> : 20 c0 06 00                load.m32 <@0006c0> ;uint32+32
	<.main+4765 @062a01> : 24 f8 09 06                store.m32 <@0609f8> ;sizeofUint32
	cmplStd/test/lang/reflect.ci:13: (8 bytes: <.main+4769 @062a05> - <.main+4777 @062a0d>): static sizeofUint64: int32 := sizeof(uint64)
	<.main+4769 @062a05> : 20 68 07 00                load.m32 <@000768> ;uint64+32
	<.main+4773 @062a09> : 24 00 0a 06                store.m32 <@060a00> ;sizeofUint64
	cmplStd/test/lang/reflect.ci:14: (8 bytes: <.main+4777 @062a0d> - <.main+4785 @062a15>): static sizeofFloat32: int32 := sizeof(float32)
	<.main+4777 @062a0d> : 20 10 08 00                load.m32 <@000810> ;float32+32
	<.main+4781 @062a11> : 24 08 0a 06                store.m32 <@060a08> ;sizeofFloat32
	cmplStd/test/lang/reflect.ci:15: (8 bytes: <.main+4785 @062a15> - <.main+4793 @062a1d>): static sizeofFloat64: int32 := sizeof(float64)
	<.main+4785 @062a15> : 20 b8 08 00                load.m32 <@0008b8> ;float64+32
	<.main+4789 @062a19> : 24 10 0a 06                store.m32 <@060a10> ;sizeofFloat64
	cmplStd/test/lang/reflect.ci:16: (8 bytes: <.main+4793 @062a1d> - <.main+4801 @062a25>): static sizeofPointer: int32 := sizeof(pointer)
	<.main+4793 @062a1d> : 20 60 09 00                load.m32 <@000960> ;pointer+32
	<.main+4797 @062a21> : 24 18 0a 06                store.m32 <@060a18> ;sizeofPointer
	cmplStd/test/lang/reflect.ci:17: (8 bytes: <.main+4801 @062a25> - <.main+4809 @062a2d>): static sizeofVariant: int32 := sizeof(variant)
	<.main+4801 @062a25> : 20 08 0a 00                load.m32 <@000a08> ;variant+32
	<.main+4805 @062a29> : 24 20 0a 06                store.m32 <@060a20> ;sizeofVariant
	cmplStd/test/lang/reflect.ci:18: (8 bytes: <.main+4809 @062a2d> - <.main+4817 @062a35>): static sizeofTypename: int32 := sizeof(typename)
	<.main+4809 @062a2d> : 20 28 00 00                load.m32 <@000028> ;typename+32
	<.main+4813 @062a31> : 24 28 0a 06                store.m32 <@060a28> ;sizeofTypename
	cmplStd/test/lang/reflect.ci:19: (8 bytes: <.main+4817 @062a35> - <.main+4825 @062a3d>): static sizeofFunction: int32 := sizeof(function)
	<.main+4817 @062a35> : 20 b0 0a 00                load.m32 <@000ab0> ;function+32
	<.main+4821 @062a39> : 24 30 0a 06                store.m32 <@060a30> ;sizeofFunction
	cmplStd/test/lang/reflect.ci:20: (8 bytes: <.main+4825 @062a3d> - <.main+4833 @062a45>): static sizeofObject: int32 := sizeof(object)
	<.main+4825 @062a3d> : 20 60 0b 00                load.m32 <@000b60> ;object+32
	<.main+4829 @062a41> : 24 38 0a 06                store.m32 <@060a38> ;sizeofObject
	cmplStd/test/lang/reflect.ci:30: (9 bytes: <.main+4833 @062a45> - <.main+4842 @062a4e>): static typeofRecord: typename := RecordSizeofExt
	<.main+4833 @062a45> : 1f f0 93 04 00             load.ref <@0493f0> ;RecordSizeofExt
	<.main+4838 @062a4a> : 24 40 0a 06                store.m32 <@060a40> ;typeofRecord
	cmplStd/test/lang/reflect.ci:31: (12 bytes: <.main+4842 @062a4e> - <.main+4854 @062a5a>): static nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+4842 @062a4e> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4846 @062a52> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4850 @062a56> : 24 48 0a 06                store.m32 <@060a48> ;nameOfRecord
	cmplStd/test/lang/reflect.ci:32: (13 bytes: <.main+4854 @062a5a> - <.main+4867 @062a67>): static offsetOfRecord: int32 := typeofRecord.offset
	<.main+4854 @062a5a> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4858 @062a5e> : 0c 28 00 00                inc.i32(+40)
	<.main+4862 @062a62> : 28                         load.i32
	<.main+4863 @062a63> : 24 50 0a 06                store.m32 <@060a50> ;offsetOfRecord
	cmplStd/test/lang/reflect.ci:33: (13 bytes: <.main+4867 @062a67> - <.main+4880 @062a74>): static sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+4867 @062a67> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4871 @062a6b> : 0c 20 00 00                inc.i32(+32)
	<.main+4875 @062a6f> : 28                         load.i32
	<.main+4876 @062a70> : 24 58 0a 06                store.m32 <@060a58> ;sizeOfRecord
	cmplStd/test/lang/reflect.ci:34: (12 bytes: <.main+4880 @062a74> - <.main+4892 @062a80>): static fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+4880 @062a74> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4884 @062a78> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4888 @062a7c> : 24 60 0a 06                store.m32 <@060a60> ;fileOfRecord
	cmplStd/test/lang/reflect.ci:35: (12 bytes: <.main+4892 @062a80> - <.main+4904 @062a8c>): static lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+4892 @062a80> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4896 @062a84> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4900 @062a88> : 24 68 0a 06                store.m32 <@060a68> ;lineOfRecord
	cmplStd/test/lang/reflect.ci:37: (12 bytes: <.main+4904 @062a8c> - <.main+4916 @062a98>): static typeofBase: typename := typename.base(typeofRecord)
	<.main+4904 @062a8c> : 20 40 0a 06                load.m32 <@060a40> ;typeofRecord
	<.main+4908 @062a90> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4912 @062a94> : 24 70 0a 06                store.m32 <@060a70> ;typeofBase
	cmplStd/test/lang/reflect.ci:38: (12 bytes: <.main+4916 @062a98> - <.main+4928 @062aa4>): static nameOfBase: char[*] := typename.name(typeofBase)
	<.main+4916 @062a98> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4920 @062a9c> : 01 05 00 00                nfc(5) ;typename.name(type: typename): .cstr
	<.main+4924 @062aa0> : 24 78 0a 06                store.m32 <@060a78> ;nameOfBase
	cmplStd/test/lang/reflect.ci:39: (13 bytes: <.main+4928 @062aa4> - <.main+4941 @062ab1>): static offsetOfBase: int32 := typeofBase.offset
	<.main+4928 @062aa4> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4932 @062aa8> : 0c 28 00 00                inc.i32(+40)
	<.main+4936 @062aac> : 28                         load.i32
	<.main+4937 @062aad> : 24 80 0a 06                store.m32 <@060a80> ;offsetOfBase
	cmplStd/test/lang/reflect.ci:40: (13 bytes: <.main+4941 @062ab1> - <.main+4954 @062abe>): static sizeOfBase: int32 := sizeof(typeofBase)
	<.main+4941 @062ab1> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4945 @062ab5> : 0c 20 00 00                inc.i32(+32)
	<.main+4949 @062ab9> : 28                         load.i32
	<.main+4950 @062aba> : 24 88 0a 06                store.m32 <@060a88> ;sizeOfBase
	cmplStd/test/lang/reflect.ci:41: (12 bytes: <.main+4954 @062abe> - <.main+4966 @062aca>): static fileOfBase: char[*] := typename.file(typeofBase)
	<.main+4954 @062abe> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4958 @062ac2> : 01 03 00 00                nfc(3) ;typename.file(type: typename): .cstr
	<.main+4962 @062ac6> : 24 90 0a 06                store.m32 <@060a90> ;fileOfBase
	cmplStd/test/lang/reflect.ci:42: (12 bytes: <.main+4966 @062aca> - <.main+4978 @062ad6>): static lineOfBase: int32 := typename.line(typeofBase)
	<.main+4966 @062aca> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4970 @062ace> : 01 04 00 00                nfc(4) ;typename.line(type: typename): int32
	<.main+4974 @062ad2> : 24 98 0a 06                store.m32 <@060a98> ;lineOfBase
	cmplStd/test/lang/reflect.ci:44: (12 bytes: <.main+4978 @062ad6> - <.main+4990 @062ae2>): static typeofBase1: typename := typename.base(typeofBase)
	<.main+4978 @062ad6> : 20 70 0a 06                load.m32 <@060a70> ;typeofBase
	<.main+4982 @062ada> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+4986 @062ade> : 24 a0 0a 06                store.m32 <@060aa0> ;typeofBase1
	cmplStd/test/lang/reflect.ci:45: (13 bytes: <.main+4990 @062ae2> - <.main+5003 @062aef>): static offsetOfBase1: int32 := typeofBase1.offset
	<.main+4990 @062ae2> : 20 a0 0a 06                load.m32 <@060aa0> ;typeofBase1
	<.main+4994 @062ae6> : 0c 28 00 00                inc.i32(+40)
	<.main+4998 @062aea> : 28                         load.i32
	<.main+4999 @062aeb> : 24 a8 0a 06                store.m32 <@060aa8> ;offsetOfBase1
	cmplStd/test/lang/reflect.ci:46: (13 bytes: <.main+5003 @062aef> - <.main+5016 @062afc>): static sizeOfBase1: int32 := typeofBase1.size
	<.main+5003 @062aef> : 20 a0 0a 06                load.m32 <@060aa0> ;typeofBase1
	<.main+5007 @062af3> : 0c 20 00 00                inc.i32(+32)
	<.main+5011 @062af7> : 28                         load.i32
	<.main+5012 @062af8> : 24 b0 0a 06                store.m32 <@060ab0> ;sizeOfBase1
	cmplStd/test/lang/reflect.ci:48: (12 bytes: <.main+5016 @062afc> - <.main+5028 @062b08>): static typeofBase2: typename := typename.base(typeofBase1)
	<.main+5016 @062afc> : 20 a0 0a 06                load.m32 <@060aa0> ;typeofBase1
	<.main+5020 @062b00> : 01 02 00 00                nfc(2) ;typename.base(type: typename): typename
	<.main+5024 @062b04> : 24 b8 0a 06                store.m32 <@060ab8> ;typeofBase2
	cmplStd/test/lang/reflect.ci:49: (13 bytes: <.main+5028 @062b08> - <.main+5041 @062b15>): static offsetOfBase2: int32 := typeofBase2.offset
	<.main+5028 @062b08> : 20 b8 0a 06                load.m32 <@060ab8> ;typeofBase2
	<.main+5032 @062b0c> : 0c 28 00 00                inc.i32(+40)
	<.main+5036 @062b10> : 28                         load.i32
	<.main+5037 @062b11> : 24 c0 0a 06                store.m32 <@060ac0> ;offsetOfBase2
	cmplStd/test/lang/reflect.ci:50: (13 bytes: <.main+5041 @062b15> - <.main+5054 @062b22>): static sizeOfBase2: int32 := typeofBase2.size
	<.main+5041 @062b15> : 20 b8 0a 06                load.m32 <@060ab8> ;typeofBase2
	<.main+5045 @062b19> : 0c 20 00 00                inc.i32(+32)
	<.main+5049 @062b1d> : 28                         load.i32
	<.main+5050 @062b1e> : 24 c8 0a 06                store.m32 <@060ac8> ;sizeOfBase2
	cmplStd/test/lang/init.member.ci:34: (5 bytes: <.main+5054 @062b22> - <.main+5059 @062b27>): static global: int32
	<.main+5054 @062b22> : 19                         load.z32
	<.main+5055 @062b23> : 24 d0 0a 06                store.m32 <@060ad0> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes: <.main+5059 @062b27> - <.main+5068 @062b30>): static globalInit: int32 := 1
	<.main+5059 @062b27> : 1c 01 00 00 00             load.c32 1
	<.main+5064 @062b2c> : 24 d8 0a 06                store.m32 <@060ad8> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes: <.main+5068 @062b30> - <.main+5077 @062b39>): static const globalConstant: int32 := 2
	<.main+5068 @062b30> : 1c 02 00 00 00             load.c32 2
	<.main+5073 @062b35> : 24 e0 0a 06                store.m32 <@060ae0> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes: <.main+5077 @062b39> - <.main+5091 @062b47>): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes: <.main+5077 @062b39> - <.main+5086 @062b42>): globalRec.constant := 4;
	<.main+5077 @062b39> : 1c 04 00 00 00             load.c32 4
	<.main+5082 @062b3e> : 24 ec 0a 06                store.m32 <@060aec> ;RecordMemberTest.globalRec+4
	:: (5 bytes: <.main+5086 @062b42> - <.main+5091 @062b47>): globalRec.member := (0);
	<.main+5086 @062b42> : 19                         load.z32
	<.main+5087 @062b43> : 24 e8 0a 06                store.m32 <@060ae8> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes: <.main+5091 @062b47> - <.main+5109 @062b59>): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5091 @062b47> - <.main+5100 @062b50>): globalRecInit.member := 4;
	<.main+5091 @062b47> : 1c 04 00 00 00             load.c32 4
	<.main+5096 @062b4c> : 24 f0 0a 06                store.m32 <@060af0> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes: <.main+5100 @062b50> - <.main+5109 @062b59>): globalRecInit.constant := 5;
	<.main+5100 @062b50> : 1c 05 00 00 00             load.c32 5
	<.main+5105 @062b55> : 24 f4 0a 06                store.m32 <@060af4> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes: <.main+5109 @062b59> - <.main+5127 @062b6b>): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5109 @062b59> - <.main+5118 @062b62>): globalConstantRec.member := 6;
	<.main+5109 @062b59> : 1c 06 00 00 00             load.c32 6
	<.main+5114 @062b5e> : 24 f8 0a 06                store.m32 <@060af8> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes: <.main+5118 @062b62> - <.main+5127 @062b6b>): globalConstantRec.constant := 7;
	<.main+5118 @062b62> : 1c 07 00 00 00             load.c32 7
	<.main+5123 @062b67> : 24 fc 0a 06                store.m32 <@060afc> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.member.ci:52: (72 bytes: <.main+5127 @062b6b> - <.main+5199 @062bb3>): static recordMemberTest: RecordMemberTest := {...}
	cmplStd/test/lang/init.member.ci:53: (9 bytes: <.main+5127 @062b6b> - <.main+5136 @062b74>): recordMemberTest.member := 10;
	<.main+5127 @062b6b> : 1c 0a 00 00 00             load.c32 10
	<.main+5132 @062b70> : 24 00 0b 06                store.m32 <@060b00> ;recordMemberTest
	cmplStd/test/lang/init.member.ci:54: (9 bytes: <.main+5136 @062b74> - <.main+5145 @062b7d>): recordMemberTest.constant := 11;
	<.main+5136 @062b74> : 1c 0b 00 00 00             load.c32 11
	<.main+5141 @062b79> : 24 04 0b 06                store.m32 <@060b04> ;recordMemberTest+4
	cmplStd/test/lang/init.member.ci:55: (9 bytes: <.main+5145 @062b7d> - <.main+5154 @062b86>): recordMemberTest.memberInit := 12;
	<.main+5145 @062b7d> : 1c 0c 00 00 00             load.c32 12
	<.main+5150 @062b82> : 24 08 0b 06                store.m32 <@060b08> ;recordMemberTest+8
	cmplStd/test/lang/init.member.ci:56: (9 bytes: <.main+5154 @062b86> - <.main+5163 @062b8f>): recordMemberTest.constantInit := 13;
	<.main+5154 @062b86> : 1c 0d 00 00 00             load.c32 13
	<.main+5159 @062b8b> : 24 0c 0b 06                store.m32 <@060b0c> ;recordMemberTest+12
	cmplStd/test/lang/init.member.ci:59: (9 bytes: <.main+5163 @062b8f> - <.main+5172 @062b98>): recordMemberTest.memberRec.member := 14;
	<.main+5163 @062b8f> : 1c 0e 00 00 00             load.c32 14
	<.main+5168 @062b94> : 24 10 0b 06                store.m32 <@060b10> ;recordMemberTest+16
	cmplStd/test/lang/init.member.ci:60: (9 bytes: <.main+5172 @062b98> - <.main+5181 @062ba1>): recordMemberTest.memberRec.constant := 15;
	<.main+5172 @062b98> : 1c 0f 00 00 00             load.c32 15
	<.main+5177 @062b9d> : 24 14 0b 06                store.m32 <@060b14> ;recordMemberTest+20
	cmplStd/test/lang/init.member.ci:64: (9 bytes: <.main+5181 @062ba1> - <.main+5190 @062baa>): recordMemberTest.constantRec.member := 16;
	<.main+5181 @062ba1> : 1c 10 00 00 00             load.c32 16
	<.main+5186 @062ba6> : 24 18 0b 06                store.m32 <@060b18> ;recordMemberTest+24
	cmplStd/test/lang/init.member.ci:65: (9 bytes: <.main+5190 @062baa> - <.main+5199 @062bb3>): recordMemberTest.constantRec.constant := 17;
	<.main+5190 @062baa> : 1c 11 00 00 00             load.c32 17
	<.main+5195 @062baf> : 24 1c 0b 06                store.m32 <@060b1c> ;recordMemberTest+28
	cmplStd/test/lang/init.method.ci:18: (9 bytes: <.main+5199 @062bb3> - <.main+5208 @062bbc>): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+5199 @062bb3> : 1f 78 0b 06 00             load.ref <@060b78> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5204 @062bb8> : 24 48 0b 06                store.m32 <@060b48> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/init.method.ci:62: (26 bytes: <.main+5208 @062bbc> - <.main+5234 @062bd6>): static recordMethodTest: RecordMethodTest := {...}
	cmplStd/test/lang/init.method.ci:64: (9 bytes: <.main+5208 @062bbc> - <.main+5217 @062bc5>): recordMethodTest.abstractMethod := globalFunction;
	<.main+5208 @062bbc> : 1f a0 0b 06 00             load.ref <@060ba0> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+5213 @062bc1> : 24 c8 0b 06                store.m32 <@060bc8> ;recordMethodTest
	:: (8 bytes: <.main+5217 @062bc5> - <.main+5225 @062bcd>): recordMethodTest.delegateMethod := forwardMethod;
	<.main+5217 @062bc5> : 20 48 0b 06                load.m32 <@060b48> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+5221 @062bc9> : 24 cc 0b 06                store.m32 <@060bcc> ;recordMethodTest+4
	:: (9 bytes: <.main+5225 @062bcd> - <.main+5234 @062bd6>): recordMethodTest.virtualMethod := virtualMethod;
	<.main+5225 @062bcd> : 1f 50 0b 06 00             load.ref <@060b50> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+5230 @062bd2> : 24 d0 0b 06                store.m32 <@060bd0> ;recordMethodTest+8
	cmplStd/test/lang/init.array.ci:11: (91 bytes: <.main+5234 @062bd6> - <.main+5325 @062c31>): static arrFixedInit: int64[7] := {...}
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5234 @062bd6> - <.main+5247 @062be3>): arrFixedInit[0] := (42);
	<.main+5234 @062bd6> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+5243 @062bdf> : 23 60 0c 06                store.m64 <@060c60> ;arrFixedInit
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5247 @062be3> - <.main+5260 @062bf0>): arrFixedInit[1] := (43);
	<.main+5247 @062be3> : 1d 2b 00 00 00 00 00 00 00 load.c64 43
	<.main+5256 @062bec> : 23 68 0c 06                store.m64 <@060c68> ;arrFixedInit+8
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5260 @062bf0> - <.main+5273 @062bfd>): arrFixedInit[2] := (44);
	<.main+5260 @062bf0> : 1d 2c 00 00 00 00 00 00 00 load.c64 44
	<.main+5269 @062bf9> : 23 70 0c 06                store.m64 <@060c70> ;arrFixedInit+16
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5273 @062bfd> - <.main+5286 @062c0a>): arrFixedInit[3] := (45);
	<.main+5273 @062bfd> : 1d 2d 00 00 00 00 00 00 00 load.c64 45
	<.main+5282 @062c06> : 23 78 0c 06                store.m64 <@060c78> ;arrFixedInit+24
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5286 @062c0a> - <.main+5299 @062c17>): arrFixedInit[4] := (46);
	<.main+5286 @062c0a> : 1d 2e 00 00 00 00 00 00 00 load.c64 46
	<.main+5295 @062c13> : 23 80 0c 06                store.m64 <@060c80> ;arrFixedInit+32
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5299 @062c17> - <.main+5312 @062c24>): arrFixedInit[5] := (47);
	<.main+5299 @062c17> : 1d 2f 00 00 00 00 00 00 00 load.c64 47
	<.main+5308 @062c20> : 23 88 0c 06                store.m64 <@060c88> ;arrFixedInit+40
	cmplStd/test/lang/init.array.ci:11: (13 bytes: <.main+5312 @062c24> - <.main+5325 @062c31>): arrFixedInit[6] := (48);
	<.main+5312 @062c24> : 1d 30 00 00 00 00 00 00 00 load.c64 48
	<.main+5321 @062c2d> : 23 90 0c 06                store.m64 <@060c90> ;arrFixedInit+48
	cmplStd/test/lang/init.array.ci:18: (9 bytes: <.main+5325 @062c31> - <.main+5334 @062c3a>): static arrArrayInitNull: int64[*] := null
	<.main+5325 @062c31> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5330 @062c36> : 24 98 0c 06                store.m32 <@060c98> ;arrArrayInitNull
	cmplStd/test/lang/init.array.ci:19: (10 bytes: <.main+5334 @062c3a> - <.main+5344 @062c44>): static arrSliceInitNull: int64[] := null
	<.main+5334 @062c3a> : 19                         load.z32
	<.main+5335 @062c3b> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+5340 @062c40> : 23 a0 0c 06                store.m64 <@060ca0> ;arrSliceInitNull
	cmplStd/test/lang/init.array.ci:22: (9 bytes: <.main+5344 @062c44> - <.main+5353 @062c4d>): static arrArrayInitFixed: int64[*] := arrFixedInit
	<.main+5344 @062c44> : 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+5349 @062c49> : 24 a8 0c 06                store.m32 <@060ca8> ;arrArrayInitFixed
	cmplStd/test/lang/init.array.ci:23: (14 bytes: <.main+5353 @062c4d> - <.main+5367 @062c5b>): static arrSliceInitFixed: int64[] := arrFixedInit
	<.main+5353 @062c4d> : 1c 07 00 00 00             load.c32 7
	<.main+5358 @062c52> : 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+5363 @062c57> : 23 b0 0c 06                store.m64 <@060cb0> ;arrSliceInitFixed
	cmplStd/test/lang/init.array.ci:26: (8 bytes: <.main+5367 @062c5b> - <.main+5375 @062c63>): static arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+5367 @062c5b> : 20 b0 0c 06                load.m32 <@060cb0> ;arrSliceInitFixed
	<.main+5371 @062c5f> : 24 b8 0c 06                store.m32 <@060cb8> ;arrArrayInitSlice
	cmplStd/test/lang/init.array.ci:27: (8 bytes: <.main+5375 @062c63> - <.main+5383 @062c6b>): static arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+5375 @062c63> : 21 b0 0c 06                load.m64 <@060cb0> ;arrSliceInitFixed
	<.main+5379 @062c67> : 23 c0 0c 06                store.m64 <@060cc0> ;arrSliceInitSlice
	cmplStd/test/lang/init.array.ci:30: (8 bytes: <.main+5383 @062c6b> - <.main+5391 @062c73>): static arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+5383 @062c6b> : 20 a8 0c 06                load.m32 <@060ca8> ;arrArrayInitFixed
	<.main+5387 @062c6f> : 24 c8 0c 06                store.m32 <@060cc8> ;arrArrayInitPtr
	cmplStd/test/lang/init.array.ci:34: (73 bytes: <.main+5391 @062c73> - <.main+5464 @062cbc>): static strFixed: char[7] := {...}
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5391 @062c73> - <.main+5402 @062c7e>): strFixed[0] := 's';
	<.main+5391 @062c73> : 1c 73 00 00 00             load.c32 115
	<.main+5396 @062c78> : 1f d0 0c 06 00             load.ref <@060cd0> ;strFixed
	<.main+5401 @062c7d> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5402 @062c7e> - <.main+5413 @062c89>): strFixed[1] := 't';
	<.main+5402 @062c7e> : 1c 74 00 00 00             load.c32 116
	<.main+5407 @062c83> : 1f d1 0c 06 00             load.ref <@060cd1> ;strFixed+1
	<.main+5412 @062c88> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5413 @062c89> - <.main+5424 @062c94>): strFixed[2] := 'r';
	<.main+5413 @062c89> : 1c 72 00 00 00             load.c32 114
	<.main+5418 @062c8e> : 1f d2 0c 06 00             load.ref <@060cd2> ;strFixed+2
	<.main+5423 @062c93> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5424 @062c94> - <.main+5435 @062c9f>): strFixed[3] := 'i';
	<.main+5424 @062c94> : 1c 69 00 00 00             load.c32 105
	<.main+5429 @062c99> : 1f d3 0c 06 00             load.ref <@060cd3> ;strFixed+3
	<.main+5434 @062c9e> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5435 @062c9f> - <.main+5446 @062caa>): strFixed[4] := 'n';
	<.main+5435 @062c9f> : 1c 6e 00 00 00             load.c32 110
	<.main+5440 @062ca4> : 1f d4 0c 06 00             load.ref <@060cd4> ;strFixed+4
	<.main+5445 @062ca9> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (11 bytes: <.main+5446 @062caa> - <.main+5457 @062cb5>): strFixed[5] := 'g';
	<.main+5446 @062caa> : 1c 67 00 00 00             load.c32 103
	<.main+5451 @062caf> : 1f d5 0c 06 00             load.ref <@060cd5> ;strFixed+5
	<.main+5456 @062cb4> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:34: (7 bytes: <.main+5457 @062cb5> - <.main+5464 @062cbc>): strFixed[6] := (0);
	<.main+5457 @062cb5> : 19                         load.z32
	<.main+5458 @062cb6> : 1f d6 0c 06 00             load.ref <@060cd6> ;strFixed+6
	<.main+5463 @062cbb> : 2b                         store.i8
	cmplStd/test/lang/init.array.ci:37: (9 bytes: <.main+5464 @062cbc> - <.main+5473 @062cc5>): static strArray: char[*] := "string"
	<.main+5464 @062cbc> : 1f 6d 78 03 00             load.ref <@03786d> ;"string"
	<.main+5469 @062cc1> : 24 d8 0c 06                store.m32 <@060cd8> ;strArray
	cmplStd/test/lang/init.array.ci:40: (14 bytes: <.main+5473 @062cc5> - <.main+5487 @062cd3>): static strSlice: char[] := "string"
	<.main+5473 @062cc5> : 1c 06 00 00 00             load.c32 6
	<.main+5478 @062cca> : 1f 6d 78 03 00             load.ref <@03786d> ;"string"
	<.main+5483 @062ccf> : 23 e0 0c 06                store.m64 <@060ce0> ;strSlice
	cmplStd/test/lang/recUnion.ci:26: (21 bytes: <.main+5487 @062cd3> - <.main+5508 @062ce8>): static black: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5487 @062cd3> - <.main+5494 @062cda>): black.r := (0);
	<.main+5487 @062cd3> : 19                         load.z32
	<.main+5488 @062cd4> : 1f 22 0d 06 00             load.ref <@060d22> ;black+2
	<.main+5493 @062cd9> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5494 @062cda> - <.main+5501 @062ce1>): black.g := (0);
	<.main+5494 @062cda> : 19                         load.z32
	<.main+5495 @062cdb> : 1f 21 0d 06 00             load.ref <@060d21> ;black+1
	<.main+5500 @062ce0> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:26: (7 bytes: <.main+5501 @062ce1> - <.main+5508 @062ce8>): black.b := (0);
	<.main+5501 @062ce1> : 19                         load.z32
	<.main+5502 @062ce2> : 1f 20 0d 06 00             load.ref <@060d20> ;black
	<.main+5507 @062ce7> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (25 bytes: <.main+5508 @062ce8> - <.main+5533 @062d01>): static green: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5508 @062ce8> - <.main+5515 @062cef>): green.r := (0);
	<.main+5508 @062ce8> : 19                         load.z32
	<.main+5509 @062ce9> : 1f 2a 0d 06 00             load.ref <@060d2a> ;green+2
	<.main+5514 @062cee> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (11 bytes: <.main+5515 @062cef> - <.main+5526 @062cfa>): green.g := (255);
	<.main+5515 @062cef> : 1c ff 00 00 00             load.c32 255
	<.main+5520 @062cf4> : 1f 29 0d 06 00             load.ref <@060d29> ;green+1
	<.main+5525 @062cf9> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:27: (7 bytes: <.main+5526 @062cfa> - <.main+5533 @062d01>): green.b := (0);
	<.main+5526 @062cfa> : 19                         load.z32
	<.main+5527 @062cfb> : 1f 28 0d 06 00             load.ref <@060d28> ;green
	<.main+5532 @062d00> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (33 bytes: <.main+5533 @062d01> - <.main+5566 @062d22>): static white: rgbU8 := {...}
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5533 @062d01> - <.main+5544 @062d0c>): white.r := (255);
	<.main+5533 @062d01> : 1c ff 00 00 00             load.c32 255
	<.main+5538 @062d06> : 1f 32 0d 06 00             load.ref <@060d32> ;white+2
	<.main+5543 @062d0b> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5544 @062d0c> - <.main+5555 @062d17>): white.g := (255);
	<.main+5544 @062d0c> : 1c ff 00 00 00             load.c32 255
	<.main+5549 @062d11> : 1f 31 0d 06 00             load.ref <@060d31> ;white+1
	<.main+5554 @062d16> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:28: (11 bytes: <.main+5555 @062d17> - <.main+5566 @062d22>): white.b := (255);
	<.main+5555 @062d17> : 1c ff 00 00 00             load.c32 255
	<.main+5560 @062d1c> : 1f 30 0d 06 00             load.ref <@060d30> ;white
	<.main+5565 @062d21> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5566 @062d22> - <.main+5575 @062d2b>): cyan.col := (65535);
	cmplStd/test/lang/recUnion.ci:30: (9 bytes: <.main+5566 @062d22> - <.main+5575 @062d2b>): static cyan: color := {...}
	<.main+5566 @062d22> : 1c ff ff 00 00             load.c32 65535
	<.main+5571 @062d27> : 24 38 0d 06                store.m32 <@060d38> ;cyan
	cmplStd/test/lang/recUnion.ci:31: (25 bytes: <.main+5575 @062d2b> - <.main+5600 @062d44>): static blue: color := {...}
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5575 @062d2b> - <.main+5582 @062d32>): blue.rgb.r := (0);
	<.main+5575 @062d2b> : 19                         load.z32
	<.main+5576 @062d2c> : 1f 42 0d 06 00             load.ref <@060d42> ;blue+2
	<.main+5581 @062d31> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (7 bytes: <.main+5582 @062d32> - <.main+5589 @062d39>): blue.rgb.g := (0);
	<.main+5582 @062d32> : 19                         load.z32
	<.main+5583 @062d33> : 1f 41 0d 06 00             load.ref <@060d41> ;blue+1
	<.main+5588 @062d38> : 2b                         store.i8
	cmplStd/test/lang/recUnion.ci:31: (11 bytes: <.main+5589 @062d39> - <.main+5600 @062d44>): blue.rgb.b := (255);
	<.main+5589 @062d39> : 1c ff 00 00 00             load.c32 255
	<.main+5594 @062d3e> : 1f 40 0d 06 00             load.ref <@060d40> ;blue
	<.main+5599 @062d43> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:5: (9 bytes: <.main+5600 @062d44> - <.main+5609 @062d4d>): static shift: int32 := 2
	<.main+5600 @062d44> : 1c 02 00 00 00             load.c32 2
	<.main+5605 @062d49> : 24 48 0d 06                store.m32 <@060d48> ;shift
	cmplStd/test/lang/useOperator.ci:7: (11 bytes: <.main+5609 @062d4d> - <.main+5620 @062d58>): static boolA: bool := true
	<.main+5609 @062d4d> : 1c 01 00 00 00             load.c32 1
	<.main+5614 @062d52> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5619 @062d57> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:8: (11 bytes: <.main+5620 @062d58> - <.main+5631 @062d63>): static boolB: bool := !false
	<.main+5620 @062d58> : 1c 01 00 00 00             load.c32 1
	<.main+5625 @062d5d> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5630 @062d62> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:17: (19 bytes: <.main+5631 @062d63> - <.main+5650 @062d76>): static boolAnd: bool := boolA & boolB
	<.main+5631 @062d63> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5636 @062d68> : 26                         load.i8
	<.main+5637 @062d69> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5642 @062d6e> : 26                         load.i8
	<.main+5643 @062d6f> : 31                         and.b32
	<.main+5644 @062d70> : 1f 60 0d 06 00             load.ref <@060d60> ;boolAnd
	<.main+5649 @062d75> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:18: (19 bytes: <.main+5650 @062d76> - <.main+5669 @062d89>): static boolIor: bool := boolA | boolB
	<.main+5650 @062d76> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5655 @062d7b> : 26                         load.i8
	<.main+5656 @062d7c> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5661 @062d81> : 26                         load.i8
	<.main+5662 @062d82> : 32                         or.b32
	<.main+5663 @062d83> : 1f 68 0d 06 00             load.ref <@060d68> ;boolIor
	<.main+5668 @062d88> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:19: (19 bytes: <.main+5669 @062d89> - <.main+5688 @062d9c>): static boolXor: bool := boolA ^ boolB
	<.main+5669 @062d89> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5674 @062d8e> : 26                         load.i8
	<.main+5675 @062d8f> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5680 @062d94> : 26                         load.i8
	<.main+5681 @062d95> : 36                         xor.b32
	<.main+5682 @062d96> : 1f 70 0d 06 00             load.ref <@060d70> ;boolXor
	<.main+5687 @062d9b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:22: (13 bytes: <.main+5688 @062d9c> - <.main+5701 @062da9>): static boolNot: bool := !boolB
	<.main+5688 @062d9c> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5693 @062da1> : 26                         load.i8
	<.main+5694 @062da2> : 0b                         not.b32
	<.main+5695 @062da3> : 1f 78 0d 06 00             load.ref <@060d78> ;boolNot
	<.main+5700 @062da8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:23: (19 bytes: <.main+5701 @062da9> - <.main+5720 @062dbc>): static boolCeq: bool := boolA == boolB
	<.main+5701 @062da9> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5706 @062dae> : 26                         load.i8
	<.main+5707 @062daf> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5712 @062db4> : 26                         load.i8
	<.main+5713 @062db5> : 57                         ceq.i32
	<.main+5714 @062db6> : 1f 80 0d 06 00             load.ref <@060d80> ;boolCeq
	<.main+5719 @062dbb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:24: (20 bytes: <.main+5720 @062dbc> - <.main+5740 @062dd0>): static boolCne: bool := boolA != boolB
	<.main+5720 @062dbc> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5725 @062dc1> : 26                         load.i8
	<.main+5726 @062dc2> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5731 @062dc7> : 26                         load.i8
	<.main+5732 @062dc8> : 57                         ceq.i32
	<.main+5733 @062dc9> : 0b                         not.b32
	<.main+5734 @062dca> : 1f 88 0d 06 00             load.ref <@060d88> ;boolCne
	<.main+5739 @062dcf> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:25: (19 bytes: <.main+5740 @062dd0> - <.main+5759 @062de3>): static boolClt: bool := boolA < boolB
	<.main+5740 @062dd0> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5745 @062dd5> : 26                         load.i8
	<.main+5746 @062dd6> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5751 @062ddb> : 26                         load.i8
	<.main+5752 @062ddc> : 58                         clt.i32
	<.main+5753 @062ddd> : 1f 90 0d 06 00             load.ref <@060d90> ;boolClt
	<.main+5758 @062de2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:26: (20 bytes: <.main+5759 @062de3> - <.main+5779 @062df7>): static boolCle: bool := boolA <= boolB
	<.main+5759 @062de3> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5764 @062de8> : 26                         load.i8
	<.main+5765 @062de9> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5770 @062dee> : 26                         load.i8
	<.main+5771 @062def> : 59                         cgt.i32
	<.main+5772 @062df0> : 0b                         not.b32
	<.main+5773 @062df1> : 1f 98 0d 06 00             load.ref <@060d98> ;boolCle
	<.main+5778 @062df6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:27: (19 bytes: <.main+5779 @062df7> - <.main+5798 @062e0a>): static boolCgt: bool := boolA > boolB
	<.main+5779 @062df7> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5784 @062dfc> : 26                         load.i8
	<.main+5785 @062dfd> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5790 @062e02> : 26                         load.i8
	<.main+5791 @062e03> : 59                         cgt.i32
	<.main+5792 @062e04> : 1f a0 0d 06 00             load.ref <@060da0> ;boolCgt
	<.main+5797 @062e09> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:28: (20 bytes: <.main+5798 @062e0a> - <.main+5818 @062e1e>): static boolCge: bool := boolA >= boolB
	<.main+5798 @062e0a> : 1f 50 0d 06 00             load.ref <@060d50> ;boolA
	<.main+5803 @062e0f> : 26                         load.i8
	<.main+5804 @062e10> : 1f 58 0d 06 00             load.ref <@060d58> ;boolB
	<.main+5809 @062e15> : 26                         load.i8
	<.main+5810 @062e16> : 58                         clt.i32
	<.main+5811 @062e17> : 0b                         not.b32
	<.main+5812 @062e18> : 1f a8 0d 06 00             load.ref <@060da8> ;boolCge
	<.main+5817 @062e1d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:30: (11 bytes: <.main+5818 @062e1e> - <.main+5829 @062e29>): static chrA: char := 'a'
	<.main+5818 @062e1e> : 1c 61 00 00 00             load.c32 97
	<.main+5823 @062e23> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5828 @062e28> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:31: (11 bytes: <.main+5829 @062e29> - <.main+5840 @062e34>): static chrB: char := 'b'
	<.main+5829 @062e29> : 1c 62 00 00 00             load.c32 98
	<.main+5834 @062e2e> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5839 @062e33> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:32: (12 bytes: <.main+5840 @062e34> - <.main+5852 @062e40>): static chrPls: char := +chrB
	<.main+5840 @062e34> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5845 @062e39> : 26                         load.i8
	<.main+5846 @062e3a> : 1f c0 0d 06 00             load.ref <@060dc0> ;chrPls
	<.main+5851 @062e3f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:33: (13 bytes: <.main+5852 @062e40> - <.main+5865 @062e4d>): static chrNeg: char := -chrB
	<.main+5852 @062e40> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5857 @062e45> : 26                         load.i8
	<.main+5858 @062e46> : 50                         neg.i32
	<.main+5859 @062e47> : 1f c8 0d 06 00             load.ref <@060dc8> ;chrNeg
	<.main+5864 @062e4c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:34: (13 bytes: <.main+5865 @062e4d> - <.main+5878 @062e5a>): static chrCmt: char := ~chrB
	<.main+5865 @062e4d> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5870 @062e52> : 26                         load.i8
	<.main+5871 @062e53> : 30                         cmt.b32
	<.main+5872 @062e54> : 1f d0 0d 06 00             load.ref <@060dd0> ;chrCmt
	<.main+5877 @062e59> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:35: (19 bytes: <.main+5878 @062e5a> - <.main+5897 @062e6d>): static chrAdd: char := chrA + chrB
	<.main+5878 @062e5a> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5883 @062e5f> : 26                         load.i8
	<.main+5884 @062e60> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5889 @062e65> : 26                         load.i8
	<.main+5890 @062e66> : 51                         add.i32
	<.main+5891 @062e67> : 1f d8 0d 06 00             load.ref <@060dd8> ;chrAdd
	<.main+5896 @062e6c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:36: (19 bytes: <.main+5897 @062e6d> - <.main+5916 @062e80>): static chrSub: char := chrA - chrB
	<.main+5897 @062e6d> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5902 @062e72> : 26                         load.i8
	<.main+5903 @062e73> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5908 @062e78> : 26                         load.i8
	<.main+5909 @062e79> : 52                         sub.i32
	<.main+5910 @062e7a> : 1f e0 0d 06 00             load.ref <@060de0> ;chrSub
	<.main+5915 @062e7f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:37: (19 bytes: <.main+5916 @062e80> - <.main+5935 @062e93>): static chrMul: char := chrA * chrB
	<.main+5916 @062e80> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5921 @062e85> : 26                         load.i8
	<.main+5922 @062e86> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5927 @062e8b> : 26                         load.i8
	<.main+5928 @062e8c> : 53                         mul.i32
	<.main+5929 @062e8d> : 1f e8 0d 06 00             load.ref <@060de8> ;chrMul
	<.main+5934 @062e92> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:38: (19 bytes: <.main+5935 @062e93> - <.main+5954 @062ea6>): static chrDiv: char := chrA / chrB
	<.main+5935 @062e93> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5940 @062e98> : 26                         load.i8
	<.main+5941 @062e99> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5946 @062e9e> : 26                         load.i8
	<.main+5947 @062e9f> : 54                         div.i32
	<.main+5948 @062ea0> : 1f f0 0d 06 00             load.ref <@060df0> ;chrDiv
	<.main+5953 @062ea5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:39: (19 bytes: <.main+5954 @062ea6> - <.main+5973 @062eb9>): static chrMod: char := chrA % chrB
	<.main+5954 @062ea6> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5959 @062eab> : 26                         load.i8
	<.main+5960 @062eac> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5965 @062eb1> : 26                         load.i8
	<.main+5966 @062eb2> : 55                         mod.i32
	<.main+5967 @062eb3> : 1f f8 0d 06 00             load.ref <@060df8> ;chrMod
	<.main+5972 @062eb8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:40: (19 bytes: <.main+5973 @062eb9> - <.main+5992 @062ecc>): static chrAnd: char := chrA & chrB
	<.main+5973 @062eb9> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5978 @062ebe> : 26                         load.i8
	<.main+5979 @062ebf> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+5984 @062ec4> : 26                         load.i8
	<.main+5985 @062ec5> : 31                         and.b32
	<.main+5986 @062ec6> : 1f 00 0e 06 00             load.ref <@060e00> ;chrAnd
	<.main+5991 @062ecb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:41: (19 bytes: <.main+5992 @062ecc> - <.main+6011 @062edf>): static chrIor: char := chrA | chrB
	<.main+5992 @062ecc> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+5997 @062ed1> : 26                         load.i8
	<.main+5998 @062ed2> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6003 @062ed7> : 26                         load.i8
	<.main+6004 @062ed8> : 32                         or.b32
	<.main+6005 @062ed9> : 1f 08 0e 06 00             load.ref <@060e08> ;chrIor
	<.main+6010 @062ede> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:42: (19 bytes: <.main+6011 @062edf> - <.main+6030 @062ef2>): static chrXor: char := chrA ^ chrB
	<.main+6011 @062edf> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6016 @062ee4> : 26                         load.i8
	<.main+6017 @062ee5> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6022 @062eea> : 26                         load.i8
	<.main+6023 @062eeb> : 36                         xor.b32
	<.main+6024 @062eec> : 1f 10 0e 06 00             load.ref <@060e10> ;chrXor
	<.main+6029 @062ef1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:43: (17 bytes: <.main+6030 @062ef2> - <.main+6047 @062f03>): static chrShl: char := (chrA) << shift
	<.main+6030 @062ef2> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6035 @062ef7> : 26                         load.i8
	<.main+6036 @062ef8> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6040 @062efc> : 3a                         shl.b32
	<.main+6041 @062efd> : 1f 18 0e 06 00             load.ref <@060e18> ;chrShl
	<.main+6046 @062f02> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:44: (17 bytes: <.main+6047 @062f03> - <.main+6064 @062f14>): static chrShr: char := (chrA) >> shift
	<.main+6047 @062f03> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6052 @062f08> : 26                         load.i8
	<.main+6053 @062f09> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6057 @062f0d> : 3c                         sar.b32
	<.main+6058 @062f0e> : 1f 20 0e 06 00             load.ref <@060e20> ;chrShr
	<.main+6063 @062f13> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:45: (14 bytes: <.main+6064 @062f14> - <.main+6078 @062f22>): static chrNot: bool := !(chrB)
	<.main+6064 @062f14> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6069 @062f19> : 26                         load.i8
	<.main+6070 @062f1a> : 5a                         i32.2bool
	<.main+6071 @062f1b> : 0b                         not.b32
	<.main+6072 @062f1c> : 1f 28 0e 06 00             load.ref <@060e28> ;chrNot
	<.main+6077 @062f21> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:46: (19 bytes: <.main+6078 @062f22> - <.main+6097 @062f35>): static chrCeq: bool := chrA == chrB
	<.main+6078 @062f22> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6083 @062f27> : 26                         load.i8
	<.main+6084 @062f28> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6089 @062f2d> : 26                         load.i8
	<.main+6090 @062f2e> : 57                         ceq.i32
	<.main+6091 @062f2f> : 1f 30 0e 06 00             load.ref <@060e30> ;chrCeq
	<.main+6096 @062f34> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:47: (20 bytes: <.main+6097 @062f35> - <.main+6117 @062f49>): static chrCne: bool := chrA != chrB
	<.main+6097 @062f35> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6102 @062f3a> : 26                         load.i8
	<.main+6103 @062f3b> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6108 @062f40> : 26                         load.i8
	<.main+6109 @062f41> : 57                         ceq.i32
	<.main+6110 @062f42> : 0b                         not.b32
	<.main+6111 @062f43> : 1f 38 0e 06 00             load.ref <@060e38> ;chrCne
	<.main+6116 @062f48> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:48: (19 bytes: <.main+6117 @062f49> - <.main+6136 @062f5c>): static chrClt: bool := chrA < chrB
	<.main+6117 @062f49> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6122 @062f4e> : 26                         load.i8
	<.main+6123 @062f4f> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6128 @062f54> : 26                         load.i8
	<.main+6129 @062f55> : 58                         clt.i32
	<.main+6130 @062f56> : 1f 40 0e 06 00             load.ref <@060e40> ;chrClt
	<.main+6135 @062f5b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:49: (20 bytes: <.main+6136 @062f5c> - <.main+6156 @062f70>): static chrCle: bool := chrA <= chrB
	<.main+6136 @062f5c> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6141 @062f61> : 26                         load.i8
	<.main+6142 @062f62> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6147 @062f67> : 26                         load.i8
	<.main+6148 @062f68> : 59                         cgt.i32
	<.main+6149 @062f69> : 0b                         not.b32
	<.main+6150 @062f6a> : 1f 48 0e 06 00             load.ref <@060e48> ;chrCle
	<.main+6155 @062f6f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:50: (19 bytes: <.main+6156 @062f70> - <.main+6175 @062f83>): static chrCgt: bool := chrA > chrB
	<.main+6156 @062f70> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6161 @062f75> : 26                         load.i8
	<.main+6162 @062f76> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6167 @062f7b> : 26                         load.i8
	<.main+6168 @062f7c> : 59                         cgt.i32
	<.main+6169 @062f7d> : 1f 50 0e 06 00             load.ref <@060e50> ;chrCgt
	<.main+6174 @062f82> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:51: (20 bytes: <.main+6175 @062f83> - <.main+6195 @062f97>): static chrCge: bool := chrA >= chrB
	<.main+6175 @062f83> : 1f b0 0d 06 00             load.ref <@060db0> ;chrA
	<.main+6180 @062f88> : 26                         load.i8
	<.main+6181 @062f89> : 1f b8 0d 06 00             load.ref <@060db8> ;chrB
	<.main+6186 @062f8e> : 26                         load.i8
	<.main+6187 @062f8f> : 58                         clt.i32
	<.main+6188 @062f90> : 0b                         not.b32
	<.main+6189 @062f91> : 1f 58 0e 06 00             load.ref <@060e58> ;chrCge
	<.main+6194 @062f96> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:53: (11 bytes: <.main+6195 @062f97> - <.main+6206 @062fa2>): static i8A: int8 := a
	<.main+6195 @062f97> : 1c 60 00 00 00             load.c32 96
	<.main+6200 @062f9c> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6205 @062fa1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:54: (11 bytes: <.main+6206 @062fa2> - <.main+6217 @062fad>): static i8B: int8 := b
	<.main+6206 @062fa2> : 1c 2a 00 00 00             load.c32 42
	<.main+6211 @062fa7> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6216 @062fac> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:55: (12 bytes: <.main+6217 @062fad> - <.main+6229 @062fb9>): static i8Pls: int8 := +i8B
	<.main+6217 @062fad> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6222 @062fb2> : 26                         load.i8
	<.main+6223 @062fb3> : 1f 70 0e 06 00             load.ref <@060e70> ;i8Pls
	<.main+6228 @062fb8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:56: (13 bytes: <.main+6229 @062fb9> - <.main+6242 @062fc6>): static i8Neg: int8 := -i8B
	<.main+6229 @062fb9> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6234 @062fbe> : 26                         load.i8
	<.main+6235 @062fbf> : 50                         neg.i32
	<.main+6236 @062fc0> : 1f 78 0e 06 00             load.ref <@060e78> ;i8Neg
	<.main+6241 @062fc5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:57: (13 bytes: <.main+6242 @062fc6> - <.main+6255 @062fd3>): static i8Cmt: int8 := ~i8B
	<.main+6242 @062fc6> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6247 @062fcb> : 26                         load.i8
	<.main+6248 @062fcc> : 30                         cmt.b32
	<.main+6249 @062fcd> : 1f 80 0e 06 00             load.ref <@060e80> ;i8Cmt
	<.main+6254 @062fd2> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:58: (19 bytes: <.main+6255 @062fd3> - <.main+6274 @062fe6>): static i8Add: int8 := i8A + i8B
	<.main+6255 @062fd3> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6260 @062fd8> : 26                         load.i8
	<.main+6261 @062fd9> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6266 @062fde> : 26                         load.i8
	<.main+6267 @062fdf> : 51                         add.i32
	<.main+6268 @062fe0> : 1f 88 0e 06 00             load.ref <@060e88> ;i8Add
	<.main+6273 @062fe5> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:59: (19 bytes: <.main+6274 @062fe6> - <.main+6293 @062ff9>): static i8Sub: int8 := i8A - i8B
	<.main+6274 @062fe6> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6279 @062feb> : 26                         load.i8
	<.main+6280 @062fec> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6285 @062ff1> : 26                         load.i8
	<.main+6286 @062ff2> : 52                         sub.i32
	<.main+6287 @062ff3> : 1f 90 0e 06 00             load.ref <@060e90> ;i8Sub
	<.main+6292 @062ff8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:60: (19 bytes: <.main+6293 @062ff9> - <.main+6312 @06300c>): static i8Mul: int8 := i8A * i8B
	<.main+6293 @062ff9> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6298 @062ffe> : 26                         load.i8
	<.main+6299 @062fff> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6304 @063004> : 26                         load.i8
	<.main+6305 @063005> : 53                         mul.i32
	<.main+6306 @063006> : 1f 98 0e 06 00             load.ref <@060e98> ;i8Mul
	<.main+6311 @06300b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:61: (19 bytes: <.main+6312 @06300c> - <.main+6331 @06301f>): static i8Div: int8 := i8A / i8B
	<.main+6312 @06300c> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6317 @063011> : 26                         load.i8
	<.main+6318 @063012> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6323 @063017> : 26                         load.i8
	<.main+6324 @063018> : 54                         div.i32
	<.main+6325 @063019> : 1f a0 0e 06 00             load.ref <@060ea0> ;i8Div
	<.main+6330 @06301e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:62: (19 bytes: <.main+6331 @06301f> - <.main+6350 @063032>): static i8Mod: int8 := i8A % i8B
	<.main+6331 @06301f> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6336 @063024> : 26                         load.i8
	<.main+6337 @063025> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6342 @06302a> : 26                         load.i8
	<.main+6343 @06302b> : 55                         mod.i32
	<.main+6344 @06302c> : 1f a8 0e 06 00             load.ref <@060ea8> ;i8Mod
	<.main+6349 @063031> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:63: (19 bytes: <.main+6350 @063032> - <.main+6369 @063045>): static i8And: int8 := i8A & i8B
	<.main+6350 @063032> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6355 @063037> : 26                         load.i8
	<.main+6356 @063038> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6361 @06303d> : 26                         load.i8
	<.main+6362 @06303e> : 31                         and.b32
	<.main+6363 @06303f> : 1f b0 0e 06 00             load.ref <@060eb0> ;i8And
	<.main+6368 @063044> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:64: (19 bytes: <.main+6369 @063045> - <.main+6388 @063058>): static i8Ior: int8 := i8A | i8B
	<.main+6369 @063045> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6374 @06304a> : 26                         load.i8
	<.main+6375 @06304b> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6380 @063050> : 26                         load.i8
	<.main+6381 @063051> : 32                         or.b32
	<.main+6382 @063052> : 1f b8 0e 06 00             load.ref <@060eb8> ;i8Ior
	<.main+6387 @063057> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:65: (19 bytes: <.main+6388 @063058> - <.main+6407 @06306b>): static i8Xor: int8 := i8A ^ i8B
	<.main+6388 @063058> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6393 @06305d> : 26                         load.i8
	<.main+6394 @06305e> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6399 @063063> : 26                         load.i8
	<.main+6400 @063064> : 36                         xor.b32
	<.main+6401 @063065> : 1f c0 0e 06 00             load.ref <@060ec0> ;i8Xor
	<.main+6406 @06306a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:66: (17 bytes: <.main+6407 @06306b> - <.main+6424 @06307c>): static i8Shl: int8 := (i8A) << shift
	<.main+6407 @06306b> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6412 @063070> : 26                         load.i8
	<.main+6413 @063071> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6417 @063075> : 3a                         shl.b32
	<.main+6418 @063076> : 1f c8 0e 06 00             load.ref <@060ec8> ;i8Shl
	<.main+6423 @06307b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:67: (17 bytes: <.main+6424 @06307c> - <.main+6441 @06308d>): static i8Shr: int8 := (i8A) >> shift
	<.main+6424 @06307c> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6429 @063081> : 26                         load.i8
	<.main+6430 @063082> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6434 @063086> : 3c                         sar.b32
	<.main+6435 @063087> : 1f d0 0e 06 00             load.ref <@060ed0> ;i8Shr
	<.main+6440 @06308c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:68: (14 bytes: <.main+6441 @06308d> - <.main+6455 @06309b>): static i8Not: bool := !(i8B)
	<.main+6441 @06308d> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6446 @063092> : 26                         load.i8
	<.main+6447 @063093> : 5a                         i32.2bool
	<.main+6448 @063094> : 0b                         not.b32
	<.main+6449 @063095> : 1f d8 0e 06 00             load.ref <@060ed8> ;i8Not
	<.main+6454 @06309a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:69: (19 bytes: <.main+6455 @06309b> - <.main+6474 @0630ae>): static i8Ceq: bool := i8A == i8B
	<.main+6455 @06309b> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6460 @0630a0> : 26                         load.i8
	<.main+6461 @0630a1> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6466 @0630a6> : 26                         load.i8
	<.main+6467 @0630a7> : 57                         ceq.i32
	<.main+6468 @0630a8> : 1f e0 0e 06 00             load.ref <@060ee0> ;i8Ceq
	<.main+6473 @0630ad> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:70: (20 bytes: <.main+6474 @0630ae> - <.main+6494 @0630c2>): static i8Cne: bool := i8A != i8B
	<.main+6474 @0630ae> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6479 @0630b3> : 26                         load.i8
	<.main+6480 @0630b4> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6485 @0630b9> : 26                         load.i8
	<.main+6486 @0630ba> : 57                         ceq.i32
	<.main+6487 @0630bb> : 0b                         not.b32
	<.main+6488 @0630bc> : 1f e8 0e 06 00             load.ref <@060ee8> ;i8Cne
	<.main+6493 @0630c1> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:71: (19 bytes: <.main+6494 @0630c2> - <.main+6513 @0630d5>): static i8Clt: bool := i8A < i8B
	<.main+6494 @0630c2> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6499 @0630c7> : 26                         load.i8
	<.main+6500 @0630c8> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6505 @0630cd> : 26                         load.i8
	<.main+6506 @0630ce> : 58                         clt.i32
	<.main+6507 @0630cf> : 1f f0 0e 06 00             load.ref <@060ef0> ;i8Clt
	<.main+6512 @0630d4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:72: (20 bytes: <.main+6513 @0630d5> - <.main+6533 @0630e9>): static i8Cle: bool := i8A <= i8B
	<.main+6513 @0630d5> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6518 @0630da> : 26                         load.i8
	<.main+6519 @0630db> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6524 @0630e0> : 26                         load.i8
	<.main+6525 @0630e1> : 59                         cgt.i32
	<.main+6526 @0630e2> : 0b                         not.b32
	<.main+6527 @0630e3> : 1f f8 0e 06 00             load.ref <@060ef8> ;i8Cle
	<.main+6532 @0630e8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:73: (19 bytes: <.main+6533 @0630e9> - <.main+6552 @0630fc>): static i8Cgt: bool := i8A > i8B
	<.main+6533 @0630e9> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6538 @0630ee> : 26                         load.i8
	<.main+6539 @0630ef> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6544 @0630f4> : 26                         load.i8
	<.main+6545 @0630f5> : 59                         cgt.i32
	<.main+6546 @0630f6> : 1f 00 0f 06 00             load.ref <@060f00> ;i8Cgt
	<.main+6551 @0630fb> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:74: (20 bytes: <.main+6552 @0630fc> - <.main+6572 @063110>): static i8Cge: bool := i8A >= i8B
	<.main+6552 @0630fc> : 1f 60 0e 06 00             load.ref <@060e60> ;i8A
	<.main+6557 @063101> : 26                         load.i8
	<.main+6558 @063102> : 1f 68 0e 06 00             load.ref <@060e68> ;i8B
	<.main+6563 @063107> : 26                         load.i8
	<.main+6564 @063108> : 58                         clt.i32
	<.main+6565 @063109> : 0b                         not.b32
	<.main+6566 @06310a> : 1f 08 0f 06 00             load.ref <@060f08> ;i8Cge
	<.main+6571 @06310f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:76: (11 bytes: <.main+6572 @063110> - <.main+6583 @06311b>): static u8A: uint8 := a
	<.main+6572 @063110> : 1c 60 00 00 00             load.c32 96
	<.main+6577 @063115> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6582 @06311a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:77: (11 bytes: <.main+6583 @06311b> - <.main+6594 @063126>): static u8B: uint8 := b
	<.main+6583 @06311b> : 1c 2a 00 00 00             load.c32 42
	<.main+6588 @063120> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6593 @063125> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:78: (12 bytes: <.main+6594 @063126> - <.main+6606 @063132>): static u8Pls: uint8 := +u8B
	<.main+6594 @063126> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6599 @06312b> : 26                         load.i8
	<.main+6600 @06312c> : 1f 20 0f 06 00             load.ref <@060f20> ;u8Pls
	<.main+6605 @063131> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:79: (13 bytes: <.main+6606 @063132> - <.main+6619 @06313f>): static u8Neg: uint8 := -u8B
	<.main+6606 @063132> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6611 @063137> : 26                         load.i8
	<.main+6612 @063138> : 50                         neg.i32
	<.main+6613 @063139> : 1f 28 0f 06 00             load.ref <@060f28> ;u8Neg
	<.main+6618 @06313e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:80: (13 bytes: <.main+6619 @06313f> - <.main+6632 @06314c>): static u8Cmt: uint8 := ~u8B
	<.main+6619 @06313f> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6624 @063144> : 26                         load.i8
	<.main+6625 @063145> : 30                         cmt.b32
	<.main+6626 @063146> : 1f 30 0f 06 00             load.ref <@060f30> ;u8Cmt
	<.main+6631 @06314b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:81: (19 bytes: <.main+6632 @06314c> - <.main+6651 @06315f>): static u8Add: uint8 := u8A + u8B
	<.main+6632 @06314c> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6637 @063151> : 26                         load.i8
	<.main+6638 @063152> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6643 @063157> : 26                         load.i8
	<.main+6644 @063158> : 51                         add.i32
	<.main+6645 @063159> : 1f 38 0f 06 00             load.ref <@060f38> ;u8Add
	<.main+6650 @06315e> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:82: (19 bytes: <.main+6651 @06315f> - <.main+6670 @063172>): static u8Sub: uint8 := u8A - u8B
	<.main+6651 @06315f> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6656 @063164> : 26                         load.i8
	<.main+6657 @063165> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6662 @06316a> : 26                         load.i8
	<.main+6663 @06316b> : 52                         sub.i32
	<.main+6664 @06316c> : 1f 40 0f 06 00             load.ref <@060f40> ;u8Sub
	<.main+6669 @063171> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:83: (19 bytes: <.main+6670 @063172> - <.main+6689 @063185>): static u8Mul: uint8 := u8A * u8B
	<.main+6670 @063172> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6675 @063177> : 26                         load.i8
	<.main+6676 @063178> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6681 @06317d> : 26                         load.i8
	<.main+6682 @06317e> : 33                         mul.u32
	<.main+6683 @06317f> : 1f 48 0f 06 00             load.ref <@060f48> ;u8Mul
	<.main+6688 @063184> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:84: (19 bytes: <.main+6689 @063185> - <.main+6708 @063198>): static u8Div: uint8 := u8A / u8B
	<.main+6689 @063185> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6694 @06318a> : 26                         load.i8
	<.main+6695 @06318b> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6700 @063190> : 26                         load.i8
	<.main+6701 @063191> : 34                         div.u32
	<.main+6702 @063192> : 1f 50 0f 06 00             load.ref <@060f50> ;u8Div
	<.main+6707 @063197> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:85: (19 bytes: <.main+6708 @063198> - <.main+6727 @0631ab>): static u8Mod: uint8 := u8A % u8B
	<.main+6708 @063198> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6713 @06319d> : 26                         load.i8
	<.main+6714 @06319e> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6719 @0631a3> : 26                         load.i8
	<.main+6720 @0631a4> : 35                         mod.u32
	<.main+6721 @0631a5> : 1f 58 0f 06 00             load.ref <@060f58> ;u8Mod
	<.main+6726 @0631aa> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:86: (19 bytes: <.main+6727 @0631ab> - <.main+6746 @0631be>): static u8And: uint8 := u8A & u8B
	<.main+6727 @0631ab> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6732 @0631b0> : 26                         load.i8
	<.main+6733 @0631b1> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6738 @0631b6> : 26                         load.i8
	<.main+6739 @0631b7> : 31                         and.b32
	<.main+6740 @0631b8> : 1f 60 0f 06 00             load.ref <@060f60> ;u8And
	<.main+6745 @0631bd> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:87: (19 bytes: <.main+6746 @0631be> - <.main+6765 @0631d1>): static u8Ior: uint8 := u8A | u8B
	<.main+6746 @0631be> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6751 @0631c3> : 26                         load.i8
	<.main+6752 @0631c4> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6757 @0631c9> : 26                         load.i8
	<.main+6758 @0631ca> : 32                         or.b32
	<.main+6759 @0631cb> : 1f 68 0f 06 00             load.ref <@060f68> ;u8Ior
	<.main+6764 @0631d0> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:88: (19 bytes: <.main+6765 @0631d1> - <.main+6784 @0631e4>): static u8Xor: uint8 := u8A ^ u8B
	<.main+6765 @0631d1> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6770 @0631d6> : 26                         load.i8
	<.main+6771 @0631d7> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6776 @0631dc> : 26                         load.i8
	<.main+6777 @0631dd> : 36                         xor.b32
	<.main+6778 @0631de> : 1f 70 0f 06 00             load.ref <@060f70> ;u8Xor
	<.main+6783 @0631e3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:89: (17 bytes: <.main+6784 @0631e4> - <.main+6801 @0631f5>): static u8Shl: uint8 := (u8A) << shift
	<.main+6784 @0631e4> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6789 @0631e9> : 26                         load.i8
	<.main+6790 @0631ea> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6794 @0631ee> : 3a                         shl.b32
	<.main+6795 @0631ef> : 1f 78 0f 06 00             load.ref <@060f78> ;u8Shl
	<.main+6800 @0631f4> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:90: (17 bytes: <.main+6801 @0631f5> - <.main+6818 @063206>): static u8Shr: uint8 := (u8A) >> shift
	<.main+6801 @0631f5> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6806 @0631fa> : 26                         load.i8
	<.main+6807 @0631fb> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+6811 @0631ff> : 3c                         sar.b32
	<.main+6812 @063200> : 1f 80 0f 06 00             load.ref <@060f80> ;u8Shr
	<.main+6817 @063205> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:91: (14 bytes: <.main+6818 @063206> - <.main+6832 @063214>): static u8Not: bool := !(u8B)
	<.main+6818 @063206> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6823 @06320b> : 26                         load.i8
	<.main+6824 @06320c> : 5a                         i32.2bool
	<.main+6825 @06320d> : 0b                         not.b32
	<.main+6826 @06320e> : 1f 88 0f 06 00             load.ref <@060f88> ;u8Not
	<.main+6831 @063213> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:92: (19 bytes: <.main+6832 @063214> - <.main+6851 @063227>): static u8Ceq: bool := u8A == u8B
	<.main+6832 @063214> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6837 @063219> : 26                         load.i8
	<.main+6838 @06321a> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6843 @06321f> : 26                         load.i8
	<.main+6844 @063220> : 57                         ceq.i32
	<.main+6845 @063221> : 1f 90 0f 06 00             load.ref <@060f90> ;u8Ceq
	<.main+6850 @063226> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:93: (20 bytes: <.main+6851 @063227> - <.main+6871 @06323b>): static u8Cne: bool := u8A != u8B
	<.main+6851 @063227> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6856 @06322c> : 26                         load.i8
	<.main+6857 @06322d> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6862 @063232> : 26                         load.i8
	<.main+6863 @063233> : 57                         ceq.i32
	<.main+6864 @063234> : 0b                         not.b32
	<.main+6865 @063235> : 1f 98 0f 06 00             load.ref <@060f98> ;u8Cne
	<.main+6870 @06323a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:94: (19 bytes: <.main+6871 @06323b> - <.main+6890 @06324e>): static u8Clt: bool := u8A < u8B
	<.main+6871 @06323b> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6876 @063240> : 26                         load.i8
	<.main+6877 @063241> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6882 @063246> : 26                         load.i8
	<.main+6883 @063247> : 38                         clt.u32
	<.main+6884 @063248> : 1f a0 0f 06 00             load.ref <@060fa0> ;u8Clt
	<.main+6889 @06324d> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:95: (20 bytes: <.main+6890 @06324e> - <.main+6910 @063262>): static u8Cle: bool := u8A <= u8B
	<.main+6890 @06324e> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6895 @063253> : 26                         load.i8
	<.main+6896 @063254> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6901 @063259> : 26                         load.i8
	<.main+6902 @06325a> : 39                         cgt.u32
	<.main+6903 @06325b> : 0b                         not.b32
	<.main+6904 @06325c> : 1f a8 0f 06 00             load.ref <@060fa8> ;u8Cle
	<.main+6909 @063261> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:96: (19 bytes: <.main+6910 @063262> - <.main+6929 @063275>): static u8Cgt: bool := u8A > u8B
	<.main+6910 @063262> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6915 @063267> : 26                         load.i8
	<.main+6916 @063268> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6921 @06326d> : 26                         load.i8
	<.main+6922 @06326e> : 39                         cgt.u32
	<.main+6923 @06326f> : 1f b0 0f 06 00             load.ref <@060fb0> ;u8Cgt
	<.main+6928 @063274> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:97: (20 bytes: <.main+6929 @063275> - <.main+6949 @063289>): static u8Cge: bool := u8A >= u8B
	<.main+6929 @063275> : 1f 10 0f 06 00             load.ref <@060f10> ;u8A
	<.main+6934 @06327a> : 26                         load.i8
	<.main+6935 @06327b> : 1f 18 0f 06 00             load.ref <@060f18> ;u8B
	<.main+6940 @063280> : 26                         load.i8
	<.main+6941 @063281> : 38                         clt.u32
	<.main+6942 @063282> : 0b                         not.b32
	<.main+6943 @063283> : 1f b8 0f 06 00             load.ref <@060fb8> ;u8Cge
	<.main+6948 @063288> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:99: (11 bytes: <.main+6949 @063289> - <.main+6960 @063294>): static i16A: int16 := a
	<.main+6949 @063289> : 1c 60 00 00 00             load.c32 96
	<.main+6954 @06328e> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+6959 @063293> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:100: (11 bytes: <.main+6960 @063294> - <.main+6971 @06329f>): static i16B: int16 := b
	<.main+6960 @063294> : 1c 2a 00 00 00             load.c32 42
	<.main+6965 @063299> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+6970 @06329e> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:101: (12 bytes: <.main+6971 @06329f> - <.main+6983 @0632ab>): static i16Pls: int16 := +i16B
	<.main+6971 @06329f> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+6976 @0632a4> : 27                         load.i16
	<.main+6977 @0632a5> : 1f d0 0f 06 00             load.ref <@060fd0> ;i16Pls
	<.main+6982 @0632aa> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:102: (13 bytes: <.main+6983 @0632ab> - <.main+6996 @0632b8>): static i16Neg: int16 := -i16B
	<.main+6983 @0632ab> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+6988 @0632b0> : 27                         load.i16
	<.main+6989 @0632b1> : 50                         neg.i32
	<.main+6990 @0632b2> : 1f d8 0f 06 00             load.ref <@060fd8> ;i16Neg
	<.main+6995 @0632b7> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:103: (13 bytes: <.main+6996 @0632b8> - <.main+7009 @0632c5>): static i16Cmt: int16 := ~i16B
	<.main+6996 @0632b8> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7001 @0632bd> : 27                         load.i16
	<.main+7002 @0632be> : 30                         cmt.b32
	<.main+7003 @0632bf> : 1f e0 0f 06 00             load.ref <@060fe0> ;i16Cmt
	<.main+7008 @0632c4> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:104: (19 bytes: <.main+7009 @0632c5> - <.main+7028 @0632d8>): static i16Add: int16 := i16A + i16B
	<.main+7009 @0632c5> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7014 @0632ca> : 27                         load.i16
	<.main+7015 @0632cb> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7020 @0632d0> : 27                         load.i16
	<.main+7021 @0632d1> : 51                         add.i32
	<.main+7022 @0632d2> : 1f e8 0f 06 00             load.ref <@060fe8> ;i16Add
	<.main+7027 @0632d7> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:105: (19 bytes: <.main+7028 @0632d8> - <.main+7047 @0632eb>): static i16Sub: int16 := i16A - i16B
	<.main+7028 @0632d8> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7033 @0632dd> : 27                         load.i16
	<.main+7034 @0632de> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7039 @0632e3> : 27                         load.i16
	<.main+7040 @0632e4> : 52                         sub.i32
	<.main+7041 @0632e5> : 1f f0 0f 06 00             load.ref <@060ff0> ;i16Sub
	<.main+7046 @0632ea> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:106: (19 bytes: <.main+7047 @0632eb> - <.main+7066 @0632fe>): static i16Mul: int16 := i16A * i16B
	<.main+7047 @0632eb> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7052 @0632f0> : 27                         load.i16
	<.main+7053 @0632f1> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7058 @0632f6> : 27                         load.i16
	<.main+7059 @0632f7> : 53                         mul.i32
	<.main+7060 @0632f8> : 1f f8 0f 06 00             load.ref <@060ff8> ;i16Mul
	<.main+7065 @0632fd> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:107: (19 bytes: <.main+7066 @0632fe> - <.main+7085 @063311>): static i16Div: int16 := i16A / i16B
	<.main+7066 @0632fe> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7071 @063303> : 27                         load.i16
	<.main+7072 @063304> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7077 @063309> : 27                         load.i16
	<.main+7078 @06330a> : 54                         div.i32
	<.main+7079 @06330b> : 1f 00 10 06 00             load.ref <@061000> ;i16Div
	<.main+7084 @063310> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:108: (19 bytes: <.main+7085 @063311> - <.main+7104 @063324>): static i16Mod: int16 := i16A % i16B
	<.main+7085 @063311> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7090 @063316> : 27                         load.i16
	<.main+7091 @063317> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7096 @06331c> : 27                         load.i16
	<.main+7097 @06331d> : 55                         mod.i32
	<.main+7098 @06331e> : 1f 08 10 06 00             load.ref <@061008> ;i16Mod
	<.main+7103 @063323> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:109: (19 bytes: <.main+7104 @063324> - <.main+7123 @063337>): static i16And: int16 := i16A & i16B
	<.main+7104 @063324> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7109 @063329> : 27                         load.i16
	<.main+7110 @06332a> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7115 @06332f> : 27                         load.i16
	<.main+7116 @063330> : 31                         and.b32
	<.main+7117 @063331> : 1f 10 10 06 00             load.ref <@061010> ;i16And
	<.main+7122 @063336> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:110: (19 bytes: <.main+7123 @063337> - <.main+7142 @06334a>): static i16Ior: int16 := i16A | i16B
	<.main+7123 @063337> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7128 @06333c> : 27                         load.i16
	<.main+7129 @06333d> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7134 @063342> : 27                         load.i16
	<.main+7135 @063343> : 32                         or.b32
	<.main+7136 @063344> : 1f 18 10 06 00             load.ref <@061018> ;i16Ior
	<.main+7141 @063349> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:111: (19 bytes: <.main+7142 @06334a> - <.main+7161 @06335d>): static i16Xor: int16 := i16A ^ i16B
	<.main+7142 @06334a> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7147 @06334f> : 27                         load.i16
	<.main+7148 @063350> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7153 @063355> : 27                         load.i16
	<.main+7154 @063356> : 36                         xor.b32
	<.main+7155 @063357> : 1f 20 10 06 00             load.ref <@061020> ;i16Xor
	<.main+7160 @06335c> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:112: (17 bytes: <.main+7161 @06335d> - <.main+7178 @06336e>): static i16Shl: int16 := (i16A) << shift
	<.main+7161 @06335d> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7166 @063362> : 27                         load.i16
	<.main+7167 @063363> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7171 @063367> : 3a                         shl.b32
	<.main+7172 @063368> : 1f 28 10 06 00             load.ref <@061028> ;i16Shl
	<.main+7177 @06336d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:113: (17 bytes: <.main+7178 @06336e> - <.main+7195 @06337f>): static i16Shr: int16 := (i16A) >> shift
	<.main+7178 @06336e> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7183 @063373> : 27                         load.i16
	<.main+7184 @063374> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7188 @063378> : 3c                         sar.b32
	<.main+7189 @063379> : 1f 30 10 06 00             load.ref <@061030> ;i16Shr
	<.main+7194 @06337e> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:114: (14 bytes: <.main+7195 @06337f> - <.main+7209 @06338d>): static i16Not: bool := !(i16B)
	<.main+7195 @06337f> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7200 @063384> : 27                         load.i16
	<.main+7201 @063385> : 5a                         i32.2bool
	<.main+7202 @063386> : 0b                         not.b32
	<.main+7203 @063387> : 1f 38 10 06 00             load.ref <@061038> ;i16Not
	<.main+7208 @06338c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:115: (19 bytes: <.main+7209 @06338d> - <.main+7228 @0633a0>): static i16Ceq: bool := i16A == i16B
	<.main+7209 @06338d> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7214 @063392> : 27                         load.i16
	<.main+7215 @063393> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7220 @063398> : 27                         load.i16
	<.main+7221 @063399> : 57                         ceq.i32
	<.main+7222 @06339a> : 1f 40 10 06 00             load.ref <@061040> ;i16Ceq
	<.main+7227 @06339f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:116: (20 bytes: <.main+7228 @0633a0> - <.main+7248 @0633b4>): static i16Cne: bool := i16A != i16B
	<.main+7228 @0633a0> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7233 @0633a5> : 27                         load.i16
	<.main+7234 @0633a6> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7239 @0633ab> : 27                         load.i16
	<.main+7240 @0633ac> : 57                         ceq.i32
	<.main+7241 @0633ad> : 0b                         not.b32
	<.main+7242 @0633ae> : 1f 48 10 06 00             load.ref <@061048> ;i16Cne
	<.main+7247 @0633b3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:117: (19 bytes: <.main+7248 @0633b4> - <.main+7267 @0633c7>): static i16Clt: bool := i16A < i16B
	<.main+7248 @0633b4> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7253 @0633b9> : 27                         load.i16
	<.main+7254 @0633ba> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7259 @0633bf> : 27                         load.i16
	<.main+7260 @0633c0> : 58                         clt.i32
	<.main+7261 @0633c1> : 1f 50 10 06 00             load.ref <@061050> ;i16Clt
	<.main+7266 @0633c6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:118: (20 bytes: <.main+7267 @0633c7> - <.main+7287 @0633db>): static i16Cle: bool := i16A <= i16B
	<.main+7267 @0633c7> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7272 @0633cc> : 27                         load.i16
	<.main+7273 @0633cd> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7278 @0633d2> : 27                         load.i16
	<.main+7279 @0633d3> : 59                         cgt.i32
	<.main+7280 @0633d4> : 0b                         not.b32
	<.main+7281 @0633d5> : 1f 58 10 06 00             load.ref <@061058> ;i16Cle
	<.main+7286 @0633da> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:119: (19 bytes: <.main+7287 @0633db> - <.main+7306 @0633ee>): static i16Cgt: bool := i16A > i16B
	<.main+7287 @0633db> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7292 @0633e0> : 27                         load.i16
	<.main+7293 @0633e1> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7298 @0633e6> : 27                         load.i16
	<.main+7299 @0633e7> : 59                         cgt.i32
	<.main+7300 @0633e8> : 1f 60 10 06 00             load.ref <@061060> ;i16Cgt
	<.main+7305 @0633ed> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:120: (20 bytes: <.main+7306 @0633ee> - <.main+7326 @063402>): static i16Cge: bool := i16A >= i16B
	<.main+7306 @0633ee> : 1f c0 0f 06 00             load.ref <@060fc0> ;i16A
	<.main+7311 @0633f3> : 27                         load.i16
	<.main+7312 @0633f4> : 1f c8 0f 06 00             load.ref <@060fc8> ;i16B
	<.main+7317 @0633f9> : 27                         load.i16
	<.main+7318 @0633fa> : 58                         clt.i32
	<.main+7319 @0633fb> : 0b                         not.b32
	<.main+7320 @0633fc> : 1f 68 10 06 00             load.ref <@061068> ;i16Cge
	<.main+7325 @063401> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:122: (11 bytes: <.main+7326 @063402> - <.main+7337 @06340d>): static u16A: uint16 := a
	<.main+7326 @063402> : 1c 60 00 00 00             load.c32 96
	<.main+7331 @063407> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7336 @06340c> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:123: (11 bytes: <.main+7337 @06340d> - <.main+7348 @063418>): static u16B: uint16 := b
	<.main+7337 @06340d> : 1c 2a 00 00 00             load.c32 42
	<.main+7342 @063412> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7347 @063417> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:124: (12 bytes: <.main+7348 @063418> - <.main+7360 @063424>): static u16Pls: uint16 := +u16B
	<.main+7348 @063418> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7353 @06341d> : 27                         load.i16
	<.main+7354 @06341e> : 1f 80 10 06 00             load.ref <@061080> ;u16Pls
	<.main+7359 @063423> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:125: (13 bytes: <.main+7360 @063424> - <.main+7373 @063431>): static u16Neg: uint16 := -u16B
	<.main+7360 @063424> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7365 @063429> : 27                         load.i16
	<.main+7366 @06342a> : 50                         neg.i32
	<.main+7367 @06342b> : 1f 88 10 06 00             load.ref <@061088> ;u16Neg
	<.main+7372 @063430> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:126: (13 bytes: <.main+7373 @063431> - <.main+7386 @06343e>): static u16Cmt: uint16 := ~u16B
	<.main+7373 @063431> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7378 @063436> : 27                         load.i16
	<.main+7379 @063437> : 30                         cmt.b32
	<.main+7380 @063438> : 1f 90 10 06 00             load.ref <@061090> ;u16Cmt
	<.main+7385 @06343d> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:127: (19 bytes: <.main+7386 @06343e> - <.main+7405 @063451>): static u16Add: uint16 := u16A + u16B
	<.main+7386 @06343e> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7391 @063443> : 27                         load.i16
	<.main+7392 @063444> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7397 @063449> : 27                         load.i16
	<.main+7398 @06344a> : 51                         add.i32
	<.main+7399 @06344b> : 1f 98 10 06 00             load.ref <@061098> ;u16Add
	<.main+7404 @063450> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:128: (19 bytes: <.main+7405 @063451> - <.main+7424 @063464>): static u16Sub: uint16 := u16A - u16B
	<.main+7405 @063451> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7410 @063456> : 27                         load.i16
	<.main+7411 @063457> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7416 @06345c> : 27                         load.i16
	<.main+7417 @06345d> : 52                         sub.i32
	<.main+7418 @06345e> : 1f a0 10 06 00             load.ref <@0610a0> ;u16Sub
	<.main+7423 @063463> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:129: (19 bytes: <.main+7424 @063464> - <.main+7443 @063477>): static u16Mul: uint16 := u16A * u16B
	<.main+7424 @063464> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7429 @063469> : 27                         load.i16
	<.main+7430 @06346a> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7435 @06346f> : 27                         load.i16
	<.main+7436 @063470> : 33                         mul.u32
	<.main+7437 @063471> : 1f a8 10 06 00             load.ref <@0610a8> ;u16Mul
	<.main+7442 @063476> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:130: (19 bytes: <.main+7443 @063477> - <.main+7462 @06348a>): static u16Div: uint16 := u16A / u16B
	<.main+7443 @063477> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7448 @06347c> : 27                         load.i16
	<.main+7449 @06347d> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7454 @063482> : 27                         load.i16
	<.main+7455 @063483> : 34                         div.u32
	<.main+7456 @063484> : 1f b0 10 06 00             load.ref <@0610b0> ;u16Div
	<.main+7461 @063489> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:131: (19 bytes: <.main+7462 @06348a> - <.main+7481 @06349d>): static u16Mod: uint16 := u16A % u16B
	<.main+7462 @06348a> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7467 @06348f> : 27                         load.i16
	<.main+7468 @063490> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7473 @063495> : 27                         load.i16
	<.main+7474 @063496> : 35                         mod.u32
	<.main+7475 @063497> : 1f b8 10 06 00             load.ref <@0610b8> ;u16Mod
	<.main+7480 @06349c> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:132: (19 bytes: <.main+7481 @06349d> - <.main+7500 @0634b0>): static u16And: uint16 := u16A & u16B
	<.main+7481 @06349d> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7486 @0634a2> : 27                         load.i16
	<.main+7487 @0634a3> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7492 @0634a8> : 27                         load.i16
	<.main+7493 @0634a9> : 31                         and.b32
	<.main+7494 @0634aa> : 1f c0 10 06 00             load.ref <@0610c0> ;u16And
	<.main+7499 @0634af> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:133: (19 bytes: <.main+7500 @0634b0> - <.main+7519 @0634c3>): static u16Ior: uint16 := u16A | u16B
	<.main+7500 @0634b0> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7505 @0634b5> : 27                         load.i16
	<.main+7506 @0634b6> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7511 @0634bb> : 27                         load.i16
	<.main+7512 @0634bc> : 32                         or.b32
	<.main+7513 @0634bd> : 1f c8 10 06 00             load.ref <@0610c8> ;u16Ior
	<.main+7518 @0634c2> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:134: (19 bytes: <.main+7519 @0634c3> - <.main+7538 @0634d6>): static u16Xor: uint16 := u16A ^ u16B
	<.main+7519 @0634c3> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7524 @0634c8> : 27                         load.i16
	<.main+7525 @0634c9> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7530 @0634ce> : 27                         load.i16
	<.main+7531 @0634cf> : 36                         xor.b32
	<.main+7532 @0634d0> : 1f d0 10 06 00             load.ref <@0610d0> ;u16Xor
	<.main+7537 @0634d5> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:135: (17 bytes: <.main+7538 @0634d6> - <.main+7555 @0634e7>): static u16Shl: uint16 := (u16A) << shift
	<.main+7538 @0634d6> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7543 @0634db> : 27                         load.i16
	<.main+7544 @0634dc> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7548 @0634e0> : 3a                         shl.b32
	<.main+7549 @0634e1> : 1f d8 10 06 00             load.ref <@0610d8> ;u16Shl
	<.main+7554 @0634e6> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:136: (17 bytes: <.main+7555 @0634e7> - <.main+7572 @0634f8>): static u16Shr: uint16 := (u16A) >> shift
	<.main+7555 @0634e7> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7560 @0634ec> : 27                         load.i16
	<.main+7561 @0634ed> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7565 @0634f1> : 3c                         sar.b32
	<.main+7566 @0634f2> : 1f e0 10 06 00             load.ref <@0610e0> ;u16Shr
	<.main+7571 @0634f7> : 2c                         store.i16
	cmplStd/test/lang/useOperator.ci:137: (14 bytes: <.main+7572 @0634f8> - <.main+7586 @063506>): static u16Not: bool := !(u16B)
	<.main+7572 @0634f8> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7577 @0634fd> : 27                         load.i16
	<.main+7578 @0634fe> : 5a                         i32.2bool
	<.main+7579 @0634ff> : 0b                         not.b32
	<.main+7580 @063500> : 1f e8 10 06 00             load.ref <@0610e8> ;u16Not
	<.main+7585 @063505> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:138: (19 bytes: <.main+7586 @063506> - <.main+7605 @063519>): static u16Ceq: bool := u16A == u16B
	<.main+7586 @063506> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7591 @06350b> : 27                         load.i16
	<.main+7592 @06350c> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7597 @063511> : 27                         load.i16
	<.main+7598 @063512> : 57                         ceq.i32
	<.main+7599 @063513> : 1f f0 10 06 00             load.ref <@0610f0> ;u16Ceq
	<.main+7604 @063518> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:139: (20 bytes: <.main+7605 @063519> - <.main+7625 @06352d>): static u16Cne: bool := u16A != u16B
	<.main+7605 @063519> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7610 @06351e> : 27                         load.i16
	<.main+7611 @06351f> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7616 @063524> : 27                         load.i16
	<.main+7617 @063525> : 57                         ceq.i32
	<.main+7618 @063526> : 0b                         not.b32
	<.main+7619 @063527> : 1f f8 10 06 00             load.ref <@0610f8> ;u16Cne
	<.main+7624 @06352c> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:140: (19 bytes: <.main+7625 @06352d> - <.main+7644 @063540>): static u16Clt: bool := u16A < u16B
	<.main+7625 @06352d> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7630 @063532> : 27                         load.i16
	<.main+7631 @063533> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7636 @063538> : 27                         load.i16
	<.main+7637 @063539> : 38                         clt.u32
	<.main+7638 @06353a> : 1f 00 11 06 00             load.ref <@061100> ;u16Clt
	<.main+7643 @06353f> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:141: (20 bytes: <.main+7644 @063540> - <.main+7664 @063554>): static u16Cle: bool := u16A <= u16B
	<.main+7644 @063540> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7649 @063545> : 27                         load.i16
	<.main+7650 @063546> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7655 @06354b> : 27                         load.i16
	<.main+7656 @06354c> : 39                         cgt.u32
	<.main+7657 @06354d> : 0b                         not.b32
	<.main+7658 @06354e> : 1f 08 11 06 00             load.ref <@061108> ;u16Cle
	<.main+7663 @063553> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:142: (19 bytes: <.main+7664 @063554> - <.main+7683 @063567>): static u16Cgt: bool := u16A > u16B
	<.main+7664 @063554> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7669 @063559> : 27                         load.i16
	<.main+7670 @06355a> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7675 @06355f> : 27                         load.i16
	<.main+7676 @063560> : 39                         cgt.u32
	<.main+7677 @063561> : 1f 10 11 06 00             load.ref <@061110> ;u16Cgt
	<.main+7682 @063566> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:143: (20 bytes: <.main+7683 @063567> - <.main+7703 @06357b>): static u16Cge: bool := u16A >= u16B
	<.main+7683 @063567> : 1f 70 10 06 00             load.ref <@061070> ;u16A
	<.main+7688 @06356c> : 27                         load.i16
	<.main+7689 @06356d> : 1f 78 10 06 00             load.ref <@061078> ;u16B
	<.main+7694 @063572> : 27                         load.i16
	<.main+7695 @063573> : 38                         clt.u32
	<.main+7696 @063574> : 0b                         not.b32
	<.main+7697 @063575> : 1f 18 11 06 00             load.ref <@061118> ;u16Cge
	<.main+7702 @06357a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:145: (9 bytes: <.main+7703 @06357b> - <.main+7712 @063584>): static i32A: int32 := a
	<.main+7703 @06357b> : 1c 60 00 00 00             load.c32 96
	<.main+7708 @063580> : 24 20 11 06                store.m32 <@061120> ;i32A
	cmplStd/test/lang/useOperator.ci:146: (9 bytes: <.main+7712 @063584> - <.main+7721 @06358d>): static i32B: int32 := b
	<.main+7712 @063584> : 1c 2a 00 00 00             load.c32 42
	<.main+7717 @063589> : 24 28 11 06                store.m32 <@061128> ;i32B
	cmplStd/test/lang/useOperator.ci:147: (8 bytes: <.main+7721 @06358d> - <.main+7729 @063595>): static i32Pls: int32 := +i32B
	<.main+7721 @06358d> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7725 @063591> : 24 30 11 06                store.m32 <@061130> ;i32Pls
	cmplStd/test/lang/useOperator.ci:148: (9 bytes: <.main+7729 @063595> - <.main+7738 @06359e>): static i32Neg: int32 := -i32B
	<.main+7729 @063595> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7733 @063599> : 50                         neg.i32
	<.main+7734 @06359a> : 24 38 11 06                store.m32 <@061138> ;i32Neg
	cmplStd/test/lang/useOperator.ci:149: (9 bytes: <.main+7738 @06359e> - <.main+7747 @0635a7>): static i32Cmt: int32 := ~i32B
	<.main+7738 @06359e> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7742 @0635a2> : 30                         cmt.b32
	<.main+7743 @0635a3> : 24 40 11 06                store.m32 <@061140> ;i32Cmt
	cmplStd/test/lang/useOperator.ci:150: (13 bytes: <.main+7747 @0635a7> - <.main+7760 @0635b4>): static i32Add: int32 := i32A + i32B
	<.main+7747 @0635a7> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7751 @0635ab> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7755 @0635af> : 51                         add.i32
	<.main+7756 @0635b0> : 24 48 11 06                store.m32 <@061148> ;i32Add
	cmplStd/test/lang/useOperator.ci:151: (13 bytes: <.main+7760 @0635b4> - <.main+7773 @0635c1>): static i32Sub: int32 := i32A - i32B
	<.main+7760 @0635b4> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7764 @0635b8> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7768 @0635bc> : 52                         sub.i32
	<.main+7769 @0635bd> : 24 50 11 06                store.m32 <@061150> ;i32Sub
	cmplStd/test/lang/useOperator.ci:152: (13 bytes: <.main+7773 @0635c1> - <.main+7786 @0635ce>): static i32Mul: int32 := i32A * i32B
	<.main+7773 @0635c1> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7777 @0635c5> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7781 @0635c9> : 53                         mul.i32
	<.main+7782 @0635ca> : 24 58 11 06                store.m32 <@061158> ;i32Mul
	cmplStd/test/lang/useOperator.ci:153: (13 bytes: <.main+7786 @0635ce> - <.main+7799 @0635db>): static i32Div: int32 := i32A / i32B
	<.main+7786 @0635ce> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7790 @0635d2> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7794 @0635d6> : 54                         div.i32
	<.main+7795 @0635d7> : 24 60 11 06                store.m32 <@061160> ;i32Div
	cmplStd/test/lang/useOperator.ci:154: (13 bytes: <.main+7799 @0635db> - <.main+7812 @0635e8>): static i32Mod: int32 := i32A % i32B
	<.main+7799 @0635db> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7803 @0635df> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7807 @0635e3> : 55                         mod.i32
	<.main+7808 @0635e4> : 24 68 11 06                store.m32 <@061168> ;i32Mod
	cmplStd/test/lang/useOperator.ci:155: (13 bytes: <.main+7812 @0635e8> - <.main+7825 @0635f5>): static i32And: int32 := i32A & i32B
	<.main+7812 @0635e8> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7816 @0635ec> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7820 @0635f0> : 31                         and.b32
	<.main+7821 @0635f1> : 24 70 11 06                store.m32 <@061170> ;i32And
	cmplStd/test/lang/useOperator.ci:156: (13 bytes: <.main+7825 @0635f5> - <.main+7838 @063602>): static i32Ior: int32 := i32A | i32B
	<.main+7825 @0635f5> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7829 @0635f9> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7833 @0635fd> : 32                         or.b32
	<.main+7834 @0635fe> : 24 78 11 06                store.m32 <@061178> ;i32Ior
	cmplStd/test/lang/useOperator.ci:157: (13 bytes: <.main+7838 @063602> - <.main+7851 @06360f>): static i32Xor: int32 := i32A ^ i32B
	<.main+7838 @063602> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7842 @063606> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7846 @06360a> : 36                         xor.b32
	<.main+7847 @06360b> : 24 80 11 06                store.m32 <@061180> ;i32Xor
	cmplStd/test/lang/useOperator.ci:158: (13 bytes: <.main+7851 @06360f> - <.main+7864 @06361c>): static i32Shl: int32 := i32A << shift
	<.main+7851 @06360f> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7855 @063613> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7859 @063617> : 3a                         shl.b32
	<.main+7860 @063618> : 24 88 11 06                store.m32 <@061188> ;i32Shl
	cmplStd/test/lang/useOperator.ci:159: (13 bytes: <.main+7864 @06361c> - <.main+7877 @063629>): static i32Shr: int32 := i32A >> shift
	<.main+7864 @06361c> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7868 @063620> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+7872 @063624> : 3c                         sar.b32
	<.main+7873 @063625> : 24 90 11 06                store.m32 <@061190> ;i32Shr
	cmplStd/test/lang/useOperator.ci:160: (12 bytes: <.main+7877 @063629> - <.main+7889 @063635>): static i32Not: bool := !(i32B)
	<.main+7877 @063629> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7881 @06362d> : 5a                         i32.2bool
	<.main+7882 @06362e> : 0b                         not.b32
	<.main+7883 @06362f> : 1f 98 11 06 00             load.ref <@061198> ;i32Not
	<.main+7888 @063634> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:161: (15 bytes: <.main+7889 @063635> - <.main+7904 @063644>): static i32Ceq: bool := i32A == i32B
	<.main+7889 @063635> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7893 @063639> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7897 @06363d> : 57                         ceq.i32
	<.main+7898 @06363e> : 1f a0 11 06 00             load.ref <@0611a0> ;i32Ceq
	<.main+7903 @063643> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:162: (16 bytes: <.main+7904 @063644> - <.main+7920 @063654>): static i32Cne: bool := i32A != i32B
	<.main+7904 @063644> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7908 @063648> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7912 @06364c> : 57                         ceq.i32
	<.main+7913 @06364d> : 0b                         not.b32
	<.main+7914 @06364e> : 1f a8 11 06 00             load.ref <@0611a8> ;i32Cne
	<.main+7919 @063653> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:163: (15 bytes: <.main+7920 @063654> - <.main+7935 @063663>): static i32Clt: bool := i32A < i32B
	<.main+7920 @063654> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7924 @063658> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7928 @06365c> : 58                         clt.i32
	<.main+7929 @06365d> : 1f b0 11 06 00             load.ref <@0611b0> ;i32Clt
	<.main+7934 @063662> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:164: (16 bytes: <.main+7935 @063663> - <.main+7951 @063673>): static i32Cle: bool := i32A <= i32B
	<.main+7935 @063663> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7939 @063667> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7943 @06366b> : 59                         cgt.i32
	<.main+7944 @06366c> : 0b                         not.b32
	<.main+7945 @06366d> : 1f b8 11 06 00             load.ref <@0611b8> ;i32Cle
	<.main+7950 @063672> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:165: (15 bytes: <.main+7951 @063673> - <.main+7966 @063682>): static i32Cgt: bool := i32A > i32B
	<.main+7951 @063673> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7955 @063677> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7959 @06367b> : 59                         cgt.i32
	<.main+7960 @06367c> : 1f c0 11 06 00             load.ref <@0611c0> ;i32Cgt
	<.main+7965 @063681> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:166: (16 bytes: <.main+7966 @063682> - <.main+7982 @063692>): static i32Cge: bool := i32A >= i32B
	<.main+7966 @063682> : 20 20 11 06                load.m32 <@061120> ;i32A
	<.main+7970 @063686> : 20 28 11 06                load.m32 <@061128> ;i32B
	<.main+7974 @06368a> : 58                         clt.i32
	<.main+7975 @06368b> : 0b                         not.b32
	<.main+7976 @06368c> : 1f c8 11 06 00             load.ref <@0611c8> ;i32Cge
	<.main+7981 @063691> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:168: (9 bytes: <.main+7982 @063692> - <.main+7991 @06369b>): static u32A: uint32 := a
	<.main+7982 @063692> : 1c 60 00 00 00             load.c32 96
	<.main+7987 @063697> : 24 d0 11 06                store.m32 <@0611d0> ;u32A
	cmplStd/test/lang/useOperator.ci:169: (9 bytes: <.main+7991 @06369b> - <.main+8000 @0636a4>): static u32B: uint32 := b
	<.main+7991 @06369b> : 1c 2a 00 00 00             load.c32 42
	<.main+7996 @0636a0> : 24 d8 11 06                store.m32 <@0611d8> ;u32B
	cmplStd/test/lang/useOperator.ci:170: (8 bytes: <.main+8000 @0636a4> - <.main+8008 @0636ac>): static u32Pls: uint32 := +u32B
	<.main+8000 @0636a4> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8004 @0636a8> : 24 e0 11 06                store.m32 <@0611e0> ;u32Pls
	cmplStd/test/lang/useOperator.ci:171: (9 bytes: <.main+8008 @0636ac> - <.main+8017 @0636b5>): static u32Neg: uint32 := -u32B
	<.main+8008 @0636ac> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8012 @0636b0> : 50                         neg.i32
	<.main+8013 @0636b1> : 24 e8 11 06                store.m32 <@0611e8> ;u32Neg
	cmplStd/test/lang/useOperator.ci:172: (9 bytes: <.main+8017 @0636b5> - <.main+8026 @0636be>): static u32Cmt: uint32 := ~u32B
	<.main+8017 @0636b5> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8021 @0636b9> : 30                         cmt.b32
	<.main+8022 @0636ba> : 24 f0 11 06                store.m32 <@0611f0> ;u32Cmt
	cmplStd/test/lang/useOperator.ci:173: (13 bytes: <.main+8026 @0636be> - <.main+8039 @0636cb>): static u32Add: uint32 := u32A + u32B
	<.main+8026 @0636be> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8030 @0636c2> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8034 @0636c6> : 51                         add.i32
	<.main+8035 @0636c7> : 24 f8 11 06                store.m32 <@0611f8> ;u32Add
	cmplStd/test/lang/useOperator.ci:174: (13 bytes: <.main+8039 @0636cb> - <.main+8052 @0636d8>): static u32Sub: uint32 := u32A - u32B
	<.main+8039 @0636cb> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8043 @0636cf> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8047 @0636d3> : 52                         sub.i32
	<.main+8048 @0636d4> : 24 00 12 06                store.m32 <@061200> ;u32Sub
	cmplStd/test/lang/useOperator.ci:175: (13 bytes: <.main+8052 @0636d8> - <.main+8065 @0636e5>): static u32Mul: uint32 := u32A * u32B
	<.main+8052 @0636d8> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8056 @0636dc> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8060 @0636e0> : 33                         mul.u32
	<.main+8061 @0636e1> : 24 08 12 06                store.m32 <@061208> ;u32Mul
	cmplStd/test/lang/useOperator.ci:176: (13 bytes: <.main+8065 @0636e5> - <.main+8078 @0636f2>): static u32Div: uint32 := u32A / u32B
	<.main+8065 @0636e5> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8069 @0636e9> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8073 @0636ed> : 34                         div.u32
	<.main+8074 @0636ee> : 24 10 12 06                store.m32 <@061210> ;u32Div
	cmplStd/test/lang/useOperator.ci:177: (13 bytes: <.main+8078 @0636f2> - <.main+8091 @0636ff>): static u32Mod: uint32 := u32A % u32B
	<.main+8078 @0636f2> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8082 @0636f6> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8086 @0636fa> : 35                         mod.u32
	<.main+8087 @0636fb> : 24 18 12 06                store.m32 <@061218> ;u32Mod
	cmplStd/test/lang/useOperator.ci:178: (13 bytes: <.main+8091 @0636ff> - <.main+8104 @06370c>): static u32And: uint32 := u32A & u32B
	<.main+8091 @0636ff> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8095 @063703> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8099 @063707> : 31                         and.b32
	<.main+8100 @063708> : 24 20 12 06                store.m32 <@061220> ;u32And
	cmplStd/test/lang/useOperator.ci:179: (13 bytes: <.main+8104 @06370c> - <.main+8117 @063719>): static u32Ior: uint32 := u32A | u32B
	<.main+8104 @06370c> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8108 @063710> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8112 @063714> : 32                         or.b32
	<.main+8113 @063715> : 24 28 12 06                store.m32 <@061228> ;u32Ior
	cmplStd/test/lang/useOperator.ci:180: (13 bytes: <.main+8117 @063719> - <.main+8130 @063726>): static u32Xor: uint32 := u32A ^ u32B
	<.main+8117 @063719> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8121 @06371d> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8125 @063721> : 36                         xor.b32
	<.main+8126 @063722> : 24 30 12 06                store.m32 <@061230> ;u32Xor
	cmplStd/test/lang/useOperator.ci:181: (13 bytes: <.main+8130 @063726> - <.main+8143 @063733>): static u32Shl: uint32 := u32A << shift
	<.main+8130 @063726> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8134 @06372a> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8138 @06372e> : 3a                         shl.b32
	<.main+8139 @06372f> : 24 38 12 06                store.m32 <@061238> ;u32Shl
	cmplStd/test/lang/useOperator.ci:182: (13 bytes: <.main+8143 @063733> - <.main+8156 @063740>): static u32Shr: uint32 := u32A >> shift
	<.main+8143 @063733> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8147 @063737> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8151 @06373b> : 3b                         shr.b32
	<.main+8152 @06373c> : 24 40 12 06                store.m32 <@061240> ;u32Shr
	cmplStd/test/lang/useOperator.ci:183: (12 bytes: <.main+8156 @063740> - <.main+8168 @06374c>): static u32Not: bool := !(u32B)
	<.main+8156 @063740> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8160 @063744> : 5a                         i32.2bool
	<.main+8161 @063745> : 0b                         not.b32
	<.main+8162 @063746> : 1f 48 12 06 00             load.ref <@061248> ;u32Not
	<.main+8167 @06374b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:184: (15 bytes: <.main+8168 @06374c> - <.main+8183 @06375b>): static u32Ceq: bool := u32A == u32B
	<.main+8168 @06374c> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8172 @063750> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8176 @063754> : 57                         ceq.i32
	<.main+8177 @063755> : 1f 50 12 06 00             load.ref <@061250> ;u32Ceq
	<.main+8182 @06375a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:185: (16 bytes: <.main+8183 @06375b> - <.main+8199 @06376b>): static u32Cne: bool := u32A != u32B
	<.main+8183 @06375b> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8187 @06375f> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8191 @063763> : 57                         ceq.i32
	<.main+8192 @063764> : 0b                         not.b32
	<.main+8193 @063765> : 1f 58 12 06 00             load.ref <@061258> ;u32Cne
	<.main+8198 @06376a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:186: (15 bytes: <.main+8199 @06376b> - <.main+8214 @06377a>): static u32Clt: bool := u32A < u32B
	<.main+8199 @06376b> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8203 @06376f> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8207 @063773> : 38                         clt.u32
	<.main+8208 @063774> : 1f 60 12 06 00             load.ref <@061260> ;u32Clt
	<.main+8213 @063779> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:187: (16 bytes: <.main+8214 @06377a> - <.main+8230 @06378a>): static u32Cle: bool := u32A <= u32B
	<.main+8214 @06377a> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8218 @06377e> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8222 @063782> : 39                         cgt.u32
	<.main+8223 @063783> : 0b                         not.b32
	<.main+8224 @063784> : 1f 68 12 06 00             load.ref <@061268> ;u32Cle
	<.main+8229 @063789> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:188: (15 bytes: <.main+8230 @06378a> - <.main+8245 @063799>): static u32Cgt: bool := u32A > u32B
	<.main+8230 @06378a> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8234 @06378e> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8238 @063792> : 39                         cgt.u32
	<.main+8239 @063793> : 1f 70 12 06 00             load.ref <@061270> ;u32Cgt
	<.main+8244 @063798> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:189: (16 bytes: <.main+8245 @063799> - <.main+8261 @0637a9>): static u32Cge: bool := u32A >= u32B
	<.main+8245 @063799> : 20 d0 11 06                load.m32 <@0611d0> ;u32A
	<.main+8249 @06379d> : 20 d8 11 06                load.m32 <@0611d8> ;u32B
	<.main+8253 @0637a1> : 38                         clt.u32
	<.main+8254 @0637a2> : 0b                         not.b32
	<.main+8255 @0637a3> : 1f 78 12 06 00             load.ref <@061278> ;u32Cge
	<.main+8260 @0637a8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:191: (13 bytes: <.main+8261 @0637a9> - <.main+8274 @0637b6>): static i64A: int64 := a
	<.main+8261 @0637a9> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8270 @0637b2> : 23 80 12 06                store.m64 <@061280> ;i64A
	cmplStd/test/lang/useOperator.ci:192: (13 bytes: <.main+8274 @0637b6> - <.main+8287 @0637c3>): static i64B: int64 := b
	<.main+8274 @0637b6> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8283 @0637bf> : 23 88 12 06                store.m64 <@061288> ;i64B
	cmplStd/test/lang/useOperator.ci:193: (8 bytes: <.main+8287 @0637c3> - <.main+8295 @0637cb>): static i64Pls: int64 := +i64B
	<.main+8287 @0637c3> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8291 @0637c7> : 23 90 12 06                store.m64 <@061290> ;i64Pls
	cmplStd/test/lang/useOperator.ci:194: (9 bytes: <.main+8295 @0637cb> - <.main+8304 @0637d4>): static i64Neg: int64 := -i64B
	<.main+8295 @0637cb> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8299 @0637cf> : 60                         neg.i64
	<.main+8300 @0637d0> : 23 98 12 06                store.m64 <@061298> ;i64Neg
	cmplStd/test/lang/useOperator.ci:195: (9 bytes: <.main+8304 @0637d4> - <.main+8313 @0637dd>): static i64Cmt: int64 := ~i64B
	<.main+8304 @0637d4> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8308 @0637d8> : 40                         cmt.b64
	<.main+8309 @0637d9> : 23 a0 12 06                store.m64 <@0612a0> ;i64Cmt
	cmplStd/test/lang/useOperator.ci:196: (13 bytes: <.main+8313 @0637dd> - <.main+8326 @0637ea>): static i64Add: int64 := i64A + i64B
	<.main+8313 @0637dd> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8317 @0637e1> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8321 @0637e5> : 61                         add.i64
	<.main+8322 @0637e6> : 23 a8 12 06                store.m64 <@0612a8> ;i64Add
	cmplStd/test/lang/useOperator.ci:197: (13 bytes: <.main+8326 @0637ea> - <.main+8339 @0637f7>): static i64Sub: int64 := i64A - i64B
	<.main+8326 @0637ea> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8330 @0637ee> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8334 @0637f2> : 62                         sub.i64
	<.main+8335 @0637f3> : 23 b0 12 06                store.m64 <@0612b0> ;i64Sub
	cmplStd/test/lang/useOperator.ci:198: (13 bytes: <.main+8339 @0637f7> - <.main+8352 @063804>): static i64Mul: int64 := i64A * i64B
	<.main+8339 @0637f7> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8343 @0637fb> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8347 @0637ff> : 63                         mul.i64
	<.main+8348 @063800> : 23 b8 12 06                store.m64 <@0612b8> ;i64Mul
	cmplStd/test/lang/useOperator.ci:199: (13 bytes: <.main+8352 @063804> - <.main+8365 @063811>): static i64Div: int64 := i64A / i64B
	<.main+8352 @063804> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8356 @063808> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8360 @06380c> : 64                         div.i64
	<.main+8361 @06380d> : 23 c0 12 06                store.m64 <@0612c0> ;i64Div
	cmplStd/test/lang/useOperator.ci:200: (13 bytes: <.main+8365 @063811> - <.main+8378 @06381e>): static i64Mod: int64 := i64A % i64B
	<.main+8365 @063811> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8369 @063815> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8373 @063819> : 65                         mod.i64
	<.main+8374 @06381a> : 23 c8 12 06                store.m64 <@0612c8> ;i64Mod
	cmplStd/test/lang/useOperator.ci:201: (13 bytes: <.main+8378 @06381e> - <.main+8391 @06382b>): static i64And: int64 := i64A & i64B
	<.main+8378 @06381e> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8382 @063822> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8386 @063826> : 41                         and.b64
	<.main+8387 @063827> : 23 d0 12 06                store.m64 <@0612d0> ;i64And
	cmplStd/test/lang/useOperator.ci:202: (13 bytes: <.main+8391 @06382b> - <.main+8404 @063838>): static i64Ior: int64 := i64A | i64B
	<.main+8391 @06382b> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8395 @06382f> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8399 @063833> : 42                         or.b64
	<.main+8400 @063834> : 23 d8 12 06                store.m64 <@0612d8> ;i64Ior
	cmplStd/test/lang/useOperator.ci:203: (13 bytes: <.main+8404 @063838> - <.main+8417 @063845>): static i64Xor: int64 := i64A ^ i64B
	<.main+8404 @063838> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8408 @06383c> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8412 @063840> : 46                         xor.b64
	<.main+8413 @063841> : 23 e0 12 06                store.m64 <@0612e0> ;i64Xor
	cmplStd/test/lang/useOperator.ci:204: (13 bytes: <.main+8417 @063845> - <.main+8430 @063852>): static i64Shl: int64 := i64A << shift
	<.main+8417 @063845> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8421 @063849> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8425 @06384d> : 4a                         shl.b64
	<.main+8426 @06384e> : 23 e8 12 06                store.m64 <@0612e8> ;i64Shl
	cmplStd/test/lang/useOperator.ci:205: (13 bytes: <.main+8430 @063852> - <.main+8443 @06385f>): static i64Shr: int64 := i64A >> shift
	<.main+8430 @063852> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8434 @063856> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8438 @06385a> : 4c                         sar.b64
	<.main+8439 @06385b> : 23 f0 12 06                store.m64 <@0612f0> ;i64Shr
	cmplStd/test/lang/useOperator.ci:206: (12 bytes: <.main+8443 @06385f> - <.main+8455 @06386b>): static i64Not: bool := !(i64B)
	<.main+8443 @06385f> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8447 @063863> : 6b                         i64.2bool
	<.main+8448 @063864> : 0b                         not.b32
	<.main+8449 @063865> : 1f f8 12 06 00             load.ref <@0612f8> ;i64Not
	<.main+8454 @06386a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:207: (15 bytes: <.main+8455 @06386b> - <.main+8470 @06387a>): static i64Ceq: bool := i64A == i64B
	<.main+8455 @06386b> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8459 @06386f> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8463 @063873> : 67                         ceq.i64
	<.main+8464 @063874> : 1f 00 13 06 00             load.ref <@061300> ;i64Ceq
	<.main+8469 @063879> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:208: (16 bytes: <.main+8470 @06387a> - <.main+8486 @06388a>): static i64Cne: bool := i64A != i64B
	<.main+8470 @06387a> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8474 @06387e> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8478 @063882> : 67                         ceq.i64
	<.main+8479 @063883> : 0b                         not.b32
	<.main+8480 @063884> : 1f 08 13 06 00             load.ref <@061308> ;i64Cne
	<.main+8485 @063889> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:209: (15 bytes: <.main+8486 @06388a> - <.main+8501 @063899>): static i64Clt: bool := i64A < i64B
	<.main+8486 @06388a> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8490 @06388e> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8494 @063892> : 68                         clt.i64
	<.main+8495 @063893> : 1f 10 13 06 00             load.ref <@061310> ;i64Clt
	<.main+8500 @063898> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:210: (16 bytes: <.main+8501 @063899> - <.main+8517 @0638a9>): static i64Cle: bool := i64A <= i64B
	<.main+8501 @063899> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8505 @06389d> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8509 @0638a1> : 69                         cgt.i64
	<.main+8510 @0638a2> : 0b                         not.b32
	<.main+8511 @0638a3> : 1f 18 13 06 00             load.ref <@061318> ;i64Cle
	<.main+8516 @0638a8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:211: (15 bytes: <.main+8517 @0638a9> - <.main+8532 @0638b8>): static i64Cgt: bool := i64A > i64B
	<.main+8517 @0638a9> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8521 @0638ad> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8525 @0638b1> : 69                         cgt.i64
	<.main+8526 @0638b2> : 1f 20 13 06 00             load.ref <@061320> ;i64Cgt
	<.main+8531 @0638b7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:212: (16 bytes: <.main+8532 @0638b8> - <.main+8548 @0638c8>): static i64Cge: bool := i64A >= i64B
	<.main+8532 @0638b8> : 21 80 12 06                load.m64 <@061280> ;i64A
	<.main+8536 @0638bc> : 21 88 12 06                load.m64 <@061288> ;i64B
	<.main+8540 @0638c0> : 68                         clt.i64
	<.main+8541 @0638c1> : 0b                         not.b32
	<.main+8542 @0638c2> : 1f 28 13 06 00             load.ref <@061328> ;i64Cge
	<.main+8547 @0638c7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:214: (13 bytes: <.main+8548 @0638c8> - <.main+8561 @0638d5>): static u64A: uint64 := a
	<.main+8548 @0638c8> : 1d 60 00 00 00 00 00 00 00 load.c64 96
	<.main+8557 @0638d1> : 23 30 13 06                store.m64 <@061330> ;u64A
	cmplStd/test/lang/useOperator.ci:215: (13 bytes: <.main+8561 @0638d5> - <.main+8574 @0638e2>): static u64B: uint64 := b
	<.main+8561 @0638d5> : 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+8570 @0638de> : 23 38 13 06                store.m64 <@061338> ;u64B
	cmplStd/test/lang/useOperator.ci:216: (8 bytes: <.main+8574 @0638e2> - <.main+8582 @0638ea>): static u64Pls: uint64 := +u64B
	<.main+8574 @0638e2> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8578 @0638e6> : 23 40 13 06                store.m64 <@061340> ;u64Pls
	cmplStd/test/lang/useOperator.ci:217: (9 bytes: <.main+8582 @0638ea> - <.main+8591 @0638f3>): static u64Neg: uint64 := -u64B
	<.main+8582 @0638ea> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8586 @0638ee> : 60                         neg.i64
	<.main+8587 @0638ef> : 23 48 13 06                store.m64 <@061348> ;u64Neg
	cmplStd/test/lang/useOperator.ci:218: (9 bytes: <.main+8591 @0638f3> - <.main+8600 @0638fc>): static u64Cmt: uint64 := ~u64B
	<.main+8591 @0638f3> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8595 @0638f7> : 40                         cmt.b64
	<.main+8596 @0638f8> : 23 50 13 06                store.m64 <@061350> ;u64Cmt
	cmplStd/test/lang/useOperator.ci:219: (13 bytes: <.main+8600 @0638fc> - <.main+8613 @063909>): static u64Add: uint64 := u64A + u64B
	<.main+8600 @0638fc> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8604 @063900> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8608 @063904> : 61                         add.i64
	<.main+8609 @063905> : 23 58 13 06                store.m64 <@061358> ;u64Add
	cmplStd/test/lang/useOperator.ci:220: (13 bytes: <.main+8613 @063909> - <.main+8626 @063916>): static u64Sub: uint64 := u64A - u64B
	<.main+8613 @063909> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8617 @06390d> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8621 @063911> : 62                         sub.i64
	<.main+8622 @063912> : 23 60 13 06                store.m64 <@061360> ;u64Sub
	cmplStd/test/lang/useOperator.ci:221: (13 bytes: <.main+8626 @063916> - <.main+8639 @063923>): static u64Mul: uint64 := u64A * u64B
	<.main+8626 @063916> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8630 @06391a> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8634 @06391e> : 43                         mul.u64
	<.main+8635 @06391f> : 23 68 13 06                store.m64 <@061368> ;u64Mul
	cmplStd/test/lang/useOperator.ci:222: (13 bytes: <.main+8639 @063923> - <.main+8652 @063930>): static u64Div: uint64 := u64A / u64B
	<.main+8639 @063923> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8643 @063927> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8647 @06392b> : 44                         div.u64
	<.main+8648 @06392c> : 23 70 13 06                store.m64 <@061370> ;u64Div
	cmplStd/test/lang/useOperator.ci:223: (13 bytes: <.main+8652 @063930> - <.main+8665 @06393d>): static u64Mod: uint64 := u64A % u64B
	<.main+8652 @063930> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8656 @063934> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8660 @063938> : 45                         mod.u64
	<.main+8661 @063939> : 23 78 13 06                store.m64 <@061378> ;u64Mod
	cmplStd/test/lang/useOperator.ci:224: (13 bytes: <.main+8665 @06393d> - <.main+8678 @06394a>): static u64And: uint64 := u64A & u64B
	<.main+8665 @06393d> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8669 @063941> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8673 @063945> : 41                         and.b64
	<.main+8674 @063946> : 23 80 13 06                store.m64 <@061380> ;u64And
	cmplStd/test/lang/useOperator.ci:225: (13 bytes: <.main+8678 @06394a> - <.main+8691 @063957>): static u64Ior: uint64 := u64A | u64B
	<.main+8678 @06394a> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8682 @06394e> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8686 @063952> : 42                         or.b64
	<.main+8687 @063953> : 23 88 13 06                store.m64 <@061388> ;u64Ior
	cmplStd/test/lang/useOperator.ci:226: (13 bytes: <.main+8691 @063957> - <.main+8704 @063964>): static u64Xor: uint64 := u64A ^ u64B
	<.main+8691 @063957> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8695 @06395b> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8699 @06395f> : 46                         xor.b64
	<.main+8700 @063960> : 23 90 13 06                store.m64 <@061390> ;u64Xor
	cmplStd/test/lang/useOperator.ci:227: (13 bytes: <.main+8704 @063964> - <.main+8717 @063971>): static u64Shl: uint64 := u64A << shift
	<.main+8704 @063964> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8708 @063968> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8712 @06396c> : 4a                         shl.b64
	<.main+8713 @06396d> : 23 98 13 06                store.m64 <@061398> ;u64Shl
	cmplStd/test/lang/useOperator.ci:228: (13 bytes: <.main+8717 @063971> - <.main+8730 @06397e>): static u64Shr: uint64 := u64A >> shift
	<.main+8717 @063971> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8721 @063975> : 20 48 0d 06                load.m32 <@060d48> ;shift
	<.main+8725 @063979> : 4b                         shr.b64
	<.main+8726 @06397a> : 23 a0 13 06                store.m64 <@0613a0> ;u64Shr
	cmplStd/test/lang/useOperator.ci:229: (12 bytes: <.main+8730 @06397e> - <.main+8742 @06398a>): static u64Not: bool := !(u64B)
	<.main+8730 @06397e> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8734 @063982> : 6b                         i64.2bool
	<.main+8735 @063983> : 0b                         not.b32
	<.main+8736 @063984> : 1f a8 13 06 00             load.ref <@0613a8> ;u64Not
	<.main+8741 @063989> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:230: (15 bytes: <.main+8742 @06398a> - <.main+8757 @063999>): static u64Ceq: bool := u64A == u64B
	<.main+8742 @06398a> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8746 @06398e> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8750 @063992> : 67                         ceq.i64
	<.main+8751 @063993> : 1f b0 13 06 00             load.ref <@0613b0> ;u64Ceq
	<.main+8756 @063998> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:231: (16 bytes: <.main+8757 @063999> - <.main+8773 @0639a9>): static u64Cne: bool := u64A != u64B
	<.main+8757 @063999> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8761 @06399d> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8765 @0639a1> : 67                         ceq.i64
	<.main+8766 @0639a2> : 0b                         not.b32
	<.main+8767 @0639a3> : 1f b8 13 06 00             load.ref <@0613b8> ;u64Cne
	<.main+8772 @0639a8> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:232: (15 bytes: <.main+8773 @0639a9> - <.main+8788 @0639b8>): static u64Clt: bool := u64A < u64B
	<.main+8773 @0639a9> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8777 @0639ad> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8781 @0639b1> : 48                         clt.u64
	<.main+8782 @0639b2> : 1f c0 13 06 00             load.ref <@0613c0> ;u64Clt
	<.main+8787 @0639b7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:233: (16 bytes: <.main+8788 @0639b8> - <.main+8804 @0639c8>): static u64Cle: bool := u64A <= u64B
	<.main+8788 @0639b8> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8792 @0639bc> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8796 @0639c0> : 49                         cgt.u64
	<.main+8797 @0639c1> : 0b                         not.b32
	<.main+8798 @0639c2> : 1f c8 13 06 00             load.ref <@0613c8> ;u64Cle
	<.main+8803 @0639c7> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:234: (15 bytes: <.main+8804 @0639c8> - <.main+8819 @0639d7>): static u64Cgt: bool := u64A > u64B
	<.main+8804 @0639c8> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8808 @0639cc> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8812 @0639d0> : 49                         cgt.u64
	<.main+8813 @0639d1> : 1f d0 13 06 00             load.ref <@0613d0> ;u64Cgt
	<.main+8818 @0639d6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:235: (16 bytes: <.main+8819 @0639d7> - <.main+8835 @0639e7>): static u64Cge: bool := u64A >= u64B
	<.main+8819 @0639d7> : 21 30 13 06                load.m64 <@061330> ;u64A
	<.main+8823 @0639db> : 21 38 13 06                load.m64 <@061338> ;u64B
	<.main+8827 @0639df> : 48                         clt.u64
	<.main+8828 @0639e0> : 0b                         not.b32
	<.main+8829 @0639e1> : 1f d8 13 06 00             load.ref <@0613d8> ;u64Cge
	<.main+8834 @0639e6> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:237: (9 bytes: <.main+8835 @0639e7> - <.main+8844 @0639f0>): static f32A: float32 := a
	<.main+8835 @0639e7> : 7f 9a 99 c0 42             load.f32 96.300003
	<.main+8840 @0639ec> : 24 e0 13 06                store.m32 <@0613e0> ;f32A
	cmplStd/test/lang/useOperator.ci:238: (9 bytes: <.main+8844 @0639f0> - <.main+8853 @0639f9>): static f32B: float32 := b
	<.main+8844 @0639f0> : 7f 5c 8f 28 42             load.f32 42.139999
	<.main+8849 @0639f5> : 24 e8 13 06                store.m32 <@0613e8> ;f32B
	cmplStd/test/lang/useOperator.ci:239: (8 bytes: <.main+8853 @0639f9> - <.main+8861 @063a01>): static f32Pls: float32 := +f32B
	<.main+8853 @0639f9> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8857 @0639fd> : 24 f0 13 06                store.m32 <@0613f0> ;f32Pls
	cmplStd/test/lang/useOperator.ci:240: (9 bytes: <.main+8861 @063a01> - <.main+8870 @063a0a>): static f32Neg: float32 := -f32B
	<.main+8861 @063a01> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8865 @063a05> : 70                         neg.f32
	<.main+8866 @063a06> : 24 f8 13 06                store.m32 <@0613f8> ;f32Neg
	cmplStd/test/lang/useOperator.ci:242: (13 bytes: <.main+8870 @063a0a> - <.main+8883 @063a17>): static f32Add: float32 := f32A + f32B
	<.main+8870 @063a0a> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8874 @063a0e> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8878 @063a12> : 71                         add.f32
	<.main+8879 @063a13> : 24 00 14 06                store.m32 <@061400> ;f32Add
	cmplStd/test/lang/useOperator.ci:243: (13 bytes: <.main+8883 @063a17> - <.main+8896 @063a24>): static f32Sub: float32 := f32A - f32B
	<.main+8883 @063a17> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8887 @063a1b> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8891 @063a1f> : 72                         sub.f32
	<.main+8892 @063a20> : 24 08 14 06                store.m32 <@061408> ;f32Sub
	cmplStd/test/lang/useOperator.ci:244: (13 bytes: <.main+8896 @063a24> - <.main+8909 @063a31>): static f32Mul: float32 := f32A * f32B
	<.main+8896 @063a24> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8900 @063a28> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8904 @063a2c> : 73                         mul.f32
	<.main+8905 @063a2d> : 24 10 14 06                store.m32 <@061410> ;f32Mul
	cmplStd/test/lang/useOperator.ci:245: (13 bytes: <.main+8909 @063a31> - <.main+8922 @063a3e>): static f32Div: float32 := f32A / f32B
	<.main+8909 @063a31> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8913 @063a35> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8917 @063a39> : 74                         div.f32
	<.main+8918 @063a3a> : 24 18 14 06                store.m32 <@061418> ;f32Div
	cmplStd/test/lang/useOperator.ci:246: (13 bytes: <.main+8922 @063a3e> - <.main+8935 @063a4b>): static f32Mod: float32 := f32A % f32B
	<.main+8922 @063a3e> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8926 @063a42> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8930 @063a46> : 75                         mod.f32
	<.main+8931 @063a47> : 24 20 14 06                store.m32 <@061420> ;f32Mod
	cmplStd/test/lang/useOperator.ci:252: (12 bytes: <.main+8935 @063a4b> - <.main+8947 @063a57>): static f32Not: bool := !(f32B)
	<.main+8935 @063a4b> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8939 @063a4f> : 7c                         f32.2bool
	<.main+8940 @063a50> : 0b                         not.b32
	<.main+8941 @063a51> : 1f 28 14 06 00             load.ref <@061428> ;f32Not
	<.main+8946 @063a56> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:253: (15 bytes: <.main+8947 @063a57> - <.main+8962 @063a66>): static f32Ceq: bool := f32A == f32B
	<.main+8947 @063a57> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8951 @063a5b> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8955 @063a5f> : 77                         ceq.f32
	<.main+8956 @063a60> : 1f 30 14 06 00             load.ref <@061430> ;f32Ceq
	<.main+8961 @063a65> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:254: (16 bytes: <.main+8962 @063a66> - <.main+8978 @063a76>): static f32Cne: bool := f32A != f32B
	<.main+8962 @063a66> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8966 @063a6a> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8970 @063a6e> : 77                         ceq.f32
	<.main+8971 @063a6f> : 0b                         not.b32
	<.main+8972 @063a70> : 1f 38 14 06 00             load.ref <@061438> ;f32Cne
	<.main+8977 @063a75> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:255: (15 bytes: <.main+8978 @063a76> - <.main+8993 @063a85>): static f32Clt: bool := f32A < f32B
	<.main+8978 @063a76> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8982 @063a7a> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+8986 @063a7e> : 78                         clt.f32
	<.main+8987 @063a7f> : 1f 40 14 06 00             load.ref <@061440> ;f32Clt
	<.main+8992 @063a84> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:256: (16 bytes: <.main+8993 @063a85> - <.main+9009 @063a95>): static f32Cle: bool := f32A <= f32B
	<.main+8993 @063a85> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+8997 @063a89> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+9001 @063a8d> : 79                         cgt.f32
	<.main+9002 @063a8e> : 0b                         not.b32
	<.main+9003 @063a8f> : 1f 48 14 06 00             load.ref <@061448> ;f32Cle
	<.main+9008 @063a94> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:257: (15 bytes: <.main+9009 @063a95> - <.main+9024 @063aa4>): static f32Cgt: bool := f32A > f32B
	<.main+9009 @063a95> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+9013 @063a99> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+9017 @063a9d> : 79                         cgt.f32
	<.main+9018 @063a9e> : 1f 50 14 06 00             load.ref <@061450> ;f32Cgt
	<.main+9023 @063aa3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:258: (16 bytes: <.main+9024 @063aa4> - <.main+9040 @063ab4>): static f32Cge: bool := f32A >= f32B
	<.main+9024 @063aa4> : 20 e0 13 06                load.m32 <@0613e0> ;f32A
	<.main+9028 @063aa8> : 20 e8 13 06                load.m32 <@0613e8> ;f32B
	<.main+9032 @063aac> : 78                         clt.f32
	<.main+9033 @063aad> : 0b                         not.b32
	<.main+9034 @063aae> : 1f 58 14 06 00             load.ref <@061458> ;f32Cge
	<.main+9039 @063ab3> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:260: (13 bytes: <.main+9040 @063ab4> - <.main+9053 @063ac1>): static f64A: float64 := a
	<.main+9040 @063ab4> : 8f 33 33 33 33 33 13 58 40 load.f64 96.300000
	<.main+9049 @063abd> : 23 60 14 06                store.m64 <@061460> ;f64A
	cmplStd/test/lang/useOperator.ci:261: (13 bytes: <.main+9053 @063ac1> - <.main+9066 @063ace>): static f64B: float64 := b
	<.main+9053 @063ac1> : 8f 52 b8 1e 85 eb 11 45 40 load.f64 42.140000
	<.main+9062 @063aca> : 23 68 14 06                store.m64 <@061468> ;f64B
	cmplStd/test/lang/useOperator.ci:262: (8 bytes: <.main+9066 @063ace> - <.main+9074 @063ad6>): static f64Pls: float64 := +f64B
	<.main+9066 @063ace> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9070 @063ad2> : 23 70 14 06                store.m64 <@061470> ;f64Pls
	cmplStd/test/lang/useOperator.ci:263: (9 bytes: <.main+9074 @063ad6> - <.main+9083 @063adf>): static f64Neg: float64 := -f64B
	<.main+9074 @063ad6> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9078 @063ada> : 80                         neg.f64
	<.main+9079 @063adb> : 23 78 14 06                store.m64 <@061478> ;f64Neg
	cmplStd/test/lang/useOperator.ci:265: (13 bytes: <.main+9083 @063adf> - <.main+9096 @063aec>): static f64Add: float64 := f64A + f64B
	<.main+9083 @063adf> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9087 @063ae3> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9091 @063ae7> : 81                         add.f64
	<.main+9092 @063ae8> : 23 80 14 06                store.m64 <@061480> ;f64Add
	cmplStd/test/lang/useOperator.ci:266: (13 bytes: <.main+9096 @063aec> - <.main+9109 @063af9>): static f64Sub: float64 := f64A - f64B
	<.main+9096 @063aec> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9100 @063af0> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9104 @063af4> : 82                         sub.f64
	<.main+9105 @063af5> : 23 88 14 06                store.m64 <@061488> ;f64Sub
	cmplStd/test/lang/useOperator.ci:267: (13 bytes: <.main+9109 @063af9> - <.main+9122 @063b06>): static f64Mul: float64 := f64A * f64B
	<.main+9109 @063af9> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9113 @063afd> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9117 @063b01> : 83                         mul.f64
	<.main+9118 @063b02> : 23 90 14 06                store.m64 <@061490> ;f64Mul
	cmplStd/test/lang/useOperator.ci:268: (13 bytes: <.main+9122 @063b06> - <.main+9135 @063b13>): static f64Div: float64 := f64A / f64B
	<.main+9122 @063b06> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9126 @063b0a> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9130 @063b0e> : 84                         div.f64
	<.main+9131 @063b0f> : 23 98 14 06                store.m64 <@061498> ;f64Div
	cmplStd/test/lang/useOperator.ci:269: (13 bytes: <.main+9135 @063b13> - <.main+9148 @063b20>): static f64Mod: float64 := f64A % f64B
	<.main+9135 @063b13> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9139 @063b17> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9143 @063b1b> : 85                         mod.f64
	<.main+9144 @063b1c> : 23 a0 14 06                store.m64 <@0614a0> ;f64Mod
	cmplStd/test/lang/useOperator.ci:275: (12 bytes: <.main+9148 @063b20> - <.main+9160 @063b2c>): static f64Not: bool := !(f64B)
	<.main+9148 @063b20> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9152 @063b24> : 8d                         f64.2bool
	<.main+9153 @063b25> : 0b                         not.b32
	<.main+9154 @063b26> : 1f a8 14 06 00             load.ref <@0614a8> ;f64Not
	<.main+9159 @063b2b> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:276: (15 bytes: <.main+9160 @063b2c> - <.main+9175 @063b3b>): static f64Ceq: bool := f64A == f64B
	<.main+9160 @063b2c> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9164 @063b30> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9168 @063b34> : 87                         ceq.f64
	<.main+9169 @063b35> : 1f b0 14 06 00             load.ref <@0614b0> ;f64Ceq
	<.main+9174 @063b3a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:277: (16 bytes: <.main+9175 @063b3b> - <.main+9191 @063b4b>): static f64Cne: bool := f64A != f64B
	<.main+9175 @063b3b> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9179 @063b3f> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9183 @063b43> : 87                         ceq.f64
	<.main+9184 @063b44> : 0b                         not.b32
	<.main+9185 @063b45> : 1f b8 14 06 00             load.ref <@0614b8> ;f64Cne
	<.main+9190 @063b4a> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:278: (15 bytes: <.main+9191 @063b4b> - <.main+9206 @063b5a>): static f64Clt: bool := f64A < f64B
	<.main+9191 @063b4b> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9195 @063b4f> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9199 @063b53> : 88                         clt.f64
	<.main+9200 @063b54> : 1f c0 14 06 00             load.ref <@0614c0> ;f64Clt
	<.main+9205 @063b59> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:279: (16 bytes: <.main+9206 @063b5a> - <.main+9222 @063b6a>): static f64Cle: bool := f64A <= f64B
	<.main+9206 @063b5a> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9210 @063b5e> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9214 @063b62> : 89                         cgt.f64
	<.main+9215 @063b63> : 0b                         not.b32
	<.main+9216 @063b64> : 1f c8 14 06 00             load.ref <@0614c8> ;f64Cle
	<.main+9221 @063b69> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:280: (15 bytes: <.main+9222 @063b6a> - <.main+9237 @063b79>): static f64Cgt: bool := f64A > f64B
	<.main+9222 @063b6a> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9226 @063b6e> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9230 @063b72> : 89                         cgt.f64
	<.main+9231 @063b73> : 1f d0 14 06 00             load.ref <@0614d0> ;f64Cgt
	<.main+9236 @063b78> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:281: (16 bytes: <.main+9237 @063b79> - <.main+9253 @063b89>): static f64Cge: bool := f64A >= f64B
	<.main+9237 @063b79> : 21 60 14 06                load.m64 <@061460> ;f64A
	<.main+9241 @063b7d> : 21 68 14 06                load.m64 <@061468> ;f64B
	<.main+9245 @063b81> : 88                         clt.f64
	<.main+9246 @063b82> : 0b                         not.b32
	<.main+9247 @063b83> : 1f d8 14 06 00             load.ref <@0614d8> ;f64Cge
	<.main+9252 @063b88> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:283: (9 bytes: <.main+9253 @063b89> - <.main+9262 @063b92>): static ptrA: pointer := null
	<.main+9253 @063b89> : 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+9258 @063b8e> : 24 e0 14 06                store.m32 <@0614e0> ;ptrA
	cmplStd/test/lang/useOperator.ci:284: (9 bytes: <.main+9262 @063b92> - <.main+9271 @063b9b>): static ptrB: pointer := pointer(shift)
	<.main+9262 @063b92> : 1f 48 0d 06 00             load.ref <@060d48> ;shift
	<.main+9267 @063b97> : 24 e8 14 06                store.m32 <@0614e8> ;ptrB
	cmplStd/test/lang/useOperator.ci:299: (15 bytes: <.main+9271 @063b9b> - <.main+9286 @063baa>): static ptrCeq: bool := ptrA == ptrB
	<.main+9271 @063b9b> : 20 e0 14 06                load.m32 <@0614e0> ;ptrA
	<.main+9275 @063b9f> : 20 e8 14 06                load.m32 <@0614e8> ;ptrB
	<.main+9279 @063ba3> : 57                         ceq.i32
	<.main+9280 @063ba4> : 1f f0 14 06 00             load.ref <@0614f0> ;ptrCeq
	<.main+9285 @063ba9> : 2b                         store.i8
	cmplStd/test/lang/useOperator.ci:300: (16 bytes: <.main+9286 @063baa> - <.main+9302 @063bba>): static ptrCne: bool := ptrA != ptrB
	<.main+9286 @063baa> : 20 e0 14 06                load.m32 <@0614e0> ;ptrA
	<.main+9290 @063bae> : 20 e8 14 06                load.m32 <@0614e8> ;ptrB
	<.main+9294 @063bb2> : 57                         ceq.i32
	<.main+9295 @063bb3> : 0b                         not.b32
	<.main+9296 @063bb4> : 1f f8 14 06 00             load.ref <@0614f8> ;ptrCne
	<.main+9301 @063bb9> : 2b                         store.i8
	cmplStd/test/lang/stmt.if.ci:26: (5 bytes: <.main+9302 @063bba> - <.main+9307 @063bbf>): static t: int32 := 0
	<.main+9302 @063bba> : 19                         load.z32
	<.main+9303 @063bbb> : 24 00 15 06                store.m32 <@061500> ;t
	cmplStd/test/lang/stmt.for.ci:12: (5 bytes: <.main+9307 @063bbf> - <.main+9312 @063bc4>): static forIdx: int32
	<.main+9307 @063bbf> : 19                         load.z32
	<.main+9308 @063bc0> : 24 08 15 06                store.m32 <@061508> ;forIdx
	cmplStd/test/std/test.math.ci:3: (24 bytes: <.main+9312 @063bc4> - <.main+9336 @063bdc>): static testMathFloor_1: float64 := Math.floor(3.200000)
	<.main+9312 @063bc4> : 1a                         load.z64
	<.main+9313 @063bc5> : 8f 9a 99 99 99 99 99 09 40 load.f64 3.200000
	<.main+9322 @063bce> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9327 @063bd3> : 02                         call
	<.main+9328 @063bd4> : 09 f8 ff ff                inc.sp(-8)
	<.main+9332 @063bd8> : 23 10 15 06                store.m64 <@061510> ;testMathFloor_1
	cmplStd/test/std/test.math.ci:4: (24 bytes: <.main+9336 @063bdc> - <.main+9360 @063bf4>): static testMathFloor_2: float64 := Math.floor(3.500000)
	<.main+9336 @063bdc> : 1a                         load.z64
	<.main+9337 @063bdd> : 8f 00 00 00 00 00 00 0c 40 load.f64 3.500000
	<.main+9346 @063be6> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9351 @063beb> : 02                         call
	<.main+9352 @063bec> : 09 f8 ff ff                inc.sp(-8)
	<.main+9356 @063bf0> : 23 18 15 06                store.m64 <@061518> ;testMathFloor_2
	cmplStd/test/std/test.math.ci:5: (24 bytes: <.main+9360 @063bf4> - <.main+9384 @063c0c>): static testMathFloor_3: float64 := Math.floor(3.600000)
	<.main+9360 @063bf4> : 1a                         load.z64
	<.main+9361 @063bf5> : 8f cd cc cc cc cc cc 0c 40 load.f64 3.600000
	<.main+9370 @063bfe> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9375 @063c03> : 02                         call
	<.main+9376 @063c04> : 09 f8 ff ff                inc.sp(-8)
	<.main+9380 @063c08> : 23 20 15 06                store.m64 <@061520> ;testMathFloor_3
	cmplStd/test/std/test.math.ci:6: (24 bytes: <.main+9384 @063c0c> - <.main+9408 @063c24>): static testMathFloor_4: float64 := Math.floor(-3.200000)
	<.main+9384 @063c0c> : 1a                         load.z64
	<.main+9385 @063c0d> : 8f 9a 99 99 99 99 99 09 c0 load.f64 -3.200000
	<.main+9394 @063c16> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9399 @063c1b> : 02                         call
	<.main+9400 @063c1c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9404 @063c20> : 23 28 15 06                store.m64 <@061528> ;testMathFloor_4
	cmplStd/test/std/test.math.ci:7: (24 bytes: <.main+9408 @063c24> - <.main+9432 @063c3c>): static testMathFloor_5: float64 := Math.floor(-3.500000)
	<.main+9408 @063c24> : 1a                         load.z64
	<.main+9409 @063c25> : 8f 00 00 00 00 00 00 0c c0 load.f64 -3.500000
	<.main+9418 @063c2e> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9423 @063c33> : 02                         call
	<.main+9424 @063c34> : 09 f8 ff ff                inc.sp(-8)
	<.main+9428 @063c38> : 23 30 15 06                store.m64 <@061530> ;testMathFloor_5
	cmplStd/test/std/test.math.ci:8: (24 bytes: <.main+9432 @063c3c> - <.main+9456 @063c54>): static testMathFloor_6: float64 := Math.floor(-3.600000)
	<.main+9432 @063c3c> : 1a                         load.z64
	<.main+9433 @063c3d> : 8f cd cc cc cc cc cc 0c c0 load.f64 -3.600000
	<.main+9442 @063c46> : 1f 38 ee 05 00             load.ref <@05ee38> ;Math.floor(x: float64): float64
	<.main+9447 @063c4b> : 02                         call
	<.main+9448 @063c4c> : 09 f8 ff ff                inc.sp(-8)
	<.main+9452 @063c50> : 23 38 15 06                store.m64 <@061538> ;testMathFloor_6
	cmplStd/test/std/test.math.ci:10: (29 bytes: <.main+9456 @063c54> - <.main+9485 @063c71>): static testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+9456 @063c54> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9465 @063c5d> : 11 00                      dup.x64 sp(0)
	<.main+9467 @063c5f> : 1a                         load.z64
	<.main+9468 @063c60> : 89                         cgt.f64
	<.main+9469 @063c61> : 11 01                      dup.x64 sp(1)
	<.main+9471 @063c63> : 1a                         load.z64
	<.main+9472 @063c64> : 88                         clt.f64
	<.main+9473 @063c65> : 52                         sub.i32
	<.main+9474 @063c66> : 13 02                      set.x32 sp(2)
	<.main+9476 @063c68> : 09 fc ff ff                inc.sp(-4)
	<.main+9480 @063c6c> : 5d                         i32.2f64
	<.main+9481 @063c6d> : 23 40 15 06                store.m64 <@061540> ;testMathSign_1F
	cmplStd/test/std/test.math.ci:11: (21 bytes: <.main+9485 @063c71> - <.main+9506 @063c86>): static testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+9485 @063c71> : 1a                         load.z64
	<.main+9486 @063c72> : 11 00                      dup.x64 sp(0)
	<.main+9488 @063c74> : 1a                         load.z64
	<.main+9489 @063c75> : 89                         cgt.f64
	<.main+9490 @063c76> : 11 01                      dup.x64 sp(1)
	<.main+9492 @063c78> : 1a                         load.z64
	<.main+9493 @063c79> : 88                         clt.f64
	<.main+9494 @063c7a> : 52                         sub.i32
	<.main+9495 @063c7b> : 13 02                      set.x32 sp(2)
	<.main+9497 @063c7d> : 09 fc ff ff                inc.sp(-4)
	<.main+9501 @063c81> : 5d                         i32.2f64
	<.main+9502 @063c82> : 23 48 15 06                store.m64 <@061548> ;testMathSign_2F
	cmplStd/test/std/test.math.ci:12: (29 bytes: <.main+9506 @063c86> - <.main+9535 @063ca3>): static testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+9506 @063c86> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9515 @063c8f> : 11 00                      dup.x64 sp(0)
	<.main+9517 @063c91> : 1a                         load.z64
	<.main+9518 @063c92> : 89                         cgt.f64
	<.main+9519 @063c93> : 11 01                      dup.x64 sp(1)
	<.main+9521 @063c95> : 1a                         load.z64
	<.main+9522 @063c96> : 88                         clt.f64
	<.main+9523 @063c97> : 52                         sub.i32
	<.main+9524 @063c98> : 13 02                      set.x32 sp(2)
	<.main+9526 @063c9a> : 09 fc ff ff                inc.sp(-4)
	<.main+9530 @063c9e> : 5d                         i32.2f64
	<.main+9531 @063c9f> : 23 50 15 06                store.m64 <@061550> ;testMathSign_3F
	cmplStd/test/std/test.math.ci:13: (21 bytes: <.main+9535 @063ca3> - <.main+9556 @063cb8>): static testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+9535 @063ca3> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9540 @063ca8> : 10 00                      dup.x32 sp(0)
	<.main+9542 @063caa> : 19                         load.z32
	<.main+9543 @063cab> : 79                         cgt.f32
	<.main+9544 @063cac> : 10 01                      dup.x32 sp(1)
	<.main+9546 @063cae> : 19                         load.z32
	<.main+9547 @063caf> : 78                         clt.f32
	<.main+9548 @063cb0> : 52                         sub.i32
	<.main+9549 @063cb1> : 13 01                      set.x32 sp(1)
	<.main+9551 @063cb3> : 5d                         i32.2f64
	<.main+9552 @063cb4> : 23 58 15 06                store.m64 <@061558> ;testMathSign_1f
	cmplStd/test/std/test.math.ci:14: (17 bytes: <.main+9556 @063cb8> - <.main+9573 @063cc9>): static testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+9556 @063cb8> : 19                         load.z32
	<.main+9557 @063cb9> : 10 00                      dup.x32 sp(0)
	<.main+9559 @063cbb> : 19                         load.z32
	<.main+9560 @063cbc> : 79                         cgt.f32
	<.main+9561 @063cbd> : 10 01                      dup.x32 sp(1)
	<.main+9563 @063cbf> : 19                         load.z32
	<.main+9564 @063cc0> : 78                         clt.f32
	<.main+9565 @063cc1> : 52                         sub.i32
	<.main+9566 @063cc2> : 13 01                      set.x32 sp(1)
	<.main+9568 @063cc4> : 5d                         i32.2f64
	<.main+9569 @063cc5> : 23 60 15 06                store.m64 <@061560> ;testMathSign_2f
	cmplStd/test/std/test.math.ci:15: (21 bytes: <.main+9573 @063cc9> - <.main+9594 @063cde>): static testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+9573 @063cc9> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9578 @063cce> : 10 00                      dup.x32 sp(0)
	<.main+9580 @063cd0> : 19                         load.z32
	<.main+9581 @063cd1> : 79                         cgt.f32
	<.main+9582 @063cd2> : 10 01                      dup.x32 sp(1)
	<.main+9584 @063cd4> : 19                         load.z32
	<.main+9585 @063cd5> : 78                         clt.f32
	<.main+9586 @063cd6> : 52                         sub.i32
	<.main+9587 @063cd7> : 13 01                      set.x32 sp(1)
	<.main+9589 @063cd9> : 5d                         i32.2f64
	<.main+9590 @063cda> : 23 68 15 06                store.m64 <@061568> ;testMathSign_3f
	cmplStd/test/std/test.math.ci:17: (24 bytes: <.main+9594 @063cde> - <.main+9618 @063cf6>): static testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+9594 @063cde> : 1a                         load.z64
	<.main+9595 @063cdf> : 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+9604 @063ce8> : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<.main+9609 @063ced> : 02                         call
	<.main+9610 @063cee> : 09 f8 ff ff                inc.sp(-8)
	<.main+9614 @063cf2> : 23 70 15 06                store.m64 <@061570> ;testMathAbs_1F
	cmplStd/test/std/test.math.ci:18: (15 bytes: <.main+9618 @063cf6> - <.main+9633 @063d05>): static testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+9618 @063cf6> : 1b                         load.z128
	<.main+9619 @063cf7> : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<.main+9624 @063cfc> : 02                         call
	<.main+9625 @063cfd> : 09 f8 ff ff                inc.sp(-8)
	<.main+9629 @063d01> : 23 78 15 06                store.m64 <@061578> ;testMathAbs_2F
	cmplStd/test/std/test.math.ci:19: (24 bytes: <.main+9633 @063d05> - <.main+9657 @063d1d>): static testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+9633 @063d05> : 1a                         load.z64
	<.main+9634 @063d06> : 8f cd cc cc cc cc cc ec bf load.f64 -0.900000
	<.main+9643 @063d0f> : 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<.main+9648 @063d14> : 02                         call
	<.main+9649 @063d15> : 09 f8 ff ff                inc.sp(-8)
	<.main+9653 @063d19> : 23 80 15 06                store.m64 <@061580> ;testMathAbs_3F
	cmplStd/test/std/test.math.ci:20: (21 bytes: <.main+9657 @063d1d> - <.main+9678 @063d32>): static testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+9657 @063d1d> : 19                         load.z32
	<.main+9658 @063d1e> : 7f cd cc 4c 3e             load.f32 0.200000
	<.main+9663 @063d23> : 1f 50 ee 05 00             load.ref <@05ee50> ;Math.abs(x: float32): float32
	<.main+9668 @063d28> : 02                         call
	<.main+9669 @063d29> : 09 fc ff ff                inc.sp(-4)
	<.main+9673 @063d2d> : 7d                         f32.2f64
	<.main+9674 @063d2e> : 23 88 15 06                store.m64 <@061588> ;testMathAbs_1f
	cmplStd/test/std/test.math.ci:21: (17 bytes: <.main+9678 @063d32> - <.main+9695 @063d43>): static testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+9678 @063d32> : 19                         load.z32
	<.main+9679 @063d33> : 19                         load.z32
	<.main+9680 @063d34> : 1f 50 ee 05 00             load.ref <@05ee50> ;Math.abs(x: float32): float32
	<.main+9685 @063d39> : 02                         call
	<.main+9686 @063d3a> : 09 fc ff ff                inc.sp(-4)
	<.main+9690 @063d3e> : 7d                         f32.2f64
	<.main+9691 @063d3f> : 23 90 15 06                store.m64 <@061590> ;testMathAbs_2f
	cmplStd/test/std/test.math.ci:22: (21 bytes: <.main+9695 @063d43> - <.main+9716 @063d58>): static testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+9695 @063d43> : 19                         load.z32
	<.main+9696 @063d44> : 7f 66 66 66 bf             load.f32 -0.900000
	<.main+9701 @063d49> : 1f 50 ee 05 00             load.ref <@05ee50> ;Math.abs(x: float32): float32
	<.main+9706 @063d4e> : 02                         call
	<.main+9707 @063d4f> : 09 fc ff ff                inc.sp(-4)
	<.main+9711 @063d53> : 7d                         f32.2f64
	<.main+9712 @063d54> : 23 98 15 06                store.m64 <@061598> ;testMathAbs_3f
	cmplStd/test/std/test.math.ci:24: (26 bytes: <.main+9716 @063d58> - <.main+9742 @063d72>): static testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+9716 @063d58> : 19                         load.z32
	<.main+9717 @063d59> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9722 @063d5e> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9727 @063d63> : 1f c0 ee 05 00             load.ref <@05eec0> ;Math.min(a: float32, b: float32): float32
	<.main+9732 @063d68> : 02                         call
	<.main+9733 @063d69> : 09 f8 ff ff                inc.sp(-8)
	<.main+9737 @063d6d> : 7d                         f32.2f64
	<.main+9738 @063d6e> : 23 a0 15 06                store.m64 <@0615a0> ;testMathMin_1f
	cmplStd/test/std/test.math.ci:25: (26 bytes: <.main+9742 @063d72> - <.main+9768 @063d8c>): static testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+9742 @063d72> : 19                         load.z32
	<.main+9743 @063d73> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9748 @063d78> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9753 @063d7d> : 1f f0 ee 05 00             load.ref <@05eef0> ;Math.max(a: float32, b: float32): float32
	<.main+9758 @063d82> : 02                         call
	<.main+9759 @063d83> : 09 f8 ff ff                inc.sp(-8)
	<.main+9763 @063d87> : 7d                         f32.2f64
	<.main+9764 @063d88> : 23 a8 15 06                store.m64 <@0615a8> ;testMathMax_2f
	cmplStd/test/std/test.math.ci:26: (33 bytes: <.main+9768 @063d8c> - <.main+9801 @063dad>): static testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+9768 @063d8c> : 1a                         load.z64
	<.main+9769 @063d8d> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9778 @063d96> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9787 @063d9f> : 1f d8 ee 05 00             load.ref <@05eed8> ;Math.min(a: float64, b: float64): float64
	<.main+9792 @063da4> : 02                         call
	<.main+9793 @063da5> : 09 f0 ff ff                inc.sp(-16)
	<.main+9797 @063da9> : 23 b0 15 06                store.m64 <@0615b0> ;testMathMin_1F
	cmplStd/test/std/test.math.ci:27: (33 bytes: <.main+9801 @063dad> - <.main+9834 @063dce>): static testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+9801 @063dad> : 1a                         load.z64
	<.main+9802 @063dae> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9811 @063db7> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9820 @063dc0> : 1f 08 ef 05 00             load.ref <@05ef08> ;Math.max(a: float64, b: float64): float64
	<.main+9825 @063dc5> : 02                         call
	<.main+9826 @063dc6> : 09 f0 ff ff                inc.sp(-16)
	<.main+9830 @063dca> : 23 b8 15 06                store.m64 <@0615b8> ;testMathMax_2F
	cmplStd/test/std/test.math.ci:29: (27 bytes: <.main+9834 @063dce> - <.main+9861 @063de9>): static testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9834 @063dce> : 19                         load.z32
	<.main+9835 @063dcf> : 7f 00 00 20 41             load.f32 10.000000
	<.main+9840 @063dd4> : 19                         load.z32
	<.main+9841 @063dd5> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9846 @063dda> : 1f 20 ef 05 00             load.ref <@05ef20> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9851 @063ddf> : 02                         call
	<.main+9852 @063de0> : 09 f4 ff ff                inc.sp(-12)
	<.main+9856 @063de4> : 7d                         f32.2f64
	<.main+9857 @063de5> : 23 c0 15 06                store.m64 <@0615c0> ;testMathClamp_1f
	cmplStd/test/std/test.math.ci:30: (34 bytes: <.main+9861 @063de9> - <.main+9895 @063e0b>): static testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+9861 @063de9> : 1a                         load.z64
	<.main+9862 @063dea> : 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+9871 @063df3> : 1a                         load.z64
	<.main+9872 @063df4> : 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+9881 @063dfd> : 1f 40 ef 05 00             load.ref <@05ef40> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+9886 @063e02> : 02                         call
	<.main+9887 @063e03> : 09 e8 ff ff                inc.sp(-24)
	<.main+9891 @063e07> : 23 c8 15 06                store.m64 <@0615c8> ;testMathClamp_1F
	cmplStd/test/std/test.math.ci:32: (25 bytes: <.main+9895 @063e0b> - <.main+9920 @063e24>): static testMathLerp_1f: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9895 @063e0b> : 19                         load.z32
	<.main+9896 @063e0c> : 10 00                      dup.x32 sp(0)
	<.main+9898 @063e0e> : 7f 00 00 00 3f             load.f32 0.500000
	<.main+9903 @063e13> : 7f 00 00 00 40             load.f32 2.000000
	<.main+9908 @063e18> : 10 03                      dup.x32 sp(3)
	<.main+9910 @063e1a> : 72                         sub.f32
	<.main+9911 @063e1b> : 73                         mul.f32
	<.main+9912 @063e1c> : 71                         add.f32
	<.main+9913 @063e1d> : 13 01                      set.x32 sp(1)
	<.main+9915 @063e1f> : 7d                         f32.2f64
	<.main+9916 @063e20> : 23 d0 15 06                store.m64 <@0615d0> ;testMathLerp_1f
	cmplStd/test/std/test.math.ci:33: (32 bytes: <.main+9920 @063e24> - <.main+9952 @063e44>): static testMathLerp_1F: float64 := Math.lerp(0.500000, 0.000000, 2.000000)
	<.main+9920 @063e24> : 1a                         load.z64
	<.main+9921 @063e25> : 11 00                      dup.x64 sp(0)
	<.main+9923 @063e27> : 8f 00 00 00 00 00 00 e0 3f load.f64 0.500000
	<.main+9932 @063e30> : 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+9941 @063e39> : 11 06                      dup.x64 sp(6)
	<.main+9943 @063e3b> : 82                         sub.f64
	<.main+9944 @063e3c> : 83                         mul.f64
	<.main+9945 @063e3d> : 81                         add.f64
	<.main+9946 @063e3e> : 14 02                      set.x64 sp(2)
	<.main+9948 @063e40> : 23 d8 15 06                store.m64 <@0615d8> ;testMathLerp_1F
	cmplStd/test/std/test.math.ci:35: (64 bytes: <.main+9952 @063e44> - <.main+10016 @063e84>): static testMathSmooth_1f: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+9952 @063e44> : 19                         load.z32
	<.main+9953 @063e45> : 19                         load.z32
	<.main+9954 @063e46> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9959 @063e4b> : 10 02                      dup.x32 sp(2)
	<.main+9961 @063e4d> : 72                         sub.f32
	<.main+9962 @063e4e> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9967 @063e53> : 10 03                      dup.x32 sp(3)
	<.main+9969 @063e55> : 72                         sub.f32
	<.main+9970 @063e56> : 74                         div.f32
	<.main+9971 @063e57> : 19                         load.z32
	<.main+9972 @063e58> : 7f 00 00 80 3f             load.f32 1.000000
	<.main+9977 @063e5d> : 1f 20 ef 05 00             load.ref <@05ef20> ;Math.clamp(t: float32, a: float32, b: float32): float32
	<.main+9982 @063e62> : 02                         call
	<.main+9983 @063e63> : 09 f4 ff ff                inc.sp(-12)
	<.main+9987 @063e67> : 10 00                      dup.x32 sp(0)
	<.main+9989 @063e69> : 10 01                      dup.x32 sp(1)
	<.main+9991 @063e6b> : 73                         mul.f32
	<.main+9992 @063e6c> : 7f 00 00 40 40             load.f32 3.000000
	<.main+9997 @063e71> : 7f 00 00 00 40             load.f32 2.000000
	<.main+10002 @063e76>: 10 03                      dup.x32 sp(3)
	<.main+10004 @063e78>: 73                         mul.f32
	<.main+10005 @063e79>: 72                         sub.f32
	<.main+10006 @063e7a>: 73                         mul.f32
	<.main+10007 @063e7b>: 13 01                      set.x32 sp(1)
	<.main+10009 @063e7d>: 13 01                      set.x32 sp(1)
	<.main+10011 @063e7f>: 7d                         f32.2f64
	<.main+10012 @063e80>: 23 e0 15 06                store.m64 <@0615e0> ;testMathSmooth_1f
	cmplStd/test/std/test.math.ci:36: (82 bytes: <.main+10016 @063e84> - <.main+10098 @063ed6>): static testMathSmooth_1F: float64 := Math.smooth(1.000000, 0.000000, 1.000000)
	<.main+10016 @063e84>: 1b                         load.z128
	<.main+10017 @063e85>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10026 @063e8e>: 11 04                      dup.x64 sp(4)
	<.main+10028 @063e90>: 82                         sub.f64
	<.main+10029 @063e91>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10038 @063e9a>: 11 06                      dup.x64 sp(6)
	<.main+10040 @063e9c>: 82                         sub.f64
	<.main+10041 @063e9d>: 84                         div.f64
	<.main+10042 @063e9e>: 1a                         load.z64
	<.main+10043 @063e9f>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10052 @063ea8>: 1f 40 ef 05 00             load.ref <@05ef40> ;Math.clamp(t: float64, a: float64, b: float64): float64
	<.main+10057 @063ead>: 02                         call
	<.main+10058 @063eae>: 09 e8 ff ff                inc.sp(-24)
	<.main+10062 @063eb2>: 11 00                      dup.x64 sp(0)
	<.main+10064 @063eb4>: 11 02                      dup.x64 sp(2)
	<.main+10066 @063eb6>: 83                         mul.f64
	<.main+10067 @063eb7>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10076 @063ec0>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10085 @063ec9>: 11 06                      dup.x64 sp(6)
	<.main+10087 @063ecb>: 83                         mul.f64
	<.main+10088 @063ecc>: 82                         sub.f64
	<.main+10089 @063ecd>: 83                         mul.f64
	<.main+10090 @063ece>: 14 02                      set.x64 sp(2)
	<.main+10092 @063ed0>: 14 02                      set.x64 sp(2)
	<.main+10094 @063ed2>: 23 e8 15 06                store.m64 <@0615e8> ;testMathSmooth_1F
	cmplStd/test/std/test.math.ci:38: (25 bytes: <.main+10098 @063ed6> - <.main+10123 @063eef>): static testMathMin_nan: float64 := Math.min()
	<.main+10098 @063ed6>: 19                         load.z32
	<.main+10099 @063ed7>: 0a 04 00 00                load.sp(+4)
	<.main+10103 @063edb>: 1a                         load.z64
	<.main+10104 @063edc>: 11 02                      dup.x64 sp(2)
	<.main+10106 @063ede>: 1f 60 ef 05 00             load.ref <@05ef60> ;Math.min(data: float64[]): float64
	<.main+10111 @063ee3>: 02                         call
	<.main+10112 @063ee4>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10115 @063ee7>: 09 f0 ff ff                inc.sp(-16)
	<.main+10119 @063eeb>: 23 f0 15 06                store.m64 <@0615f0> ;testMathMin_nan
	cmplStd/test/std/test.math.ci:39: (110 bytes: <.main+10123 @063eef> - <.main+10233 @063f5d>): static testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10123 @063eef>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10132 @063ef8>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10141 @063f01>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10150 @063f0a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10159 @063f13>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10168 @063f1c>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10177 @063f25>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10186 @063f2e>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10195 @063f37>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10204 @063f40>: 1c 09 00 00 00             load.c32 9
	<.main+10209 @063f45>: 0a 04 00 00                load.sp(+4)
	<.main+10213 @063f49>: 1a                         load.z64
	<.main+10214 @063f4a>: 11 02                      dup.x64 sp(2)
	<.main+10216 @063f4c>: 1f 60 ef 05 00             load.ref <@05ef60> ;Math.min(data: float64[]): float64
	<.main+10221 @063f51>: 02                         call
	<.main+10222 @063f52>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10225 @063f55>: 09 a8 ff ff                inc.sp(-88)
	<.main+10229 @063f59>: 23 f8 15 06                store.m64 <@0615f8> ;testMathMin_1
	cmplStd/test/std/test.math.ci:40: (25 bytes: <.main+10233 @063f5d> - <.main+10258 @063f76>): static testMathMax_nan: float64 := Math.max()
	<.main+10233 @063f5d>: 19                         load.z32
	<.main+10234 @063f5e>: 0a 04 00 00                load.sp(+4)
	<.main+10238 @063f62>: 1a                         load.z64
	<.main+10239 @063f63>: 11 02                      dup.x64 sp(2)
	<.main+10241 @063f65>: 1f b0 ef 05 00             load.ref <@05efb0> ;Math.max(data: float64[]): float64
	<.main+10246 @063f6a>: 02                         call
	<.main+10247 @063f6b>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10250 @063f6e>: 09 f0 ff ff                inc.sp(-16)
	<.main+10254 @063f72>: 23 00 16 06                store.m64 <@061600> ;testMathMax_nan
	cmplStd/test/std/test.math.ci:41: (110 bytes: <.main+10258 @063f76> - <.main+10368 @063fe4>): static testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+10258 @063f76>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10267 @063f7f>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10276 @063f88>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10285 @063f91>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10294 @063f9a>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10303 @063fa3>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10312 @063fac>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10321 @063fb5>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10330 @063fbe>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10339 @063fc7>: 1c 09 00 00 00             load.c32 9
	<.main+10344 @063fcc>: 0a 04 00 00                load.sp(+4)
	<.main+10348 @063fd0>: 1a                         load.z64
	<.main+10349 @063fd1>: 11 02                      dup.x64 sp(2)
	<.main+10351 @063fd3>: 1f b0 ef 05 00             load.ref <@05efb0> ;Math.max(data: float64[]): float64
	<.main+10356 @063fd8>: 02                         call
	<.main+10357 @063fd9>: 17 16 02                   mov.x64 sp(22, 2)
	<.main+10360 @063fdc>: 09 a8 ff ff                inc.sp(-88)
	<.main+10364 @063fe0>: 23 08 16 06                store.m64 <@061608> ;testMathMax_9
	cmplStd/test/std/test.math.ci:43: (25 bytes: <.main+10368 @063fe4> - <.main+10393 @063ffd>): static testMathSum_0: float64 := Math.sum()
	<.main+10368 @063fe4>: 19                         load.z32
	<.main+10369 @063fe5>: 0a 04 00 00                load.sp(+4)
	<.main+10373 @063fe9>: 1a                         load.z64
	<.main+10374 @063fea>: 11 02                      dup.x64 sp(2)
	<.main+10376 @063fec>: 1f 00 f0 05 00             load.ref <@05f000> ;Math.sum(data: float64[]): float64
	<.main+10381 @063ff1>: 02                         call
	<.main+10382 @063ff2>: 17 04 02                   mov.x64 sp(4, 2)
	<.main+10385 @063ff5>: 09 f0 ff ff                inc.sp(-16)
	<.main+10389 @063ff9>: 23 10 16 06                store.m64 <@061610> ;testMathSum_0
	cmplStd/test/std/test.math.ci:44: (38 bytes: <.main+10393 @063ffd> - <.main+10431 @064023>): static testMathSum_1: float64 := Math.sum(1)
	<.main+10393 @063ffd>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10402 @064006>: 1c 01 00 00 00             load.c32 1
	<.main+10407 @06400b>: 0a 04 00 00                load.sp(+4)
	<.main+10411 @06400f>: 1a                         load.z64
	<.main+10412 @064010>: 11 02                      dup.x64 sp(2)
	<.main+10414 @064012>: 1f 00 f0 05 00             load.ref <@05f000> ;Math.sum(data: float64[]): float64
	<.main+10419 @064017>: 02                         call
	<.main+10420 @064018>: 17 06 02                   mov.x64 sp(6, 2)
	<.main+10423 @06401b>: 09 e8 ff ff                inc.sp(-24)
	<.main+10427 @06401f>: 23 18 16 06                store.m64 <@061618> ;testMathSum_1
	cmplStd/test/std/test.math.ci:45: (47 bytes: <.main+10431 @064023> - <.main+10478 @064052>): static testMathSum_3: float64 := Math.sum(1, 2)
	<.main+10431 @064023>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10440 @06402c>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10449 @064035>: 1c 02 00 00 00             load.c32 2
	<.main+10454 @06403a>: 0a 04 00 00                load.sp(+4)
	<.main+10458 @06403e>: 1a                         load.z64
	<.main+10459 @06403f>: 11 02                      dup.x64 sp(2)
	<.main+10461 @064041>: 1f 00 f0 05 00             load.ref <@05f000> ;Math.sum(data: float64[]): float64
	<.main+10466 @064046>: 02                         call
	<.main+10467 @064047>: 17 08 02                   mov.x64 sp(8, 2)
	<.main+10470 @06404a>: 09 e0 ff ff                inc.sp(-32)
	<.main+10474 @06404e>: 23 20 16 06                store.m64 <@061620> ;testMathSum_3
	cmplStd/test/std/test.math.ci:46: (119 bytes: <.main+10478 @064052> - <.main+10597 @0640c9>): static testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+10478 @064052>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10487 @06405b>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+10496 @064064>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+10505 @06406d>: 8f 00 00 00 00 00 00 1c 40 load.f64 7.000000
	<.main+10514 @064076>: 8f 00 00 00 00 00 00 18 40 load.f64 6.000000
	<.main+10523 @06407f>: 8f 00 00 00 00 00 00 14 40 load.f64 5.000000
	<.main+10532 @064088>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+10541 @064091>: 8f 00 00 00 00 00 00 08 40 load.f64 3.000000
	<.main+10550 @06409a>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10559 @0640a3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10568 @0640ac>: 1c 0a 00 00 00             load.c32 10
	<.main+10573 @0640b1>: 0a 04 00 00                load.sp(+4)
	<.main+10577 @0640b5>: 1a                         load.z64
	<.main+10578 @0640b6>: 11 02                      dup.x64 sp(2)
	<.main+10580 @0640b8>: 1f 00 f0 05 00             load.ref <@05f000> ;Math.sum(data: float64[]): float64
	<.main+10585 @0640bd>: 02                         call
	<.main+10586 @0640be>: 17 18 02                   mov.x64 sp(24, 2)
	<.main+10589 @0640c1>: 09 a0 ff ff                inc.sp(-96)
	<.main+10593 @0640c5>: 23 28 16 06                store.m64 <@061628> ;testMathSum_55
	cmplStd/test/std/test.math.ci:48: (13 bytes: <.main+10597 @0640c9> - <.main+10610 @0640d6>): static testMathEval_x: float64 := 10
	<.main+10597 @0640c9>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+10606 @0640d2>: 23 30 16 06                store.m64 <@061630> ;testMathEval_x
	cmplStd/test/std/test.math.ci:49: (29 bytes: <.main+10610 @0640d6> - <.main+10639 @0640f3>): static testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+10610 @0640d6>: 19                         load.z32
	<.main+10611 @0640d7>: 0a 04 00 00                load.sp(+4)
	<.main+10615 @0640db>: 1a                         load.z64
	<.main+10616 @0640dc>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10620 @0640e0>: 11 04                      dup.x64 sp(4)
	<.main+10622 @0640e2>: 1f 40 f0 05 00             load.ref <@05f040> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10627 @0640e7>: 02                         call
	<.main+10628 @0640e8>: 17 06 04                   mov.x64 sp(6, 4)
	<.main+10631 @0640eb>: 09 e8 ff ff                inc.sp(-24)
	<.main+10635 @0640ef>: 23 38 16 06                store.m64 <@061638> ;testMathEval_0
	cmplStd/test/std/test.math.ci:50: (13 bytes: <.main+10639 @0640f3> - <.main+10652 @064100>): static testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+10639 @0640f3>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10648 @0640fc>: 23 40 16 06                store.m64 <@061640> ;testMathEval_1
	cmplStd/test/std/test.math.ci:51: (28 bytes: <.main+10652 @064100> - <.main+10680 @06411c>): static testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+10652 @064100>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10661 @064109>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10665 @06410d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10674 @064116>: 83                         mul.f64
	<.main+10675 @064117>: 81                         add.f64
	<.main+10676 @064118>: 23 48 16 06                store.m64 <@061648> ;testMathEval_2
	cmplStd/test/std/test.math.ci:52: (45 bytes: <.main+10680 @06411c> - <.main+10725 @064149>): static testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+10680 @06411c>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10684 @064120>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10693 @064129>: 11 02                      dup.x64 sp(2)
	<.main+10695 @06412b>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10704 @064134>: 11 06                      dup.x64 sp(6)
	<.main+10706 @064136>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10715 @06413f>: 83                         mul.f64
	<.main+10716 @064140>: 81                         add.f64
	<.main+10717 @064141>: 83                         mul.f64
	<.main+10718 @064142>: 81                         add.f64
	<.main+10719 @064143>: 14 02                      set.x64 sp(2)
	<.main+10721 @064145>: 23 50 16 06                store.m64 <@061650> ;testMathEval_3
	cmplStd/test/std/test.math.ci:53: (62 bytes: <.main+10725 @064149> - <.main+10787 @064187>): static testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10725 @064149>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10729 @06414d>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10738 @064156>: 11 02                      dup.x64 sp(2)
	<.main+10740 @064158>: 11 04                      dup.x64 sp(4)
	<.main+10742 @06415a>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10751 @064163>: 11 02                      dup.x64 sp(2)
	<.main+10753 @064165>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10762 @06416e>: 11 06                      dup.x64 sp(6)
	<.main+10764 @064170>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10773 @064179>: 83                         mul.f64
	<.main+10774 @06417a>: 81                         add.f64
	<.main+10775 @06417b>: 83                         mul.f64
	<.main+10776 @06417c>: 81                         add.f64
	<.main+10777 @06417d>: 14 02                      set.x64 sp(2)
	<.main+10779 @06417f>: 83                         mul.f64
	<.main+10780 @064180>: 81                         add.f64
	<.main+10781 @064181>: 14 02                      set.x64 sp(2)
	<.main+10783 @064183>: 23 58 16 06                store.m64 <@061658> ;testMathEval_4
	cmplStd/test/std/test.math.ci:54: (78 bytes: <.main+10787 @064187> - <.main+10865 @0641d5>): static testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10787 @064187>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10796 @064190>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10805 @064199>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10814 @0641a2>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10823 @0641ab>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10832 @0641b4>: 1c 05 00 00 00             load.c32 5
	<.main+10837 @0641b9>: 0a 04 00 00                load.sp(+4)
	<.main+10841 @0641bd>: 1a                         load.z64
	<.main+10842 @0641be>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10846 @0641c2>: 11 04                      dup.x64 sp(4)
	<.main+10848 @0641c4>: 1f 40 f0 05 00             load.ref <@05f040> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10853 @0641c9>: 02                         call
	<.main+10854 @0641ca>: 17 10 04                   mov.x64 sp(16, 4)
	<.main+10857 @0641cd>: 09 c0 ff ff                inc.sp(-64)
	<.main+10861 @0641d1>: 23 60 16 06                store.m64 <@061660> ;testMathEval_5
	cmplStd/test/std/test.math.ci:55: (87 bytes: <.main+10865 @0641d5> - <.main+10952 @06422c>): static testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+10865 @0641d5>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10874 @0641de>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10883 @0641e7>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10892 @0641f0>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10901 @0641f9>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10910 @064202>: 8f 00 00 00 00 00 00 f0 3f load.f64 1.000000
	<.main+10919 @06420b>: 1c 06 00 00 00             load.c32 6
	<.main+10924 @064210>: 0a 04 00 00                load.sp(+4)
	<.main+10928 @064214>: 1a                         load.z64
	<.main+10929 @064215>: 21 30 16 06                load.m64 <@061630> ;testMathEval_x
	<.main+10933 @064219>: 11 04                      dup.x64 sp(4)
	<.main+10935 @06421b>: 1f 40 f0 05 00             load.ref <@05f040> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+10940 @064220>: 02                         call
	<.main+10941 @064221>: 17 12 04                   mov.x64 sp(18, 4)
	<.main+10944 @064224>: 09 b8 ff ff                inc.sp(-72)
	<.main+10948 @064228>: 23 68 16 06                store.m64 <@061668> ;testMathEval_6
	cmplStd/test/std/test.math.ci:57: (35 bytes: <.main+10952 @06422c> - <.main+10987 @06424f>): static testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+10952 @06422c>: 1a                         load.z64
	<.main+10953 @06422d>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10962 @064236>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+10971 @06423f>: 84                         div.f64
	<.main+10972 @064240>: 19                         load.z32
	<.main+10973 @064241>: 1f f0 f0 05 00             load.ref <@05f0f0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+10978 @064246>: 02                         call
	<.main+10979 @064247>: 09 f4 ff ff                inc.sp(-12)
	<.main+10983 @06424b>: 23 70 16 06                store.m64 <@061670> ;testMathSin_f64
	cmplStd/test/std/test.math.ci:58: (49 bytes: <.main+10987 @06424f> - <.main+11036 @064280>): static testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+10987 @06424f>: 1b                         load.z128
	<.main+10988 @064250>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+10997 @064259>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11006 @064262>: 84                         div.f64
	<.main+11007 @064263>: 1f 68 ee 05 00             load.ref <@05ee68> ;Math.abs(x: float64): float64
	<.main+11012 @064268>: 02                         call
	<.main+11013 @064269>: 09 f8 ff ff                inc.sp(-8)
	<.main+11017 @06426d>: 1c 01 00 00 00             load.c32 1
	<.main+11022 @064272>: 1f f0 f0 05 00             load.ref <@05f0f0> ;Math.sinCos(arg: float64, quad: int32): float64
	<.main+11027 @064277>: 02                         call
	<.main+11028 @064278>: 09 f4 ff ff                inc.sp(-12)
	<.main+11032 @06427c>: 23 78 16 06                store.m64 <@061678> ;testMathCos_f64
	cmplStd/test/std/test.math.ci:59: (34 bytes: <.main+11036 @064280> - <.main+11070 @0642a2>): static testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+11036 @064280>: 1a                         load.z64
	<.main+11037 @064281>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11046 @06428a>: 8f 00 00 00 00 00 00 10 40 load.f64 4.000000
	<.main+11055 @064293>: 84                         div.f64
	<.main+11056 @064294>: 1f 40 f2 05 00             load.ref <@05f240> ;Math.tan(arg: float64): float64
	<.main+11061 @064299>: 02                         call
	<.main+11062 @06429a>: 09 f8 ff ff                inc.sp(-8)
	<.main+11066 @06429e>: 23 80 16 06                store.m64 <@061680> ;testMathTan_f64
	cmplStd/test/std/test.math.ci:60: (34 bytes: <.main+11070 @0642a2> - <.main+11104 @0642c4>): static testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+11070 @0642a2>: 1a                         load.z64
	<.main+11071 @0642a3>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11080 @0642ac>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11089 @0642b5>: 84                         div.f64
	<.main+11090 @0642b6>: 1f c0 f3 05 00             load.ref <@05f3c0> ;Math.sinh(x: float64): float64
	<.main+11095 @0642bb>: 02                         call
	<.main+11096 @0642bc>: 09 f8 ff ff                inc.sp(-8)
	<.main+11100 @0642c0>: 23 88 16 06                store.m64 <@061688> ;testMathSinh_f64
	cmplStd/test/std/test.math.ci:61: (34 bytes: <.main+11104 @0642c4> - <.main+11138 @0642e6>): static testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+11104 @0642c4>: 1a                         load.z64
	<.main+11105 @0642c5>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11114 @0642ce>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11123 @0642d7>: 84                         div.f64
	<.main+11124 @0642d8>: 1f b8 f4 05 00             load.ref <@05f4b8> ;Math.cosh(x: float64): float64
	<.main+11129 @0642dd>: 02                         call
	<.main+11130 @0642de>: 09 f8 ff ff                inc.sp(-8)
	<.main+11134 @0642e2>: 23 90 16 06                store.m64 <@061690> ;testMathCosh_f64
	cmplStd/test/std/test.math.ci:63: (24 bytes: <.main+11138 @0642e6> - <.main+11162 @0642fe>): static testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+11138 @0642e6>: 1a                         load.z64
	<.main+11139 @0642e7>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11148 @0642f0>: 1f 08 f5 05 00             load.ref <@05f508> ;Math.asin(x: float64): float64
	<.main+11153 @0642f5>: 02                         call
	<.main+11154 @0642f6>: 09 f8 ff ff                inc.sp(-8)
	<.main+11158 @0642fa>: 23 98 16 06                store.m64 <@061698> ;testMathAsin_f64
	cmplStd/test/std/test.math.ci:64: (44 bytes: <.main+11162 @0642fe> - <.main+11206 @06432a>): static testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+11162 @0642fe>: 8f 18 2d 44 54 fb 21 09 40 load.f64 3.141593
	<.main+11171 @064307>: 8f 00 00 00 00 00 00 00 40 load.f64 2.000000
	<.main+11180 @064310>: 84                         div.f64
	<.main+11181 @064311>: 1a                         load.z64
	<.main+11182 @064312>: 8f 9a 99 99 99 99 99 c9 3f load.f64 0.200000
	<.main+11191 @06431b>: 1f 08 f5 05 00             load.ref <@05f508> ;Math.asin(x: float64): float64
	<.main+11196 @064320>: 02                         call
	<.main+11197 @064321>: 09 f8 ff ff                inc.sp(-8)
	<.main+11201 @064325>: 82                         sub.f64
	<.main+11202 @064326>: 23 a0 16 06                store.m64 <@0616a0> ;testMathAcos_f64
	cmplStd/test/std/test.math.ci:67: (34 bytes: <.main+11206 @06432a> - <.main+11240 @06434c>): static testMathCmp_f32: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11206 @06432a>: 19                         load.z32
	<.main+11207 @06432b>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11212 @064330>: 7f 9c 53 49 37             load.f32 0.000012
	<.main+11217 @064335>: 7f ac c5 27 37             load.f32 0.000010
	<.main+11222 @06433a>: 1f 70 f0 05 00             load.ref <@05f070> ;Math.cmp(a: float32, b: float32, eps: float32): int32
	<.main+11227 @06433f>: 02                         call
	<.main+11228 @064340>: 09 f4 ff ff                inc.sp(-12)
	<.main+11232 @064344>: 19                         load.z32
	<.main+11233 @064345>: 57                         ceq.i32
	<.main+11234 @064346>: 1f a8 16 06 00             load.ref <@0616a8> ;testMathCmp_f32
	<.main+11239 @06434b>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:68: (46 bytes: <.main+11240 @06434c> - <.main+11286 @06437a>): static testMathCmp_f64: bool := Math.cmp(0.000010, 0.000012, 0.000010) == 0
	<.main+11240 @06434c>: 19                         load.z32
	<.main+11241 @06434d>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11250 @064356>: 8f 54 e4 10 71 73 2a e9 3e load.f64 0.000012
	<.main+11259 @06435f>: 8f f1 68 e3 88 b5 f8 e4 3e load.f64 0.000010
	<.main+11268 @064368>: 1f b0 f0 05 00             load.ref <@05f0b0> ;Math.cmp(a: float64, b: float64, eps: float64): int32
	<.main+11273 @06436d>: 02                         call
	<.main+11274 @06436e>: 09 e8 ff ff                inc.sp(-24)
	<.main+11278 @064372>: 19                         load.z32
	<.main+11279 @064373>: 57                         ceq.i32
	<.main+11280 @064374>: 1f b0 16 06 00             load.ref <@0616b0> ;testMathCmp_f64
	<.main+11285 @064379>: 2b                         store.i8
	cmplStd/test/std/test.math.ci:70: (33 bytes: <.main+11286 @06437a> - <.main+11319 @06439b>): static testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+11286 @06437a>: 1a                         load.z64
	<.main+11287 @06437b>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11296 @064384>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11305 @06438d>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11310 @064392>: 02                         call
	<.main+11311 @064393>: 09 f0 ff ff                inc.sp(-16)
	<.main+11315 @064397>: 23 b8 16 06                store.m64 <@0616b8> ;testMathAbsMod_f64_0a
	cmplStd/test/std/test.math.ci:71: (24 bytes: <.main+11319 @06439b> - <.main+11343 @0643b3>): static testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+11319 @06439b>: 1b                         load.z128
	<.main+11320 @06439c>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11329 @0643a5>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11334 @0643aa>: 02                         call
	<.main+11335 @0643ab>: 09 f0 ff ff                inc.sp(-16)
	<.main+11339 @0643af>: 23 c0 16 06                store.m64 <@0616c0> ;testMathAbsMod_f64_0b
	cmplStd/test/std/test.math.ci:72: (33 bytes: <.main+11343 @0643b3> - <.main+11376 @0643d4>): static testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+11343 @0643b3>: 1a                         load.z64
	<.main+11344 @0643b4>: 8f 00 00 00 00 00 00 24 c0 load.f64 -10.000000
	<.main+11353 @0643bd>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11362 @0643c6>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11367 @0643cb>: 02                         call
	<.main+11368 @0643cc>: 09 f0 ff ff                inc.sp(-16)
	<.main+11372 @0643d0>: 23 c8 16 06                store.m64 <@0616c8> ;testMathAbsMod_f64_0c
	cmplStd/test/std/test.math.ci:74: (33 bytes: <.main+11376 @0643d4> - <.main+11409 @0643f5>): static testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+11376 @0643d4>: 1a                         load.z64
	<.main+11377 @0643d5>: 8f 00 00 00 00 00 00 33 40 load.f64 19.000000
	<.main+11386 @0643de>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11395 @0643e7>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11400 @0643ec>: 02                         call
	<.main+11401 @0643ed>: 09 f0 ff ff                inc.sp(-16)
	<.main+11405 @0643f1>: 23 d0 16 06                store.m64 <@0616d0> ;testMathAbsMod_f64_9a
	cmplStd/test/std/test.math.ci:75: (33 bytes: <.main+11409 @0643f5> - <.main+11442 @064416>): static testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+11409 @0643f5>: 1a                         load.z64
	<.main+11410 @0643f6>: 8f 00 00 00 00 00 00 22 40 load.f64 9.000000
	<.main+11419 @0643ff>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11428 @064408>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11433 @06440d>: 02                         call
	<.main+11434 @06440e>: 09 f0 ff ff                inc.sp(-16)
	<.main+11438 @064412>: 23 d8 16 06                store.m64 <@0616d8> ;testMathAbsMod_f64_9b
	cmplStd/test/std/test.math.ci:76: (33 bytes: <.main+11442 @064416> - <.main+11475 @064437>): static testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+11442 @064416>: 1a                         load.z64
	<.main+11443 @064417>: 8f 00 00 00 00 00 00 f0 bf load.f64 -1.000000
	<.main+11452 @064420>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11461 @064429>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11466 @06442e>: 02                         call
	<.main+11467 @06442f>: 09 f0 ff ff                inc.sp(-16)
	<.main+11471 @064433>: 23 e0 16 06                store.m64 <@0616e0> ;testMathAbsMod_f64_9c
	cmplStd/test/std/test.math.ci:77: (33 bytes: <.main+11475 @064437> - <.main+11508 @064458>): static testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+11475 @064437>: 1a                         load.z64
	<.main+11476 @064438>: 8f 00 00 00 00 00 00 26 c0 load.f64 -11.000000
	<.main+11485 @064441>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11494 @06444a>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11499 @06444f>: 02                         call
	<.main+11500 @064450>: 09 f0 ff ff                inc.sp(-16)
	<.main+11504 @064454>: 23 e8 16 06                store.m64 <@0616e8> ;testMathAbsMod_f64_9d
	cmplStd/test/std/test.math.ci:79: (33 bytes: <.main+11508 @064458> - <.main+11541 @064479>): static testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+11508 @064458>: 1a                         load.z64
	<.main+11509 @064459>: 8f 00 00 00 00 00 00 32 40 load.f64 18.000000
	<.main+11518 @064462>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11527 @06446b>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11532 @064470>: 02                         call
	<.main+11533 @064471>: 09 f0 ff ff                inc.sp(-16)
	<.main+11537 @064475>: 23 f0 16 06                store.m64 <@0616f0> ;testMathAbsMod_f64_8a
	cmplStd/test/std/test.math.ci:80: (33 bytes: <.main+11541 @064479> - <.main+11574 @06449a>): static testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+11541 @064479>: 1a                         load.z64
	<.main+11542 @06447a>: 8f 00 00 00 00 00 00 20 40 load.f64 8.000000
	<.main+11551 @064483>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11560 @06448c>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11565 @064491>: 02                         call
	<.main+11566 @064492>: 09 f0 ff ff                inc.sp(-16)
	<.main+11570 @064496>: 23 f8 16 06                store.m64 <@0616f8> ;testMathAbsMod_f64_8b
	cmplStd/test/std/test.math.ci:81: (33 bytes: <.main+11574 @06449a> - <.main+11607 @0644bb>): static testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+11574 @06449a>: 1a                         load.z64
	<.main+11575 @06449b>: 8f 00 00 00 00 00 00 00 c0 load.f64 -2.000000
	<.main+11584 @0644a4>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11593 @0644ad>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11598 @0644b2>: 02                         call
	<.main+11599 @0644b3>: 09 f0 ff ff                inc.sp(-16)
	<.main+11603 @0644b7>: 23 00 17 06                store.m64 <@061700> ;testMathAbsMod_f64_8c
	cmplStd/test/std/test.math.ci:82: (33 bytes: <.main+11607 @0644bb> - <.main+11640 @0644dc>): static testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+11607 @0644bb>: 1a                         load.z64
	<.main+11608 @0644bc>: 8f 00 00 00 00 00 00 28 c0 load.f64 -12.000000
	<.main+11617 @0644c5>: 8f 00 00 00 00 00 00 24 40 load.f64 10.000000
	<.main+11626 @0644ce>: 1f a0 ee 05 00             load.ref <@05eea0> ;Math.absMod(val: float64, mod: float64): float64
	<.main+11631 @0644d3>: 02                         call
	<.main+11632 @0644d4>: 09 f0 ff ff                inc.sp(-16)
	<.main+11636 @0644d8>: 23 08 17 06                store.m64 <@061708> ;testMathAbsMod_f64_8d
	cmplStd/test/std/test.math.ci:84: (25 bytes: <.main+11640 @0644dc> - <.main+11665 @0644f5>): static testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+11640 @0644dc>: 19                         load.z32
	<.main+11641 @0644dd>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11646 @0644e2>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11651 @0644e7>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11656 @0644ec>: 02                         call
	<.main+11657 @0644ed>: 09 f8 ff ff                inc.sp(-8)
	<.main+11661 @0644f1>: 24 10 17 06                store.m32 <@061710> ;testMathAbsMod_f32_0a
	cmplStd/test/std/test.math.ci:85: (21 bytes: <.main+11665 @0644f5> - <.main+11686 @06450a>): static testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+11665 @0644f5>: 19                         load.z32
	<.main+11666 @0644f6>: 19                         load.z32
	<.main+11667 @0644f7>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11672 @0644fc>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11677 @064501>: 02                         call
	<.main+11678 @064502>: 09 f8 ff ff                inc.sp(-8)
	<.main+11682 @064506>: 24 18 17 06                store.m32 <@061718> ;testMathAbsMod_f32_0b
	cmplStd/test/std/test.math.ci:86: (25 bytes: <.main+11686 @06450a> - <.main+11711 @064523>): static testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+11686 @06450a>: 19                         load.z32
	<.main+11687 @06450b>: 7f 00 00 20 c1             load.f32 -10.000000
	<.main+11692 @064510>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11697 @064515>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11702 @06451a>: 02                         call
	<.main+11703 @06451b>: 09 f8 ff ff                inc.sp(-8)
	<.main+11707 @06451f>: 24 20 17 06                store.m32 <@061720> ;testMathAbsMod_f32_0c
	cmplStd/test/std/test.math.ci:88: (25 bytes: <.main+11711 @064523> - <.main+11736 @06453c>): static testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+11711 @064523>: 19                         load.z32
	<.main+11712 @064524>: 7f 00 00 98 41             load.f32 19.000000
	<.main+11717 @064529>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11722 @06452e>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11727 @064533>: 02                         call
	<.main+11728 @064534>: 09 f8 ff ff                inc.sp(-8)
	<.main+11732 @064538>: 24 28 17 06                store.m32 <@061728> ;testMathAbsMod_f32_9a
	cmplStd/test/std/test.math.ci:89: (25 bytes: <.main+11736 @06453c> - <.main+11761 @064555>): static testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+11736 @06453c>: 19                         load.z32
	<.main+11737 @06453d>: 7f 00 00 10 41             load.f32 9.000000
	<.main+11742 @064542>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11747 @064547>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11752 @06454c>: 02                         call
	<.main+11753 @06454d>: 09 f8 ff ff                inc.sp(-8)
	<.main+11757 @064551>: 24 30 17 06                store.m32 <@061730> ;testMathAbsMod_f32_9b
	cmplStd/test/std/test.math.ci:90: (25 bytes: <.main+11761 @064555> - <.main+11786 @06456e>): static testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+11761 @064555>: 19                         load.z32
	<.main+11762 @064556>: 7f 00 00 80 bf             load.f32 -1.000000
	<.main+11767 @06455b>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11772 @064560>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11777 @064565>: 02                         call
	<.main+11778 @064566>: 09 f8 ff ff                inc.sp(-8)
	<.main+11782 @06456a>: 24 38 17 06                store.m32 <@061738> ;testMathAbsMod_f32_9c
	cmplStd/test/std/test.math.ci:91: (25 bytes: <.main+11786 @06456e> - <.main+11811 @064587>): static testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+11786 @06456e>: 19                         load.z32
	<.main+11787 @06456f>: 7f 00 00 30 c1             load.f32 -11.000000
	<.main+11792 @064574>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11797 @064579>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11802 @06457e>: 02                         call
	<.main+11803 @06457f>: 09 f8 ff ff                inc.sp(-8)
	<.main+11807 @064583>: 24 40 17 06                store.m32 <@061740> ;testMathAbsMod_f32_9d
	cmplStd/test/std/test.math.ci:93: (25 bytes: <.main+11811 @064587> - <.main+11836 @0645a0>): static testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+11811 @064587>: 19                         load.z32
	<.main+11812 @064588>: 7f 00 00 90 41             load.f32 18.000000
	<.main+11817 @06458d>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11822 @064592>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11827 @064597>: 02                         call
	<.main+11828 @064598>: 09 f8 ff ff                inc.sp(-8)
	<.main+11832 @06459c>: 24 48 17 06                store.m32 <@061748> ;testMathAbsMod_f32_8a
	cmplStd/test/std/test.math.ci:94: (25 bytes: <.main+11836 @0645a0> - <.main+11861 @0645b9>): static testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+11836 @0645a0>: 19                         load.z32
	<.main+11837 @0645a1>: 7f 00 00 00 41             load.f32 8.000000
	<.main+11842 @0645a6>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11847 @0645ab>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11852 @0645b0>: 02                         call
	<.main+11853 @0645b1>: 09 f8 ff ff                inc.sp(-8)
	<.main+11857 @0645b5>: 24 50 17 06                store.m32 <@061750> ;testMathAbsMod_f32_8b
	cmplStd/test/std/test.math.ci:95: (25 bytes: <.main+11861 @0645b9> - <.main+11886 @0645d2>): static testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+11861 @0645b9>: 19                         load.z32
	<.main+11862 @0645ba>: 7f 00 00 00 c0             load.f32 -2.000000
	<.main+11867 @0645bf>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11872 @0645c4>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11877 @0645c9>: 02                         call
	<.main+11878 @0645ca>: 09 f8 ff ff                inc.sp(-8)
	<.main+11882 @0645ce>: 24 58 17 06                store.m32 <@061758> ;testMathAbsMod_f32_8c
	cmplStd/test/std/test.math.ci:96: (25 bytes: <.main+11886 @0645d2> - <.main+11911 @0645eb>): static testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+11886 @0645d2>: 19                         load.z32
	<.main+11887 @0645d3>: 7f 00 00 40 c1             load.f32 -12.000000
	<.main+11892 @0645d8>: 7f 00 00 20 41             load.f32 10.000000
	<.main+11897 @0645dd>: 1f 80 ee 05 00             load.ref <@05ee80> ;Math.absMod(val: float32, mod: float32): float32
	<.main+11902 @0645e2>: 02                         call
	<.main+11903 @0645e3>: 09 f8 ff ff                inc.sp(-8)
	<.main+11907 @0645e7>: 24 60 17 06                store.m32 <@061760> ;testMathAbsMod_f32_8d
	cmplStd/test/std/memory.ci:13: (18 bytes: <.main+11911 @0645eb> - <.main+11929 @0645fd>): pointer.fill(p1, 0, 1024);
	<.main+11911 @0645eb>: 20 68 05 06                load.m32 <@060568> ;p1
	<.main+11915 @0645ef>: 19                         load.z32
	<.main+11916 @0645f0>: 1c 00 04 00 00             load.c32 1024
	<.main+11921 @0645f5>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+11925 @0645f9>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:14: (21 bytes: <.main+11929 @0645fd> - <.main+11950 @064612>): pointer.copy(p1, p3, 160);
	<.main+11929 @0645fd>: 20 68 05 06                load.m32 <@060568> ;p1
	<.main+11933 @064601>: 20 78 05 06                load.m32 <@060578> ;p3
	<.main+11937 @064605>: 1c a0 00 00 00             load.c32 160
	<.main+11942 @06460a>: 01 0c 00 00                nfc(12) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+11946 @06460e>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:17: (13 bytes: <.main+11950 @064612> - <.main+11963 @06461f>): free(p1);
	<.main+11950 @064612>: 20 68 05 06                load.m32 <@060568> ;p1
	<.main+11954 @064616>: 19                         load.z32
	<.main+11955 @064617>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11959 @06461b>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:18: (13 bytes: <.main+11963 @06461f> - <.main+11976 @06462c>): free(p2);
	<.main+11963 @06461f>: 20 70 05 06                load.m32 <@060570> ;p2
	<.main+11967 @064623>: 19                         load.z32
	<.main+11968 @064624>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11972 @064628>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:19: (13 bytes: <.main+11976 @06462c> - <.main+11989 @064639>): free(p3);
	<.main+11976 @06462c>: 20 78 05 06                load.m32 <@060578> ;p3
	<.main+11980 @064630>: 19                         load.z32
	<.main+11981 @064631>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11985 @064635>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:20: (13 bytes: <.main+11989 @064639> - <.main+12002 @064646>): free(p4);
	<.main+11989 @064639>: 20 80 05 06                load.m32 <@060580> ;p4
	<.main+11993 @06463d>: 19                         load.z32
	<.main+11994 @06463e>: 01 0a 00 00                nfc(10) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+11998 @064642>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:26: (35 bytes: <.main+12002 @064646> - <.main+12037 @064669>): debug("val1", val1);
	<.main+12002 @064646>: 1f 38 0d 04 00             load.ref <@040d38> ;"cmplStd/test/std/memory.ci"
	<.main+12007 @06464b>: 1c 1a 00 00 00             load.c32 26
	<.main+12012 @064650>: 1c 0e 00 00 00             load.c32 14
	<.main+12017 @064655>: 19                         load.z32
	<.main+12018 @064656>: 1f 67 0d 04 00             load.ref <@040d67> ;"val1"
	<.main+12023 @06465b>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12028 @064660>: 1f 88 05 06 00             load.ref <@060588> ;val1
	<.main+12033 @064665>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:27: (35 bytes: <.main+12037 @064669> - <.main+12072 @06468c>): debug("val2", val2);
	<.main+12037 @064669>: 1f 38 0d 04 00             load.ref <@040d38> ;"cmplStd/test/std/memory.ci"
	<.main+12042 @06466e>: 1c 1b 00 00 00             load.c32 27
	<.main+12047 @064673>: 1c 0e 00 00 00             load.c32 14
	<.main+12052 @064678>: 19                         load.z32
	<.main+12053 @064679>: 1f 6c 0d 04 00             load.ref <@040d6c> ;"val2"
	<.main+12058 @06467e>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12063 @064683>: 1f 90 05 06 00             load.ref <@060590> ;val2
	<.main+12068 @064688>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:29: (22 bytes: <.main+12072 @06468c> - <.main+12094 @0646a2>): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+12072 @06468c>: 1f 90 05 06 00             load.ref <@060590> ;val2
	<.main+12077 @064691>: 1f 88 05 06 00             load.ref <@060588> ;val1
	<.main+12082 @064696>: 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+12086 @06469a>: 01 0d 00 00                nfc(13) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+12090 @06469e>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:30: (18 bytes: <.main+12094 @0646a2> - <.main+12112 @0646b4>): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+12094 @0646a2>: 1f 88 05 06 00             load.ref <@060588> ;val1
	<.main+12099 @0646a7>: 19                         load.z32
	<.main+12100 @0646a8>: 20 c8 04 00                load.m32 <@0004c8> ;int64+32
	<.main+12104 @0646ac>: 01 0b 00 00                nfc(11) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+12108 @0646b0>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/std/memory.ci:32: (35 bytes: <.main+12112 @0646b4> - <.main+12147 @0646d7>): debug("val1", val1);
	<.main+12112 @0646b4>: 1f 38 0d 04 00             load.ref <@040d38> ;"cmplStd/test/std/memory.ci"
	<.main+12117 @0646b9>: 1c 20 00 00 00             load.c32 32
	<.main+12122 @0646be>: 1c 0e 00 00 00             load.c32 14
	<.main+12127 @0646c3>: 19                         load.z32
	<.main+12128 @0646c4>: 1f 67 0d 04 00             load.ref <@040d67> ;"val1"
	<.main+12133 @0646c9>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12138 @0646ce>: 1f 88 05 06 00             load.ref <@060588> ;val1
	<.main+12143 @0646d3>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/std/memory.ci:33: (35 bytes: <.main+12147 @0646d7> - <.main+12182 @0646fa>): debug("val2", val2);
	<.main+12147 @0646d7>: 1f 38 0d 04 00             load.ref <@040d38> ;"cmplStd/test/std/memory.ci"
	<.main+12152 @0646dc>: 1c 21 00 00 00             load.c32 33
	<.main+12157 @0646e1>: 1c 0e 00 00 00             load.c32 14
	<.main+12162 @0646e6>: 19                         load.z32
	<.main+12163 @0646e7>: 1f 6c 0d 04 00             load.ref <@040d6c> ;"val2"
	<.main+12168 @0646ec>: 1f a8 04 00 00             load.ref <@0004a8> ;int64
	<.main+12173 @0646f1>: 1f 90 05 06 00             load.ref <@060590> ;val2
	<.main+12178 @0646f6>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.method.ci:78: (21 bytes: <.main+12182 @0646fa> - <.main+12203 @06470f>): recordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+12182 @0646fa>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12186 @0646fe>: 1c 01 00 00 00             load.c32 1
	<.main+12191 @064703>: 13 04                      set.x32 sp(4)
	<.main+12193 @064705>: 1f 20 0b 06 00             load.ref <@060b20> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12198 @06470a>: 02                         call
	<.main+12199 @06470b>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:79: (20 bytes: <.main+12203 @06470f> - <.main+12223 @064723>): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+12203 @06470f>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12207 @064713>: 1c 01 00 00 00             load.c32 1
	<.main+12212 @064718>: 13 04                      set.x32 sp(4)
	<.main+12214 @06471a>: 20 d0 0b 06                load.m32 <@060bd0> ;recordMethodTest+8
	<.main+12218 @06471e>: 02                         call
	<.main+12219 @06471f>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:97: (19 bytes: <.main+12223 @064723> - <.main+12242 @064736>): staticMethod(recordMethodTest, 2);
	<.main+12223 @064723>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12227 @064727>: 1c 02 00 00 00             load.c32 2
	<.main+12232 @06472c>: 1f d8 0b 06 00             load.ref <@060bd8> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12237 @064731>: 02                         call
	<.main+12238 @064732>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (19 bytes: <.main+12242 @064736> - <.main+12261 @064749>): virtualMethod(recordMethodTest, 2);
	<.main+12242 @064736>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12246 @06473a>: 1c 02 00 00 00             load.c32 2
	<.main+12251 @06473f>: 1f 20 0c 06 00             load.ref <@060c20> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12256 @064744>: 02                         call
	<.main+12257 @064745>: 09 ec ff ff                inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (21 bytes: <.main+12261 @064749> - <.main+12282 @06475e>): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+12261 @064749>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12265 @06474d>: 1c 03 00 00 00             load.c32 3
	<.main+12270 @064752>: 13 04                      set.x32 sp(4)
	<.main+12272 @064754>: 1f 20 0b 06 00             load.ref <@060b20> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+12277 @064759>: 02                         call
	<.main+12278 @06475a>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:102: (21 bytes: <.main+12282 @06475e> - <.main+12303 @064773>): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12282 @06475e>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12286 @064762>: 1c 03 00 00 00             load.c32 3
	<.main+12291 @064767>: 13 04                      set.x32 sp(4)
	<.main+12293 @064769>: 1f 50 0b 06 00             load.ref <@060b50> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+12298 @06476e>: 02                         call
	<.main+12299 @06476f>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.method.ci:103: (20 bytes: <.main+12303 @064773> - <.main+12323 @064787>): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+12303 @064773>: 22 c8 0b 06                load.m128 <@060bc8> ;recordMethodTest
	<.main+12307 @064777>: 1c 03 00 00 00             load.c32 3
	<.main+12312 @06477c>: 13 04                      set.x32 sp(4)
	<.main+12314 @06477e>: 20 d0 0b 06                load.m32 <@060bd0> ;recordMethodTest+8
	<.main+12318 @064782>: 02                         call
	<.main+12319 @064783>: 09 f0 ff ff                inc.sp(-16)
	cmplStd/test/lang/init.array.ci:35: (35 bytes: <.main+12323 @064787> - <.main+12358 @0647aa>): debug("string as variant", strFixed);
	<.main+12323 @064787>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12328 @06478c>: 1c 23 00 00 00             load.c32 35
	<.main+12333 @064791>: 1c 0e 00 00 00             load.c32 14
	<.main+12338 @064796>: 19                         load.z32
	<.main+12339 @064797>: 1f 18 cc 04 00             load.ref <@04cc18> ;"string as variant"
	<.main+12344 @06479c>: 1f b0 d7 04 00             load.ref <@04d7b0>
	<.main+12349 @0647a1>: 1f d0 0c 06 00             load.ref <@060cd0> ;strFixed
	<.main+12354 @0647a6>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:38: (34 bytes: <.main+12358 @0647aa> - <.main+12392 @0647cc>): debug("string as variant", strArray);
	<.main+12358 @0647aa>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12363 @0647af>: 1c 26 00 00 00             load.c32 38
	<.main+12368 @0647b4>: 1c 0e 00 00 00             load.c32 14
	<.main+12373 @0647b9>: 19                         load.z32
	<.main+12374 @0647ba>: 1f 18 cc 04 00             load.ref <@04cc18> ;"string as variant"
	<.main+12379 @0647bf>: 1f 90 d9 04 00             load.ref <@04d990>
	<.main+12384 @0647c4>: 20 d8 0c 06                load.m32 <@060cd8> ;strArray
	<.main+12388 @0647c8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:41: (34 bytes: <.main+12392 @0647cc> - <.main+12426 @0647ee>): debug("string as variant", strSlice);
	<.main+12392 @0647cc>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12397 @0647d1>: 1c 29 00 00 00             load.c32 41
	<.main+12402 @0647d6>: 1c 0e 00 00 00             load.c32 14
	<.main+12407 @0647db>: 19                         load.z32
	<.main+12408 @0647dc>: 1f 18 cc 04 00             load.ref <@04cc18> ;"string as variant"
	<.main+12413 @0647e1>: 1f d0 da 04 00             load.ref <@04dad0>
	<.main+12418 @0647e6>: 20 e0 0c 06                load.m32 <@060ce0> ;strSlice
	<.main+12422 @0647ea>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:48: (53 bytes: <.main+12426 @0647ee> - <.main+12479 @064823>): assert(arrSliceInitNull.length == (0));
	<.main+12426 @0647ee>: 20 a4 0c 06                load.m32 <@060ca4> ;arrSliceInitNull+4
	<.main+12430 @0647f2>: 19                         load.z32
	<.main+12431 @0647f3>: 57                         ceq.i32
	<.main+12432 @0647f4>: 06 08 00 00                jz <.main+12440 @0647fc>
	<.main+12436 @0647f8>: 04 2b 00 00                jmp <.main+12479 @064823>
	<.main+12440 @0647fc>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12445 @064801>: 1c 30 00 00 00             load.c32 48
	<.main+12450 @064806>: 1c fe ff ff ff             load.c32 -2
	<.main+12455 @06480b>: 1c 80 00 00 00             load.c32 128
	<.main+12460 @064810>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12465 @064815>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12470 @06481a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12475 @06481f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:49: (61 bytes: <.main+12479 @064823> - <.main+12540 @064860>): assert(arrFixedInit[0] == (42));
	<.main+12479 @064823>: 21 60 0c 06                load.m64 <@060c60> ;arrFixedInit
	<.main+12483 @064827>: 1d 2a 00 00 00 00 00 00 00 load.c64 42
	<.main+12492 @064830>: 67                         ceq.i64
	<.main+12493 @064831>: 06 08 00 00                jz <.main+12501 @064839>
	<.main+12497 @064835>: 04 2b 00 00                jmp <.main+12540 @064860>
	<.main+12501 @064839>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12506 @06483e>: 1c 31 00 00 00             load.c32 49
	<.main+12511 @064843>: 1c fe ff ff ff             load.c32 -2
	<.main+12516 @064848>: 1c 80 00 00 00             load.c32 128
	<.main+12521 @06484d>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12526 @064852>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12531 @064857>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12536 @06485c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:56: (25 bytes: <.main+12540 @064860> - <.main+12565 @064879>): assertEq(7, arrFixedInit.(length));
	<.main+12540 @064860>: 1c 07 00 00 00             load.c32 7
	<.main+12545 @064865>: 1c 07 00 00 00             load.c32 7
	<.main+12550 @06486a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12555 @06486f>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12560 @064874>: 02                         call
	<.main+12561 @064875>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:57: (24 bytes: <.main+12565 @064879> - <.main+12589 @064891>): assertEq(arrFixedInit.(length), arrSliceInitFixed.length);
	<.main+12565 @064879>: 1c 07 00 00 00             load.c32 7
	<.main+12570 @06487e>: 20 b4 0c 06                load.m32 <@060cb4> ;arrSliceInitFixed+4
	<.main+12574 @064882>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12579 @064887>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12584 @06488c>: 02                         call
	<.main+12585 @06488d>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:58: (24 bytes: <.main+12589 @064891> - <.main+12613 @0648a9>): assertEq(arrFixedInit.(length), arrSliceInitSlice.length);
	<.main+12589 @064891>: 1c 07 00 00 00             load.c32 7
	<.main+12594 @064896>: 20 c4 0c 06                load.m32 <@060cc4> ;arrSliceInitSlice+4
	<.main+12598 @06489a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12603 @06489f>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12608 @0648a4>: 02                         call
	<.main+12609 @0648a5>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:60: (32 bytes: <.main+12613 @0648a9> - <.main+12645 @0648c9>): assertEq(0, lenSlice(null));
	<.main+12613 @0648a9>: 19                         load.z32
	<.main+12614 @0648aa>: 1a                         load.z64
	<.main+12615 @0648ab>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12620 @0648b0>: 1f e8 0c 06 00             load.ref <@060ce8> ;lenSlice(values: int64[]): int32
	<.main+12625 @0648b5>: 02                         call
	<.main+12626 @0648b6>: 09 f8 ff ff                inc.sp(-8)
	<.main+12630 @0648ba>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12635 @0648bf>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12640 @0648c4>: 02                         call
	<.main+12641 @0648c5>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:61: (31 bytes: <.main+12645 @0648c9> - <.main+12676 @0648e8>): assertEq(0, lenSlice(arrSliceInitNull));
	<.main+12645 @0648c9>: 19                         load.z32
	<.main+12646 @0648ca>: 19                         load.z32
	<.main+12647 @0648cb>: 21 a0 0c 06                load.m64 <@060ca0> ;arrSliceInitNull
	<.main+12651 @0648cf>: 1f e8 0c 06 00             load.ref <@060ce8> ;lenSlice(values: int64[]): int32
	<.main+12656 @0648d4>: 02                         call
	<.main+12657 @0648d5>: 09 f8 ff ff                inc.sp(-8)
	<.main+12661 @0648d9>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12666 @0648de>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12671 @0648e3>: 02                         call
	<.main+12672 @0648e4>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:62: (41 bytes: <.main+12676 @0648e8> - <.main+12717 @064911>): assertEq(arrFixedInit.(length), lenSlice(arrFixedInit));
	<.main+12676 @0648e8>: 1c 07 00 00 00             load.c32 7
	<.main+12681 @0648ed>: 19                         load.z32
	<.main+12682 @0648ee>: 1c 07 00 00 00             load.c32 7
	<.main+12687 @0648f3>: 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+12692 @0648f8>: 1f e8 0c 06 00             load.ref <@060ce8> ;lenSlice(values: int64[]): int32
	<.main+12697 @0648fd>: 02                         call
	<.main+12698 @0648fe>: 09 f8 ff ff                inc.sp(-8)
	<.main+12702 @064902>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12707 @064907>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12712 @06490c>: 02                         call
	<.main+12713 @06490d>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:63: (35 bytes: <.main+12717 @064911> - <.main+12752 @064934>): assertEq(arrFixedInit.(length), lenSlice(arrSliceInitFixed));
	<.main+12717 @064911>: 1c 07 00 00 00             load.c32 7
	<.main+12722 @064916>: 19                         load.z32
	<.main+12723 @064917>: 21 b0 0c 06                load.m64 <@060cb0> ;arrSliceInitFixed
	<.main+12727 @06491b>: 1f e8 0c 06 00             load.ref <@060ce8> ;lenSlice(values: int64[]): int32
	<.main+12732 @064920>: 02                         call
	<.main+12733 @064921>: 09 f8 ff ff                inc.sp(-8)
	<.main+12737 @064925>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12742 @06492a>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12747 @06492f>: 02                         call
	<.main+12748 @064930>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:64: (35 bytes: <.main+12752 @064934> - <.main+12787 @064957>): assertEq(arrFixedInit.(length), lenSlice(arrSliceInitSlice));
	<.main+12752 @064934>: 1c 07 00 00 00             load.c32 7
	<.main+12757 @064939>: 19                         load.z32
	<.main+12758 @06493a>: 21 c0 0c 06                load.m64 <@060cc0> ;arrSliceInitSlice
	<.main+12762 @06493e>: 1f e8 0c 06 00             load.ref <@060ce8> ;lenSlice(values: int64[]): int32
	<.main+12767 @064943>: 02                         call
	<.main+12768 @064944>: 09 f8 ff ff                inc.sp(-8)
	<.main+12772 @064948>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12777 @06494d>: 1f 78 ed 05 00             load.ref <@05ed78> ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+12782 @064952>: 02                         call
	<.main+12783 @064953>: 09 f4 ff ff                inc.sp(-12)
	cmplStd/test/lang/init.array.ci:66: (827 bytes: <.main+12787 @064957> - <.main+13614 @064c92>): for (i: int32 := 0; i < arrFixedInit.(length); i := i + 1)
	<.main+12787 @064957>: 19                         load.z32
	<.main+12788 @064958>: 04 2a 03 00                jmp <.main+13598 @064c82>
	cmplStd/test/lang/init.array.ci:67: (9 bytes: <.main+12792 @06495c> - <.main+12801 @064965>): expected: int64 := 42 + i
	<.main+12792 @06495c>: 1c 2a 00 00 00             load.c32 42
	<.main+12797 @064961>: 10 01                      dup.x32 sp(1)
	<.main+12799 @064963>: 51                         add.i32
	<.main+12800 @064964>: 5b                         i32.2i64
	cmplStd/test/lang/init.array.ci:68: (62 bytes: <.main+12801 @064965> - <.main+12863 @0649a3>): assert(expected == arrFixedInit[i]);
	<.main+12801 @064965>: 11 00                      dup.x64 sp(0)
	<.main+12803 @064967>: 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+12808 @06496c>: 10 05                      dup.x32 sp(5)
	<.main+12810 @06496e>: 0d 08 00 00                mad.u32 8
	<.main+12814 @064972>: 29                         load.i64
	<.main+12815 @064973>: 67                         ceq.i64
	<.main+12816 @064974>: 06 08 00 00                jz <.main+12824 @06497c>
	<.main+12820 @064978>: 04 2b 00 00                jmp <.main+12863 @0649a3>
	<.main+12824 @06497c>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12829 @064981>: 1c 44 00 00 00             load.c32 68
	<.main+12834 @064986>: 1c fe ff ff ff             load.c32 -2
	<.main+12839 @06498b>: 1c 80 00 00 00             load.c32 128
	<.main+12844 @064990>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12849 @064995>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12854 @06499a>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12859 @06499f>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:69: (61 bytes: <.main+12863 @0649a3> - <.main+12924 @0649e0>): assert(expected == arrArrayInitFixed[i]);
	<.main+12863 @0649a3>: 11 00                      dup.x64 sp(0)
	<.main+12865 @0649a5>: 20 a8 0c 06                load.m32 <@060ca8> ;arrArrayInitFixed
	<.main+12869 @0649a9>: 10 05                      dup.x32 sp(5)
	<.main+12871 @0649ab>: 0d 08 00 00                mad.u32 8
	<.main+12875 @0649af>: 29                         load.i64
	<.main+12876 @0649b0>: 67                         ceq.i64
	<.main+12877 @0649b1>: 06 08 00 00                jz <.main+12885 @0649b9>
	<.main+12881 @0649b5>: 04 2b 00 00                jmp <.main+12924 @0649e0>
	<.main+12885 @0649b9>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12890 @0649be>: 1c 45 00 00 00             load.c32 69
	<.main+12895 @0649c3>: 1c fe ff ff ff             load.c32 -2
	<.main+12900 @0649c8>: 1c 80 00 00 00             load.c32 128
	<.main+12905 @0649cd>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12910 @0649d2>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12915 @0649d7>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12920 @0649dc>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:70: (61 bytes: <.main+12924 @0649e0> - <.main+12985 @064a1d>): assert(expected == arrSliceInitFixed[i]);
	<.main+12924 @0649e0>: 11 00                      dup.x64 sp(0)
	<.main+12926 @0649e2>: 20 b0 0c 06                load.m32 <@060cb0> ;arrSliceInitFixed
	<.main+12930 @0649e6>: 10 05                      dup.x32 sp(5)
	<.main+12932 @0649e8>: 0d 08 00 00                mad.u32 8
	<.main+12936 @0649ec>: 29                         load.i64
	<.main+12937 @0649ed>: 67                         ceq.i64
	<.main+12938 @0649ee>: 06 08 00 00                jz <.main+12946 @0649f6>
	<.main+12942 @0649f2>: 04 2b 00 00                jmp <.main+12985 @064a1d>
	<.main+12946 @0649f6>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+12951 @0649fb>: 1c 46 00 00 00             load.c32 70
	<.main+12956 @064a00>: 1c fe ff ff ff             load.c32 -2
	<.main+12961 @064a05>: 1c 80 00 00 00             load.c32 128
	<.main+12966 @064a0a>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+12971 @064a0f>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+12976 @064a14>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+12981 @064a19>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:72: (68 bytes: <.main+12985 @064a1d> - <.main+13053 @064a61>): assert(expected == nthFixed(i, arrFixedInit));
	<.main+12985 @064a1d>: 11 00                      dup.x64 sp(0)
	<.main+12987 @064a1f>: 1a                         load.z64
	<.main+12988 @064a20>: 10 06                      dup.x32 sp(6)
	<.main+12990 @064a22>: 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+12995 @064a27>: 1f f0 0c 06 00             load.ref <@060cf0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13000 @064a2c>: 02                         call
	<.main+13001 @064a2d>: 09 f8 ff ff                inc.sp(-8)
	<.main+13005 @064a31>: 67                         ceq.i64
	<.main+13006 @064a32>: 06 08 00 00                jz <.main+13014 @064a3a>
	<.main+13010 @064a36>: 04 2b 00 00                jmp <.main+13053 @064a61>
	<.main+13014 @064a3a>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13019 @064a3f>: 1c 48 00 00 00             load.c32 72
	<.main+13024 @064a44>: 1c fe ff ff ff             load.c32 -2
	<.main+13029 @064a49>: 1c 80 00 00 00             load.c32 128
	<.main+13034 @064a4e>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13039 @064a53>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13044 @064a58>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13049 @064a5d>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:73: (67 bytes: <.main+13053 @064a61> - <.main+13120 @064aa4>): assert(expected == nthFixed(i, arrArrayInitFixed));
	<.main+13053 @064a61>: 11 00                      dup.x64 sp(0)
	<.main+13055 @064a63>: 1a                         load.z64
	<.main+13056 @064a64>: 10 06                      dup.x32 sp(6)
	<.main+13058 @064a66>: 20 a8 0c 06                load.m32 <@060ca8> ;arrArrayInitFixed
	<.main+13062 @064a6a>: 1f f0 0c 06 00             load.ref <@060cf0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13067 @064a6f>: 02                         call
	<.main+13068 @064a70>: 09 f8 ff ff                inc.sp(-8)
	<.main+13072 @064a74>: 67                         ceq.i64
	<.main+13073 @064a75>: 06 08 00 00                jz <.main+13081 @064a7d>
	<.main+13077 @064a79>: 04 2b 00 00                jmp <.main+13120 @064aa4>
	<.main+13081 @064a7d>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13086 @064a82>: 1c 49 00 00 00             load.c32 73
	<.main+13091 @064a87>: 1c fe ff ff ff             load.c32 -2
	<.main+13096 @064a8c>: 1c 80 00 00 00             load.c32 128
	<.main+13101 @064a91>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13106 @064a96>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13111 @064a9b>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13116 @064aa0>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:74: (67 bytes: <.main+13120 @064aa4> - <.main+13187 @064ae7>): assert(expected == nthFixed(i, arrSliceInitFixed));
	<.main+13120 @064aa4>: 11 00                      dup.x64 sp(0)
	<.main+13122 @064aa6>: 1a                         load.z64
	<.main+13123 @064aa7>: 10 06                      dup.x32 sp(6)
	<.main+13125 @064aa9>: 20 b0 0c 06                load.m32 <@060cb0> ;arrSliceInitFixed
	<.main+13129 @064aad>: 1f f0 0c 06 00             load.ref <@060cf0> ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+13134 @064ab2>: 02                         call
	<.main+13135 @064ab3>: 09 f8 ff ff                inc.sp(-8)
	<.main+13139 @064ab7>: 67                         ceq.i64
	<.main+13140 @064ab8>: 06 08 00 00                jz <.main+13148 @064ac0>
	<.main+13144 @064abc>: 04 2b 00 00                jmp <.main+13187 @064ae7>
	<.main+13148 @064ac0>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13153 @064ac5>: 1c 4a 00 00 00             load.c32 74
	<.main+13158 @064aca>: 1c fe ff ff ff             load.c32 -2
	<.main+13163 @064acf>: 1c 80 00 00 00             load.c32 128
	<.main+13168 @064ad4>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13173 @064ad9>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13178 @064ade>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13183 @064ae3>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:76: (68 bytes: <.main+13187 @064ae7> - <.main+13255 @064b2b>): assert(expected == nthArray(i, arrFixedInit));
	<.main+13187 @064ae7>: 11 00                      dup.x64 sp(0)
	<.main+13189 @064ae9>: 1a                         load.z64
	<.main+13190 @064aea>: 10 06                      dup.x32 sp(6)
	<.main+13192 @064aec>: 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+13197 @064af1>: 1f 00 0d 06 00             load.ref <@060d00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13202 @064af6>: 02                         call
	<.main+13203 @064af7>: 09 f8 ff ff                inc.sp(-8)
	<.main+13207 @064afb>: 67                         ceq.i64
	<.main+13208 @064afc>: 06 08 00 00                jz <.main+13216 @064b04>
	<.main+13212 @064b00>: 04 2b 00 00                jmp <.main+13255 @064b2b>
	<.main+13216 @064b04>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13221 @064b09>: 1c 4c 00 00 00             load.c32 76
	<.main+13226 @064b0e>: 1c fe ff ff ff             load.c32 -2
	<.main+13231 @064b13>: 1c 80 00 00 00             load.c32 128
	<.main+13236 @064b18>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13241 @064b1d>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13246 @064b22>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13251 @064b27>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:77: (67 bytes: <.main+13255 @064b2b> - <.main+13322 @064b6e>): assert(expected == nthArray(i, arrArrayInitFixed));
	<.main+13255 @064b2b>: 11 00                      dup.x64 sp(0)
	<.main+13257 @064b2d>: 1a                         load.z64
	<.main+13258 @064b2e>: 10 06                      dup.x32 sp(6)
	<.main+13260 @064b30>: 20 a8 0c 06                load.m32 <@060ca8> ;arrArrayInitFixed
	<.main+13264 @064b34>: 1f 00 0d 06 00             load.ref <@060d00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13269 @064b39>: 02                         call
	<.main+13270 @064b3a>: 09 f8 ff ff                inc.sp(-8)
	<.main+13274 @064b3e>: 67                         ceq.i64
	<.main+13275 @064b3f>: 06 08 00 00                jz <.main+13283 @064b47>
	<.main+13279 @064b43>: 04 2b 00 00                jmp <.main+13322 @064b6e>
	<.main+13283 @064b47>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13288 @064b4c>: 1c 4d 00 00 00             load.c32 77
	<.main+13293 @064b51>: 1c fe ff ff ff             load.c32 -2
	<.main+13298 @064b56>: 1c 80 00 00 00             load.c32 128
	<.main+13303 @064b5b>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13308 @064b60>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13313 @064b65>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13318 @064b6a>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:78: (67 bytes: <.main+13322 @064b6e> - <.main+13389 @064bb1>): assert(expected == nthArray(i, arrSliceInitFixed));
	<.main+13322 @064b6e>: 11 00                      dup.x64 sp(0)
	<.main+13324 @064b70>: 1a                         load.z64
	<.main+13325 @064b71>: 10 06                      dup.x32 sp(6)
	<.main+13327 @064b73>: 20 b0 0c 06                load.m32 <@060cb0> ;arrSliceInitFixed
	<.main+13331 @064b77>: 1f 00 0d 06 00             load.ref <@060d00> ;nthArray(idx: int32, values: int64[*]): int64
	<.main+13336 @064b7c>: 02                         call
	<.main+13337 @064b7d>: 09 f8 ff ff                inc.sp(-8)
	<.main+13341 @064b81>: 67                         ceq.i64
	<.main+13342 @064b82>: 06 08 00 00                jz <.main+13350 @064b8a>
	<.main+13346 @064b86>: 04 2b 00 00                jmp <.main+13389 @064bb1>
	<.main+13350 @064b8a>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13355 @064b8f>: 1c 4e 00 00 00             load.c32 78
	<.main+13360 @064b94>: 1c fe ff ff ff             load.c32 -2
	<.main+13365 @064b99>: 1c 80 00 00 00             load.c32 128
	<.main+13370 @064b9e>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13375 @064ba3>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13380 @064ba8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13385 @064bad>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:80: (73 bytes: <.main+13389 @064bb1> - <.main+13462 @064bfa>): assert(expected == nthSlice(i, arrFixedInit));
	<.main+13389 @064bb1>: 11 00                      dup.x64 sp(0)
	<.main+13391 @064bb3>: 1a                         load.z64
	<.main+13392 @064bb4>: 10 06                      dup.x32 sp(6)
	<.main+13394 @064bb6>: 1c 07 00 00 00             load.c32 7
	<.main+13399 @064bbb>: 1f 60 0c 06 00             load.ref <@060c60> ;arrFixedInit
	<.main+13404 @064bc0>: 1f 10 0d 06 00             load.ref <@060d10> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13409 @064bc5>: 02                         call
	<.main+13410 @064bc6>: 09 f4 ff ff                inc.sp(-12)
	<.main+13414 @064bca>: 67                         ceq.i64
	<.main+13415 @064bcb>: 06 08 00 00                jz <.main+13423 @064bd3>
	<.main+13419 @064bcf>: 04 2b 00 00                jmp <.main+13462 @064bfa>
	<.main+13423 @064bd3>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13428 @064bd8>: 1c 50 00 00 00             load.c32 80
	<.main+13433 @064bdd>: 1c fe ff ff ff             load.c32 -2
	<.main+13438 @064be2>: 1c 80 00 00 00             load.c32 128
	<.main+13443 @064be7>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13448 @064bec>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13453 @064bf1>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13458 @064bf6>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:82: (67 bytes: <.main+13462 @064bfa> - <.main+13529 @064c3d>): assert(expected == nthSlice(i, arrSliceInitFixed));
	<.main+13462 @064bfa>: 11 00                      dup.x64 sp(0)
	<.main+13464 @064bfc>: 1a                         load.z64
	<.main+13465 @064bfd>: 10 06                      dup.x32 sp(6)
	<.main+13467 @064bff>: 21 b0 0c 06                load.m64 <@060cb0> ;arrSliceInitFixed
	<.main+13471 @064c03>: 1f 10 0d 06 00             load.ref <@060d10> ;nthSlice(idx: int32, values: int64[]): int64
	<.main+13476 @064c08>: 02                         call
	<.main+13477 @064c09>: 09 f4 ff ff                inc.sp(-12)
	<.main+13481 @064c0d>: 67                         ceq.i64
	<.main+13482 @064c0e>: 06 08 00 00                jz <.main+13490 @064c16>
	<.main+13486 @064c12>: 04 2b 00 00                jmp <.main+13529 @064c3d>
	<.main+13490 @064c16>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13495 @064c1b>: 1c 52 00 00 00             load.c32 82
	<.main+13500 @064c20>: 1c fe ff ff ff             load.c32 -2
	<.main+13505 @064c25>: 1c 80 00 00 00             load.c32 128
	<.main+13510 @064c2a>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13515 @064c2f>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13520 @064c34>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13525 @064c39>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/init.array.ci:84: (61 bytes: <.main+13529 @064c3d> - <.main+13590 @064c7a>): assert(expected == arrSliceInitSlice[i]);
	<.main+13529 @064c3d>: 11 00                      dup.x64 sp(0)
	<.main+13531 @064c3f>: 20 c0 0c 06                load.m32 <@060cc0> ;arrSliceInitSlice
	<.main+13535 @064c43>: 10 05                      dup.x32 sp(5)
	<.main+13537 @064c45>: 0d 08 00 00                mad.u32 8
	<.main+13541 @064c49>: 29                         load.i64
	<.main+13542 @064c4a>: 67                         ceq.i64
	<.main+13543 @064c4b>: 06 08 00 00                jz <.main+13551 @064c53>
	<.main+13547 @064c4f>: 04 2b 00 00                jmp <.main+13590 @064c7a>
	<.main+13551 @064c53>: 1f 68 cb 04 00             load.ref <@04cb68> ;"cmplStd/test/lang/init.array.ci"
	<.main+13556 @064c58>: 1c 54 00 00 00             load.c32 84
	<.main+13561 @064c5d>: 1c fe ff ff ff             load.c32 -2
	<.main+13566 @064c62>: 1c 80 00 00 00             load.c32 128
	<.main+13571 @064c67>: 1f d8 f0 00 00             load.ref <@00f0d8> ;"assertion failed!"
	<.main+13576 @064c6c>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13581 @064c71>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13586 @064c76>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13590 @064c7a>: 09 f8 ff ff                inc.sp(-8)
	cmplStd/test/lang/init.array.ci:66: (4 bytes: <.main+13594 @064c7e> - <.main+13598 @064c82>): i := i + 1
	<.main+13594 @064c7e>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/init.array.ci:66: (12 bytes: <.main+13598 @064c82> - <.main+13610 @064c8e>): i < arrFixedInit.(length)
	<.main+13598 @064c82>: 10 00                      dup.x32 sp(0)
	<.main+13600 @064c84>: 1c 07 00 00 00             load.c32 7
	<.main+13605 @064c89>: 58                         clt.i32
	<.main+13606 @064c8a>: 05 d2 fc ff                jnz <.main+12792 @06495c>
	<.main+13610 @064c8e>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.if.ci:4: (39 bytes: <.main+13614 @064c92> - <.main+13653 @064cb9>): raise(raise.debug, 1, "0 == 0", null);
	<.main+13614 @064c92>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13619 @064c97>: 1c 04 00 00 00             load.c32 4
	<.main+13624 @064c9c>: 1c 0e 00 00 00             load.c32 14
	<.main+13629 @064ca1>: 1c 01 00 00 00             load.c32 1
	<.main+13634 @064ca6>: 1f 7d b2 05 00             load.ref <@05b27d> ;"0 == 0"
	<.main+13639 @064cab>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13644 @064cb0>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13649 @064cb5>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:12: (39 bytes: <.main+13653 @064cb9> - <.main+13692 @064ce0>): raise(raise.debug, 3, "0 == 0", null);
	<.main+13653 @064cb9>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13658 @064cbe>: 1c 0c 00 00 00             load.c32 12
	<.main+13663 @064cc3>: 1c 0e 00 00 00             load.c32 14
	<.main+13668 @064cc8>: 1c 03 00 00 00             load.c32 3
	<.main+13673 @064ccd>: 1f 7d b2 05 00             load.ref <@05b27d> ;"0 == 0"
	<.main+13678 @064cd2>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13683 @064cd7>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13688 @064cdc>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:22: (39 bytes: <.main+13692 @064ce0> - <.main+13731 @064d07>): raise(raise.debug, 6, "0 == 0", null);
	<.main+13692 @064ce0>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13697 @064ce5>: 1c 16 00 00 00             load.c32 22
	<.main+13702 @064cea>: 1c 0e 00 00 00             load.c32 14
	<.main+13707 @064cef>: 1c 06 00 00 00             load.c32 6
	<.main+13712 @064cf4>: 1f 7d b2 05 00             load.ref <@05b27d> ;"0 == 0"
	<.main+13717 @064cf9>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+13722 @064cfe>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+13727 @064d03>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:28: (49 bytes: <.main+13731 @064d07> - <.main+13780 @064d38>): if (t == 0)
	<.main+13731 @064d07>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+13735 @064d0b>: 19                         load.z32
	<.main+13736 @064d0c>: 57                         ceq.i32
	<.main+13737 @064d0d>: 06 2b 00 00                jz <.main+13780 @064d38>
	cmplStd/test/lang/stmt.if.ci:29: (39 bytes: <.main+13741 @064d11> - <.main+13780 @064d38>): raise(raise.debug, 7, "t == 0", t);
	<.main+13741 @064d11>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13746 @064d16>: 1c 1d 00 00 00             load.c32 29
	<.main+13751 @064d1b>: 1c 0e 00 00 00             load.c32 14
	<.main+13756 @064d20>: 1c 07 00 00 00             load.c32 7
	<.main+13761 @064d25>: 1f 8b b2 05 00             load.ref <@05b28b> ;"t == 0"
	<.main+13766 @064d2a>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13771 @064d2f>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+13776 @064d34>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:32: (49 bytes: <.main+13780 @064d38> - <.main+13829 @064d69>): if (t != 0)
	<.main+13780 @064d38>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+13784 @064d3c>: 19                         load.z32
	<.main+13785 @064d3d>: 57                         ceq.i32
	<.main+13786 @064d3e>: 05 2b 00 00                jnz <.main+13829 @064d69>
	cmplStd/test/lang/stmt.if.ci:33: (39 bytes: <.main+13790 @064d42> - <.main+13829 @064d69>): raise(raise.debug, 8, "t != 0", t);
	<.main+13790 @064d42>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13795 @064d47>: 1c 21 00 00 00             load.c32 33
	<.main+13800 @064d4c>: 1c 0e 00 00 00             load.c32 14
	<.main+13805 @064d51>: 1c 08 00 00 00             load.c32 8
	<.main+13810 @064d56>: 1f 92 b2 05 00             load.ref <@05b292> ;"t != 0"
	<.main+13815 @064d5b>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13820 @064d60>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+13825 @064d65>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:36: (92 bytes: <.main+13829 @064d69> - <.main+13921 @064dc5>): if (t == 0)
	<.main+13829 @064d69>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+13833 @064d6d>: 19                         load.z32
	<.main+13834 @064d6e>: 57                         ceq.i32
	<.main+13835 @064d6f>: 06 2f 00 00                jz <.main+13882 @064d9e>
	cmplStd/test/lang/stmt.if.ci:37: (39 bytes: <.main+13839 @064d73> - <.main+13878 @064d9a>): raise(raise.debug, 9, "t == 0", t);
	<.main+13839 @064d73>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13844 @064d78>: 1c 25 00 00 00             load.c32 37
	<.main+13849 @064d7d>: 1c 0e 00 00 00             load.c32 14
	<.main+13854 @064d82>: 1c 09 00 00 00             load.c32 9
	<.main+13859 @064d87>: 1f 8b b2 05 00             load.ref <@05b28b> ;"t == 0"
	<.main+13864 @064d8c>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13869 @064d91>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+13874 @064d96>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13878 @064d9a>: 04 2b 00 00                jmp <.main+13921 @064dc5>
	cmplStd/test/lang/stmt.if.ci:40: (39 bytes: <.main+13882 @064d9e> - <.main+13921 @064dc5>): raise(raise.debug, 10, "t != 0", t);
	<.main+13882 @064d9e>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13887 @064da3>: 1c 28 00 00 00             load.c32 40
	<.main+13892 @064da8>: 1c 0e 00 00 00             load.c32 14
	<.main+13897 @064dad>: 1c 0a 00 00 00             load.c32 10
	<.main+13902 @064db2>: 1f 92 b2 05 00             load.ref <@05b292> ;"t != 0"
	<.main+13907 @064db7>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13912 @064dbc>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+13917 @064dc1>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:43: (92 bytes: <.main+13921 @064dc5> - <.main+14013 @064e21>): if (t != 0)
	<.main+13921 @064dc5>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+13925 @064dc9>: 19                         load.z32
	<.main+13926 @064dca>: 57                         ceq.i32
	<.main+13927 @064dcb>: 05 2f 00 00                jnz <.main+13974 @064dfa>
	cmplStd/test/lang/stmt.if.ci:44: (39 bytes: <.main+13931 @064dcf> - <.main+13970 @064df6>): raise(raise.debug, 11, "t != 0", t);
	<.main+13931 @064dcf>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13936 @064dd4>: 1c 2c 00 00 00             load.c32 44
	<.main+13941 @064dd9>: 1c 0e 00 00 00             load.c32 14
	<.main+13946 @064dde>: 1c 0b 00 00 00             load.c32 11
	<.main+13951 @064de3>: 1f 92 b2 05 00             load.ref <@05b292> ;"t != 0"
	<.main+13956 @064de8>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+13961 @064ded>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+13966 @064df2>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+13970 @064df6>: 04 2b 00 00                jmp <.main+14013 @064e21>
	cmplStd/test/lang/stmt.if.ci:47: (39 bytes: <.main+13974 @064dfa> - <.main+14013 @064e21>): raise(raise.debug, 12, "t == 0", t);
	<.main+13974 @064dfa>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+13979 @064dff>: 1c 2f 00 00 00             load.c32 47
	<.main+13984 @064e04>: 1c 0e 00 00 00             load.c32 14
	<.main+13989 @064e09>: 1c 0c 00 00 00             load.c32 12
	<.main+13994 @064e0e>: 1f 8b b2 05 00             load.ref <@05b28b> ;"t == 0"
	<.main+13999 @064e13>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14004 @064e18>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14009 @064e1d>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.if.ci:50: (377 bytes: <.main+14013 @064e21> - <.main+14390 @064f9a>): if (t == 0)
	<.main+14013 @064e21>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14017 @064e25>: 19                         load.z32
	<.main+14018 @064e26>: 57                         ceq.i32
	<.main+14019 @064e27>: 06 2f 00 00                jz <.main+14066 @064e56>
	cmplStd/test/lang/stmt.if.ci:51: (39 bytes: <.main+14023 @064e2b> - <.main+14062 @064e52>): raise(raise.debug, 9, "t == 0", t);
	<.main+14023 @064e2b>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14028 @064e30>: 1c 33 00 00 00             load.c32 51
	<.main+14033 @064e35>: 1c 0e 00 00 00             load.c32 14
	<.main+14038 @064e3a>: 1c 09 00 00 00             load.c32 9
	<.main+14043 @064e3f>: 1f 8b b2 05 00             load.ref <@05b28b> ;"t == 0"
	<.main+14048 @064e44>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14053 @064e49>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14058 @064e4e>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14062 @064e52>: 04 48 01 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:53: (324 bytes: <.main+14066 @064e56> - <.main+14390 @064f9a>): if (t == 1)
	<.main+14066 @064e56>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14070 @064e5a>: 1c 01 00 00 00             load.c32 1
	<.main+14075 @064e5f>: 57                         ceq.i32
	<.main+14076 @064e60>: 06 2f 00 00                jz <.main+14123 @064e8f>
	cmplStd/test/lang/stmt.if.ci:54: (39 bytes: <.main+14080 @064e64> - <.main+14119 @064e8b>): raise(raise.debug, 10, "t == 1", t);
	<.main+14080 @064e64>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14085 @064e69>: 1c 36 00 00 00             load.c32 54
	<.main+14090 @064e6e>: 1c 0e 00 00 00             load.c32 14
	<.main+14095 @064e73>: 1c 0a 00 00 00             load.c32 10
	<.main+14100 @064e78>: 1f 99 b2 05 00             load.ref <@05b299> ;"t == 1"
	<.main+14105 @064e7d>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14110 @064e82>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14115 @064e87>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14119 @064e8b>: 04 0f 01 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:56: (267 bytes: <.main+14123 @064e8f> - <.main+14390 @064f9a>): if (t == 2)
	<.main+14123 @064e8f>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14127 @064e93>: 1c 02 00 00 00             load.c32 2
	<.main+14132 @064e98>: 57                         ceq.i32
	<.main+14133 @064e99>: 06 2f 00 00                jz <.main+14180 @064ec8>
	cmplStd/test/lang/stmt.if.ci:57: (39 bytes: <.main+14137 @064e9d> - <.main+14176 @064ec4>): raise(raise.debug, 10, "t == 2", t);
	<.main+14137 @064e9d>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14142 @064ea2>: 1c 39 00 00 00             load.c32 57
	<.main+14147 @064ea7>: 1c 0e 00 00 00             load.c32 14
	<.main+14152 @064eac>: 1c 0a 00 00 00             load.c32 10
	<.main+14157 @064eb1>: 1f a0 b2 05 00             load.ref <@05b2a0> ;"t == 2"
	<.main+14162 @064eb6>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14167 @064ebb>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14172 @064ec0>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14176 @064ec4>: 04 d6 00 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:59: (210 bytes: <.main+14180 @064ec8> - <.main+14390 @064f9a>): if (t == 3)
	<.main+14180 @064ec8>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14184 @064ecc>: 1c 03 00 00 00             load.c32 3
	<.main+14189 @064ed1>: 57                         ceq.i32
	<.main+14190 @064ed2>: 06 2f 00 00                jz <.main+14237 @064f01>
	cmplStd/test/lang/stmt.if.ci:60: (39 bytes: <.main+14194 @064ed6> - <.main+14233 @064efd>): raise(raise.debug, 10, "t == 3", t);
	<.main+14194 @064ed6>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14199 @064edb>: 1c 3c 00 00 00             load.c32 60
	<.main+14204 @064ee0>: 1c 0e 00 00 00             load.c32 14
	<.main+14209 @064ee5>: 1c 0a 00 00 00             load.c32 10
	<.main+14214 @064eea>: 1f a7 b2 05 00             load.ref <@05b2a7> ;"t == 3"
	<.main+14219 @064eef>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14224 @064ef4>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14229 @064ef9>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14233 @064efd>: 04 9d 00 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:62: (153 bytes: <.main+14237 @064f01> - <.main+14390 @064f9a>): if (t == 4)
	<.main+14237 @064f01>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14241 @064f05>: 1c 04 00 00 00             load.c32 4
	<.main+14246 @064f0a>: 57                         ceq.i32
	<.main+14247 @064f0b>: 06 2f 00 00                jz <.main+14294 @064f3a>
	cmplStd/test/lang/stmt.if.ci:63: (39 bytes: <.main+14251 @064f0f> - <.main+14290 @064f36>): raise(raise.debug, 10, "t == 4", t);
	<.main+14251 @064f0f>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14256 @064f14>: 1c 3f 00 00 00             load.c32 63
	<.main+14261 @064f19>: 1c 0e 00 00 00             load.c32 14
	<.main+14266 @064f1e>: 1c 0a 00 00 00             load.c32 10
	<.main+14271 @064f23>: 1f ae b2 05 00             load.ref <@05b2ae> ;"t == 4"
	<.main+14276 @064f28>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14281 @064f2d>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14286 @064f32>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14290 @064f36>: 04 64 00 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:65: (96 bytes: <.main+14294 @064f3a> - <.main+14390 @064f9a>): if (t == 5)
	<.main+14294 @064f3a>: 20 00 15 06                load.m32 <@061500> ;t
	<.main+14298 @064f3e>: 1c 05 00 00 00             load.c32 5
	<.main+14303 @064f43>: 57                         ceq.i32
	<.main+14304 @064f44>: 06 2f 00 00                jz <.main+14351 @064f73>
	cmplStd/test/lang/stmt.if.ci:66: (39 bytes: <.main+14308 @064f48> - <.main+14347 @064f6f>): raise(raise.debug, 10, "t == 5", t);
	<.main+14308 @064f48>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14313 @064f4d>: 1c 42 00 00 00             load.c32 66
	<.main+14318 @064f52>: 1c 0e 00 00 00             load.c32 14
	<.main+14323 @064f57>: 1c 0a 00 00 00             load.c32 10
	<.main+14328 @064f5c>: 1f b5 b2 05 00             load.ref <@05b2b5> ;"t == 5"
	<.main+14333 @064f61>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14338 @064f66>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14343 @064f6b>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+14347 @064f6f>: 04 2b 00 00                jmp <.main+14390 @064f9a>
	cmplStd/test/lang/stmt.if.ci:69: (39 bytes: <.main+14351 @064f73> - <.main+14390 @064f9a>): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+14351 @064f73>: 1f 60 b2 05 00             load.ref <@05b260> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+14356 @064f78>: 1c 45 00 00 00             load.c32 69
	<.main+14361 @064f7d>: 1c 0e 00 00 00             load.c32 14
	<.main+14366 @064f82>: 1c 0a 00 00 00             load.c32 10
	<.main+14371 @064f87>: 1f bc b2 05 00             load.ref <@05b2bc> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+14376 @064f8c>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14381 @064f91>: 1f 00 15 06 00             load.ref <@061500> ;t
	<.main+14386 @064f96>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:3: (47 bytes: <.main+14390 @064f9a> - <.main+14437 @064fc9>): for ( ; ; )
	<.main+14390 @064f9a>: 04 2b 00 00                jmp <.main+14433 @064fc5>
	cmplStd/test/lang/stmt.for.ci:4: (35 bytes: <.main+14394 @064f9e> - <.main+14429 @064fc1>): debug("for ( ; ; )");
	<.main+14394 @064f9e>: 1f a8 b3 05 00             load.ref <@05b3a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14399 @064fa3>: 1c 04 00 00 00             load.c32 4
	<.main+14404 @064fa8>: 1c 0e 00 00 00             load.c32 14
	<.main+14409 @064fad>: 19                         load.z32
	<.main+14410 @064fae>: 1f c6 b3 05 00             load.ref <@05b3c6> ;"for ( ; ; )"
	<.main+14415 @064fb3>: 1f 40 09 00 00             load.ref <@000940> ;pointer
	<.main+14420 @064fb8>: 1f 00 00 00 00             load.ref <@000000> ;null
	<.main+14425 @064fbd>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes: <.main+14429 @064fc1> - <.main+14433 @064fc5>): break;
	<.main+14429 @064fc1>: 04 08 00 00                jmp <.main+14437 @064fc9>
	:: (4 bytes: <.main+14433 @064fc5> - <.main+14437 @064fc9>)
	<.main+14433 @064fc5>: 04 d9 ff ff                jmp <.main+14394 @064f9e>
	cmplStd/test/lang/stmt.for.ci:8: (59 bytes: <.main+14437 @064fc9> - <.main+14496 @065004>): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+14437 @064fc9>: 19                         load.z32
	<.main+14438 @064fca>: 04 2a 00 00                jmp <.main+14480 @064ff4>
	cmplStd/test/lang/stmt.for.ci:9: (34 bytes: <.main+14442 @064fce> - <.main+14476 @064ff0>): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+14442 @064fce>: 1f a8 b3 05 00             load.ref <@05b3a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14447 @064fd3>: 1c 09 00 00 00             load.c32 9
	<.main+14452 @064fd8>: 1c 0e 00 00 00             load.c32 14
	<.main+14457 @064fdd>: 19                         load.z32
	<.main+14458 @064fde>: 1f d2 b3 05 00             load.ref <@05b3d2> ;"for (int i = 0; i < 2; i += 1)"
	<.main+14463 @064fe3>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14468 @064fe8>: 0a 18 00 00                load.sp(+24)
	<.main+14472 @064fec>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes: <.main+14476 @064ff0> - <.main+14480 @064ff4>): i := i + 1
	<.main+14476 @064ff0>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes: <.main+14480 @064ff4> - <.main+14492 @065000>): i < 2
	<.main+14480 @064ff4>: 10 00                      dup.x32 sp(0)
	<.main+14482 @064ff6>: 1c 02 00 00 00             load.c32 2
	<.main+14487 @064ffb>: 58                         clt.i32
	<.main+14488 @064ffc>: 05 d2 ff ff                jnz <.main+14442 @064fce>
	<.main+14492 @065000>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:13: (70 bytes: <.main+14496 @065004> - <.main+14566 @06504a>): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+14496 @065004>: 19                         load.z32
	<.main+14497 @065005>: 24 08 15 06                store.m32 <@061508> ;forIdx
	<.main+14501 @065009>: 04 33 00 00                jmp <.main+14552 @06503c>
	cmplStd/test/lang/stmt.for.ci:14: (35 bytes: <.main+14505 @06500d> - <.main+14540 @065030>): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+14505 @06500d>: 1f a8 b3 05 00             load.ref <@05b3a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14510 @065012>: 1c 0e 00 00 00             load.c32 14
	<.main+14515 @065017>: 1c 0e 00 00 00             load.c32 14
	<.main+14520 @06501c>: 19                         load.z32
	<.main+14521 @06501d>: 1f f8 b3 05 00             load.ref <@05b3f8> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+14526 @065022>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14531 @065027>: 1f 08 15 06 00             load.ref <@061508> ;forIdx
	<.main+14536 @06502c>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes: <.main+14540 @065030> - <.main+14552 @06503c>): forIdx := forIdx + 1
	<.main+14540 @065030>: 20 08 15 06                load.m32 <@061508> ;forIdx
	<.main+14544 @065034>: 0c 01 00 00                inc.i32(+1)
	<.main+14548 @065038>: 24 08 15 06                store.m32 <@061508> ;forIdx
	cmplStd/test/lang/stmt.for.ci:13: (14 bytes: <.main+14552 @06503c> - <.main+14566 @06504a>): forIdx < 2
	<.main+14552 @06503c>: 20 08 15 06                load.m32 <@061508> ;forIdx
	<.main+14556 @065040>: 1c 02 00 00 00             load.c32 2
	<.main+14561 @065045>: 58                         clt.i32
	<.main+14562 @065046>: 05 c7 ff ff                jnz <.main+14505 @06500d>
	cmplStd/test/lang/stmt.for.ci:17: (75 bytes: <.main+14566 @06504a> - <.main+14641 @065095>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14566 @06504a>: 19                         load.z32
	<.main+14567 @06504b>: 04 3a 00 00                jmp <.main+14625 @065085>
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes: <.main+14571 @06504f> - <.main+14587 @06505f>): if (i < 2)
	<.main+14571 @06504f>: 10 00                      dup.x32 sp(0)
	<.main+14573 @065051>: 1c 02 00 00 00             load.c32 2
	<.main+14578 @065056>: 58                         clt.i32
	<.main+14579 @065057>: 06 08 00 00                jz <.main+14587 @06505f>
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes: <.main+14583 @06505b> - <.main+14587 @06505f>): continue;
	<.main+14583 @06505b>: 04 26 00 00                jmp <.main+14621 @065081>
	cmplStd/test/lang/stmt.for.ci:21: (34 bytes: <.main+14587 @06505f> - <.main+14621 @065081>): debug("for with continue", i);
	<.main+14587 @06505f>: 1f a8 b3 05 00             load.ref <@05b3a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14592 @065064>: 1c 15 00 00 00             load.c32 21
	<.main+14597 @065069>: 1c 0e 00 00 00             load.c32 14
	<.main+14602 @06506e>: 19                         load.z32
	<.main+14603 @06506f>: 1f 22 b4 05 00             load.ref <@05b422> ;"for with continue"
	<.main+14608 @065074>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14613 @065079>: 0a 18 00 00                load.sp(+24)
	<.main+14617 @06507d>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes: <.main+14621 @065081> - <.main+14625 @065085>): i := i + 1
	<.main+14621 @065081>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes: <.main+14625 @065085> - <.main+14637 @065091>): i < 7
	<.main+14625 @065085>: 10 00                      dup.x32 sp(0)
	<.main+14627 @065087>: 1c 07 00 00 00             load.c32 7
	<.main+14632 @06508c>: 58                         clt.i32
	<.main+14633 @06508d>: 05 c2 ff ff                jnz <.main+14571 @06504f>
	<.main+14637 @065091>: 09 fc ff ff                inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (75 bytes: <.main+14641 @065095> - <.main+14716 @0650e0>): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+14641 @065095>: 19                         load.z32
	<.main+14642 @065096>: 04 3a 00 00                jmp <.main+14700 @0650d0>
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes: <.main+14646 @06509a> - <.main+14662 @0650aa>): if (i > 2)
	<.main+14646 @06509a>: 10 00                      dup.x32 sp(0)
	<.main+14648 @06509c>: 1c 02 00 00 00             load.c32 2
	<.main+14653 @0650a1>: 59                         cgt.i32
	<.main+14654 @0650a2>: 06 08 00 00                jz <.main+14662 @0650aa>
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes: <.main+14658 @0650a6> - <.main+14662 @0650aa>): break;
	<.main+14658 @0650a6>: 04 36 00 00                jmp <.main+14712 @0650dc>
	cmplStd/test/lang/stmt.for.ci:28: (34 bytes: <.main+14662 @0650aa> - <.main+14696 @0650cc>): debug("for with break", i);
	<.main+14662 @0650aa>: 1f a8 b3 05 00             load.ref <@05b3a8> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+14667 @0650af>: 1c 1c 00 00 00             load.c32 28
	<.main+14672 @0650b4>: 1c 0e 00 00 00             load.c32 14
	<.main+14677 @0650b9>: 19                         load.z32
	<.main+14678 @0650ba>: 1f 34 b4 05 00             load.ref <@05b434> ;"for with break"
	<.main+14683 @0650bf>: 1f 00 04 00 00             load.ref <@000400> ;int32
	<.main+14688 @0650c4>: 0a 18 00 00                load.sp(+24)
	<.main+14692 @0650c8>: 01 08 00 00                nfc(8) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes: <.main+14696 @0650cc> - <.main+14700 @0650d0>): i := i + 1
	<.main+14696 @0650cc>: 0c 01 00 00                inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes: <.main+14700 @0650d0> - <.main+14712 @0650dc>): i < 7
	<.main+14700 @0650d0>: 10 00                      dup.x32 sp(0)
	<.main+14702 @0650d2>: 1c 07 00 00 00             load.c32 7
	<.main+14707 @0650d7>: 58                         clt.i32
	<.main+14708 @0650d8>: 05 c2 ff ff                jnz <.main+14646 @06509a>
	<.main+14712 @0650dc>: 09 fc ff ff                inc.sp(-4)
	<.main+14716 @0650e0>: 01 00 00 00                nfc(0) ;halt(): void
}

---------- Execute: byte-code
[ 182.49] > .main
[ 182.51]  > float32.sin(x: float32): float32
[ 182.53]  < return
[ 182.87]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 182.88]  < return
[ 182.89]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 182.90]  < return
[ 182.90]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 182.91]  < return
[ 182.92]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 182.93]  < return
[ 182.94]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 182.95]  < return
[ 182.96]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 182.97]  < return
[ 182.97]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 182.98]  < return
[ 182.99]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 183.00]  < return
[ 183.01]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 183.02]  < return
[ 183.03]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 183.04]  < return
[ 183.05]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 183.06]  < return
[ 183.07]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 183.08]  < return
[ 183.09]  > float64.sin(x: float64): float64
[ 183.10]  < return
[ 183.11]  > float64.cos(x: float64): float64
[ 183.12]  < return
[ 183.13]  > float64.tan(x: float64): float64
[ 183.14]  < return
[ 183.15]  > float64.log(x: float64): float64
[ 183.16]  < return
[ 183.16]  > float64.exp(x: float64): float64
[ 183.17]  < return
[ 183.18]  > float64.pow(x: float64, y: float64): float64
[ 183.19]  < return
[ 183.20]  > float64.sqrt(x: float64): float64
[ 183.21]  < return
[ 183.22]  > float64.atan2(x: float64, y: float64): float64
[ 183.23]  < return
[ 183.23]  > float32.sin(x: float32): float32
[ 183.25]  < return
[ 183.25]  > float32.cos(x: float32): float32
[ 183.26]  < return
[ 183.27]  > float32.tan(x: float32): float32
[ 183.28]  < return
[ 183.29]  > float32.log(x: float32): float32
[ 183.30]  < return
[ 183.30]  > float32.exp(x: float32): float32
[ 183.31]  < return
[ 183.32]  > float32.pow(x: float32, y: float32): float32
[ 183.34]  < return
[ 183.34]  > float32.sqrt(x: float32): float32
[ 183.35]  < return
[ 183.36]  > float32.atan2(x: float32, y: float32): float32
[ 183.37]  < return
[ 183.38]  > uint32.pop(value: int32): int32
[ 183.39]  < return
[ 183.40]  > uint32.swap(value: int32): int32
[ 183.41]  < return
[ 183.41]  > uint32.bsr(value: int32): int32
[ 183.42]  < return
[ 183.43]  > uint32.bsf(value: int32): int32
[ 183.44]  < return
[ 183.44]  > uint32.hib(value: int32): int32
[ 183.46]  < return
[ 183.46]  > uint32.lob(value: int32): int32
[ 183.47]  < return
[ 183.48]  > uint32.zxt(value: int32, offs: int32, count: int32): int32
[ 183.49]  < return
[ 183.50]  > uint32.sxt(value: int32, offs: int32, count: int32): int32
[ 183.51]  < return
[ 183.52]  > uint64.zxt(value: int64, offs: int32, count: int32): int64
[ 183.53]  < return
[ 183.54]  > uint64.sxt(value: int64, offs: int32, count: int32): int64
[ 183.56]  < return
[ 183.56]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 183.57]  < return
[ 183.58]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 183.59]  < return
[ 183.60]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 183.61]  < return
[ 183.62]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 183.63]  < return
[ 183.64]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 183.65]   > noError(ptr: pointer): void
[ 183.66]   < return
[ 183.66]   > halt(): void
[ 183.67]   < return
[ 183.67]  < return
[ 183.68]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 183.69]  < return
[ 183.69]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 183.70]   > stackOverflow(ptr: pointer): void
[ 183.71]    > stackOverflow(ptr: pointer): void
[ 183.72]     > stackOverflow(ptr: pointer): void
[ 183.73]      > stackOverflow(ptr: pointer): void
[ 183.74]       > stackOverflow(ptr: pointer): void
[ 183.75]        > stackOverflow(ptr: pointer): void
[ 183.75]         > stackOverflow(ptr: pointer): void
[ 183.76]          > stackOverflow(ptr: pointer): void
[ 183.77]           > stackOverflow(ptr: pointer): void
[ 183.78]            > stackOverflow(ptr: pointer): void
[ 183.79]             > stackOverflow(ptr: pointer): void
[ 183.80]              > stackOverflow(ptr: pointer): void
[ 183.81]               > stackOverflow(ptr: pointer): void
[ 183.81]                > stackOverflow(ptr: pointer): void
[ 183.82]                 > stackOverflow(ptr: pointer): void
[ 183.84]                  > stackOverflow(ptr: pointer): void
[ 183.84]                   > stackOverflow(ptr: pointer): void
[ 183.85]                    > stackOverflow(ptr: pointer): void
[ 183.86]                     > stackOverflow(ptr: pointer): void
[ 183.87]                      > stackOverflow(ptr: pointer): void
[ 183.88]                       > stackOverflow(ptr: pointer): void
[ 183.89]                        > stackOverflow(ptr: pointer): void
[ 183.90]                         > stackOverflow(ptr: pointer): void
[ 183.91]                          > stackOverflow(ptr: pointer): void
[ 183.92]                           > stackOverflow(ptr: pointer): void
[ 183.93]                            > stackOverflow(ptr: pointer): void
[ 183.94]                             > stackOverflow(ptr: pointer): void
[ 183.95]                              > stackOverflow(ptr: pointer): void
[ 183.96]                               > stackOverflow(ptr: pointer): void
[ 183.96]                                > stackOverflow(ptr: pointer): void
[ 183.97]                                 > stackOverflow(ptr: pointer): void
[ 183.98]                                  > stackOverflow(ptr: pointer): void
[ 183.99]                                   > stackOverflow(ptr: pointer): void
[ 184.00]                                    > stackOverflow(ptr: pointer): void
[ 184.01]                                     > stackOverflow(ptr: pointer): void
[ 184.02]                                      > stackOverflow(ptr: pointer): void
[ 184.03]                                       > stackOverflow(ptr: pointer): void
[ 184.04]                                        > stackOverflow(ptr: pointer): void
[ 184.05]                                         > stackOverflow(ptr: pointer): void
[ 184.06]                                          > stackOverflow(ptr: pointer): void
[ 184.07]                                           > stackOverflow(ptr: pointer): void
[ 184.08]                                            > stackOverflow(ptr: pointer): void
[ 184.09]                                             > stackOverflow(ptr: pointer): void
[ 184.10]                                              > stackOverflow(ptr: pointer): void
[ 184.11]                                               > stackOverflow(ptr: pointer): void
[ 184.12]                                                > stackOverflow(ptr: pointer): void
[ 184.13]                                                 > stackOverflow(ptr: pointer): void
[ 184.14]                                                  > stackOverflow(ptr: pointer): void
[ 184.15]                                                   > stackOverflow(ptr: pointer): void
[ 184.16]                                                    > stackOverflow(ptr: pointer): void
[ 184.16]                                                     > stackOverflow(ptr: pointer): void
[ 184.17]                                                      > stackOverflow(ptr: pointer): void
[ 184.18]                                                       > stackOverflow(ptr: pointer): void
[ 184.19]                                                        > stackOverflow(ptr: pointer): void
[ 184.20]                                                         > stackOverflow(ptr: pointer): void
[ 184.21]                                                          > stackOverflow(ptr: pointer): void
[ 184.22]                                                           > stackOverflow(ptr: pointer): void
[ 184.22]                                                            > stackOverflow(ptr: pointer): void
[ 184.23]                                                             > stackOverflow(ptr: pointer): void
[ 184.24]                                                              > stackOverflow(ptr: pointer): void
[ 184.26]                                                               > stackOverflow(ptr: pointer): void
[ 184.27]                                                                > stackOverflow(ptr: pointer): void
[ 184.28]                                                                 > stackOverflow(ptr: pointer): void
[ 184.29]                                                                  > stackOverflow(ptr: pointer): void
[ 184.30]                                                                   > stackOverflow(ptr: pointer): void
[ 184.31]                                                                    > stackOverflow(ptr: pointer): void
[ 184.32]                                                                     > stackOverflow(ptr: pointer): void
[ 184.33]                                                                      > stackOverflow(ptr: pointer): void
[ 184.34]                                                                       > stackOverflow(ptr: pointer): void
[ 184.35]                                                                        > stackOverflow(ptr: pointer): void
[ 184.36]                                                                         > stackOverflow(ptr: pointer): void
[ 184.37]                                                                          > stackOverflow(ptr: pointer): void
[ 184.37]                                                                           > stackOverflow(ptr: pointer): void
[ 184.38]                                                                            > stackOverflow(ptr: pointer): void
[ 184.39]                                                                             > stackOverflow(ptr: pointer): void
[ 184.40]                                                                              > stackOverflow(ptr: pointer): void
[ 184.41]                                                                               > stackOverflow(ptr: pointer): void
[ 184.42]                                                                                > stackOverflow(ptr: pointer): void
[ 184.43]                                                                                 > stackOverflow(ptr: pointer): void
[ 184.43]                                                                                  > stackOverflow(ptr: pointer): void
[ 184.44]                                                                                   > stackOverflow(ptr: pointer): void
[ 184.45]                                                                                    > stackOverflow(ptr: pointer): void
[ 184.46]                                                                                     > stackOverflow(ptr: pointer): void
[ 184.47]                                                                                      > stackOverflow(ptr: pointer): void
[ 184.48]                                                                                       > stackOverflow(ptr: pointer): void
[ 184.49]                                                                                        > stackOverflow(ptr: pointer): void
[ 184.50]                                                                                         > stackOverflow(ptr: pointer): void
[ 184.51]                                                                                          > stackOverflow(ptr: pointer): void
[ 184.51]                                                                                           > stackOverflow(ptr: pointer): void
[ 184.52]                                                                                            > stackOverflow(ptr: pointer): void
[ 184.53]                                                                                             > stackOverflow(ptr: pointer): void
[ 184.54]                                                                                              > stackOverflow(ptr: pointer): void
[ 184.55]                                                                                               > stackOverflow(ptr: pointer): void
[ 184.56]                                                                                                > stackOverflow(ptr: pointer): void
[ 184.57]                                                                                                 > stackOverflow(ptr: pointer): void
[ 184.58]                                                                                                  > stackOverflow(ptr: pointer): void
[ 184.59]                                                                                                   > stackOverflow(ptr: pointer): void
[ 184.60]                                                                                                    > stackOverflow(ptr: pointer): void
[ 184.61]                                                                                                     > stackOverflow(ptr: pointer): void
[ 184.62]                                                                                                      > stackOverflow(ptr: pointer): void
[ 184.63]                                                                                                       > stackOverflow(ptr: pointer): void
[ 184.64]                                                                                                        > stackOverflow(ptr: pointer): void
[ 184.65]                                                                                                         > stackOverflow(ptr: pointer): void
[ 184.66]                                                                                                          > stackOverflow(ptr: pointer): void
[ 184.67]                                                                                                           > stackOverflow(ptr: pointer): void
[ 184.68]                                                                                                            > stackOverflow(ptr: pointer): void
[ 184.69]                                                                                                             > stackOverflow(ptr: pointer): void
[ 184.70]                                                                                                              > stackOverflow(ptr: pointer): void
[ 184.71]                                                                                                               > stackOverflow(ptr: pointer): void
[ 184.71]                                                                                                                > stackOverflow(ptr: pointer): void
[ 184.72]                                                                                                                 > stackOverflow(ptr: pointer): void
[ 184.73]                                                                                                                  > stackOverflow(ptr: pointer): void
[ 184.74]                                                                                                                   > stackOverflow(ptr: pointer): void
[ 184.75]                                                                                                                    > stackOverflow(ptr: pointer): void
[ 184.76]                                                                                                                     > stackOverflow(ptr: pointer): void
[ 184.77]                                                                                                                      > stackOverflow(ptr: pointer): void
[ 184.78]                                                                                                                       > stackOverflow(ptr: pointer): void
[ 184.79]                                                                                                                        > stackOverflow(ptr: pointer): void
[ 184.80]                                                                                                                         > stackOverflow(ptr: pointer): void
[ 184.81]                                                                                                                          > stackOverflow(ptr: pointer): void
[ 184.81]                                                                                                                           > stackOverflow(ptr: pointer): void
[ 184.82]                                                                                                                            > stackOverflow(ptr: pointer): void
[ 184.83]                                                                                                                             > stackOverflow(ptr: pointer): void
[ 184.84]                                                                                                                              > stackOverflow(ptr: pointer): void
[ 184.85]                                                                                                                               > stackOverflow(ptr: pointer): void
[ 184.87]                                                                                                                                > stackOverflow(ptr: pointer): void
[ 184.88]                                                                                                                                 > stackOverflow(ptr: pointer): void
[ 184.88]                                                                                                                                  > stackOverflow(ptr: pointer): void
[ 184.89]                                                                                                                                  < return
[ 184.90]                                                                                                                                 < return
[ 184.90]                                                                                                                                < return
[ 184.91]                                                                                                                               < return
[ 184.91]                                                                                                                              < return
[ 184.91]                                                                                                                             < return
[ 184.92]                                                                                                                            < return
[ 184.92]                                                                                                                           < return
[ 184.93]                                                                                                                          < return
[ 184.93]                                                                                                                         < return
[ 184.94]                                                                                                                        < return
[ 184.94]                                                                                                                       < return
[ 184.95]                                                                                                                      < return
[ 184.95]                                                                                                                     < return
[ 184.96]                                                                                                                    < return
[ 184.96]                                                                                                                   < return
[ 184.97]                                                                                                                  < return
[ 184.97]                                                                                                                 < return
[ 184.97]                                                                                                                < return
[ 184.98]                                                                                                               < return
[ 184.98]                                                                                                              < return
[ 184.99]                                                                                                             < return
[ 184.99]                                                                                                            < return
[ 185.00]                                                                                                           < return
[ 185.00]                                                                                                          < return
[ 185.01]                                                                                                         < return
[ 185.01]                                                                                                        < return
[ 185.01]                                                                                                       < return
[ 185.02]                                                                                                      < return
[ 185.02]                                                                                                     < return
[ 185.03]                                                                                                    < return
[ 185.03]                                                                                                   < return
[ 185.04]                                                                                                  < return
[ 185.04]                                                                                                 < return
[ 185.05]                                                                                                < return
[ 185.05]                                                                                               < return
[ 185.06]                                                                                              < return
[ 185.06]                                                                                             < return
[ 185.06]                                                                                            < return
[ 185.07]                                                                                           < return
[ 185.07]                                                                                          < return
[ 185.08]                                                                                         < return
[ 185.08]                                                                                        < return
[ 185.09]                                                                                       < return
[ 185.09]                                                                                      < return
[ 185.09]                                                                                     < return
[ 185.10]                                                                                    < return
[ 185.10]                                                                                   < return
[ 185.11]                                                                                  < return
[ 185.11]                                                                                 < return
[ 185.12]                                                                                < return
[ 185.12]                                                                               < return
[ 185.13]                                                                              < return
[ 185.13]                                                                             < return
[ 185.14]                                                                            < return
[ 185.14]                                                                           < return
[ 185.15]                                                                          < return
[ 185.15]                                                                         < return
[ 185.16]                                                                        < return
[ 185.16]                                                                       < return
[ 185.16]                                                                      < return
[ 185.17]                                                                     < return
[ 185.17]                                                                    < return
[ 185.18]                                                                   < return
[ 185.18]                                                                  < return
[ 185.18]                                                                 < return
[ 185.19]                                                                < return
[ 185.19]                                                               < return
[ 185.20]                                                              < return
[ 185.20]                                                             < return
[ 185.21]                                                            < return
[ 185.21]                                                           < return
[ 185.22]                                                          < return
[ 185.22]                                                         < return
[ 185.23]                                                        < return
[ 185.23]                                                       < return
[ 185.24]                                                      < return
[ 185.24]                                                     < return
[ 185.24]                                                    < return
[ 185.25]                                                   < return
[ 185.25]                                                  < return
[ 185.26]                                                 < return
[ 185.26]                                                < return
[ 185.27]                                               < return
[ 185.27]                                              < return
[ 185.28]                                             < return
[ 185.28]                                            < return
[ 185.28]                                           < return
[ 185.29]                                          < return
[ 185.29]                                         < return
[ 185.30]                                        < return
[ 185.31]                                       < return
[ 185.31]                                      < return
[ 185.31]                                     < return
[ 185.32]                                    < return
[ 185.32]                                   < return
[ 185.33]                                  < return
[ 185.33]                                 < return
[ 185.34]                                < return
[ 185.34]                               < return
[ 185.34]                              < return
[ 185.35]                             < return
[ 185.35]                            < return
[ 185.35]                           < return
[ 185.36]                          < return
[ 185.36]                         < return
[ 185.37]                        < return
[ 185.37]                       < return
[ 185.38]                      < return
[ 185.38]                     < return
[ 185.38]                    < return
[ 185.39]                   < return
[ 185.39]                  < return
[ 185.40]                 < return
[ 185.40]                < return
[ 185.41]               < return
[ 185.41]              < return
[ 185.42]             < return
[ 185.42]            < return
[ 185.42]           < return
[ 185.43]          < return
[ 185.43]         < return
[ 185.44]        < return
[ 185.44]       < return
[ 185.45]      < return
[ 185.45]     < return
[ 185.46]    < return
[ 185.46]   < return
[ 185.47]  < return
[ 185.47]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 185.48]   > divisionByZero(args: pointer): void
[ 185.49]   < return
[ 185.50]  < return
[ 185.50]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 185.51]   > invalidInstruction(args: pointer): void
[ 185.52]   < return
[ 185.53]  < return
[ 185.53]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 185.54]   > invalidMemoryAccess(args: pointer): void
[ 185.55]   < return
[ 185.55]  < return
[ 185.56]  > tryExec(args: pointer, action(args: pointer): void): int32
[ 185.56]   > abortExecution(args: pointer): void
[ 185.58]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/tryExec.ci:35: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/std/tryExec.ci:53: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
[ 185.66]    < return
[ 185.66]   < return
[ 185.66]  < return
[ 185.81]  > object.create(type: typename): pointer
[ 185.83]  < return
[ 185.84]  > object.create(type: typename): pointer
[ 185.85]  < return
[ 185.87]  > funAdd(x: int32, y: int32): int32
[ 185.88]  < return
[ 185.89]  > funAdd(x: int32, y: int32): int32
[ 185.90]  < return
[ 185.91]  > funMul(x: int32, y: int32): int32
[ 185.92]  < return
[ 185.93]  > funMul(x: int32, y: int32): int32
[ 185.94]  < return
[ 185.95]  > fib(n: uint32): uint32
[ 185.96]   > fib(n: uint32): uint32
[ 185.97]    > fib(n: uint32): uint32
[ 185.98]     > fib(n: uint32): uint32
[ 185.99]      > fib(n: uint32): uint32
[ 186.01]       > fib(n: uint32): uint32
[ 186.02]        > fib(n: uint32): uint32
[ 186.03]         > fib(n: uint32): uint32
[ 186.04]          > fib(n: uint32): uint32
[ 186.05]           > fib(n: uint32): uint32
[ 186.07]            > fib(n: uint32): uint32
[ 186.08]             > fib(n: uint32): uint32
[ 186.09]              > fib(n: uint32): uint32
[ 186.10]              < return
[ 186.11]              > fib(n: uint32): uint32
[ 186.12]              < return
[ 186.13]             < return
[ 186.13]             > fib(n: uint32): uint32
[ 186.14]             < return
[ 186.15]            < return
[ 186.16]            > fib(n: uint32): uint32
[ 186.17]             > fib(n: uint32): uint32
[ 186.18]             < return
[ 186.19]             > fib(n: uint32): uint32
[ 186.20]             < return
[ 186.21]            < return
[ 186.21]           < return
[ 186.22]           > fib(n: uint32): uint32
[ 186.23]            > fib(n: uint32): uint32
[ 186.25]             > fib(n: uint32): uint32
[ 186.26]             < return
[ 186.27]             > fib(n: uint32): uint32
[ 186.28]             < return
[ 186.28]            < return
[ 186.29]            > fib(n: uint32): uint32
[ 186.30]            < return
[ 186.31]           < return
[ 186.31]          < return
[ 186.32]          > fib(n: uint32): uint32
[ 186.33]           > fib(n: uint32): uint32
[ 186.34]            > fib(n: uint32): uint32
[ 186.36]             > fib(n: uint32): uint32
[ 186.37]             < return
[ 186.37]             > fib(n: uint32): uint32
[ 186.38]             < return
[ 186.39]            < return
[ 186.40]            > fib(n: uint32): uint32
[ 186.41]            < return
[ 186.41]           < return
[ 186.42]           > fib(n: uint32): uint32
[ 186.43]            > fib(n: uint32): uint32
[ 186.44]            < return
[ 186.44]            > fib(n: uint32): uint32
[ 186.45]            < return
[ 186.46]           < return
[ 186.46]          < return
[ 186.47]         < return
[ 186.47]         > fib(n: uint32): uint32
[ 186.49]          > fib(n: uint32): uint32
[ 186.50]           > fib(n: uint32): uint32
[ 186.51]            > fib(n: uint32): uint32
[ 186.52]             > fib(n: uint32): uint32
[ 186.53]             < return
[ 186.53]             > fib(n: uint32): uint32
[ 186.55]             < return
[ 186.55]            < return
[ 186.56]            > fib(n: uint32): uint32
[ 186.57]            < return
[ 186.57]           < return
[ 186.58]           > fib(n: uint32): uint32
[ 186.59]            > fib(n: uint32): uint32
[ 186.60]            < return
[ 186.61]            > fib(n: uint32): uint32
[ 186.62]            < return
[ 186.62]           < return
[ 186.63]          < return
[ 186.63]          > fib(n: uint32): uint32
[ 186.65]           > fib(n: uint32): uint32
[ 186.66]            > fib(n: uint32): uint32
[ 186.67]            < return
[ 186.68]            > fib(n: uint32): uint32
[ 186.69]            < return
[ 186.69]           < return
[ 186.70]           > fib(n: uint32): uint32
[ 186.71]           < return
[ 186.71]          < return
[ 186.72]         < return
[ 186.72]        < return
[ 186.73]        > fib(n: uint32): uint32
[ 186.74]         > fib(n: uint32): uint32
[ 186.75]          > fib(n: uint32): uint32
[ 186.77]           > fib(n: uint32): uint32
[ 186.78]            > fib(n: uint32): uint32
[ 186.79]             > fib(n: uint32): uint32
[ 186.81]             < return
[ 186.81]             > fib(n: uint32): uint32
[ 186.82]             < return
[ 186.83]            < return
[ 186.83]            > fib(n: uint32): uint32
[ 186.85]            < return
[ 186.85]           < return
[ 186.86]           > fib(n: uint32): uint32
[ 186.87]            > fib(n: uint32): uint32
[ 186.88]            < return
[ 186.89]            > fib(n: uint32): uint32
[ 186.90]            < return
[ 186.90]           < return
[ 186.91]          < return
[ 186.91]          > fib(n: uint32): uint32
[ 186.93]           > fib(n: uint32): uint32
[ 186.94]            > fib(n: uint32): uint32
[ 186.95]            < return
[ 186.96]            > fib(n: uint32): uint32
[ 186.97]            < return
[ 186.97]           < return
[ 186.98]           > fib(n: uint32): uint32
[ 186.99]           < return
[ 187.00]          < return
[ 187.00]         < return
[ 187.01]         > fib(n: uint32): uint32
[ 187.02]          > fib(n: uint32): uint32
[ 187.03]           > fib(n: uint32): uint32
[ 187.05]            > fib(n: uint32): uint32
[ 187.06]            < return
[ 187.06]            > fib(n: uint32): uint32
[ 187.07]            < return
[ 187.08]           < return
[ 187.09]           > fib(n: uint32): uint32
[ 187.10]           < return
[ 187.10]          < return
[ 187.11]          > fib(n: uint32): uint32
[ 187.12]           > fib(n: uint32): uint32
[ 187.13]           < return
[ 187.14]           > fib(n: uint32): uint32
[ 187.15]           < return
[ 187.16]          < return
[ 187.16]         < return
[ 187.17]        < return
[ 187.18]       < return
[ 187.18]       > fib(n: uint32): uint32
[ 187.20]        > fib(n: uint32): uint32
[ 187.21]         > fib(n: uint32): uint32
[ 187.22]          > fib(n: uint32): uint32
[ 187.23]           > fib(n: uint32): uint32
[ 187.24]            > fib(n: uint32): uint32
[ 187.25]             > fib(n: uint32): uint32
[ 187.26]             < return
[ 187.27]             > fib(n: uint32): uint32
[ 187.28]             < return
[ 187.28]            < return
[ 187.29]            > fib(n: uint32): uint32
[ 187.30]            < return
[ 187.30]           < return
[ 187.31]           > fib(n: uint32): uint32
[ 187.32]            > fib(n: uint32): uint32
[ 187.33]            < return
[ 187.34]            > fib(n: uint32): uint32
[ 187.35]            < return
[ 187.35]           < return
[ 187.36]          < return
[ 187.37]          > fib(n: uint32): uint32
[ 187.38]           > fib(n: uint32): uint32
[ 187.39]            > fib(n: uint32): uint32
[ 187.40]            < return
[ 187.41]            > fib(n: uint32): uint32
[ 187.42]            < return
[ 187.43]           < return
[ 187.43]           > fib(n: uint32): uint32
[ 187.44]           < return
[ 187.45]          < return
[ 187.46]         < return
[ 187.46]         > fib(n: uint32): uint32
[ 187.47]          > fib(n: uint32): uint32
[ 187.49]           > fib(n: uint32): uint32
[ 187.50]            > fib(n: uint32): uint32
[ 187.51]            < return
[ 187.51]            > fib(n: uint32): uint32
[ 187.52]            < return
[ 187.53]           < return
[ 187.53]           > fib(n: uint32): uint32
[ 187.54]           < return
[ 187.55]          < return
[ 187.55]          > fib(n: uint32): uint32
[ 187.56]           > fib(n: uint32): uint32
[ 187.57]           < return
[ 187.58]           > fib(n: uint32): uint32
[ 187.59]           < return
[ 187.59]          < return
[ 187.60]         < return
[ 187.60]        < return
[ 187.61]        > fib(n: uint32): uint32
[ 187.62]         > fib(n: uint32): uint32
[ 187.63]          > fib(n: uint32): uint32
[ 187.65]           > fib(n: uint32): uint32
[ 187.66]            > fib(n: uint32): uint32
[ 187.67]            < return
[ 187.68]            > fib(n: uint32): uint32
[ 187.69]            < return
[ 187.69]           < return
[ 187.70]           > fib(n: uint32): uint32
[ 187.71]           < return
[ 187.72]          < return
[ 187.72]          > fib(n: uint32): uint32
[ 187.74]           > fib(n: uint32): uint32
[ 187.75]           < return
[ 187.75]           > fib(n: uint32): uint32
[ 187.76]           < return
[ 187.77]          < return
[ 187.77]         < return
[ 187.78]         > fib(n: uint32): uint32
[ 187.79]          > fib(n: uint32): uint32
[ 187.80]           > fib(n: uint32): uint32
[ 187.81]           < return
[ 187.82]           > fib(n: uint32): uint32
[ 187.83]           < return
[ 187.83]          < return
[ 187.84]          > fib(n: uint32): uint32
[ 187.85]          < return
[ 187.85]         < return
[ 187.86]        < return
[ 187.86]       < return
[ 187.87]      < return
[ 187.87]      > fib(n: uint32): uint32
[ 187.88]       > fib(n: uint32): uint32
[ 187.90]        > fib(n: uint32): uint32
[ 187.91]         > fib(n: uint32): uint32
[ 187.92]          > fib(n: uint32): uint32
[ 187.93]           > fib(n: uint32): uint32
[ 187.94]            > fib(n: uint32): uint32
[ 187.96]             > fib(n: uint32): uint32
[ 187.97]             < return
[ 187.97]             > fib(n: uint32): uint32
[ 187.99]             < return
[ 187.99]            < return
[ 188.00]            > fib(n: uint32): uint32
[ 188.01]            < return
[ 188.01]           < return
[ 188.02]           > fib(n: uint32): uint32
[ 188.03]            > fib(n: uint32): uint32
[ 188.04]            < return
[ 188.05]            > fib(n: uint32): uint32
[ 188.06]            < return
[ 188.06]           < return
[ 188.07]          < return
[ 188.07]          > fib(n: uint32): uint32
[ 188.09]           > fib(n: uint32): uint32
[ 188.10]            > fib(n: uint32): uint32
[ 188.11]            < return
[ 188.11]            > fib(n: uint32): uint32
[ 188.12]            < return
[ 188.13]           < return
[ 188.14]           > fib(n: uint32): uint32
[ 188.15]           < return
[ 188.16]          < return
[ 188.16]         < return
[ 188.17]         > fib(n: uint32): uint32
[ 188.18]          > fib(n: uint32): uint32
[ 188.19]           > fib(n: uint32): uint32
[ 188.21]            > fib(n: uint32): uint32
[ 188.22]            < return
[ 188.22]            > fib(n: uint32): uint32
[ 188.24]            < return
[ 188.24]           < return
[ 188.25]           > fib(n: uint32): uint32
[ 188.27]           < return
[ 188.27]          < return
[ 188.28]          > fib(n: uint32): uint32
[ 188.29]           > fib(n: uint32): uint32
[ 188.30]           < return
[ 188.31]           > fib(n: uint32): uint32
[ 188.32]           < return
[ 188.32]          < return
[ 188.33]         < return
[ 188.34]        < return
[ 188.34]        > fib(n: uint32): uint32
[ 188.35]         > fib(n: uint32): uint32
[ 188.37]          > fib(n: uint32): uint32
[ 188.38]           > fib(n: uint32): uint32
[ 188.39]            > fib(n: uint32): uint32
[ 188.40]            < return
[ 188.41]            > fib(n: uint32): uint32
[ 188.42]            < return
[ 188.42]           < return
[ 188.43]           > fib(n: uint32): uint32
[ 188.44]           < return
[ 188.44]          < return
[ 188.45]          > fib(n: uint32): uint32
[ 188.46]           > fib(n: uint32): uint32
[ 188.47]           < return
[ 188.48]           > fib(n: uint32): uint32
[ 188.49]           < return
[ 188.49]          < return
[ 188.50]         < return
[ 188.50]         > fib(n: uint32): uint32
[ 188.51]          > fib(n: uint32): uint32
[ 188.53]           > fib(n: uint32): uint32
[ 188.54]           < return
[ 188.54]           > fib(n: uint32): uint32
[ 188.55]           < return
[ 188.56]          < return
[ 188.57]          > fib(n: uint32): uint32
[ 188.58]          < return
[ 188.58]         < return
[ 188.59]        < return
[ 188.59]       < return
[ 188.60]       > fib(n: uint32): uint32
[ 188.61]        > fib(n: uint32): uint32
[ 188.62]         > fib(n: uint32): uint32
[ 188.63]          > fib(n: uint32): uint32
[ 188.65]           > fib(n: uint32): uint32
[ 188.66]            > fib(n: uint32): uint32
[ 188.67]            < return
[ 188.68]            > fib(n: uint32): uint32
[ 188.69]            < return
[ 188.69]           < return
[ 188.70]           > fib(n: uint32): uint32
[ 188.71]           < return
[ 188.72]          < return
[ 188.72]          > fib(n: uint32): uint32
[ 188.74]           > fib(n: uint32): uint32
[ 188.75]           < return
[ 188.75]           > fib(n: uint32): uint32
[ 188.76]           < return
[ 188.77]          < return
[ 188.78]         < return
[ 188.78]         > fib(n: uint32): uint32
[ 188.79]          > fib(n: uint32): uint32
[ 188.80]           > fib(n: uint32): uint32
[ 188.81]           < return
[ 188.82]           > fib(n: uint32): uint32
[ 188.83]           < return
[ 188.84]          < return
[ 188.85]          > fib(n: uint32): uint32
[ 188.86]          < return
[ 188.86]         < return
[ 188.87]        < return
[ 188.87]        > fib(n: uint32): uint32
[ 188.89]         > fib(n: uint32): uint32
[ 188.90]          > fib(n: uint32): uint32
[ 188.91]           > fib(n: uint32): uint32
[ 188.93]           < return
[ 188.93]           > fib(n: uint32): uint32
[ 188.94]           < return
[ 188.95]          < return
[ 188.96]          > fib(n: uint32): uint32
[ 188.97]          < return
[ 188.97]         < return
[ 188.98]         > fib(n: uint32): uint32
[ 188.99]          > fib(n: uint32): uint32
[ 189.01]          < return
[ 189.01]          > fib(n: uint32): uint32
[ 189.02]          < return
[ 189.03]         < return
[ 189.04]        < return
[ 189.04]       < return
[ 189.05]      < return
[ 189.05]     < return
[ 189.06]     > fib(n: uint32): uint32
[ 189.07]      > fib(n: uint32): uint32
[ 189.09]       > fib(n: uint32): uint32
[ 189.10]        > fib(n: uint32): uint32
[ 189.11]         > fib(n: uint32): uint32
[ 189.12]          > fib(n: uint32): uint32
[ 189.13]           > fib(n: uint32): uint32
[ 189.15]            > fib(n: uint32): uint32
[ 189.16]             > fib(n: uint32): uint32
[ 189.17]             < return
[ 189.17]             > fib(n: uint32): uint32
[ 189.18]             < return
[ 189.19]            < return
[ 189.19]            > fib(n: uint32): uint32
[ 189.20]            < return
[ 189.21]           < return
[ 189.21]           > fib(n: uint32): uint32
[ 189.22]            > fib(n: uint32): uint32
[ 189.24]            < return
[ 189.24]            > fib(n: uint32): uint32
[ 189.25]            < return
[ 189.26]           < return
[ 189.26]          < return
[ 189.27]          > fib(n: uint32): uint32
[ 189.28]           > fib(n: uint32): uint32
[ 189.30]            > fib(n: uint32): uint32
[ 189.31]            < return
[ 189.31]            > fib(n: uint32): uint32
[ 189.32]            < return
[ 189.33]           < return
[ 189.33]           > fib(n: uint32): uint32
[ 189.34]           < return
[ 189.35]          < return
[ 189.36]         < return
[ 189.36]         > fib(n: uint32): uint32
[ 189.37]          > fib(n: uint32): uint32
[ 189.39]           > fib(n: uint32): uint32
[ 189.40]            > fib(n: uint32): uint32
[ 189.41]            < return
[ 189.41]            > fib(n: uint32): uint32
[ 189.43]            < return
[ 189.43]           < return
[ 189.44]           > fib(n: uint32): uint32
[ 189.45]           < return
[ 189.46]          < return
[ 189.46]          > fib(n: uint32): uint32
[ 189.48]           > fib(n: uint32): uint32
[ 189.49]           < return
[ 189.50]           > fib(n: uint32): uint32
[ 189.51]           < return
[ 189.51]          < return
[ 189.52]         < return
[ 189.52]        < return
[ 189.53]        > fib(n: uint32): uint32
[ 189.54]         > fib(n: uint32): uint32
[ 189.55]          > fib(n: uint32): uint32
[ 189.56]           > fib(n: uint32): uint32
[ 189.57]            > fib(n: uint32): uint32
[ 189.58]            < return
[ 189.59]            > fib(n: uint32): uint32
[ 189.60]            < return
[ 189.61]           < return
[ 189.61]           > fib(n: uint32): uint32
[ 189.62]           < return
[ 189.63]          < return
[ 189.63]          > fib(n: uint32): uint32
[ 189.65]           > fib(n: uint32): uint32
[ 189.66]           < return
[ 189.66]           > fib(n: uint32): uint32
[ 189.67]           < return
[ 189.68]          < return
[ 189.68]         < return
[ 189.69]         > fib(n: uint32): uint32
[ 189.70]          > fib(n: uint32): uint32
[ 189.71]           > fib(n: uint32): uint32
[ 189.72]           < return
[ 189.73]           > fib(n: uint32): uint32
[ 189.74]           < return
[ 189.74]          < return
[ 189.75]          > fib(n: uint32): uint32
[ 189.76]          < return
[ 189.76]         < return
[ 189.77]        < return
[ 189.77]       < return
[ 189.78]       > fib(n: uint32): uint32
[ 189.79]        > fib(n: uint32): uint32
[ 189.80]         > fib(n: uint32): uint32
[ 189.82]          > fib(n: uint32): uint32
[ 189.83]           > fib(n: uint32): uint32
[ 189.84]            > fib(n: uint32): uint32
[ 189.85]            < return
[ 189.85]            > fib(n: uint32): uint32
[ 189.87]            < return
[ 189.87]           < return
[ 189.88]           > fib(n: uint32): uint32
[ 189.89]           < return
[ 189.89]          < return
[ 189.90]          > fib(n: uint32): uint32
[ 189.91]           > fib(n: uint32): uint32
[ 189.92]           < return
[ 189.93]           > fib(n: uint32): uint32
[ 189.94]           < return
[ 189.94]          < return
[ 189.95]         < return
[ 189.95]         > fib(n: uint32): uint32
[ 189.97]          > fib(n: uint32): uint32
[ 189.98]           > fib(n: uint32): uint32
[ 189.99]           < return
[ 189.99]           > fib(n: uint32): uint32
[ 190.00]           < return
[ 190.01]          < return
[ 190.02]          > fib(n: uint32): uint32
[ 190.03]          < return
[ 190.03]         < return
[ 190.04]        < return
[ 190.04]        > fib(n: uint32): uint32
[ 190.06]         > fib(n: uint32): uint32
[ 190.07]          > fib(n: uint32): uint32
[ 190.08]           > fib(n: uint32): uint32
[ 190.10]           < return
[ 190.10]           > fib(n: uint32): uint32
[ 190.11]           < return
[ 190.12]          < return
[ 190.12]          > fib(n: uint32): uint32
[ 190.14]          < return
[ 190.14]         < return
[ 190.15]         > fib(n: uint32): uint32
[ 190.16]          > fib(n: uint32): uint32
[ 190.17]          < return
[ 190.18]          > fib(n: uint32): uint32
[ 190.19]          < return
[ 190.19]         < return
[ 190.20]        < return
[ 190.20]       < return
[ 190.21]      < return
[ 190.21]      > fib(n: uint32): uint32
[ 190.22]       > fib(n: uint32): uint32
[ 190.24]        > fib(n: uint32): uint32
[ 190.25]         > fib(n: uint32): uint32
[ 190.26]          > fib(n: uint32): uint32
[ 190.27]           > fib(n: uint32): uint32
[ 190.28]            > fib(n: uint32): uint32
[ 190.30]            < return
[ 190.30]            > fib(n: uint32): uint32
[ 190.31]            < return
[ 190.32]           < return
[ 190.33]           > fib(n: uint32): uint32
[ 190.34]           < return
[ 190.34]          < return
[ 190.35]          > fib(n: uint32): uint32
[ 190.36]           > fib(n: uint32): uint32
[ 190.37]           < return
[ 190.38]           > fib(n: uint32): uint32
[ 190.39]           < return
[ 190.40]          < return
[ 190.40]         < return
[ 190.41]         > fib(n: uint32): uint32
[ 190.42]          > fib(n: uint32): uint32
[ 190.43]           > fib(n: uint32): uint32
[ 190.44]           < return
[ 190.45]           > fib(n: uint32): uint32
[ 190.46]           < return
[ 190.47]          < return
[ 190.47]          > fib(n: uint32): uint32
[ 190.48]          < return
[ 190.49]         < return
[ 190.49]        < return
[ 190.50]        > fib(n: uint32): uint32
[ 190.51]         > fib(n: uint32): uint32
[ 190.52]          > fib(n: uint32): uint32
[ 190.54]           > fib(n: uint32): uint32
[ 190.55]           < return
[ 190.56]           > fib(n: uint32): uint32
[ 190.57]           < return
[ 190.57]          < return
[ 190.58]          > fib(n: uint32): uint32
[ 190.59]          < return
[ 190.59]         < return
[ 190.60]         > fib(n: uint32): uint32
[ 190.61]          > fib(n: uint32): uint32
[ 190.62]          < return
[ 190.63]          > fib(n: uint32): uint32
[ 190.64]          < return
[ 190.65]         < return
[ 190.65]        < return
[ 190.66]       < return
[ 190.66]       > fib(n: uint32): uint32
[ 190.68]        > fib(n: uint32): uint32
[ 190.69]         > fib(n: uint32): uint32
[ 190.70]          > fib(n: uint32): uint32
[ 190.71]           > fib(n: uint32): uint32
[ 190.72]           < return
[ 190.73]           > fib(n: uint32): uint32
[ 190.74]           < return
[ 190.74]          < return
[ 190.75]          > fib(n: uint32): uint32
[ 190.76]          < return
[ 190.76]         < return
[ 190.77]         > fib(n: uint32): uint32
[ 190.78]          > fib(n: uint32): uint32
[ 190.79]          < return
[ 190.80]          > fib(n: uint32): uint32
[ 190.81]          < return
[ 190.81]         < return
[ 190.82]        < return
[ 190.82]        > fib(n: uint32): uint32
[ 190.83]         > fib(n: uint32): uint32
[ 190.84]          > fib(n: uint32): uint32
[ 190.85]          < return
[ 190.86]          > fib(n: uint32): uint32
[ 190.87]          < return
[ 190.88]         < return
[ 190.88]         > fib(n: uint32): uint32
[ 190.89]         < return
[ 190.90]        < return
[ 190.90]       < return
[ 190.91]      < return
[ 190.92]     < return
[ 190.92]    < return
[ 190.93]    > fib(n: uint32): uint32
[ 190.94]     > fib(n: uint32): uint32
[ 190.95]      > fib(n: uint32): uint32
[ 190.97]       > fib(n: uint32): uint32
[ 190.98]        > fib(n: uint32): uint32
[ 190.99]         > fib(n: uint32): uint32
[ 191.00]          > fib(n: uint32): uint32
[ 191.01]           > fib(n: uint32): uint32
[ 191.02]            > fib(n: uint32): uint32
[ 191.03]             > fib(n: uint32): uint32
[ 191.04]             < return
[ 191.05]             > fib(n: uint32): uint32
[ 191.06]             < return
[ 191.07]            < return
[ 191.07]            > fib(n: uint32): uint32
[ 191.08]            < return
[ 191.09]           < return
[ 191.09]           > fib(n: uint32): uint32
[ 191.11]            > fib(n: uint32): uint32
[ 191.12]            < return
[ 191.12]            > fib(n: uint32): uint32
[ 191.13]            < return
[ 191.14]           < return
[ 191.14]          < return
[ 191.15]          > fib(n: uint32): uint32
[ 191.16]           > fib(n: uint32): uint32
[ 191.17]            > fib(n: uint32): uint32
[ 191.18]            < return
[ 191.19]            > fib(n: uint32): uint32
[ 191.20]            < return
[ 191.21]           < return
[ 191.21]           > fib(n: uint32): uint32
[ 191.22]           < return
[ 191.23]          < return
[ 191.24]         < return
[ 191.24]         > fib(n: uint32): uint32
[ 191.25]          > fib(n: uint32): uint32
[ 191.27]           > fib(n: uint32): uint32
[ 191.28]            > fib(n: uint32): uint32
[ 191.29]            < return
[ 191.29]            > fib(n: uint32): uint32
[ 191.30]            < return
[ 191.31]           < return
[ 191.31]           > fib(n: uint32): uint32
[ 191.32]           < return
[ 191.33]          < return
[ 191.34]          > fib(n: uint32): uint32
[ 191.35]           > fib(n: uint32): uint32
[ 191.36]           < return
[ 191.36]           > fib(n: uint32): uint32
[ 191.37]           < return
[ 191.38]          < return
[ 191.38]         < return
[ 191.39]        < return
[ 191.39]        > fib(n: uint32): uint32
[ 191.40]         > fib(n: uint32): uint32
[ 191.41]          > fib(n: uint32): uint32
[ 191.43]           > fib(n: uint32): uint32
[ 191.44]            > fib(n: uint32): uint32
[ 191.45]            < return
[ 191.45]            > fib(n: uint32): uint32
[ 191.46]            < return
[ 191.47]           < return
[ 191.47]           > fib(n: uint32): uint32
[ 191.49]           < return
[ 191.49]          < return
[ 191.50]          > fib(n: uint32): uint32
[ 191.51]           > fib(n: uint32): uint32
[ 191.52]           < return
[ 191.52]           > fib(n: uint32): uint32
[ 191.53]           < return
[ 191.54]          < return
[ 191.54]         < return
[ 191.55]         > fib(n: uint32): uint32
[ 191.56]          > fib(n: uint32): uint32
[ 191.58]           > fib(n: uint32): uint32
[ 191.59]           < return
[ 191.59]           > fib(n: uint32): uint32
[ 191.60]           < return
[ 191.61]          < return
[ 191.62]          > fib(n: uint32): uint32
[ 191.63]          < return
[ 191.63]         < return
[ 191.64]        < return
[ 191.65]       < return
[ 191.65]       > fib(n: uint32): uint32
[ 191.67]        > fib(n: uint32): uint32
[ 191.68]         > fib(n: uint32): uint32
[ 191.69]          > fib(n: uint32): uint32
[ 191.71]           > fib(n: uint32): uint32
[ 191.72]            > fib(n: uint32): uint32
[ 191.73]            < return
[ 191.74]            > fib(n: uint32): uint32
[ 191.75]            < return
[ 191.75]           < return
[ 191.76]           > fib(n: uint32): uint32
[ 191.77]           < return
[ 191.77]          < return
[ 191.78]          > fib(n: uint32): uint32
[ 191.79]           > fib(n: uint32): uint32
[ 191.80]           < return
[ 191.81]           > fib(n: uint32): uint32
[ 191.82]           < return
[ 191.82]          < return
[ 191.83]         < return
[ 191.83]         > fib(n: uint32): uint32
[ 191.84]          > fib(n: uint32): uint32
[ 191.85]           > fib(n: uint32): uint32
[ 191.87]           < return
[ 191.87]           > fib(n: uint32): uint32
[ 191.88]           < return
[ 191.89]          < return
[ 191.89]          > fib(n: uint32): uint32
[ 191.90]          < return
[ 191.91]         < return
[ 191.91]        < return
[ 191.92]        > fib(n: uint32): uint32
[ 191.93]         > fib(n: uint32): uint32
[ 191.94]          > fib(n: uint32): uint32
[ 191.95]           > fib(n: uint32): uint32
[ 191.96]           < return
[ 191.97]           > fib(n: uint32): uint32
[ 191.98]           < return
[ 191.99]          < return
[ 191.99]          > fib(n: uint32): uint32
[ 192.00]          < return
[ 192.01]         < return
[ 192.02]         > fib(n: uint32): uint32
[ 192.03]          > fib(n: uint32): uint32
[ 192.04]          < return
[ 192.05]          > fib(n: uint32): uint32
[ 192.06]          < return
[ 192.06]         < return
[ 192.07]        < return
[ 192.07]       < return
[ 192.08]      < return
[ 192.08]      > fib(n: uint32): uint32
[ 192.10]       > fib(n: uint32): uint32
[ 192.11]        > fib(n: uint32): uint32
[ 192.12]         > fib(n: uint32): uint32
[ 192.13]          > fib(n: uint32): uint32
[ 192.14]           > fib(n: uint32): uint32
[ 192.16]            > fib(n: uint32): uint32
[ 192.17]            < return
[ 192.18]            > fib(n: uint32): uint32
[ 192.19]            < return
[ 192.19]           < return
[ 192.20]           > fib(n: uint32): uint32
[ 192.21]           < return
[ 192.22]          < return
[ 192.22]          > fib(n: uint32): uint32
[ 192.23]           > fib(n: uint32): uint32
[ 192.25]           < return
[ 192.25]           > fib(n: uint32): uint32
[ 192.26]           < return
[ 192.27]          < return
[ 192.28]         < return
[ 192.28]         > fib(n: uint32): uint32
[ 192.29]          > fib(n: uint32): uint32
[ 192.30]           > fib(n: uint32): uint32
[ 192.32]           < return
[ 192.32]           > fib(n: uint32): uint32
[ 192.33]           < return
[ 192.34]          < return
[ 192.34]          > fib(n: uint32): uint32
[ 192.36]          < return
[ 192.36]         < return
[ 192.37]        < return
[ 192.38]        > fib(n: uint32): uint32
[ 192.39]         > fib(n: uint32): uint32
[ 192.40]          > fib(n: uint32): uint32
[ 192.41]           > fib(n: uint32): uint32
[ 192.43]           < return
[ 192.43]           > fib(n: uint32): uint32
[ 192.44]           < return
[ 192.45]          < return
[ 192.46]          > fib(n: uint32): uint32
[ 192.47]          < return
[ 192.47]         < return
[ 192.48]         > fib(n: uint32): uint32
[ 192.49]          > fib(n: uint32): uint32
[ 192.50]          < return
[ 192.51]          > fib(n: uint32): uint32
[ 192.52]          < return
[ 192.53]         < return
[ 192.53]        < return
[ 192.54]       < return
[ 192.54]       > fib(n: uint32): uint32
[ 192.56]        > fib(n: uint32): uint32
[ 192.57]         > fib(n: uint32): uint32
[ 192.58]          > fib(n: uint32): uint32
[ 192.60]           > fib(n: uint32): uint32
[ 192.61]           < return
[ 192.61]           > fib(n: uint32): uint32
[ 192.62]           < return
[ 192.63]          < return
[ 192.63]          > fib(n: uint32): uint32
[ 192.65]          < return
[ 192.65]         < return
[ 192.66]         > fib(n: uint32): uint32
[ 192.67]          > fib(n: uint32): uint32
[ 192.68]          < return
[ 192.68]          > fib(n: uint32): uint32
[ 192.69]          < return
[ 192.70]         < return
[ 192.70]        < return
[ 192.71]        > fib(n: uint32): uint32
[ 192.72]         > fib(n: uint32): uint32
[ 192.73]          > fib(n: uint32): uint32
[ 192.74]          < return
[ 192.75]          > fib(n: uint32): uint32
[ 192.76]          < return
[ 192.77]         < return
[ 192.77]         > fib(n: uint32): uint32
[ 192.78]         < return
[ 192.79]        < return
[ 192.79]       < return
[ 192.80]      < return
[ 192.81]     < return
[ 192.81]     > fib(n: uint32): uint32
[ 192.82]      > fib(n: uint32): uint32
[ 192.84]       > fib(n: uint32): uint32
[ 192.85]        > fib(n: uint32): uint32
[ 192.86]         > fib(n: uint32): uint32
[ 192.88]          > fib(n: uint32): uint32
[ 192.89]           > fib(n: uint32): uint32
[ 192.90]            > fib(n: uint32): uint32
[ 192.91]            < return
[ 192.92]            > fib(n: uint32): uint32
[ 192.93]            < return
[ 192.94]           < return
[ 192.94]           > fib(n: uint32): uint32
[ 192.96]           < return
[ 192.96]          < return
[ 192.97]          > fib(n: uint32): uint32
[ 192.98]           > fib(n: uint32): uint32
[ 193.00]           < return
[ 193.00]           > fib(n: uint32): uint32
[ 193.01]           < return
[ 193.02]          < return
[ 193.03]         < return
[ 193.03]         > fib(n: uint32): uint32
[ 193.05]          > fib(n: uint32): uint32
[ 193.06]           > fib(n: uint32): uint32
[ 193.07]           < return
[ 193.08]           > fib(n: uint32): uint32
[ 193.09]           < return
[ 193.09]          < return
[ 193.10]          > fib(n: uint32): uint32
[ 193.11]          < return
[ 193.11]         < return
[ 193.12]        < return
[ 193.12]        > fib(n: uint32): uint32
[ 193.13]         > fib(n: uint32): uint32
[ 193.15]          > fib(n: uint32): uint32
[ 193.16]           > fib(n: uint32): uint32
[ 193.17]           < return
[ 193.17]           > fib(n: uint32): uint32
[ 193.18]           < return
[ 193.19]          < return
[ 193.19]          > fib(n: uint32): uint32
[ 193.20]          < return
[ 193.21]         < return
[ 193.21]         > fib(n: uint32): uint32
[ 193.23]          > fib(n: uint32): uint32
[ 193.24]          < return
[ 193.24]          > fib(n: uint32): uint32
[ 193.26]          < return
[ 193.26]         < return
[ 193.27]        < return
[ 193.27]       < return
[ 193.28]       > fib(n: uint32): uint32
[ 193.29]        > fib(n: uint32): uint32
[ 193.30]         > fib(n: uint32): uint32
[ 193.31]          > fib(n: uint32): uint32
[ 193.32]           > fib(n: uint32): uint32
[ 193.34]           < return
[ 193.34]           > fib(n: uint32): uint32
[ 193.35]           < return
[ 193.36]          < return
[ 193.37]          > fib(n: uint32): uint32
[ 193.38]          < return
[ 193.38]         < return
[ 193.39]         > fib(n: uint32): uint32
[ 193.40]          > fib(n: uint32): uint32
[ 193.41]          < return
[ 193.41]          > fib(n: uint32): uint32
[ 193.42]          < return
[ 193.43]         < return
[ 193.43]        < return
[ 193.44]        > fib(n: uint32): uint32
[ 193.45]         > fib(n: uint32): uint32
[ 193.46]          > fib(n: uint32): uint32
[ 193.47]          < return
[ 193.48]          > fib(n: uint32): uint32
[ 193.49]          < return
[ 193.50]         < return
[ 193.50]         > fib(n: uint32): uint32
[ 193.51]         < return
[ 193.52]        < return
[ 193.53]       < return
[ 193.53]      < return
[ 193.54]      > fib(n: uint32): uint32
[ 193.55]       > fib(n: uint32): uint32
[ 193.56]        > fib(n: uint32): uint32
[ 193.57]         > fib(n: uint32): uint32
[ 193.59]          > fib(n: uint32): uint32
[ 193.60]           > fib(n: uint32): uint32
[ 193.61]           < return
[ 193.62]           > fib(n: uint32): uint32
[ 193.63]           < return
[ 193.63]          < return
[ 193.64]          > fib(n: uint32): uint32
[ 193.65]          < return
[ 193.66]         < return
[ 193.66]         > fib(n: uint32): uint32
[ 193.68]          > fib(n: uint32): uint32
[ 193.69]          < return
[ 193.69]          > fib(n: uint32): uint32
[ 193.70]          < return
[ 193.71]         < return
[ 193.71]        < return
[ 193.72]        > fib(n: uint32): uint32
[ 193.73]         > fib(n: uint32): uint32
[ 193.74]          > fib(n: uint32): uint32
[ 193.75]          < return
[ 193.76]          > fib(n: uint32): uint32
[ 193.77]          < return
[ 193.78]         < return
[ 193.78]         > fib(n: uint32): uint32
[ 193.79]         < return
[ 193.80]        < return
[ 193.81]       < return
[ 193.81]       > fib(n: uint32): uint32
[ 193.82]        > fib(n: uint32): uint32
[ 193.84]         > fib(n: uint32): uint32
[ 193.85]          > fib(n: uint32): uint32
[ 193.86]          < return
[ 193.87]          > fib(n: uint32): uint32
[ 193.88]          < return
[ 193.89]         < return
[ 193.89]         > fib(n: uint32): uint32
[ 193.90]         < return
[ 193.91]        < return
[ 193.91]        > fib(n: uint32): uint32
[ 193.93]         > fib(n: uint32): uint32
[ 193.94]         < return
[ 193.95]         > fib(n: uint32): uint32
[ 193.96]         < return
[ 193.96]        < return
[ 193.97]       < return
[ 193.97]      < return
[ 193.98]     < return
[ 193.99]    < return
[ 193.99]   < return
[ 194.00]   > fib(n: uint32): uint32
[ 194.01]    > fib(n: uint32): uint32
[ 194.02]     > fib(n: uint32): uint32
[ 194.03]      > fib(n: uint32): uint32
[ 194.04]       > fib(n: uint32): uint32
[ 194.06]        > fib(n: uint32): uint32
[ 194.07]         > fib(n: uint32): uint32
[ 194.08]          > fib(n: uint32): uint32
[ 194.09]           > fib(n: uint32): uint32
[ 194.10]            > fib(n: uint32): uint32
[ 194.11]             > fib(n: uint32): uint32
[ 194.12]             < return
[ 194.13]             > fib(n: uint32): uint32
[ 194.14]             < return
[ 194.14]            < return
[ 194.15]            > fib(n: uint32): uint32
[ 194.16]            < return
[ 194.16]           < return
[ 194.17]           > fib(n: uint32): uint32
[ 194.18]            > fib(n: uint32): uint32
[ 194.19]            < return
[ 194.20]            > fib(n: uint32): uint32
[ 194.21]            < return
[ 194.22]           < return
[ 194.22]          < return
[ 194.23]          > fib(n: uint32): uint32
[ 194.24]           > fib(n: uint32): uint32
[ 194.25]            > fib(n: uint32): uint32
[ 194.26]            < return
[ 194.27]            > fib(n: uint32): uint32
[ 194.28]            < return
[ 194.29]           < return
[ 194.29]           > fib(n: uint32): uint32
[ 194.31]           < return
[ 194.31]          < return
[ 194.32]         < return
[ 194.32]         > fib(n: uint32): uint32
[ 194.33]          > fib(n: uint32): uint32
[ 194.34]           > fib(n: uint32): uint32
[ 194.35]            > fib(n: uint32): uint32
[ 194.37]            < return
[ 194.37]            > fib(n: uint32): uint32
[ 194.38]            < return
[ 194.39]           < return
[ 194.39]           > fib(n: uint32): uint32
[ 194.40]           < return
[ 194.41]          < return
[ 194.41]          > fib(n: uint32): uint32
[ 194.42]           > fib(n: uint32): uint32
[ 194.43]           < return
[ 194.44]           > fib(n: uint32): uint32
[ 194.45]           < return
[ 194.45]          < return
[ 194.46]         < return
[ 194.46]        < return
[ 194.47]        > fib(n: uint32): uint32
[ 194.48]         > fib(n: uint32): uint32
[ 194.49]          > fib(n: uint32): uint32
[ 194.51]           > fib(n: uint32): uint32
[ 194.52]            > fib(n: uint32): uint32
[ 194.53]            < return
[ 194.54]            > fib(n: uint32): uint32
[ 194.55]            < return
[ 194.56]           < return
[ 194.56]           > fib(n: uint32): uint32
[ 194.57]           < return
[ 194.58]          < return
[ 194.59]          > fib(n: uint32): uint32
[ 194.60]           > fib(n: uint32): uint32
[ 194.61]           < return
[ 194.61]           > fib(n: uint32): uint32
[ 194.62]           < return
[ 194.63]          < return
[ 194.63]         < return
[ 194.64]         > fib(n: uint32): uint32
[ 194.65]          > fib(n: uint32): uint32
[ 194.66]           > fib(n: uint32): uint32
[ 194.67]           < return
[ 194.68]           > fib(n: uint32): uint32
[ 194.69]           < return
[ 194.69]          < return
[ 194.70]          > fib(n: uint32): uint32
[ 194.71]          < return
[ 194.71]         < return
[ 194.72]        < return
[ 194.72]       < return
[ 194.73]       > fib(n: uint32): uint32
[ 194.74]        > fib(n: uint32): uint32
[ 194.75]         > fib(n: uint32): uint32
[ 194.76]          > fib(n: uint32): uint32
[ 194.78]           > fib(n: uint32): uint32
[ 194.79]            > fib(n: uint32): uint32
[ 194.80]            < return
[ 194.81]            > fib(n: uint32): uint32
[ 194.82]            < return
[ 194.82]           < return
[ 194.83]           > fib(n: uint32): uint32
[ 194.84]           < return
[ 194.84]          < return
[ 194.85]          > fib(n: uint32): uint32
[ 194.86]           > fib(n: uint32): uint32
[ 194.87]           < return
[ 194.88]           > fib(n: uint32): uint32
[ 194.89]           < return
[ 194.90]          < return
[ 194.90]         < return
[ 194.91]         > fib(n: uint32): uint32
[ 194.92]          > fib(n: uint32): uint32
[ 194.93]           > fib(n: uint32): uint32
[ 194.94]           < return
[ 194.95]           > fib(n: uint32): uint32
[ 194.96]           < return
[ 194.96]          < return
[ 194.97]          > fib(n: uint32): uint32
[ 194.98]          < return
[ 194.98]         < return
[ 194.99]        < return
[ 195.00]        > fib(n: uint32): uint32
[ 195.01]         > fib(n: uint32): uint32
[ 195.02]          > fib(n: uint32): uint32
[ 195.03]           > fib(n: uint32): uint32
[ 195.04]           < return
[ 195.04]           > fib(n: uint32): uint32
[ 195.06]           < return
[ 195.06]          < return
[ 195.07]          > fib(n: uint32): uint32
[ 195.08]          < return
[ 195.08]         < return
[ 195.09]         > fib(n: uint32): uint32
[ 195.10]          > fib(n: uint32): uint32
[ 195.11]          < return
[ 195.12]          > fib(n: uint32): uint32
[ 195.13]          < return
[ 195.14]         < return
[ 195.14]        < return
[ 195.15]       < return
[ 195.15]      < return
[ 195.16]      > fib(n: uint32): uint32
[ 195.17]       > fib(n: uint32): uint32
[ 195.19]        > fib(n: uint32): uint32
[ 195.20]         > fib(n: uint32): uint32
[ 195.21]          > fib(n: uint32): uint32
[ 195.22]           > fib(n: uint32): uint32
[ 195.24]            > fib(n: uint32): uint32
[ 195.25]            < return
[ 195.25]            > fib(n: uint32): uint32
[ 195.26]            < return
[ 195.27]           < return
[ 195.28]           > fib(n: uint32): uint32
[ 195.29]           < return
[ 195.29]          < return
[ 195.30]          > fib(n: uint32): uint32
[ 195.31]           > fib(n: uint32): uint32
[ 195.32]           < return
[ 195.32]           > fib(n: uint32): uint32
[ 195.33]           < return
[ 195.34]          < return
[ 195.34]         < return
[ 195.35]         > fib(n: uint32): uint32
[ 195.36]          > fib(n: uint32): uint32
[ 195.37]           > fib(n: uint32): uint32
[ 195.38]           < return
[ 195.39]           > fib(n: uint32): uint32
[ 195.40]           < return
[ 195.40]          < return
[ 195.41]          > fib(n: uint32): uint32
[ 195.42]          < return
[ 195.43]         < return
[ 195.43]        < return
[ 195.44]        > fib(n: uint32): uint32
[ 195.45]         > fib(n: uint32): uint32
[ 195.46]          > fib(n: uint32): uint32
[ 195.47]           > fib(n: uint32): uint32
[ 195.48]           < return
[ 195.49]           > fib(n: uint32): uint32
[ 195.50]           < return
[ 195.51]          < return
[ 195.51]          > fib(n: uint32): uint32
[ 195.52]          < return
[ 195.53]         < return
[ 195.53]         > fib(n: uint32): uint32
[ 195.54]          > fib(n: uint32): uint32
[ 195.56]          < return
[ 195.56]          > fib(n: uint32): uint32
[ 195.57]          < return
[ 195.58]         < return
[ 195.59]        < return
[ 195.59]       < return
[ 195.60]       > fib(n: uint32): uint32
[ 195.61]        > fib(n: uint32): uint32
[ 195.62]         > fib(n: uint32): uint32
[ 195.63]          > fib(n: uint32): uint32
[ 195.65]           > fib(n: uint32): uint32
[ 195.66]           < return
[ 195.66]           > fib(n: uint32): uint32
[ 195.68]           < return
[ 195.68]          < return
[ 195.69]          > fib(n: uint32): uint32
[ 195.70]          < return
[ 195.70]         < return
[ 195.71]         > fib(n: uint32): uint32
[ 195.72]          > fib(n: uint32): uint32
[ 195.73]          < return
[ 195.73]          > fib(n: uint32): uint32
[ 195.75]          < return
[ 195.75]         < return
[ 195.76]        < return
[ 195.76]        > fib(n: uint32): uint32
[ 195.77]         > fib(n: uint32): uint32
[ 195.79]          > fib(n: uint32): uint32
[ 195.80]          < return
[ 195.81]          > fib(n: uint32): uint32
[ 195.82]          < return
[ 195.82]         < return
[ 195.83]         > fib(n: uint32): uint32
[ 195.84]         < return
[ 195.84]        < return
[ 195.85]       < return
[ 195.85]      < return
[ 195.86]     < return
[ 195.87]     > fib(n: uint32): uint32
[ 195.88]      > fib(n: uint32): uint32
[ 195.89]       > fib(n: uint32): uint32
[ 195.91]        > fib(n: uint32): uint32
[ 195.92]         > fib(n: uint32): uint32
[ 195.93]          > fib(n: uint32): uint32
[ 195.95]           > fib(n: uint32): uint32
[ 195.96]            > fib(n: uint32): uint32
[ 195.97]            < return
[ 195.98]            > fib(n: uint32): uint32
[ 195.99]            < return
[ 196.00]           < return
[ 196.00]           > fib(n: uint32): uint32
[ 196.02]           < return
[ 196.02]          < return
[ 196.03]          > fib(n: uint32): uint32
[ 196.04]           > fib(n: uint32): uint32
[ 196.05]           < return
[ 196.06]           > fib(n: uint32): uint32
[ 196.07]           < return
[ 196.08]          < return
[ 196.08]         < return
[ 196.09]         > fib(n: uint32): uint32
[ 196.10]          > fib(n: uint32): uint32
[ 196.11]           > fib(n: uint32): uint32
[ 196.12]           < return
[ 196.13]           > fib(n: uint32): uint32
[ 196.14]           < return
[ 196.14]          < return
[ 196.15]          > fib(n: uint32): uint32
[ 196.16]          < return
[ 196.17]         < return
[ 196.17]        < return
[ 196.18]        > fib(n: uint32): uint32
[ 196.19]         > fib(n: uint32): uint32
[ 196.20]          > fib(n: uint32): uint32
[ 196.22]           > fib(n: uint32): uint32
[ 196.23]           < return
[ 196.24]           > fib(n: uint32): uint32
[ 196.25]           < return
[ 196.26]          < return
[ 196.26]          > fib(n: uint32): uint32
[ 196.27]          < return
[ 196.28]         < return
[ 196.29]         > fib(n: uint32): uint32
[ 196.30]          > fib(n: uint32): uint32
[ 196.31]          < return
[ 196.32]          > fib(n: uint32): uint32
[ 196.33]          < return
[ 196.34]         < return
[ 196.34]        < return
[ 196.34]       < return
[ 196.35]       > fib(n: uint32): uint32
[ 196.36]        > fib(n: uint32): uint32
[ 196.38]         > fib(n: uint32): uint32
[ 196.39]          > fib(n: uint32): uint32
[ 196.40]           > fib(n: uint32): uint32
[ 196.41]           < return
[ 196.42]           > fib(n: uint32): uint32
[ 196.43]           < return
[ 196.44]          < return
[ 196.44]          > fib(n: uint32): uint32
[ 196.46]          < return
[ 196.46]         < return
[ 196.47]         > fib(n: uint32): uint32
[ 196.48]          > fib(n: uint32): uint32
[ 196.49]          < return
[ 196.49]          > fib(n: uint32): uint32
[ 196.50]          < return
[ 196.51]         < return
[ 196.51]        < return
[ 196.52]        > fib(n: uint32): uint32
[ 196.53]         > fib(n: uint32): uint32
[ 196.54]          > fib(n: uint32): uint32
[ 196.55]          < return
[ 196.56]          > fib(n: uint32): uint32
[ 196.57]          < return
[ 196.57]         < return
[ 196.58]         > fib(n: uint32): uint32
[ 196.59]         < return
[ 196.59]        < return
[ 196.60]       < return
[ 196.60]      < return
[ 196.61]      > fib(n: uint32): uint32
[ 196.62]       > fib(n: uint32): uint32
[ 196.63]        > fib(n: uint32): uint32
[ 196.64]         > fib(n: uint32): uint32
[ 196.65]          > fib(n: uint32): uint32
[ 196.66]           > fib(n: uint32): uint32
[ 196.68]           < return
[ 196.68]           > fib(n: uint32): uint32
[ 196.69]           < return
[ 196.70]          < return
[ 196.70]          > fib(n: uint32): uint32
[ 196.71]          < return
[ 196.72]         < return
[ 196.72]         > fib(n: uint32): uint32
[ 196.74]          > fib(n: uint32): uint32
[ 196.75]          < return
[ 196.75]          > fib(n: uint32): uint32
[ 196.76]          < return
[ 196.77]         < return
[ 196.78]        < return
[ 196.78]        > fib(n: uint32): uint32
[ 196.79]         > fib(n: uint32): uint32
[ 196.80]          > fib(n: uint32): uint32
[ 196.81]          < return
[ 196.82]          > fib(n: uint32): uint32
[ 196.83]          < return
[ 196.84]         < return
[ 196.84]         > fib(n: uint32): uint32
[ 196.85]         < return
[ 196.86]        < return
[ 196.86]       < return
[ 196.87]       > fib(n: uint32): uint32
[ 196.88]        > fib(n: uint32): uint32
[ 196.89]         > fib(n: uint32): uint32
[ 196.91]          > fib(n: uint32): uint32
[ 196.91]          < return
[ 196.92]          > fib(n: uint32): uint32
[ 196.93]          < return
[ 196.94]         < return
[ 196.94]         > fib(n: uint32): uint32
[ 196.95]         < return
[ 196.96]        < return
[ 196.97]        > fib(n: uint32): uint32
[ 196.98]         > fib(n: uint32): uint32
[ 197.00]         < return
[ 197.00]         > fib(n: uint32): uint32
[ 197.01]         < return
[ 197.02]        < return
[ 197.02]       < return
[ 197.03]      < return
[ 197.03]     < return
[ 197.04]    < return
[ 197.04]    > fib(n: uint32): uint32
[ 197.06]     > fib(n: uint32): uint32
[ 197.07]      > fib(n: uint32): uint32
[ 197.08]       > fib(n: uint32): uint32
[ 197.09]        > fib(n: uint32): uint32
[ 197.10]         > fib(n: uint32): uint32
[ 197.11]          > fib(n: uint32): uint32
[ 197.12]           > fib(n: uint32): uint32
[ 197.14]            > fib(n: uint32): uint32
[ 197.15]            < return
[ 197.15]            > fib(n: uint32): uint32
[ 197.17]            < return
[ 197.17]           < return
[ 197.18]           > fib(n: uint32): uint32
[ 197.19]           < return
[ 197.19]          < return
[ 197.20]          > fib(n: uint32): uint32
[ 197.22]           > fib(n: uint32): uint32
[ 197.22]           < return
[ 197.23]           > fib(n: uint32): uint32
[ 197.24]           < return
[ 197.25]          < return
[ 197.25]         < return
[ 197.26]         > fib(n: uint32): uint32
[ 197.27]          > fib(n: uint32): uint32
[ 197.28]           > fib(n: uint32): uint32
[ 197.29]           < return
[ 197.30]           > fib(n: uint32): uint32
[ 197.31]           < return
[ 197.32]          < return
[ 197.33]          > fib(n: uint32): uint32
[ 197.34]          < return
[ 197.34]         < return
[ 197.35]        < return
[ 197.35]        > fib(n: uint32): uint32
[ 197.36]         > fib(n: uint32): uint32
[ 197.38]          > fib(n: uint32): uint32
[ 197.39]           > fib(n: uint32): uint32
[ 197.40]           < return
[ 197.40]           > fib(n: uint32): uint32
[ 197.41]           < return
[ 197.42]          < return
[ 197.42]          > fib(n: uint32): uint32
[ 197.43]          < return
[ 197.44]         < return
[ 197.45]         > fib(n: uint32): uint32
[ 197.46]          > fib(n: uint32): uint32
[ 197.47]          < return
[ 197.48]          > fib(n: uint32): uint32
[ 197.49]          < return
[ 197.49]         < return
[ 197.50]        < return
[ 197.50]       < return
[ 197.51]       > fib(n: uint32): uint32
[ 197.52]        > fib(n: uint32): uint32
[ 197.54]         > fib(n: uint32): uint32
[ 197.55]          > fib(n: uint32): uint32
[ 197.56]           > fib(n: uint32): uint32
[ 197.57]           < return
[ 197.58]           > fib(n: uint32): uint32
[ 197.59]           < return
[ 197.59]          < return
[ 197.60]          > fib(n: uint32): uint32
[ 197.61]          < return
[ 197.61]         < return
[ 197.62]         > fib(n: uint32): uint32
[ 197.63]          > fib(n: uint32): uint32
[ 197.64]          < return
[ 197.64]          > fib(n: uint32): uint32
[ 197.65]          < return
[ 197.66]         < return
[ 197.66]        < return
[ 197.67]        > fib(n: uint32): uint32
[ 197.68]         > fib(n: uint32): uint32
[ 197.69]          > fib(n: uint32): uint32
[ 197.70]          < return
[ 197.71]          > fib(n: uint32): uint32
[ 197.72]          < return
[ 197.73]         < return
[ 197.73]         > fib(n: uint32): uint32
[ 197.74]         < return
[ 197.75]        < return
[ 197.75]       < return
[ 197.76]      < return
[ 197.77]      > fib(n: uint32): uint32
[ 197.78]       > fib(n: uint32): uint32
[ 197.79]        > fib(n: uint32): uint32
[ 197.81]         > fib(n: uint32): uint32
[ 197.82]          > fib(n: uint32): uint32
[ 197.83]           > fib(n: uint32): uint32
[ 197.84]           < return
[ 197.85]           > fib(n: uint32): uint32
[ 197.86]           < return
[ 197.86]          < return
[ 197.87]          > fib(n: uint32): uint32
[ 197.88]          < return
[ 197.88]         < return
[ 197.89]         > fib(n: uint32): uint32
[ 197.90]          > fib(n: uint32): uint32
[ 197.91]          < return
[ 197.91]          > fib(n: uint32): uint32
[ 197.92]          < return
[ 197.93]         < return
[ 197.93]        < return
[ 197.94]        > fib(n: uint32): uint32
[ 197.95]         > fib(n: uint32): uint32
[ 197.96]          > fib(n: uint32): uint32
[ 197.97]          < return
[ 197.98]          > fib(n: uint32): uint32
[ 197.99]          < return
[ 198.00]         < return
[ 198.00]         > fib(n: uint32): uint32
[ 198.01]         < return
[ 198.02]        < return
[ 198.02]       < return
[ 198.03]       > fib(n: uint32): uint32
[ 198.04]        > fib(n: uint32): uint32
[ 198.06]         > fib(n: uint32): uint32
[ 198.07]          > fib(n: uint32): uint32
[ 198.08]          < return
[ 198.09]          > fib(n: uint32): uint32
[ 198.10]          < return
[ 198.10]         < return
[ 198.11]         > fib(n: uint32): uint32
[ 198.12]         < return
[ 198.12]        < return
[ 198.13]        > fib(n: uint32): uint32
[ 198.14]         > fib(n: uint32): uint32
[ 198.15]         < return
[ 198.16]         > fib(n: uint32): uint32
[ 198.17]         < return
[ 198.17]        < return
[ 198.18]       < return
[ 198.18]      < return
[ 198.19]     < return
[ 198.19]     > fib(n: uint32): uint32
[ 198.21]      > fib(n: uint32): uint32
[ 198.22]       > fib(n: uint32): uint32
[ 198.23]        > fib(n: uint32): uint32
[ 198.24]         > fib(n: uint32): uint32
[ 198.25]          > fib(n: uint32): uint32
[ 198.26]           > fib(n: uint32): uint32
[ 198.27]           < return
[ 198.28]           > fib(n: uint32): uint32
[ 198.29]           < return
[ 198.29]          < return
[ 198.30]          > fib(n: uint32): uint32
[ 198.31]          < return
[ 198.32]         < return
[ 198.32]         > fib(n: uint32): uint32
[ 198.34]          > fib(n: uint32): uint32
[ 198.35]          < return
[ 198.36]          > fib(n: uint32): uint32
[ 198.37]          < return
[ 198.37]         < return
[ 198.38]        < return
[ 198.38]        > fib(n: uint32): uint32
[ 198.39]         > fib(n: uint32): uint32
[ 198.41]          > fib(n: uint32): uint32
[ 198.41]          < return
[ 198.42]          > fib(n: uint32): uint32
[ 198.43]          < return
[ 198.44]         < return
[ 198.44]         > fib(n: uint32): uint32
[ 198.46]         < return
[ 198.46]        < return
[ 198.47]       < return
[ 198.47]       > fib(n: uint32): uint32
[ 198.49]        > fib(n: uint32): uint32
[ 198.50]         > fib(n: uint32): uint32
[ 198.51]          > fib(n: uint32): uint32
[ 198.53]          < return
[ 198.53]          > fib(n: uint32): uint32
[ 198.54]          < return
[ 198.55]         < return
[ 198.56]         > fib(n: uint32): uint32
[ 198.57]         < return
[ 198.57]        < return
[ 198.58]        > fib(n: uint32): uint32
[ 198.59]         > fib(n: uint32): uint32
[ 198.60]         < return
[ 198.61]         > fib(n: uint32): uint32
[ 198.62]         < return
[ 198.62]        < return
[ 198.63]       < return
[ 198.63]      < return
[ 198.64]      > fib(n: uint32): uint32
[ 198.65]       > fib(n: uint32): uint32
[ 198.66]        > fib(n: uint32): uint32
[ 198.67]         > fib(n: uint32): uint32
[ 198.69]          > fib(n: uint32): uint32
[ 198.69]          < return
[ 198.70]          > fib(n: uint32): uint32
[ 198.71]          < return
[ 198.72]         < return
[ 198.72]         > fib(n: uint32): uint32
[ 198.73]         < return
[ 198.74]        < return
[ 198.74]        > fib(n: uint32): uint32
[ 198.75]         > fib(n: uint32): uint32
[ 198.76]         < return
[ 198.77]         > fib(n: uint32): uint32
[ 198.78]         < return
[ 198.79]        < return
[ 198.79]       < return
[ 198.80]       > fib(n: uint32): uint32
[ 198.81]        > fib(n: uint32): uint32
[ 198.82]         > fib(n: uint32): uint32
[ 198.83]         < return
[ 198.84]         > fib(n: uint32): uint32
[ 198.85]         < return
[ 198.85]        < return
[ 198.86]        > fib(n: uint32): uint32
[ 198.87]        < return
[ 198.88]       < return
[ 198.88]      < return
[ 198.89]     < return
[ 198.89]    < return
[ 198.90]   < return
[ 198.90]  < return
[ 198.94]  > typename.name(type: typename): .cstr
[ 198.96]  < return
[ 198.98]  > typename.file(type: typename): .cstr
[ 198.99]  < return
[ 199.00]  > typename.line(type: typename): int32
[ 199.02]  < return
[ 199.02]  > typename.base(type: typename): typename
[ 199.04]  < return
[ 199.05]  > typename.name(type: typename): .cstr
[ 199.06]  < return
[ 199.07]  > typename.file(type: typename): .cstr
[ 199.09]  < return
[ 199.10]  > typename.line(type: typename): int32
[ 199.11]  < return
[ 199.12]  > typename.base(type: typename): typename
[ 199.14]  < return
[ 199.15]  > typename.base(type: typename): typename
[ 199.16]  < return
[ 200.37]  > Math.floor(x: float64): float64
[ 200.37]   > Math.modf(x: float64, intPart: float64): float64
[ 200.38]   < return
[ 200.38]  < return
[ 200.39]  > Math.floor(x: float64): float64
[ 200.40]   > Math.modf(x: float64, intPart: float64): float64
[ 200.40]   < return
[ 200.41]  < return
[ 200.42]  > Math.floor(x: float64): float64
[ 200.42]   > Math.modf(x: float64, intPart: float64): float64
[ 200.43]   < return
[ 200.43]  < return
[ 200.44]  > Math.floor(x: float64): float64
[ 200.45]   > Math.modf(x: float64, intPart: float64): float64
[ 200.45]    > Math.modf(x: float64, intPart: float64): float64
[ 200.46]    < return
[ 200.46]   < return
[ 200.47]  < return
[ 200.48]  > Math.floor(x: float64): float64
[ 200.48]   > Math.modf(x: float64, intPart: float64): float64
[ 200.49]    > Math.modf(x: float64, intPart: float64): float64
[ 200.49]    < return
[ 200.50]   < return
[ 200.50]  < return
[ 200.51]  > Math.floor(x: float64): float64
[ 200.51]   > Math.modf(x: float64, intPart: float64): float64
[ 200.52]    > Math.modf(x: float64, intPart: float64): float64
[ 200.52]    < return
[ 200.53]   < return
[ 200.53]  < return
[ 200.61]  > Math.abs(x: float64): float64
[ 200.61]  < return
[ 200.62]  > Math.abs(x: float64): float64
[ 200.63]  < return
[ 200.64]  > Math.abs(x: float64): float64
[ 200.64]  < return
[ 200.65]  > Math.abs(x: float32): float32
[ 200.66]  < return
[ 200.67]  > Math.abs(x: float32): float32
[ 200.68]  < return
[ 200.69]  > Math.abs(x: float32): float32
[ 200.70]  < return
[ 200.71]  > Math.min(a: float32, b: float32): float32
[ 200.71]  < return
[ 200.73]  > Math.max(a: float32, b: float32): float32
[ 200.73]  < return
[ 200.74]  > Math.min(a: float64, b: float64): float64
[ 200.75]  < return
[ 200.76]  > Math.max(a: float64, b: float64): float64
[ 200.76]  < return
[ 200.78]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 200.78]  < return
[ 200.79]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 200.80]  < return
[ 200.84]  > Math.clamp(t: float32, a: float32, b: float32): float32
[ 200.84]  < return
[ 200.87]  > Math.clamp(t: float64, a: float64, b: float64): float64
[ 200.88]  < return
[ 200.90]  > Math.min(data: float64[]): float64
[ 200.91]  < return
[ 200.93]  > Math.min(data: float64[]): float64
[ 200.95]  < return
[ 200.97]  > Math.max(data: float64[]): float64
[ 200.97]  < return
[ 201.00]  > Math.max(data: float64[]): float64
[ 201.02]  < return
[ 201.03]  > Math.sum(data: float64[]): float64
[ 201.04]  < return
[ 201.05]  > Math.sum(data: float64[]): float64
[ 201.06]  < return
[ 201.07]  > Math.sum(data: float64[]): float64
[ 201.09]  < return
[ 201.11]  > Math.sum(data: float64[]): float64
[ 201.13]  < return
[ 201.15]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 201.16]  < return
[ 201.21]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 201.23]  < return
[ 201.25]  > Math.eval(x: float64, polynomial: float64[]): float64
[ 201.27]  < return
[ 201.28]  > Math.sinCos(arg: float64, quad: int32): float64
[ 201.30]  < return
[ 201.32]  > Math.abs(x: float64): float64
[ 201.32]  < return
[ 201.33]  > Math.sinCos(arg: float64, quad: int32): float64
[ 201.35]  < return
[ 201.36]  > Math.tan(arg: float64): float64
[ 201.37]   > Math.modf(x: float64, intPart: float64): float64
[ 201.37]   < return
[ 201.39]  < return
[ 201.40]  > Math.sinh(x: float64): float64
[ 201.41]   > float64.exp(x: float64): float64
[ 201.42]   < return
[ 201.43]   > float64.exp(x: float64): float64
[ 201.44]   < return
[ 201.44]  < return
[ 201.46]  > Math.cosh(x: float64): float64
[ 201.46]   > float64.exp(x: float64): float64
[ 201.47]   < return
[ 201.48]   > float64.exp(x: float64): float64
[ 201.49]   < return
[ 201.50]  < return
[ 201.51]  > Math.asin(x: float64): float64
[ 201.52]   > float64.sqrt(x: float64): float64
[ 201.53]   < return
[ 201.54]   > float64.atan2(x: float64, y: float64): float64
[ 201.55]   < return
[ 201.55]  < return
[ 201.57]  > Math.asin(x: float64): float64
[ 201.58]   > float64.sqrt(x: float64): float64
[ 201.59]   < return
[ 201.59]   > float64.atan2(x: float64, y: float64): float64
[ 201.60]   < return
[ 201.61]  < return
[ 201.62]  > Math.cmp(a: float32, b: float32, eps: float32): int32
[ 201.63]  < return
[ 201.64]  > Math.cmp(a: float64, b: float64, eps: float64): int32
[ 201.65]  < return
[ 201.66]  > Math.absMod(val: float64, mod: float64): float64
[ 201.67]  < return
[ 201.68]  > Math.absMod(val: float64, mod: float64): float64
[ 201.68]  < return
[ 201.69]  > Math.absMod(val: float64, mod: float64): float64
[ 201.70]  < return
[ 201.71]  > Math.absMod(val: float64, mod: float64): float64
[ 201.72]  < return
[ 201.73]  > Math.absMod(val: float64, mod: float64): float64
[ 201.74]  < return
[ 201.75]  > Math.absMod(val: float64, mod: float64): float64
[ 201.75]  < return
[ 201.77]  > Math.absMod(val: float64, mod: float64): float64
[ 201.77]  < return
[ 201.78]  > Math.absMod(val: float64, mod: float64): float64
[ 201.79]  < return
[ 201.80]  > Math.absMod(val: float64, mod: float64): float64
[ 201.81]  < return
[ 201.82]  > Math.absMod(val: float64, mod: float64): float64
[ 201.83]  < return
[ 201.84]  > Math.absMod(val: float64, mod: float64): float64
[ 201.84]  < return
[ 201.86]  > Math.absMod(val: float32, mod: float32): float32
[ 201.86]  < return
[ 201.87]  > Math.absMod(val: float32, mod: float32): float32
[ 201.88]  < return
[ 201.89]  > Math.absMod(val: float32, mod: float32): float32
[ 201.90]  < return
[ 201.91]  > Math.absMod(val: float32, mod: float32): float32
[ 201.91]  < return
[ 201.93]  > Math.absMod(val: float32, mod: float32): float32
[ 201.93]  < return
[ 201.94]  > Math.absMod(val: float32, mod: float32): float32
[ 201.95]  < return
[ 201.96]  > Math.absMod(val: float32, mod: float32): float32
[ 201.96]  < return
[ 201.97]  > Math.absMod(val: float32, mod: float32): float32
[ 201.98]  < return
[ 201.99]  > Math.absMod(val: float32, mod: float32): float32
[ 201.99]  < return
[ 202.00]  > Math.absMod(val: float32, mod: float32): float32
[ 202.01]  < return
[ 202.02]  > Math.absMod(val: float32, mod: float32): float32
[ 202.03]  < return
[ 202.03]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 202.05]  < return
[ 202.06]  > pointer.copy(dst: pointer, src: pointer, size: int32): pointer
[ 202.07]  < return
[ 202.08]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 202.09]  < return
[ 202.10]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 202.12]  < return
[ 202.13]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 202.14]  < return
[ 202.15]  > pointer.alloc(ptr: pointer, size: int32): pointer
[ 202.16]  < return
[ 202.17]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:26: debug: val1: int64(42)
[ 202.19]  < return
[ 202.21]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:27: debug: val2: int64(96)
[ 202.22]  < return
[ 202.23]  > pointer.move(dst: pointer, src: pointer, size: int32): pointer
[ 202.24]  < return
[ 202.25]  > pointer.fill(dst: pointer, value: uint8, size: int32): pointer
[ 202.26]  < return
[ 202.28]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:32: debug: val1: int64(0)
[ 202.30]  < return
[ 202.31]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/std/memory.ci:33: debug: val2: int64(42)
[ 202.32]  < return
[ 202.33]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 202.34]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 202.41]   < return
[ 202.42]  < return
[ 202.43]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 202.44]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 1)
	native.code:: .main
[ 202.51]   < return
[ 202.52]  < return
[ 202.53]  > staticMethod(this: RecordMethodTest, x: int32): void
[ 202.54]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
[ 202.55]   < return
[ 202.56]   > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 202.57]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
[ 202.65]    < return
[ 202.65]   < return
[ 202.66]  < return
[ 202.67]  > virtualMethod(this: RecordMethodTest, x: int32): void
[ 202.68]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
[ 202.69]   < return
[ 202.70]   > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 202.71]    > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
[ 202.78]    < return
[ 202.79]   < return
[ 202.79]  < return
[ 202.81]  > RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
[ 202.82]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 202.88]   < return
[ 202.89]  < return
[ 202.90]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 202.91]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 202.97]   < return
[ 202.98]  < return
[ 202.99]  > RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
[ 203.00]   > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: {
		abstractMethod: <globalFunction>,
		delegateMethod: <RecordMethodTest.forwardMethod>,
		virtualMethod: <RecordMethodTest.virtualMethod>
	}, x: 3)
	native.code:: .main
[ 203.07]   < return
[ 203.08]  < return
[ 203.09]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:35: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
[ 203.14]  < return
[ 203.15]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:38: debug: string as variant: char[*]("string")
[ 203.17]  < return
[ 203.18]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/init.array.ci:41: debug: string as variant: char[]([0] {})
[ 203.19]  < return
[ 203.21]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.22]  < return
[ 203.23]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.24]  < return
[ 203.25]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.25]  < return
[ 203.26]  > lenSlice(values: int64[]): int32
[ 203.27]  < return
[ 203.28]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.29]  < return
[ 203.30]  > lenSlice(values: int64[]): int32
[ 203.31]  < return
[ 203.32]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.32]  < return
[ 203.33]  > lenSlice(values: int64[]): int32
[ 203.35]  < return
[ 203.35]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.36]  < return
[ 203.37]  > lenSlice(values: int64[]): int32
[ 203.38]  < return
[ 203.39]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.40]  < return
[ 203.41]  > lenSlice(values: int64[]): int32
[ 203.42]  < return
[ 203.43]  > assertEq(expected: int32, returned: int32, message: char[*]): void
[ 203.43]  < return
[ 203.48]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.49]  < return
[ 203.51]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.52]  < return
[ 203.54]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.55]  < return
[ 203.57]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.58]  < return
[ 203.59]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.61]  < return
[ 203.62]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.64]  < return
[ 203.66]  > nthSlice(idx: int32, values: int64[]): int64
[ 203.67]  < return
[ 203.68]  > nthSlice(idx: int32, values: int64[]): int64
[ 203.70]  < return
[ 203.76]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.77]  < return
[ 203.79]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.80]  < return
[ 203.82]  > nthFixed(idx: int32, values: int64[7]): int64
[ 203.83]  < return
[ 203.85]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.86]  < return
[ 203.88]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.89]  < return
[ 203.91]  > nthArray(idx: int32, values: int64[*]): int64
[ 203.92]  < return
[ 203.94]  > nthSlice(idx: int32, values: int64[]): int64
[ 203.95]  < return
[ 203.97]  > nthSlice(idx: int32, values: int64[]): int64
[ 203.98]  < return
[ 204.04]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.05]  < return
[ 204.06]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.08]  < return
[ 204.09]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.10]  < return
[ 204.12]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.13]  < return
[ 204.14]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.16]  < return
[ 204.17]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.18]  < return
[ 204.20]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.21]  < return
[ 204.23]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.24]  < return
[ 204.31]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.32]  < return
[ 204.34]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.35]  < return
[ 204.37]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.38]  < return
[ 204.39]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.40]  < return
[ 204.42]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.43]  < return
[ 204.45]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.46]  < return
[ 204.47]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.49]  < return
[ 204.50]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.51]  < return
[ 204.58]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.59]  < return
[ 204.61]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.62]  < return
[ 204.63]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.65]  < return
[ 204.66]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.67]  < return
[ 204.69]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.70]  < return
[ 204.71]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.72]  < return
[ 204.74]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.75]  < return
[ 204.77]  > nthSlice(idx: int32, values: int64[]): int64
[ 204.78]  < return
[ 204.84]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.86]  < return
[ 204.87]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.88]  < return
[ 204.90]  > nthFixed(idx: int32, values: int64[7]): int64
[ 204.91]  < return
[ 204.93]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.94]  < return
[ 204.95]  > nthArray(idx: int32, values: int64[*]): int64
[ 204.97]  < return
[ 204.98]  > nthArray(idx: int32, values: int64[*]): int64
[ 205.00]  < return
[ 205.01]  > nthSlice(idx: int32, values: int64[]): int64
[ 205.02]  < return
[ 205.04]  > nthSlice(idx: int32, values: int64[]): int64
[ 205.05]  < return
[ 205.11]  > nthFixed(idx: int32, values: int64[7]): int64
[ 205.12]  < return
[ 205.13]  > nthFixed(idx: int32, values: int64[7]): int64
[ 205.15]  < return
[ 205.16]  > nthFixed(idx: int32, values: int64[7]): int64
[ 205.18]  < return
[ 205.19]  > nthArray(idx: int32, values: int64[*]): int64
[ 205.21]  < return
[ 205.22]  > nthArray(idx: int32, values: int64[*]): int64
[ 205.23]  < return
[ 205.25]  > nthArray(idx: int32, values: int64[*]): int64
[ 205.26]  < return
[ 205.27]  > nthSlice(idx: int32, values: int64[]): int64
[ 205.29]  < return
[ 205.30]  > nthSlice(idx: int32, values: int64[]): int64
[ 205.32]  < return
[ 205.35]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
[ 205.36]  < return
[ 205.37]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
[ 205.39]  < return
[ 205.40]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
[ 205.41]  < return
[ 205.43]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
[ 205.45]  < return
[ 205.47]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
[ 205.48]  < return
[ 205.50]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
[ 205.52]  < return
[ 205.53]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
[ 205.55]  < return
[ 205.56]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
[ 205.57]  < return
[ 205.59]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
[ 205.61]  < return
[ 205.63]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
[ 205.64]  < return
[ 205.67]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
[ 205.69]  < return
[ 205.71]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
[ 205.72]  < return
[ 205.77]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
[ 205.79]  < return
[ 205.81]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
[ 205.82]  < return
[ 205.84]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
[ 205.86]  < return
[ 205.88]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
[ 205.89]  < return
[ 205.92]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
[ 205.93]  < return
[ 205.96]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
[ 205.98]  < return
[ 206.00]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
[ 206.02]  < return
[ 206.04]  > raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)
[ 206.05]  < return
[ 206.07]  > halt(): void
[ 206.08]  < return
[ 206.08] < return

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System: typename(<System>)
cmplStd/lib/debug.ci:48: NotEquals: typename(<NotEquals>)
cmplStd/lib/debug.ci:61: assertEq: function(<assertEq>)
cmplStd/lib/math.ci:22: Math.modf: function(<Math.modf>)
cmplStd/lib/math.ci:47: Math.floor: function(<Math.floor>)
cmplStd/lib/math.ci:77: Math.abs: function(<Math.abs>)
cmplStd/lib/math.ci:85: Math.abs: function(<Math.abs>)
cmplStd/lib/math.ci:93: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:101: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math.ci:115: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:123: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:137: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:145: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:159: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:170: Math.clamp: function(<Math.clamp>)
cmplStd/lib/math.ci:201: Math.min: function(<Math.min>)
cmplStd/lib/math.ci:215: Math.max: function(<Math.max>)
cmplStd/lib/math.ci:229: Math.sum: function(<Math.sum>)
cmplStd/lib/math.ci:238: Math.mean: function(<Math.mean>)
cmplStd/lib/math.ci:255: Math.eval: function(<Math.eval>)
cmplStd/lib/math.ci:264: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:279: Math.cmp: function(<Math.cmp>)
cmplStd/lib/math.ci:294: Math.sinCos: function(<Math.sinCos>)
cmplStd/lib/math.ci:351: Math.tan: function(<Math.tan>)
cmplStd/lib/math.ci:408: Math.sinh: function(<Math.sinh>)
cmplStd/lib/math.ci:447: Math.cosh: function(<Math.cosh>)
cmplStd/lib/math.ci:462: Math.asin: function(<Math.asin>)
cmplStd/lib/math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:24: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:31: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:86: div: function(<div>)
cmplStd/lib/math/Complex.ci:117: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:135: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:111: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:163: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:173: scale: function(<scale>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/string.ci:4: length: function(<length>)
cmplStd/lib/string.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/string.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/string.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/string.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/string.ci:61: compare: function(<compare>)
cmplStd/lib/string.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/string.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/string.ci:112: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/string.ci:127: append: function(<append>)
cmplStd/lib/string.ci:144: append: function(<append>)
cmplStd/lib/string.ci:234: append: function(<append>)
cmplStd/lib/string.ci:262: append: function(<append>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:29: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/std/number.ci:3: pi64: float64(3.141593)
cmplStd/test/std/number.ci:4: e64: float64(2.718282)
cmplStd/test/std/number.ci:6: pi32: float32(3.141593)
cmplStd/test/std/number.ci:7: e32: float32(2.718282)
cmplStd/test/std/number.ci:14: r_comp: int32(112)
cmplStd/test/std/number.ci:15: g_comp: int32(252)
cmplStd/test/std/number.ci:16: b_comp: int32(248)
cmplStd/test/std/number.ci:18: r5g6b5: int32(30719)
cmplStd/test/std/number.ci:19: r8g8b8: int32(7404792)
cmplStd/test/std/number.ci:21: zxtR5: int32(14)
cmplStd/test/std/number.ci:22: zxtG6: int32(63)
cmplStd/test/std/number.ci:23: zxtB5: int32(31)
cmplStd/test/std/number.ci:25: sxtR5: int32(14)
cmplStd/test/std/number.ci:26: sxtG6: int32(-1)
cmplStd/test/std/number.ci:27: sxtB5: int32(-1)
cmplStd/test/std/number.ci:29: zxtR8: int32(112)
cmplStd/test/std/number.ci:30: zxtG8: int32(252)
cmplStd/test/std/number.ci:31: zxtB8: int32(248)
cmplStd/test/std/number.ci:33: sxtR8: int32(112)
cmplStd/test/std/number.ci:34: sxtG8: int32(-4)
cmplStd/test/std/number.ci:35: sxtB8: int32(-8)
cmplStd/test/std/number.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/std/number.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/std/number.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/std/number.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/std/number.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/std/number.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/std/number.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/std/number.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/std/number.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/std/number.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/std/number.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/std/number.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/std/number.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/std/number.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/std/number.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/std/number.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/std/number.ci:55: testPopulation_u32: int32(14)
cmplStd/test/std/number.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/std/number.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/std/number.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/std/number.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/std/number.ci:60: testLowBit_u32: int32(1)
cmplStd/test/std/number.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/std/number.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/std/number.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/std/number.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/std/memory.ci:7: p1: pointer(<?>)
cmplStd/test/std/memory.ci:8: p2: pointer(<?>)
cmplStd/test/std/memory.ci:9: p3: pointer(<?>)
cmplStd/test/std/memory.ci:10: p4: pointer(<?>)
cmplStd/test/std/memory.ci:23: val1: int64(0)
cmplStd/test/std/memory.ci:24: val2: int64(42)
cmplStd/test/std/tryExec.ci:11: noError: function(<noError>)
cmplStd/test/std/tryExec.ci:14: stackOverflow: function(<stackOverflow>)
cmplStd/test/std/tryExec.ci:20: divisionByZero: function(<divisionByZero>)
cmplStd/test/std/tryExec.ci:24: abortExecution: function(<abortExecution>)
cmplStd/test/std/tryExec.ci:38: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/std/tryExec.ci:43: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/std/tryExec.ci:47: tryExecErr0: int32(0)
cmplStd/test/std/tryExec.ci:48: tryExecErr1: int32(1)
cmplStd/test/std/tryExec.ci:49: tryExecErr2: int32(2)
cmplStd/test/std/tryExec.ci:50: tryExecErr3: int32(3)
cmplStd/test/std/tryExec.ci:51: tryExecErr4: int32(4)
cmplStd/test/std/tryExec.ci:52: tryExecErr5: int32(5)
cmplStd/test/std/tryExec.ci:53: tryExecErr6: int32(6)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(160)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(300016)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(299696)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/init.array.ci:11: arrFixedInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:18: arrArrayInitNull: int64[*](null)
cmplStd/test/lang/init.array.ci:19: arrSliceInitNull: int64[](null)
cmplStd/test/lang/init.array.ci:22: arrArrayInitFixed: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:23: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:26: arrArrayInitSlice: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:27: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
cmplStd/test/lang/init.array.ci:30: arrArrayInitPtr: int64[*]([0] {})
cmplStd/test/lang/init.array.ci:34: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
cmplStd/test/lang/init.array.ci:37: strArray: char[*]("string")
cmplStd/test/lang/init.array.ci:40: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
cmplStd/test/lang/init.array.ci:51: lenSlice: function(<lenSlice>)
cmplStd/test/lang/init.array.ci:52: nthFixed: function(<nthFixed>)
cmplStd/test/lang/init.array.ci:53: nthArray: function(<nthArray>)
cmplStd/test/lang/init.array.ci:54: nthSlice: function(<nthSlice>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<shift>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/std/test.math.ci:3: testMathFloor_1: float64(3.000000)
cmplStd/test/std/test.math.ci:4: testMathFloor_2: float64(3.000000)
cmplStd/test/std/test.math.ci:5: testMathFloor_3: float64(3.000000)
cmplStd/test/std/test.math.ci:6: testMathFloor_4: float64(-3.000000)
cmplStd/test/std/test.math.ci:7: testMathFloor_5: float64(-3.000000)
cmplStd/test/std/test.math.ci:8: testMathFloor_6: float64(-3.000000)
cmplStd/test/std/test.math.ci:10: testMathSign_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:11: testMathSign_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:12: testMathSign_3F: float64(-1.000000)
cmplStd/test/std/test.math.ci:13: testMathSign_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:14: testMathSign_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:15: testMathSign_3f: float64(-1.000000)
cmplStd/test/std/test.math.ci:17: testMathAbs_1F: float64(0.200000)
cmplStd/test/std/test.math.ci:18: testMathAbs_2F: float64(0.000000)
cmplStd/test/std/test.math.ci:19: testMathAbs_3F: float64(0.900000)
cmplStd/test/std/test.math.ci:20: testMathAbs_1f: float64(0.200000)
cmplStd/test/std/test.math.ci:21: testMathAbs_2f: float64(0.000000)
cmplStd/test/std/test.math.ci:22: testMathAbs_3f: float64(0.900000)
cmplStd/test/std/test.math.ci:24: testMathMin_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:25: testMathMax_2f: float64(2.000000)
cmplStd/test/std/test.math.ci:26: testMathMin_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:27: testMathMax_2F: float64(2.000000)
cmplStd/test/std/test.math.ci:29: testMathClamp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:30: testMathClamp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:32: testMathLerp_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:33: testMathLerp_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:35: testMathSmooth_1f: float64(1.000000)
cmplStd/test/std/test.math.ci:36: testMathSmooth_1F: float64(1.000000)
cmplStd/test/std/test.math.ci:38: testMathMin_nan: float64(-nan)
cmplStd/test/std/test.math.ci:39: testMathMin_1: float64(1.000000)
cmplStd/test/std/test.math.ci:40: testMathMax_nan: float64(-nan)
cmplStd/test/std/test.math.ci:41: testMathMax_9: float64(9.000000)
cmplStd/test/std/test.math.ci:43: testMathSum_0: float64(0.000000)
cmplStd/test/std/test.math.ci:44: testMathSum_1: float64(1.000000)
cmplStd/test/std/test.math.ci:45: testMathSum_3: float64(3.000000)
cmplStd/test/std/test.math.ci:46: testMathSum_55: float64(55.000000)
cmplStd/test/std/test.math.ci:48: testMathEval_x: float64(10.000000)
cmplStd/test/std/test.math.ci:49: testMathEval_0: float64(0.000000)
cmplStd/test/std/test.math.ci:50: testMathEval_1: float64(1.000000)
cmplStd/test/std/test.math.ci:51: testMathEval_2: float64(11.000000)
cmplStd/test/std/test.math.ci:52: testMathEval_3: float64(111.000000)
cmplStd/test/std/test.math.ci:53: testMathEval_4: float64(1111.000000)
cmplStd/test/std/test.math.ci:54: testMathEval_5: float64(11111.000000)
cmplStd/test/std/test.math.ci:55: testMathEval_6: float64(111111.000000)
cmplStd/test/std/test.math.ci:57: testMathSin_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:58: testMathCos_f64: float64(-0.000000)
cmplStd/test/std/test.math.ci:59: testMathTan_f64: float64(1.000000)
cmplStd/test/std/test.math.ci:60: testMathSinh_f64: float64(2.301299)
cmplStd/test/std/test.math.ci:61: testMathCosh_f64: float64(2.509178)
cmplStd/test/std/test.math.ci:63: testMathAsin_f64: float64(0.201358)
cmplStd/test/std/test.math.ci:64: testMathAcos_f64: float64(1.369438)
cmplStd/test/std/test.math.ci:67: testMathCmp_f32: bool(1)
cmplStd/test/std/test.math.ci:68: testMathCmp_f64: bool(1)
cmplStd/test/std/test.math.ci:70: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/std/test.math.ci:71: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/std/test.math.ci:72: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/std/test.math.ci:74: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/std/test.math.ci:75: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/std/test.math.ci:76: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/std/test.math.ci:77: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/std/test.math.ci:79: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/std/test.math.ci:80: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/std/test.math.ci:81: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/std/test.math.ci:82: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/std/test.math.ci:84: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/std/test.math.ci:85: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/std/test.math.ci:86: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/std/test.math.ci:88: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/std/test.math.ci:89: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/std/test.math.ci:90: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/std/test.math.ci:91: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/std/test.math.ci:93: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/std/test.math.ci:94: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/std/test.math.ci:95: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/std/test.math.ci:96: testMathAbsMod_f32_8d: float32(8.000000)

---------- Memory usage:
memory[all] @000000; size: 4194016(4.0 Mb)
memory[used] @000000; size: 413924(404.2 Kb)
memory[heap] @0650e4; size: 2731540(2.6 Mb)
memory[stack] @1fff40; size: 1048504(1023.9 Kb)

---------- used memory:
memory[meta] @000000; size: 388472(379.4 Kb)
memory[code] @000000; size: 20248(19.8 Kb)
memory[data] @000000; size: 2698(2.6 Kb)

---------- heap memory:
memory[free] @065100; size: 2144(2.1 Kb)
memory[used] @065970; size: 32(32.0 bytes)
memory[used] @0659a0; size: 32(32.0 bytes)
memory[free] @0659d0; size: 2729232(2.6 Mb)

---------- Profile functions: 80/119, coverage: 67.23%
::[.005ed8, .005ed8): exec(2), time(0.010 ms): halt(): void
::[.006198, .006198): exec(0), time(0.000 ms): variant.as(var: variant, type: typename): pointer
::[.006500, .006500): exec(3), time(0.045 ms): typename.base(type: typename): typename
::[.006718, .006718): exec(2), time(0.034 ms): typename.file(type: typename): .cstr
::[.006930, .006930): exec(2), time(0.031 ms): typename.line(type: typename): int32
::[.006b48, .006b48): exec(2), time(0.036 ms): typename.name(type: typename): .cstr
::[.006e08, .006e08): exec(2), time(0.033 ms): object.create(type: typename): pointer
::[.0070c0, .0070c0): exec(0), time(0.000 ms): object.as(this: object, type: typename): pointer
::[.0078e0, .0078e0): exec(37), time(0.980 ms): raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
::[.008230, .008230): exec(7), time(1.987 ms): tryExec(args: pointer, action(args: pointer): void): int32
::[.0084f0, .0084f0): exec(8), time(0.091 ms): pointer.alloc(ptr: pointer, size: int32): pointer
::[.008850, .008850): exec(2), time(0.026 ms): pointer.fill(dst: pointer, value: uint8, size: int32): pointer
::[.008bb0, .008bb0): exec(1), time(0.012 ms): pointer.copy(dst: pointer, src: pointer, size: int32): pointer
::[.008f08, .008f08): exec(1), time(0.012 ms): pointer.move(dst: pointer, src: pointer, size: int32): pointer
::[.0091d0, .0091d0): exec(0), time(0.000 ms): System.exit(code: int32): void
::[.0093f0, .0093f0): exec(0), time(0.000 ms): System.srand(seed: int32): void
::[.009568, .009568): exec(0), time(0.000 ms): System.rand(): int32
::[.0096e0, .0096e0): exec(0), time(0.000 ms): System.time(): int32
::[.009858, .009858): exec(0), time(0.000 ms): System.clock(): int32
::[.0099d0, .0099d0): exec(0), time(0.000 ms): System.millis(): int64
::[.009be8, .009be8): exec(0), time(0.000 ms): System.sleep(millis: int64): void
::[.009f48, .009f48): exec(7), time(0.075 ms): uint32.zxt(value: int32, offs: int32, count: int32): int32
::[.00a2a0, .00a2a0): exec(7), time(0.078 ms): uint32.sxt(value: int32, offs: int32, count: int32): int32
::[.00a4b8, .00a4b8): exec(1), time(0.011 ms): uint32.pop(value: int32): int32
::[.00a6d0, .00a6d0): exec(1), time(0.009 ms): uint32.swap(value: int32): int32
::[.00a8e8, .00a8e8): exec(1), time(0.010 ms): uint32.bsr(value: int32): int32
::[.00ab00, .00ab00): exec(1), time(0.010 ms): uint32.bsf(value: int32): int32
::[.00ad18, .00ad18): exec(1), time(0.011 ms): uint32.hib(value: int32): int32
::[.00af30, .00af30): exec(1), time(0.010 ms): uint32.lob(value: int32): int32
::[.00b280, .00b280): exec(1), time(0.012 ms): uint64.zxt(value: int64, offs: int32, count: int32): int64
::[.00b5d0, .00b5d0): exec(1), time(0.012 ms): uint64.sxt(value: int64, offs: int32, count: int32): int64
::[.00b7e8, .00b7e8): exec(2), time(0.027 ms): float32.sin(x: float32): float32
::[.00ba00, .00ba00): exec(1), time(0.010 ms): float32.cos(x: float32): float32
::[.00bc18, .00bc18): exec(1), time(0.011 ms): float32.tan(x: float32): float32
::[.00be30, .00be30): exec(1), time(0.011 ms): float32.log(x: float32): float32
::[.00c048, .00c048): exec(1), time(0.010 ms): float32.exp(x: float32): float32
::[.00c300, .00c300): exec(1), time(0.012 ms): float32.pow(x: float32, y: float32): float32
::[.00c518, .00c518): exec(1), time(0.010 ms): float32.sqrt(x: float32): float32
::[.00c7d0, .00c7d0): exec(1), time(0.011 ms): float32.atan2(x: float32, y: float32): float32
::[.00c9e0, .00c9e0): exec(1), time(0.017 ms): float64.sin(x: float64): float64
::[.00cbf0, .00cbf0): exec(1), time(0.011 ms): float64.cos(x: float64): float64
::[.00ce00, .00ce00): exec(1), time(0.011 ms): float64.tan(x: float64): float64
::[.00d010, .00d010): exec(1), time(0.011 ms): float64.log(x: float64): float64
::[.00d220, .00d220): exec(5), time(0.056 ms): float64.exp(x: float64): float64
::[.00d4d0, .00d4d0): exec(1), time(0.010 ms): float64.pow(x: float64, y: float64): float64
::[.00d6e0, .00d6e0): exec(3), time(0.031 ms): float64.sqrt(x: float64): float64
::[.00d990, .00d990): exec(3), time(0.034 ms): float64.atan2(x: float64, y: float64): float64
cmplStd/lib/debug.ci:61:[.05ed78, .05eddf): exec(8), time(0.054 ms): assertEq(expected: int32, returned: int32, message: char[*]): void
cmplStd/lib/math.ci:22:[.05ede0, .05ee36): exec(10), time(0.064 ms): Math.modf(x: float64, intPart: float64): float64
cmplStd/lib/math.ci:47:[.05ee38, .05ee50): exec(6), time(0.115-0.058 ms): Math.floor(x: float64): float64
cmplStd/lib/math.ci:77:[.05ee50, .05ee62): exec(3), time(0.018 ms): Math.abs(x: float32): float32
cmplStd/lib/math.ci:85:[.05ee68, .05ee7a): exec(4), time(0.026 ms): Math.abs(x: float64): float64
cmplStd/lib/math.ci:93:[.05ee80, .05ee9b): exec(11), time(0.068 ms): Math.absMod(val: float32, mod: float32): float32
cmplStd/lib/math.ci:101:[.05eea0, .05eebb): exec(11), time(0.076 ms): Math.absMod(val: float64, mod: float64): float64
cmplStd/lib/math.ci:115:[.05eec0, .05eed1): exec(1), time(0.006 ms): Math.min(a: float32, b: float32): float32
cmplStd/lib/math.ci:123:[.05eed8, .05eee9): exec(1), time(0.006 ms): Math.min(a: float64, b: float64): float64
cmplStd/lib/math.ci:137:[.05eef0, .05ef01): exec(1), time(0.007 ms): Math.max(a: float32, b: float32): float32
cmplStd/lib/math.ci:145:[.05ef08, .05ef19): exec(1), time(0.006 ms): Math.max(a: float64, b: float64): float64
cmplStd/lib/math.ci:159:[.05ef20, .05ef3e): exec(2), time(0.013 ms): Math.clamp(t: float32, a: float32, b: float32): float32
cmplStd/lib/math.ci:170:[.05ef40, .05ef5e): exec(2), time(0.014 ms): Math.clamp(t: float64, a: float64, b: float64): float64
cmplStd/lib/math.ci:201:[.05ef60, .05efaf): exec(2), time(0.034 ms): Math.min(data: float64[]): float64
cmplStd/lib/math.ci:215:[.05efb0, .05efff): exec(2), time(0.032 ms): Math.max(data: float64[]): float64
cmplStd/lib/math.ci:229:[.05f000, .05f028): exec(4), time(0.054 ms): Math.sum(data: float64[]): float64
cmplStd/lib/math.ci:238:[.05f028, .05f03c): exec(0), time(0.000 ms): Math.mean(data: float64[]): float64
cmplStd/lib/math.ci:255:[.05f040, .05f06f): exec(3), time(0.052 ms): Math.eval(x: float64, polynomial: float64[]): float64
cmplStd/lib/math.ci:264:[.05f070, .05f0a9): exec(1), time(0.008 ms): Math.cmp(a: float32, b: float32, eps: float32): int32
cmplStd/lib/math.ci:279:[.05f0b0, .05f0e9): exec(1), time(0.007 ms): Math.cmp(a: float64, b: float64, eps: float64): int32
cmplStd/lib/math.ci:294:[.05f0f0, .05f23f): exec(2), time(0.038 ms): Math.sinCos(arg: float64, quad: int32): float64
cmplStd/lib/math.ci:351:[.05f240, .05f3ba): exec(1), time(0.031-0.006 ms): Math.tan(arg: float64): float64
cmplStd/lib/math.ci:408:[.05f3c0, .05f4b1): exec(1), time(0.042-0.022 ms): Math.sinh(x: float64): float64
cmplStd/lib/math.ci:447:[.05f4b8, .05f503): exec(1), time(0.040-0.024 ms): Math.cosh(x: float64): float64
cmplStd/lib/math.ci:462:[.05f508, .05f5b5): exec(2), time(0.086-0.042 ms): Math.asin(x: float64): float64
cmplStd/lib/math/Complex.ci:24:[.05f5b8, .05f5bf): exec(0), time(0.000 ms): Complex(re: float64): Complex
cmplStd/lib/math/Complex.ci:31:[.05f5c0, .05f5c7): exec(0), time(0.000 ms): Complex(re: float64, im: float64): Complex
cmplStd/lib/math/Complex.ci:86:[.05f5c8, .05f643): exec(0), time(0.000 ms): div(a: Complex, b: Complex): Complex
cmplStd/lib/math/Complex.ci:117:[.05f648, .05f667): exec(0), time(0.000 ms): inv(a: Complex): Complex
cmplStd/lib/math/Complex.ci:135:[.05f668, .05f6cc): exec(0), time(0.000 ms): pow(a: Complex, b: Complex): Complex
cmplStd/lib/math/Matrix4f.ci:62:[.05f6d0, .05f701): exec(0), time(0.000 ms): mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:75:[.05f708, .05f71d): exec(0), time(0.000 ms): mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
cmplStd/lib/math/Matrix4f.ci:87:[.05f720, .05f751): exec(0), time(0.000 ms): transpose(mat: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:97:[.05f758, .05f84d): exec(0), time(0.000 ms): mul(lhs: mat4f, rhs: mat4f): mat4f
cmplStd/lib/math/Matrix4f.ci:111:[.05f850, .05fa16): exec(0), time(0.000 ms): rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:163:[.05fa18, .05fa70): exec(0), time(0.000 ms): translation(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Matrix4f.ci:173:[.05fa70, .05fb49): exec(0), time(0.000 ms): scale(direction: vec4f, amount: float32): mat4f
cmplStd/lib/math/Vector2d.ci:14:[.05fb50, .05fb57): exec(0), time(0.000 ms): vec2d(x: float64, y: float64): vec2d
cmplStd/lib/string.ci:4:[.05fb58, .05fb7e): exec(0), time(0.000 ms): length(str: char[*]): int32
cmplStd/lib/string.ci:15:[.05fb80, .05fbb2): exec(0), time(0.000 ms): indexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:25:[.05fbb8, .05fbea): exec(0), time(0.000 ms): lastIndexOf(str: char[*], chr: char): int32
cmplStd/lib/string.ci:36:[.05fbf0, .05fc39): exec(0), time(0.000 ms): startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:46:[.05fc40, .05fcbe): exec(0), time(0.000 ms): endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
cmplStd/lib/string.ci:61:[.05fcc0, .05fcff): exec(0), time(0.000 ms): compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
cmplStd/lib/string.ci:74:[.05fd00, .05fd47): exec(0), time(0.000 ms): ignCaseCmp.ignCase(chr: char): char
cmplStd/lib/string.ci:73:[.05fd48, .05fd6c): exec(0), time(0.000 ms): ignCaseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:88:[.05fd70, .05fd7e): exec(0), time(0.000 ms): caseCmp(chr: char, with: char): int32
cmplStd/lib/string.ci:127:[.05fd80, .05fdd4): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: char[*]): int32
cmplStd/lib/string.ci:144:[.05fde8, .0600ab): exec(0), time(0.000 ms): append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
cmplStd/lib/string.ci:234:[.0600b0, .060193): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
cmplStd/lib/string.ci:262:[.0601a8, .0601e7): exec(0), time(0.000 ms): append(output: char[], pos: int32, value: int32): int32
cmplStd/test/std/tryExec.ci:11:[.060598, .060599): exec(1), time(0.010 ms): noError(ptr: pointer): void
cmplStd/test/std/tryExec.ci:14:[.0605a0, .0605b8): exec(128-128), time(1.759 ms): stackOverflow(ptr: pointer): void
cmplStd/test/std/tryExec.ci:20:[.0605b8, .0605c4): exec(1-1), time(0.009 ms): divisionByZero(args: pointer): void
cmplStd/test/std/tryExec.ci:24:[.0605c8, .06060c): exec(1-1), time(0.094-0.075 ms): abortExecution(args: pointer): void
cmplStd/test/std/tryExec.ci:38:[.060610, .06061d): exec(1-1), time(0.010 ms): invalidMemoryAccess(args: pointer): void
cmplStd/test/std/tryExec.ci:43:[.060620, .060622): exec(1-1), time(0.009 ms): invalidInstruction(args: pointer): void
cmplStd/test/lang/function.ci:4:[.060920, .060921): exec(0), time(0.000 ms): empty(): void
cmplStd/test/lang/function.ci:7:[.060928, .060930): exec(2), time(0.021 ms): funAdd(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:33:[.060968, .060970): exec(2), time(0.020 ms): funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:38:[.060970, .0609a6): exec(753), time(12.955 ms): fib(n: uint32): uint32
cmplStd/test/lang/init.method.ci:10:[.060b20, .060b47): exec(3), time(0.262-0.203 ms): RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:40:[.060b50, .060b77): exec(4), time(0.342-0.268 ms): RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47:[.060b78, .060b9f): exec(0), time(0.000 ms): RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:57:[.060ba0, .060bc7): exec(0), time(0.000 ms): globalFunction(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:84:[.060bd8, .060c1a): exec(1), time(0.130-0.103 ms): staticMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:90:[.060c20, .060c5f): exec(1), time(0.124-0.097 ms): virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.array.ci:51:[.060ce8, .060cec): exec(5), time(0.058 ms): lenSlice(values: int64[]): int32
cmplStd/test/lang/init.array.ci:52:[.060cf0, .060cfc): exec(21), time(0.289 ms): nthFixed(idx: int32, values: int64[7]): int64
cmplStd/test/lang/init.array.ci:53:[.060d00, .060d0c): exec(21), time(0.280 ms): nthArray(idx: int32, values: int64[*]): int64
cmplStd/test/lang/init.array.ci:54:[.060d10, .060d1c): exec(14), time(0.189 ms): nthSlice(idx: int32, values: int64[]): int64
::[.061764, .0650e4): exec(1), time(23.597-18.487 ms): .main

---------- Profile statements: 893/1255, coverage: 71.16%
cmplStd/lib/debug.ci:63:[.05ed81, .05ed82) exec(8), time(0.027-0.027 ms): <assertEq+9>
cmplStd/lib/debug.ci:62:[.05ed78, .05ed82) exec(8-8), time(0.000 ms): <assertEq+0>
cmplStd/lib/debug.ci:65:[.05ed86, .05ed8f) exec(0), time(0.000 ms): <assertEq+14>
cmplStd/lib/debug.ci:65:[.05ed82, .05ed8f) exec(0), time(0.000 ms): <assertEq+10>
cmplStd/lib/debug.ci:67:[.05ed93, .05ed9e) exec(0), time(0.000 ms): <assertEq+27>
cmplStd/lib/debug.ci:68:[.05ed9e, .05eda9) exec(0), time(0.000 ms): <assertEq+38>
cmplStd/lib/debug.ci:69:[.05eda9, .05edb4) exec(0), time(0.000 ms): <assertEq+49>
cmplStd/lib/debug.ci:66:[.05ed8f, .05edb4) exec(0), time(0.000 ms): <assertEq+23>
cmplStd/lib/debug.ci:71:[.05edb4, .05edda) exec(0), time(0.000 ms): <assertEq+60>
cmplStd/lib/math.ci:25:[.05edf8, .05ee09) exec(3), time(0.025-0.025 ms): <modf+24>
cmplStd/lib/math.ci:26:[.05ee09, .05ee10) exec(3), time(0.000 ms): <modf+41>
cmplStd/lib/math.ci:27:[.05ee10, .05ee13) exec(3), time(0.009-0.009 ms): <modf+48>
cmplStd/lib/math.ci:24:[.05edf0, .05ee17) exec(3-3), time(0.000 ms): <modf+16>
cmplStd/lib/math.ci:29:[.05ee17, .05ee1b) exec(0), time(0.000 ms): <modf+55>
cmplStd/lib/math.ci:30:[.05ee1b, .05ee1f) exec(0), time(0.000 ms): <modf+59>
cmplStd/lib/math.ci:23:[.05ede0, .05ee1f) exec(10-3), time(0.002-0.002 ms): <modf+0>
cmplStd/lib/math.ci:32:[.05ee1f, .05ee2b) exec(7), time(0.001-0.001 ms): <modf+63>
cmplStd/lib/math.ci:33:[.05ee2b, .05ee33) exec(7), time(0.000 ms): <modf+75>
cmplStd/lib/math.ci:34:[.05ee33, .05ee36) exec(7), time(0.022-0.022 ms): <modf+83>
cmplStd/lib/math.ci:48:[.05ee38, .05ee39) exec(6), time(0.003-0.003 ms): <floor+0>
cmplStd/lib/math.ci:49:[.05ee39, .05ee4d) exec(6), time(0.078-0.078 ms): <floor+1>
cmplStd/lib/math.ci:50:[.05ee4d, .05ee50) exec(6), time(0.022-0.022 ms): <floor+21>
cmplStd/lib/math.ci:79:[.05ee58, .05ee5e) exec(1), time(0.005-0.005 ms): <abs+8>
cmplStd/lib/math.ci:78:[.05ee50, .05ee5e) exec(3-1), time(0.000 ms): <abs+0>
cmplStd/lib/math.ci:81:[.05ee5e, .05ee62) exec(2), time(0.010-0.010 ms): <abs+14>
cmplStd/lib/math.ci:87:[.05ee70, .05ee76) exec(1), time(0.003-0.003 ms): <abs+8>
cmplStd/lib/math.ci:86:[.05ee68, .05ee76) exec(4-1), time(0.000 ms): <abs+0>
cmplStd/lib/math.ci:89:[.05ee76, .05ee7a) exec(3), time(0.010-0.010 ms): <abs+14>
cmplStd/lib/math.ci:95:[.05ee8f, .05ee97) exec(4), time(0.012-0.012 ms): <absMod+15>
cmplStd/lib/math.ci:94:[.05ee80, .05ee97) exec(11-4), time(0.004-0.004 ms): <absMod+0>
cmplStd/lib/math.ci:97:[.05ee97, .05ee9b) exec(7), time(0.022-0.022 ms): <absMod+23>
cmplStd/lib/math.ci:103:[.05eeaf, .05eeb7) exec(4), time(0.014-0.014 ms): <absMod+15>
cmplStd/lib/math.ci:102:[.05eea0, .05eeb7) exec(11-4), time(0.006-0.006 ms): <absMod+0>
cmplStd/lib/math.ci:105:[.05eeb7, .05eebb) exec(7), time(0.025-0.025 ms): <absMod+23>
cmplStd/lib/math.ci:117:[.05eec9, .05eecd) exec(1), time(0.003-0.003 ms): <min+9>
cmplStd/lib/math.ci:116:[.05eec0, .05eecd) exec(1-1), time(0.000 ms): <min+0>
cmplStd/lib/math.ci:119:[.05eecd, .05eed1) exec(0), time(0.000 ms): <min+13>
cmplStd/lib/math.ci:125:[.05eee1, .05eee5) exec(1), time(0.003-0.003 ms): <min+9>
cmplStd/lib/math.ci:124:[.05eed8, .05eee5) exec(1-1), time(0.000 ms): <min+0>
cmplStd/lib/math.ci:127:[.05eee5, .05eee9) exec(0), time(0.000 ms): <min+13>
cmplStd/lib/math.ci:139:[.05eef9, .05eefd) exec(0), time(0.000 ms): <max+9>
cmplStd/lib/math.ci:138:[.05eef0, .05eefd) exec(1), time(0.000 ms): <max+0>
cmplStd/lib/math.ci:141:[.05eefd, .05ef01) exec(1), time(0.003-0.003 ms): <max+13>
cmplStd/lib/math.ci:147:[.05ef11, .05ef15) exec(0), time(0.000 ms): <max+9>
cmplStd/lib/math.ci:146:[.05ef08, .05ef15) exec(1), time(0.000 ms): <max+0>
cmplStd/lib/math.ci:149:[.05ef15, .05ef19) exec(1), time(0.004-0.004 ms): <max+13>
cmplStd/lib/math.ci:161:[.05ef29, .05ef2d) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:160:[.05ef20, .05ef2d) exec(2), time(0.001-0.001 ms): <clamp+0>
cmplStd/lib/math.ci:164:[.05ef36, .05ef3a) exec(1), time(0.004-0.004 ms): <clamp+22>
cmplStd/lib/math.ci:163:[.05ef2d, .05ef3a) exec(2-1), time(0.000 ms): <clamp+13>
cmplStd/lib/math.ci:166:[.05ef3a, .05ef3e) exec(1), time(0.003-0.003 ms): <clamp+26>
cmplStd/lib/math.ci:172:[.05ef49, .05ef4d) exec(0), time(0.000 ms): <clamp+9>
cmplStd/lib/math.ci:171:[.05ef40, .05ef4d) exec(2), time(0.000 ms): <clamp+0>
cmplStd/lib/math.ci:175:[.05ef56, .05ef5a) exec(1), time(0.003-0.003 ms): <clamp+22>
cmplStd/lib/math.ci:174:[.05ef4d, .05ef5a) exec(2-1), time(0.000 ms): <clamp+13>
cmplStd/lib/math.ci:177:[.05ef5a, .05ef5e) exec(1), time(0.004-0.004 ms): <clamp+26>
cmplStd/lib/math.ci:203:[.05ef68, .05ef74) exec(1), time(0.003-0.003 ms): <min+8>
cmplStd/lib/math.ci:202:[.05ef60, .05ef74) exec(2-1), time(0.000 ms): <min+0>
cmplStd/lib/math.ci:205:[.05ef74, .05ef77) exec(1), time(0.001-0.001 ms): <min+20>
cmplStd/lib/math.ci:208:[.05ef90, .05ef9b) exec(2), time(0.002-0.002 ms): <min+48>
cmplStd/lib/math.ci:207:[.05ef80, .05ef9b) exec(8-2), time(0.003-0.003 ms): <min+32>
cmplStd/lib/math.ci:206:[.05ef9b, .05ef9f) exec(8), time(0.000 ms): <min+59>
cmplStd/lib/math.ci:206:[.05ef9f, .05efa8) exec(9), time(0.005-0.005 ms): <min+63>
cmplStd/lib/math.ci:206:[.05ef77, .05efac) exec(1), time(0.001-0.001 ms): <min+23>
cmplStd/lib/math.ci:211:[.05efac, .05efaf) exec(1), time(0.004-0.004 ms): <min+76>
cmplStd/lib/math.ci:217:[.05efb8, .05efc4) exec(1), time(0.004-0.004 ms): <max+8>
cmplStd/lib/math.ci:216:[.05efb0, .05efc4) exec(2-1), time(0.001-0.001 ms): <max+0>
cmplStd/lib/math.ci:219:[.05efc4, .05efc7) exec(1), time(0.000 ms): <max+20>
cmplStd/lib/math.ci:222:[.05efe0, .05efeb) exec(2), time(0.001-0.001 ms): <max+48>
cmplStd/lib/math.ci:221:[.05efd0, .05efeb) exec(8-2), time(0.004-0.004 ms): <max+32>
cmplStd/lib/math.ci:220:[.05efeb, .05efef) exec(8), time(0.001-0.001 ms): <max+59>
cmplStd/lib/math.ci:220:[.05efef, .05eff8) exec(9), time(0.003-0.003 ms): <max+63>
cmplStd/lib/math.ci:220:[.05efc7, .05effc) exec(1), time(0.000 ms): <max+23>
cmplStd/lib/math.ci:225:[.05effc, .05efff) exec(1), time(0.004-0.004 ms): <max+76>
cmplStd/lib/math.ci:230:[.05f000, .05f001) exec(4), time(0.001-0.001 ms): <sum+0>
cmplStd/lib/math.ci:232:[.05f006, .05f014) exec(13), time(0.007-0.007 ms): <sum+6>
cmplStd/lib/math.ci:231:[.05f014, .05f018) exec(13), time(0.002-0.002 ms): <sum+20>
cmplStd/lib/math.ci:231:[.05f018, .05f021) exec(17), time(0.007-0.007 ms): <sum+24>
cmplStd/lib/math.ci:231:[.05f001, .05f025) exec(4), time(0.003-0.003 ms): <sum+1>
cmplStd/lib/math.ci:234:[.05f025, .05f028) exec(4), time(0.013-0.013 ms): <sum+37>
cmplStd/lib/math.ci:239:[.05f028, .05f03c) exec(0), time(0.000 ms): <mean+0>
cmplStd/lib/math.ci:256:[.05f040, .05f041) exec(3), time(0.000 ms): <eval+0>
cmplStd/lib/math.ci:258:[.05f04b, .05f05c) exec(11), time(0.011-0.011 ms): <eval+11>
cmplStd/lib/math.ci:257:[.05f05c, .05f060) exec(11), time(0.003-0.003 ms): <eval+28>
cmplStd/lib/math.ci:257:[.05f060, .05f068) exec(14), time(0.006-0.006 ms): <eval+32>
cmplStd/lib/math.ci:257:[.05f041, .05f06c) exec(3), time(0.002-0.002 ms): <eval+1>
cmplStd/lib/math.ci:260:[.05f06c, .05f06f) exec(3), time(0.012-0.012 ms): <eval+44>
cmplStd/lib/math.ci:267:[.05f085, .05f08d) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:266:[.05f079, .05f08d) exec(1), time(0.001-0.001 ms): <cmp+9>
cmplStd/lib/math.ci:272:[.05f09d, .05f0a5) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:271:[.05f091, .05f0a5) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:265:[.05f070, .05f0a5) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:275:[.05f0a5, .05f0a9) exec(1), time(0.004-0.004 ms): <cmp+53>
cmplStd/lib/math.ci:282:[.05f0c5, .05f0cd) exec(0), time(0.000 ms): <cmp+21>
cmplStd/lib/math.ci:281:[.05f0b9, .05f0cd) exec(1), time(0.000 ms): <cmp+9>
cmplStd/lib/math.ci:287:[.05f0dd, .05f0e5) exec(0), time(0.000 ms): <cmp+45>
cmplStd/lib/math.ci:286:[.05f0d1, .05f0e5) exec(0), time(0.000 ms): <cmp+33>
cmplStd/lib/math.ci:280:[.05f0b0, .05f0e5) exec(1), time(0.001-0.001 ms): <cmp+0>
cmplStd/lib/math.ci:290:[.05f0e5, .05f0e9) exec(1), time(0.003-0.003 ms): <cmp+53>
cmplStd/lib/math.ci:308:[.05f0f0, .05f0f2) exec(2), time(0.000 ms): <sinCos+0>
cmplStd/lib/math.ci:310:[.05f0fa, .05f0fb) exec(0), time(0.000 ms): <sinCos+10>
cmplStd/lib/math.ci:311:[.05f0fb, .05f103) exec(0), time(0.000 ms): <sinCos+11>
cmplStd/lib/math.ci:309:[.05f0f2, .05f103) exec(2), time(0.001-0.001 ms): <sinCos+2>
cmplStd/lib/math.ci:314:[.05f103, .05f104) exec(2), time(0.000 ms): <sinCos+19>
cmplStd/lib/math.ci:315:[.05f104, .05f11c) exec(2), time(0.001-0.001 ms): <sinCos+20>
cmplStd/lib/math.ci:317:[.05f12c, .05f12d) exec(0), time(0.000 ms): <sinCos+60>
cmplStd/lib/math.ci:318:[.05f12d, .05f13f) exec(0), time(0.000 ms): <sinCos+61>
cmplStd/lib/math.ci:319:[.05f13f, .05f143) exec(0), time(0.000 ms): <sinCos+79>
cmplStd/lib/math.ci:321:[.05f143, .05f144) exec(0), time(0.000 ms): <sinCos+83>
cmplStd/lib/math.ci:322:[.05f144, .05f162) exec(0), time(0.000 ms): <sinCos+84>
cmplStd/lib/math.ci:323:[.05f162, .05f174) exec(0), time(0.000 ms): <sinCos+114>
cmplStd/lib/math.ci:326:[.05f17c, .05f17f) exec(2), time(0.000 ms): <sinCos+140>
cmplStd/lib/math.ci:327:[.05f17f, .05f187) exec(2), time(0.001-0.001 ms): <sinCos+143>
cmplStd/lib/math.ci:328:[.05f187, .05f18e) exec(2), time(0.002-0.002 ms): <sinCos+151>
cmplStd/lib/math.ci:329:[.05f18e, .05f194) exec(2), time(0.001-0.001 ms): <sinCos+158>
cmplStd/lib/math.ci:316:[.05f11c, .05f198) exec(2), time(0.001-0.001 ms): <sinCos+44>
cmplStd/lib/math.ci:332:[.05f1a0, .05f1ae) exec(1), time(0.001-0.001 ms): <sinCos+176>
cmplStd/lib/math.ci:331:[.05f198, .05f1ae) exec(2-1), time(0.000 ms): <sinCos+168>
cmplStd/lib/math.ci:335:[.05f1ba, .05f1bb) exec(1), time(0.000 ms): <sinCos+202>
cmplStd/lib/math.ci:334:[.05f1ae, .05f1bb) exec(2-1), time(0.000 ms): <sinCos+190>
cmplStd/lib/math.ci:338:[.05f1bb, .05f1c0) exec(2), time(0.000 ms): <sinCos+203>
cmplStd/lib/math.ci:339:[.05f1c0, .05f200) exec(2), time(0.004-0.004 ms): <sinCos+208>
cmplStd/lib/math.ci:340:[.05f200, .05f233) exec(2), time(0.002-0.002 ms): <sinCos+272>
cmplStd/lib/math.ci:341:[.05f233, .05f23f) exec(2), time(0.008-0.008 ms): <sinCos+323>
cmplStd/lib/math.ci:364:[.05f240, .05f241) exec(1), time(0.000 ms): <tan+0>
cmplStd/lib/math.ci:365:[.05f241, .05f242) exec(1), time(0.000 ms): <tan+1>
cmplStd/lib/math.ci:368:[.05f24a, .05f24f) exec(0), time(0.000 ms): <tan+10>
cmplStd/lib/math.ci:369:[.05f24f, .05f259) exec(0), time(0.000 ms): <tan+15>
cmplStd/lib/math.ci:367:[.05f242, .05f259) exec(1), time(0.001-0.001 ms): <tan+2>
cmplStd/lib/math.ci:371:[.05f259, .05f271) exec(1), time(0.001-0.001 ms): <tan+25>
cmplStd/lib/math.ci:373:[.05f271, .05f272) exec(1), time(0.001-0.001 ms): <tan+49>
cmplStd/lib/math.ci:374:[.05f272, .05f282) exec(1), time(0.009-0.009 ms): <tan+50>
cmplStd/lib/math.ci:375:[.05f282, .05f28b) exec(1), time(0.001-0.001 ms): <tan+66>
cmplStd/lib/math.ci:379:[.05f29f, .05f2ad) exec(1), time(0.001-0.001 ms): <tan+95>
cmplStd/lib/math.ci:380:[.05f2ad, .05f2b7) exec(1), time(0.000 ms): <tan+109>
cmplStd/lib/math.ci:383:[.05f2c7, .05f2d2) exec(0), time(0.000 ms): <tan+135>
cmplStd/lib/math.ci:384:[.05f2d2, .05f2dc) exec(0), time(0.000 ms): <tan+146>
cmplStd/lib/math.ci:387:[.05f2ec, .05f2fa) exec(0), time(0.000 ms): <tan+172>
cmplStd/lib/math.ci:388:[.05f2fa, .05f305) exec(0), time(0.000 ms): <tan+186>
cmplStd/lib/math.ci:386:[.05f2e0, .05f305) exec(0), time(0.000 ms): <tan+160>
cmplStd/lib/math.ci:382:[.05f2bb, .05f305) exec(0), time(0.000 ms): <tan+123>
cmplStd/lib/math.ci:378:[.05f293, .05f305) exec(1), time(0.001-0.001 ms): <tan+83>
cmplStd/lib/math.ci:377:[.05f28b, .05f305) exec(1-1), time(0.000 ms): <tan+75>
cmplStd/lib/math.ci:391:[.05f305, .05f30a) exec(1), time(0.000 ms): <tan+197>
cmplStd/lib/math.ci:392:[.05f30a, .05f34a) exec(1), time(0.002-0.002 ms): <tan+202>
cmplStd/lib/math.ci:393:[.05f34a, .05f371) exec(1), time(0.002-0.002 ms): <tan+266>
cmplStd/lib/math.ci:397:[.05f382, .05f392) exec(0), time(0.000 ms): <tan+322>
cmplStd/lib/math.ci:396:[.05f37a, .05f392) exec(1), time(0.001-0.001 ms): <tan+314>
cmplStd/lib/math.ci:399:[.05f392, .05f3a0) exec(1), time(0.000 ms): <tan+338>
cmplStd/lib/math.ci:395:[.05f371, .05f3a0) exec(1-1), time(0.000 ms): <tan+305>
cmplStd/lib/math.ci:402:[.05f3a9, .05f3b3) exec(0), time(0.000 ms): <tan+361>
cmplStd/lib/math.ci:401:[.05f3a0, .05f3b3) exec(1), time(0.000 ms): <tan+352>
cmplStd/lib/math.ci:404:[.05f3b3, .05f3ba) exec(1), time(0.004-0.004 ms): <tan+371>
cmplStd/lib/math.ci:420:[.05f3c0, .05f3c1) exec(1), time(0.000 ms): <sinh+0>
cmplStd/lib/math.ci:422:[.05f3c9, .05f3ce) exec(0), time(0.000 ms): <sinh+9>
cmplStd/lib/math.ci:423:[.05f3ce, .05f3d8) exec(0), time(0.000 ms): <sinh+14>
cmplStd/lib/math.ci:421:[.05f3c1, .05f3d8) exec(1), time(0.001-0.001 ms): <sinh+1>
cmplStd/lib/math.ci:427:[.05f3e8, .05f3ff) exec(0), time(0.000 ms): <sinh+40>
cmplStd/lib/math.ci:426:[.05f3d8, .05f3ff) exec(1), time(0.001-0.001 ms): <sinh+24>
cmplStd/lib/math.ci:430:[.05f3ff, .05f400) exec(1), time(0.000 ms): <sinh+63>
cmplStd/lib/math.ci:432:[.05f410, .05f42a) exec(1), time(0.031-0.031 ms): <sinh+80>
cmplStd/lib/math.ci:435:[.05f42e, .05f433) exec(0), time(0.000 ms): <sinh+110>
cmplStd/lib/math.ci:436:[.05f433, .05f468) exec(0), time(0.000 ms): <sinh+115>
cmplStd/lib/math.ci:437:[.05f468, .05f493) exec(0), time(0.000 ms): <sinh+168>
cmplStd/lib/math.ci:431:[.05f400, .05f497) exec(1), time(0.031-0.031 ms): <sinh+64>
cmplStd/lib/math.ci:441:[.05f4a0, .05f4aa) exec(0), time(0.000 ms): <sinh+224>
cmplStd/lib/math.ci:440:[.05f497, .05f4aa) exec(1), time(0.000 ms): <sinh+215>
cmplStd/lib/math.ci:443:[.05f4aa, .05f4b1) exec(1), time(0.004-0.004 ms): <sinh+234>
cmplStd/lib/math.ci:449:[.05f4c0, .05f4c5) exec(0), time(0.000 ms): <cosh+8>
cmplStd/lib/math.ci:448:[.05f4b8, .05f4c5) exec(1), time(0.001-0.001 ms): <cosh+0>
cmplStd/lib/math.ci:452:[.05f4d5, .05f4e8) exec(0), time(0.000 ms): <cosh+29>
cmplStd/lib/math.ci:451:[.05f4c5, .05f4e8) exec(1), time(0.001-0.001 ms): <cosh+13>
cmplStd/lib/math.ci:454:[.05f4e8, .05f503) exec(1), time(0.037-0.037 ms): <cosh+48>
cmplStd/lib/math.ci:465:[.05f510, .05f514) exec(0), time(0.000 ms): <asin+8>
cmplStd/lib/math.ci:463:[.05f508, .05f514) exec(2), time(0.002-0.002 ms): <asin+0>
cmplStd/lib/math.ci:468:[.05f514, .05f515) exec(2), time(0.001-0.001 ms): <asin+12>
cmplStd/lib/math.ci:470:[.05f51d, .05f527) exec(0), time(0.000 ms): <asin+21>
cmplStd/lib/math.ci:471:[.05f527, .05f52c) exec(0), time(0.000 ms): <asin+31>
cmplStd/lib/math.ci:469:[.05f515, .05f52c) exec(2), time(0.002-0.002 ms): <asin+13>
cmplStd/lib/math.ci:476:[.05f53c, .05f54c) exec(0), time(0.000 ms): <asin+52>
cmplStd/lib/math.ci:474:[.05f52c, .05f54c) exec(2), time(0.002-0.002 ms): <asin+36>
cmplStd/lib/math.ci:479:[.05f54c, .05f55f) exec(2), time(0.032-0.032 ms): <asin+68>
cmplStd/lib/math.ci:481:[.05f56f, .05f58d) exec(0), time(0.000 ms): <asin+103>
cmplStd/lib/math.ci:484:[.05f591, .05f59b) exec(2), time(0.029-0.029 ms): <asin+137>
cmplStd/lib/math.ci:480:[.05f55f, .05f59b) exec(2-2), time(0.000 ms): <asin+87>
cmplStd/lib/math.ci:488:[.05f5a4, .05f5ae) exec(0), time(0.000 ms): <asin+156>
cmplStd/lib/math.ci:487:[.05f59b, .05f5ae) exec(2), time(0.001-0.001 ms): <asin+147>
cmplStd/lib/math.ci:490:[.05f5ae, .05f5b5) exec(2), time(0.008-0.008 ms): <asin+166>
cmplStd/lib/math/Complex.ci:26:[.05f5b8, .05f5bb) exec(0), time(0.000 ms): <Complex+0>
::[.05f5bb, .05f5be) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:25:[.05f5b8, .05f5bf) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:33:[.05f5c0, .05f5c3) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:34:[.05f5c3, .05f5c6) exec(0), time(0.000 ms): <Complex+3>
cmplStd/lib/math/Complex.ci:32:[.05f5c0, .05f5c7) exec(0), time(0.000 ms): <Complex+0>
cmplStd/lib/math/Complex.ci:91:[.05f5e7, .05f5ec) exec(0), time(0.000 ms): <div+31>
cmplStd/lib/math/Complex.ci:92:[.05f5ec, .05f5f4) exec(0), time(0.000 ms): <div+36>
cmplStd/lib/math/Complex.ci:94:[.05f5f4, .05f601) exec(0), time(0.000 ms): <div+44>
cmplStd/lib/math/Complex.ci:95:[.05f601, .05f60e) exec(0), time(0.000 ms): <div+57>
cmplStd/lib/math/Complex.ci:93:[.05f5f4, .05f613) exec(0), time(0.000 ms): <div+44>
cmplStd/lib/math/Complex.ci:90:[.05f5c8, .05f617) exec(0), time(0.000 ms): <div+0>
cmplStd/lib/math/Complex.ci:98:[.05f617, .05f61c) exec(0), time(0.000 ms): <div+79>
cmplStd/lib/math/Complex.ci:99:[.05f61c, .05f624) exec(0), time(0.000 ms): <div+84>
cmplStd/lib/math/Complex.ci:101:[.05f624, .05f631) exec(0), time(0.000 ms): <div+92>
cmplStd/lib/math/Complex.ci:102:[.05f631, .05f63e) exec(0), time(0.000 ms): <div+105>
cmplStd/lib/math/Complex.ci:100:[.05f624, .05f643) exec(0), time(0.000 ms): <div+92>
cmplStd/lib/math/Complex.ci:118:[.05f648, .05f653) exec(0), time(0.000 ms): <inv+0>
cmplStd/lib/math/Complex.ci:120:[.05f653, .05f65a) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:121:[.05f65a, .05f662) exec(0), time(0.000 ms): <inv+18>
cmplStd/lib/math/Complex.ci:119:[.05f653, .05f667) exec(0), time(0.000 ms): <inv+11>
cmplStd/lib/math/Complex.ci:136:[.05f668, .05f67f) exec(0), time(0.000 ms): <pow+0>
cmplStd/lib/math/Complex.ci:137:[.05f67f, .05f68f) exec(0), time(0.000 ms): <pow+23>
cmplStd/lib/math/Complex.ci:138:[.05f68f, .05f69e) exec(0), time(0.000 ms): <pow+39>
cmplStd/lib/math/Complex.ci:139:[.05f69e, .05f6b1) exec(0), time(0.000 ms): <pow+54>
cmplStd/lib/math/Complex.ci:141:[.05f6b1, .05f6bc) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Complex.ci:142:[.05f6bc, .05f6c7) exec(0), time(0.000 ms): <pow+84>
cmplStd/lib/math/Complex.ci:140:[.05f6b1, .05f6cc) exec(0), time(0.000 ms): <pow+73>
cmplStd/lib/math/Matrix4f.ci:67:[.05f6d0, .05f6d3) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:67:[.05f6d3, .05f6d6) exec(0), time(0.000 ms): <mat4f+3>
cmplStd/lib/math/Matrix4f.ci:67:[.05f6d6, .05f6d9) exec(0), time(0.000 ms): <mat4f+6>
cmplStd/lib/math/Matrix4f.ci:67:[.05f6d9, .05f6dc) exec(0), time(0.000 ms): <mat4f+9>
cmplStd/lib/math/Matrix4f.ci:68:[.05f6dc, .05f6df) exec(0), time(0.000 ms): <mat4f+12>
cmplStd/lib/math/Matrix4f.ci:68:[.05f6df, .05f6e2) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:68:[.05f6e2, .05f6e5) exec(0), time(0.000 ms): <mat4f+18>
cmplStd/lib/math/Matrix4f.ci:68:[.05f6e5, .05f6e8) exec(0), time(0.000 ms): <mat4f+21>
cmplStd/lib/math/Matrix4f.ci:69:[.05f6e8, .05f6eb) exec(0), time(0.000 ms): <mat4f+24>
cmplStd/lib/math/Matrix4f.ci:69:[.05f6eb, .05f6ee) exec(0), time(0.000 ms): <mat4f+27>
cmplStd/lib/math/Matrix4f.ci:69:[.05f6ee, .05f6f1) exec(0), time(0.000 ms): <mat4f+30>
cmplStd/lib/math/Matrix4f.ci:69:[.05f6f1, .05f6f4) exec(0), time(0.000 ms): <mat4f+33>
cmplStd/lib/math/Matrix4f.ci:70:[.05f6f4, .05f6f7) exec(0), time(0.000 ms): <mat4f+36>
cmplStd/lib/math/Matrix4f.ci:70:[.05f6f7, .05f6fa) exec(0), time(0.000 ms): <mat4f+39>
cmplStd/lib/math/Matrix4f.ci:70:[.05f6fa, .05f6fd) exec(0), time(0.000 ms): <mat4f+42>
cmplStd/lib/math/Matrix4f.ci:70:[.05f6fd, .05f700) exec(0), time(0.000 ms): <mat4f+45>
cmplStd/lib/math/Matrix4f.ci:66:[.05f6d0, .05f701) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.05f708, .05f70d) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:76:[.05f70d, .05f712) exec(0), time(0.000 ms): <mat4f+5>
cmplStd/lib/math/Matrix4f.ci:76:[.05f712, .05f717) exec(0), time(0.000 ms): <mat4f+10>
cmplStd/lib/math/Matrix4f.ci:76:[.05f717, .05f71c) exec(0), time(0.000 ms): <mat4f+15>
cmplStd/lib/math/Matrix4f.ci:76:[.05f708, .05f71d) exec(0), time(0.000 ms): <mat4f+0>
cmplStd/lib/math/Matrix4f.ci:89:[.05f720, .05f723) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:89:[.05f723, .05f726) exec(0), time(0.000 ms): <transpose+3>
cmplStd/lib/math/Matrix4f.ci:89:[.05f726, .05f729) exec(0), time(0.000 ms): <transpose+6>
cmplStd/lib/math/Matrix4f.ci:89:[.05f729, .05f72c) exec(0), time(0.000 ms): <transpose+9>
cmplStd/lib/math/Matrix4f.ci:90:[.05f72c, .05f72f) exec(0), time(0.000 ms): <transpose+12>
cmplStd/lib/math/Matrix4f.ci:90:[.05f72f, .05f732) exec(0), time(0.000 ms): <transpose+15>
cmplStd/lib/math/Matrix4f.ci:90:[.05f732, .05f735) exec(0), time(0.000 ms): <transpose+18>
cmplStd/lib/math/Matrix4f.ci:90:[.05f735, .05f738) exec(0), time(0.000 ms): <transpose+21>
cmplStd/lib/math/Matrix4f.ci:91:[.05f738, .05f73b) exec(0), time(0.000 ms): <transpose+24>
cmplStd/lib/math/Matrix4f.ci:91:[.05f73b, .05f73e) exec(0), time(0.000 ms): <transpose+27>
cmplStd/lib/math/Matrix4f.ci:91:[.05f73e, .05f741) exec(0), time(0.000 ms): <transpose+30>
cmplStd/lib/math/Matrix4f.ci:91:[.05f741, .05f744) exec(0), time(0.000 ms): <transpose+33>
cmplStd/lib/math/Matrix4f.ci:92:[.05f744, .05f747) exec(0), time(0.000 ms): <transpose+36>
cmplStd/lib/math/Matrix4f.ci:92:[.05f747, .05f74a) exec(0), time(0.000 ms): <transpose+39>
cmplStd/lib/math/Matrix4f.ci:92:[.05f74a, .05f74d) exec(0), time(0.000 ms): <transpose+42>
cmplStd/lib/math/Matrix4f.ci:92:[.05f74d, .05f750) exec(0), time(0.000 ms): <transpose+45>
cmplStd/lib/math/Matrix4f.ci:88:[.05f720, .05f751) exec(0), time(0.000 ms): <transpose+0>
cmplStd/lib/math/Matrix4f.ci:98:[.05f758, .05f774) exec(0), time(0.000 ms): <mul+0>
cmplStd/lib/math/Matrix4f.ci:100:[.05f774, .05f7a6) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:101:[.05f7a6, .05f7dc) exec(0), time(0.000 ms): <mul+78>
cmplStd/lib/math/Matrix4f.ci:102:[.05f7dc, .05f812) exec(0), time(0.000 ms): <mul+132>
cmplStd/lib/math/Matrix4f.ci:103:[.05f812, .05f848) exec(0), time(0.000 ms): <mul+186>
cmplStd/lib/math/Matrix4f.ci:99:[.05f774, .05f84d) exec(0), time(0.000 ms): <mul+28>
cmplStd/lib/math/Matrix4f.ci:112:[.05f850, .05f862) exec(0), time(0.000 ms): <rotation+0>
cmplStd/lib/math/Matrix4f.ci:114:[.05f873, .05f897) exec(0), time(0.000 ms): <rotation+35>
cmplStd/lib/math/Matrix4f.ci:116:[.05f897, .05f89d) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:117:[.05f89d, .05f8a3) exec(0), time(0.000 ms): <rotation+77>
cmplStd/lib/math/Matrix4f.ci:118:[.05f8a3, .05f8a9) exec(0), time(0.000 ms): <rotation+83>
cmplStd/lib/math/Matrix4f.ci:119:[.05f8a9, .05f8af) exec(0), time(0.000 ms): <rotation+89>
cmplStd/lib/math/Matrix4f.ci:115:[.05f897, .05f8b4) exec(0), time(0.000 ms): <rotation+71>
cmplStd/lib/math/Matrix4f.ci:113:[.05f862, .05f8b4) exec(0), time(0.000 ms): <rotation+18>
cmplStd/lib/math/Matrix4f.ci:122:[.05f8b4, .05f8ba) exec(0), time(0.000 ms): <rotation+100>
cmplStd/lib/math/Matrix4f.ci:123:[.05f8ba, .05f8c4) exec(0), time(0.000 ms): <rotation+106>
cmplStd/lib/math/Matrix4f.ci:124:[.05f8c4, .05f8ce) exec(0), time(0.000 ms): <rotation+116>
cmplStd/lib/math/Matrix4f.ci:125:[.05f8ce, .05f8d1) exec(0), time(0.000 ms): <rotation+126>
cmplStd/lib/math/Matrix4f.ci:126:[.05f8d1, .05f8d8) exec(0), time(0.000 ms): <rotation+129>
cmplStd/lib/math/Matrix4f.ci:127:[.05f8d8, .05f8df) exec(0), time(0.000 ms): <rotation+136>
cmplStd/lib/math/Matrix4f.ci:128:[.05f8df, .05f8e4) exec(0), time(0.000 ms): <rotation+143>
cmplStd/lib/math/Matrix4f.ci:129:[.05f8e4, .05f8e9) exec(0), time(0.000 ms): <rotation+148>
cmplStd/lib/math/Matrix4f.ci:130:[.05f8e9, .05f8ee) exec(0), time(0.000 ms): <rotation+153>
cmplStd/lib/math/Matrix4f.ci:131:[.05f8ee, .05f8f3) exec(0), time(0.000 ms): <rotation+158>
cmplStd/lib/math/Matrix4f.ci:132:[.05f8f3, .05f8f8) exec(0), time(0.000 ms): <rotation+163>
cmplStd/lib/math/Matrix4f.ci:133:[.05f8f8, .05f8fd) exec(0), time(0.000 ms): <rotation+168>
cmplStd/lib/math/Matrix4f.ci:135:[.05f8fd, .05f903) exec(0), time(0.000 ms): <rotation+173>
cmplStd/lib/math/Matrix4f.ci:136:[.05f903, .05f909) exec(0), time(0.000 ms): <rotation+179>
cmplStd/lib/math/Matrix4f.ci:137:[.05f909, .05f911) exec(0), time(0.000 ms): <rotation+185>
cmplStd/lib/math/Matrix4f.ci:140:[.05f911, .05f91e) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:141:[.05f91e, .05f92b) exec(0), time(0.000 ms): <rotation+206>
cmplStd/lib/math/Matrix4f.ci:142:[.05f92b, .05f938) exec(0), time(0.000 ms): <rotation+219>
cmplStd/lib/math/Matrix4f.ci:143:[.05f938, .05f963) exec(0), time(0.000 ms): <rotation+232>
cmplStd/lib/math/Matrix4f.ci:145:[.05f963, .05f970) exec(0), time(0.000 ms): <rotation+275>
cmplStd/lib/math/Matrix4f.ci:146:[.05f970, .05f97d) exec(0), time(0.000 ms): <rotation+288>
cmplStd/lib/math/Matrix4f.ci:147:[.05f97d, .05f98a) exec(0), time(0.000 ms): <rotation+301>
cmplStd/lib/math/Matrix4f.ci:148:[.05f98a, .05f9b5) exec(0), time(0.000 ms): <rotation+314>
cmplStd/lib/math/Matrix4f.ci:150:[.05f9b5, .05f9c2) exec(0), time(0.000 ms): <rotation+357>
cmplStd/lib/math/Matrix4f.ci:151:[.05f9c2, .05f9cf) exec(0), time(0.000 ms): <rotation+370>
cmplStd/lib/math/Matrix4f.ci:152:[.05f9cf, .05f9dc) exec(0), time(0.000 ms): <rotation+383>
cmplStd/lib/math/Matrix4f.ci:153:[.05f9dc, .05fa07) exec(0), time(0.000 ms): <rotation+396>
cmplStd/lib/math/Matrix4f.ci:155:[.05fa07, .05fa11) exec(0), time(0.000 ms): <rotation+439>
cmplStd/lib/math/Matrix4f.ci:139:[.05f911, .05fa16) exec(0), time(0.000 ms): <rotation+193>
cmplStd/lib/math/Matrix4f.ci:165:[.05fa18, .05fa1f) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:165:[.05fa1f, .05fa22) exec(0), time(0.000 ms): <translation+7>
cmplStd/lib/math/Matrix4f.ci:165:[.05fa22, .05fa25) exec(0), time(0.000 ms): <translation+10>
cmplStd/lib/math/Matrix4f.ci:165:[.05fa25, .05fa2d) exec(0), time(0.000 ms): <translation+13>
cmplStd/lib/math/Matrix4f.ci:166:[.05fa2d, .05fa30) exec(0), time(0.000 ms): <translation+21>
cmplStd/lib/math/Matrix4f.ci:166:[.05fa30, .05fa37) exec(0), time(0.000 ms): <translation+24>
cmplStd/lib/math/Matrix4f.ci:166:[.05fa37, .05fa3a) exec(0), time(0.000 ms): <translation+31>
cmplStd/lib/math/Matrix4f.ci:166:[.05fa3a, .05fa46) exec(0), time(0.000 ms): <translation+34>
cmplStd/lib/math/Matrix4f.ci:167:[.05fa46, .05fa49) exec(0), time(0.000 ms): <translation+46>
cmplStd/lib/math/Matrix4f.ci:167:[.05fa49, .05fa4c) exec(0), time(0.000 ms): <translation+49>
cmplStd/lib/math/Matrix4f.ci:167:[.05fa4c, .05fa53) exec(0), time(0.000 ms): <translation+52>
cmplStd/lib/math/Matrix4f.ci:167:[.05fa53, .05fa5f) exec(0), time(0.000 ms): <translation+59>
cmplStd/lib/math/Matrix4f.ci:168:[.05fa5f, .05fa62) exec(0), time(0.000 ms): <translation+71>
cmplStd/lib/math/Matrix4f.ci:168:[.05fa62, .05fa65) exec(0), time(0.000 ms): <translation+74>
cmplStd/lib/math/Matrix4f.ci:168:[.05fa65, .05fa68) exec(0), time(0.000 ms): <translation+77>
cmplStd/lib/math/Matrix4f.ci:168:[.05fa68, .05fa6f) exec(0), time(0.000 ms): <translation+80>
cmplStd/lib/math/Matrix4f.ci:164:[.05fa18, .05fa70) exec(0), time(0.000 ms): <translation+0>
cmplStd/lib/math/Matrix4f.ci:176:[.05fa70, .05faa7) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Matrix4f.ci:176:[.05faa7, .05faaa) exec(0), time(0.000 ms): <scale+55>
cmplStd/lib/math/Matrix4f.ci:176:[.05faaa, .05faad) exec(0), time(0.000 ms): <scale+58>
cmplStd/lib/math/Matrix4f.ci:176:[.05faad, .05fab0) exec(0), time(0.000 ms): <scale+61>
cmplStd/lib/math/Matrix4f.ci:177:[.05fab0, .05fab3) exec(0), time(0.000 ms): <scale+64>
cmplStd/lib/math/Matrix4f.ci:177:[.05fab3, .05faee) exec(0), time(0.000 ms): <scale+67>
cmplStd/lib/math/Matrix4f.ci:177:[.05faee, .05faf1) exec(0), time(0.000 ms): <scale+126>
cmplStd/lib/math/Matrix4f.ci:177:[.05faf1, .05faf4) exec(0), time(0.000 ms): <scale+129>
cmplStd/lib/math/Matrix4f.ci:178:[.05faf4, .05faf7) exec(0), time(0.000 ms): <scale+132>
cmplStd/lib/math/Matrix4f.ci:178:[.05faf7, .05fafa) exec(0), time(0.000 ms): <scale+135>
cmplStd/lib/math/Matrix4f.ci:178:[.05fafa, .05fb35) exec(0), time(0.000 ms): <scale+138>
cmplStd/lib/math/Matrix4f.ci:178:[.05fb35, .05fb38) exec(0), time(0.000 ms): <scale+197>
cmplStd/lib/math/Matrix4f.ci:179:[.05fb38, .05fb3b) exec(0), time(0.000 ms): <scale+200>
cmplStd/lib/math/Matrix4f.ci:179:[.05fb3b, .05fb3e) exec(0), time(0.000 ms): <scale+203>
cmplStd/lib/math/Matrix4f.ci:179:[.05fb3e, .05fb41) exec(0), time(0.000 ms): <scale+206>
cmplStd/lib/math/Matrix4f.ci:179:[.05fb41, .05fb48) exec(0), time(0.000 ms): <scale+209>
cmplStd/lib/math/Matrix4f.ci:175:[.05fa70, .05fb49) exec(0), time(0.000 ms): <scale+0>
cmplStd/lib/math/Vector2d.ci:16:[.05fb50, .05fb53) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/math/Vector2d.ci:17:[.05fb53, .05fb56) exec(0), time(0.000 ms): <vec2d+3>
cmplStd/lib/math/Vector2d.ci:15:[.05fb50, .05fb57) exec(0), time(0.000 ms): <vec2d+0>
cmplStd/lib/string.ci:6:[.05fb64, .05fb68) exec(0), time(0.000 ms): <length+12>
cmplStd/lib/string.ci:5:[.05fb58, .05fb68) exec(0), time(0.000 ms): <length+0>
cmplStd/lib/string.ci:8:[.05fb68, .05fb69) exec(0), time(0.000 ms): <length+16>
cmplStd/lib/string.ci:9:[.05fb6d, .05fb71) exec(0), time(0.000 ms): <length+21>
cmplStd/lib/string.ci:9:[.05fb71, .05fb7b) exec(0), time(0.000 ms): <length+25>
cmplStd/lib/string.ci:9:[.05fb69, .05fb7b) exec(0), time(0.000 ms): <length+17>
cmplStd/lib/string.ci:11:[.05fb7b, .05fb7e) exec(0), time(0.000 ms): <length+35>
cmplStd/lib/string.ci:18:[.05fb95, .05fb98) exec(0), time(0.000 ms): <indexOf+21>
cmplStd/lib/string.ci:17:[.05fb85, .05fb98) exec(0), time(0.000 ms): <indexOf+5>
cmplStd/lib/string.ci:16:[.05fb98, .05fb9c) exec(0), time(0.000 ms): <indexOf+24>
cmplStd/lib/string.ci:16:[.05fb9c, .05fba6) exec(0), time(0.000 ms): <indexOf+28>
cmplStd/lib/string.ci:16:[.05fb80, .05fbaa) exec(0), time(0.000 ms): <indexOf+0>
cmplStd/lib/string.ci:21:[.05fbaa, .05fbb2) exec(0), time(0.000 ms): <indexOf+42>
cmplStd/lib/string.ci:26:[.05fbb8, .05fbbd) exec(0), time(0.000 ms): <lastIndexOf+0>
cmplStd/lib/string.ci:29:[.05fbd2, .05fbd5) exec(0), time(0.000 ms): <lastIndexOf+26>
cmplStd/lib/string.ci:28:[.05fbc2, .05fbd5) exec(0), time(0.000 ms): <lastIndexOf+10>
cmplStd/lib/string.ci:27:[.05fbd5, .05fbd9) exec(0), time(0.000 ms): <lastIndexOf+29>
cmplStd/lib/string.ci:27:[.05fbd9, .05fbe3) exec(0), time(0.000 ms): <lastIndexOf+33>
cmplStd/lib/string.ci:27:[.05fbbd, .05fbe7) exec(0), time(0.000 ms): <lastIndexOf+5>
cmplStd/lib/string.ci:32:[.05fbe7, .05fbea) exec(0), time(0.000 ms): <lastIndexOf+47>
cmplStd/lib/string.ci:39:[.05fc0f, .05fc1a) exec(0), time(0.000 ms): <startsWith+31>
cmplStd/lib/string.ci:38:[.05fbf5, .05fc1a) exec(0), time(0.000 ms): <startsWith+5>
cmplStd/lib/string.ci:37:[.05fc1a, .05fc1e) exec(0), time(0.000 ms): <startsWith+42>
cmplStd/lib/string.ci:37:[.05fc1e, .05fc2a) exec(0), time(0.000 ms): <startsWith+46>
cmplStd/lib/string.ci:37:[.05fbf0, .05fc2e) exec(0), time(0.000 ms): <startsWith+0>
cmplStd/lib/string.ci:42:[.05fc2e, .05fc39) exec(0), time(0.000 ms): <startsWith+62>
cmplStd/lib/string.ci:47:[.05fc40, .05fc4d) exec(0), time(0.000 ms): <endsWith+0>
cmplStd/lib/string.ci:48:[.05fc4d, .05fc5a) exec(0), time(0.000 ms): <endsWith+13>
cmplStd/lib/string.ci:50:[.05fc63, .05fc6e) exec(0), time(0.000 ms): <endsWith+35>
cmplStd/lib/string.ci:49:[.05fc5a, .05fc6e) exec(0), time(0.000 ms): <endsWith+26>
cmplStd/lib/string.ci:54:[.05fc93, .05fc9e) exec(0), time(0.000 ms): <endsWith+83>
cmplStd/lib/string.ci:53:[.05fc73, .05fc9e) exec(0), time(0.000 ms): <endsWith+51>
cmplStd/lib/string.ci:52:[.05fc9e, .05fca2) exec(0), time(0.000 ms): <endsWith+94>
cmplStd/lib/string.ci:52:[.05fca2, .05fcab) exec(0), time(0.000 ms): <endsWith+98>
cmplStd/lib/string.ci:52:[.05fc6e, .05fcaf) exec(0), time(0.000 ms): <endsWith+46>
cmplStd/lib/string.ci:57:[.05fcaf, .05fcbe) exec(0), time(0.000 ms): <endsWith+111>
cmplStd/lib/string.ci:62:[.05fcc0, .05fcc1) exec(0), time(0.000 ms): <compare+0>
cmplStd/lib/string.ci:64:[.05fcc6, .05fcdc) exec(0), time(0.000 ms): <compare+6>
cmplStd/lib/string.ci:66:[.05fce8, .05fcec) exec(0), time(0.000 ms): <compare+40>
cmplStd/lib/string.ci:65:[.05fcdc, .05fcec) exec(0), time(0.000 ms): <compare+28>
cmplStd/lib/string.ci:63:[.05fcec, .05fcf0) exec(0), time(0.000 ms): <compare+44>
cmplStd/lib/string.ci:63:[.05fcf0, .05fcf8) exec(0), time(0.000 ms): <compare+48>
cmplStd/lib/string.ci:63:[.05fcc1, .05fcfc) exec(0), time(0.000 ms): <compare+1>
cmplStd/lib/string.ci:69:[.05fcfc, .05fcff) exec(0), time(0.000 ms): <compare+60>
cmplStd/lib/string.ci:76:[.05fd0f, .05fd1a) exec(0), time(0.000 ms): <ignCase+15>
cmplStd/lib/string.ci:75:[.05fd00, .05fd1a) exec(0), time(0.000 ms): <ignCase+0>
cmplStd/lib/string.ci:79:[.05fd29, .05fd34) exec(0), time(0.000 ms): <ignCase+41>
cmplStd/lib/string.ci:78:[.05fd1a, .05fd34) exec(0), time(0.000 ms): <ignCase+26>
cmplStd/lib/string.ci:81:[.05fd34, .05fd47) exec(0), time(0.000 ms): <ignCase+52>
cmplStd/lib/string.ci:84:[.05fd48, .05fd6c) exec(0), time(0.000 ms): <ignCaseCmp+0>
cmplStd/lib/string.ci:89:[.05fd70, .05fd7e) exec(0), time(0.000 ms): <caseCmp+0>
cmplStd/lib/string.ci:130:[.05fd8e, .05fd92) exec(0), time(0.000 ms): <append+14>
cmplStd/lib/string.ci:129:[.05fd85, .05fd92) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:132:[.05fd92, .05fd9e) exec(0), time(0.000 ms): <append+18>
cmplStd/lib/string.ci:133:[.05fd9e, .05fda6) exec(0), time(0.000 ms): <append+30>
cmplStd/lib/string.ci:128:[.05fda6, .05fdaa) exec(0), time(0.000 ms): <append+38>
cmplStd/lib/string.ci:128:[.05fdaa, .05fdb4) exec(0), time(0.000 ms): <append+42>
cmplStd/lib/string.ci:128:[.05fd80, .05fdb8) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:137:[.05fdc1, .05fdc9) exec(0), time(0.000 ms): <append+65>
cmplStd/lib/string.ci:136:[.05fdb8, .05fdc9) exec(0), time(0.000 ms): <append+56>
cmplStd/lib/string.ci:139:[.05fdc9, .05fdd0) exec(0), time(0.000 ms): <append+73>
cmplStd/lib/string.ci:140:[.05fdd0, .05fdd4) exec(0), time(0.000 ms): <append+80>
cmplStd/lib/string.ci:148:[.05fde8, .05fde9) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:149:[.05fde9, .05fded) exec(0), time(0.000 ms): <append+1>
cmplStd/lib/string.ci:153:[.05fdff, .05fe09) exec(0), time(0.000 ms): <append+23>
cmplStd/lib/string.ci:152:[.05fdf4, .05fe09) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:151:[.05fded, .05fe09) exec(0), time(0.000 ms): <append+5>
cmplStd/lib/string.ci:157:[.05fe09, .05fe10) exec(0), time(0.000 ms): <append+33>
cmplStd/lib/string.ci:159:[.05fe18, .05fe1f) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:158:[.05fe10, .05fe1f) exec(0), time(0.000 ms): <append+40>
cmplStd/lib/string.ci:161:[.05fe1f, .05fe55) exec(0), time(0.000 ms): <append+55>
cmplStd/lib/string.ci:162:[.05fe55, .05fe8a) exec(0), time(0.000 ms): <append+109>
cmplStd/lib/string.ci:166:[.05fe8e, .05feab) exec(0), time(0.000 ms): <append+166>
cmplStd/lib/string.ci:165:[.05feab, .05feb3) exec(0), time(0.000 ms): <append+195>
cmplStd/lib/string.ci:165:[.05feb3, .05febb) exec(0), time(0.000 ms): <append+203>
cmplStd/lib/string.ci:165:[.05fe8a, .05febb) exec(0), time(0.000 ms): <append+162>
cmplStd/lib/string.ci:169:[.05fec3, .05fed8) exec(0), time(0.000 ms): <append+219>
cmplStd/lib/string.ci:168:[.05febb, .05fed8) exec(0), time(0.000 ms): <append+211>
cmplStd/lib/string.ci:172:[.05fed8, .05fee2) exec(0), time(0.000 ms): <append+240>
cmplStd/lib/string.ci:174:[.05fee2, .05fee9) exec(0), time(0.000 ms): <append+250>
cmplStd/lib/string.ci:176:[.05fef4, .05fefe) exec(0), time(0.000 ms): <append+268>
cmplStd/lib/string.ci:175:[.05fee9, .05fefe) exec(0), time(0.000 ms): <append+257>
cmplStd/lib/string.ci:181:[.05ff09, .05ff11) exec(0), time(0.000 ms): <append+289>
cmplStd/lib/string.ci:185:[.05ff2f, .05ff63) exec(0), time(0.000 ms): <append+327>
cmplStd/lib/string.ci:186:[.05ff63, .05ff6e) exec(0), time(0.000 ms): <append+379>
cmplStd/lib/string.ci:187:[.05ff6e, .05ff76) exec(0), time(0.000 ms): <append+390>
cmplStd/lib/string.ci:184:[.05ff76, .05ff7e) exec(0), time(0.000 ms): <append+398>
cmplStd/lib/string.ci:184:[.05ff7e, .05ff86) exec(0), time(0.000 ms): <append+406>
cmplStd/lib/string.ci:184:[.05ff2b, .05ff86) exec(0), time(0.000 ms): <append+323>
cmplStd/lib/string.ci:182:[.05ff11, .05ff86) exec(0), time(0.000 ms): <append+297>
cmplStd/lib/string.ci:190:[.05ff86, .05ffba) exec(0), time(0.000 ms): <append+414>
cmplStd/lib/string.ci:191:[.05ffba, .05ffc5) exec(0), time(0.000 ms): <append+466>
cmplStd/lib/string.ci:192:[.05ffc5, .05ffcd) exec(0), time(0.000 ms): <append+477>
cmplStd/lib/string.ci:180:[.05fefe, .05ffcd) exec(0), time(0.000 ms): <append+278>
cmplStd/lib/string.ci:197:[.05ffd1, .060005) exec(0), time(0.000 ms): <append+489>
cmplStd/lib/string.ci:198:[.060005, .060010) exec(0), time(0.000 ms): <append+541>
cmplStd/lib/string.ci:199:[.060010, .060018) exec(0), time(0.000 ms): <append+552>
cmplStd/lib/string.ci:196:[.060018, .060020) exec(0), time(0.000 ms): <append+560>
cmplStd/lib/string.ci:196:[.060020, .060028) exec(0), time(0.000 ms): <append+568>
cmplStd/lib/string.ci:196:[.05ffcd, .060028) exec(0), time(0.000 ms): <append+485>
cmplStd/lib/string.ci:204:[.06002d, .060061) exec(0), time(0.000 ms): <append+581>
cmplStd/lib/string.ci:205:[.060061, .060072) exec(0), time(0.000 ms): <append+633>
cmplStd/lib/string.ci:206:[.060072, .06007a) exec(0), time(0.000 ms): <append+650>
cmplStd/lib/string.ci:203:[.06007a, .06007e) exec(0), time(0.000 ms): <append+658>
cmplStd/lib/string.ci:203:[.06007e, .060087) exec(0), time(0.000 ms): <append+662>
cmplStd/lib/string.ci:203:[.060028, .06008b) exec(0), time(0.000 ms): <append+576>
cmplStd/lib/string.ci:210:[.060094, .06009c) exec(0), time(0.000 ms): <append+684>
cmplStd/lib/string.ci:209:[.06008b, .06009c) exec(0), time(0.000 ms): <append+675>
cmplStd/lib/string.ci:212:[.06009c, .0600a3) exec(0), time(0.000 ms): <append+692>
cmplStd/lib/string.ci:213:[.0600a3, .0600ab) exec(0), time(0.000 ms): <append+699>
cmplStd/lib/string.ci:236:[.0600b4, .0600bc) exec(0), time(0.000 ms): <append+4>
cmplStd/lib/string.ci:237:[.0600bc, .0600bf) exec(0), time(0.000 ms): <append+12>
cmplStd/lib/string.ci:238:[.0600bf, .0600cb) exec(0), time(0.000 ms): <append+15>
cmplStd/lib/string.ci:239:[.0600cb, .0600dc) exec(0), time(0.000 ms): <append+27>
cmplStd/lib/string.ci:235:[.0600b0, .0600dc) exec(0), time(0.000 ms): <append+0>
cmplStd/lib/string.ci:242:[.0600e0, .0600e6) exec(0), time(0.000 ms): <append+48>
cmplStd/lib/string.ci:243:[.0600e6, .0600e9) exec(0), time(0.000 ms): <append+54>
cmplStd/lib/string.ci:244:[.0600e9, .0600f3) exec(0), time(0.000 ms): <append+57>
cmplStd/lib/string.ci:245:[.0600f3, .0600fc) exec(0), time(0.000 ms): <append+67>
cmplStd/lib/string.ci:241:[.0600dc, .0600fc) exec(0), time(0.000 ms): <append+44>
cmplStd/lib/string.ci:248:[.0600fc, .06010e) exec(0), time(0.000 ms): <append+76>
cmplStd/lib/string.ci:249:[.06010e, .060129) exec(0), time(0.000 ms): <append+94>
cmplStd/lib/string.ci:250:[.060129, .060146) exec(0), time(0.000 ms): <append+121>
cmplStd/lib/string.ci:252:[.060146, .06015c) exec(0), time(0.000 ms): <append+150>
cmplStd/lib/string.ci:253:[.06015c, .060172) exec(0), time(0.000 ms): <append+172>
cmplStd/lib/string.ci:254:[.060172, .06018b) exec(0), time(0.000 ms): <append+194>
cmplStd/lib/string.ci:255:[.06018b, .060193) exec(0), time(0.000 ms): <append+219>
cmplStd/lib/string.ci:264:[.0601a8, .0601e7) exec(0), time(0.000 ms): <append+0>
cmplStd/test/std/tryExec.ci:16:[.0605a0, .0605a4) exec(128-1), time(0.028-0.028 ms): <stackOverflow+0>
cmplStd/test/std/tryExec.ci:17:[.0605a4, .0605b3) exec(127-127), time(0.000 ms): <stackOverflow+4>
cmplStd/test/std/tryExec.ci:21:[.0605b8, .0605bf) exec(1-1), time(0.000 ms): <divisionByZero+0>
cmplStd/test/std/tryExec.ci:31:[.0605cc, .0605d3) exec(1), time(0.000 ms): <abortExecution+4>
cmplStd/test/std/tryExec.ci:32:[.0605d3, .0605da) exec(1), time(0.000 ms): <abortExecution+11>
cmplStd/test/std/tryExec.ci:33:[.0605da, .0605e1) exec(1), time(0.000 ms): <abortExecution+18>
cmplStd/test/std/tryExec.ci:30:[.0605c8, .0605e1) exec(1-1), time(0.000 ms): <abortExecution+0>
cmplStd/test/std/tryExec.ci:35:[.0605e1, .060607) exec(1-1), time(0.000 ms): <abortExecution+25>
cmplStd/test/std/tryExec.ci:39:[.060610, .060615) exec(1), time(0.000 ms): <invalidMemoryAccess+0>
cmplStd/test/std/tryExec.ci:40:[.060615, .060618) exec(1-1), time(0.000 ms): <invalidMemoryAccess+5>
cmplStd/test/std/tryExec.ci:44:[.060620, .060622) exec(1-1), time(0.000 ms): <invalidInstruction+0>
cmplStd/test/lang/function.ci:8:[.060928, .060930) exec(2), time(0.011-0.011 ms): <funAdd+0>
cmplStd/test/lang/function.ci:34:[.060968, .060970) exec(2), time(0.011-0.011 ms): <funMul+0>
cmplStd/test/lang/function.ci:40:[.06097c, .060980) exec(377), time(1.724-1.724 ms): <fib+12>
cmplStd/test/lang/function.ci:39:[.060970, .060980) exec(753-377), time(0.574-0.574 ms): <fib+0>
cmplStd/test/lang/function.ci:42:[.060980, .0609a6) exec(376-375), time(12.949-12.949 ms): <fib+16>
cmplStd/test/lang/init.method.ci:11:[.060b20, .060b46) exec(3), time(0.226-0.226 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:41:[.060b50, .060b76) exec(4), time(0.298-0.298 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:48:[.060b78, .060b9e) exec(0), time(0.000 ms): <forwardMethod+0>
cmplStd/test/lang/init.method.ci:58:[.060ba0, .060bc6) exec(0), time(0.000 ms): <globalFunction+0>
cmplStd/test/lang/init.method.ci:85:[.060bd8, .060bfb) exec(1), time(0.019-0.019 ms): <staticMethod+0>
cmplStd/test/lang/init.method.ci:87:[.060c09, .060c19) exec(1), time(0.099-0.099 ms): <staticMethod+49>
cmplStd/test/lang/init.method.ci:86:[.060bfb, .060c19) exec(1-1), time(0.000 ms): <staticMethod+35>
cmplStd/test/lang/init.method.ci:91:[.060c20, .060c43) exec(1), time(0.016-0.016 ms): <virtualMethod+0>
cmplStd/test/lang/init.method.ci:93:[.060c51, .060c5e) exec(1), time(0.093-0.093 ms): <virtualMethod+49>
cmplStd/test/lang/init.method.ci:92:[.060c43, .060c5e) exec(1-1), time(0.000 ms): <virtualMethod+35>
cmplStd/test/lang/init.array.ci:51:[.060ce8, .060cec) exec(5), time(0.024-0.024 ms): <lenSlice+0>
cmplStd/test/lang/init.array.ci:52:[.060cf0, .060cfc) exec(21), time(0.134-0.134 ms): <nthFixed+0>
cmplStd/test/lang/init.array.ci:53:[.060d00, .060d0c) exec(21), time(0.132-0.132 ms): <nthArray+0>
cmplStd/test/lang/init.array.ci:54:[.060d10, .060d1c) exec(14), time(0.092-0.092 ms): <nthSlice+0>
cmplStd/lib/string.ci:145:[.061764, .061772) exec(1), time(0.001-0.001 ms): <.main+0>
cmplStd/lib/string.ci:146:[.061772, .061780) exec(1), time(0.001-0.001 ms): <.main+14>
::[.061780, .061787) exec(1), time(0.001-0.001 ms): <.main+28>
::[.061787, .06178c) exec(1), time(0.000 ms): <.main+35>
::[.06178c, .061793) exec(1), time(0.001-0.001 ms): <.main+40>
::[.061793, .061798) exec(1), time(0.000 ms): <.main+47>
cmplStd/lib/string.ci:263:[.061780, .061798) exec(0), time(0.000 ms): <.main+28>
cmplStd/test/lang/emit.ci:3:[.061798, .06179d) exec(1), time(0.000 ms): <.main+52>
cmplStd/test/lang/emit.ci:4:[.06179d, .0617a2) exec(1), time(0.001-0.001 ms): <.main+57>
cmplStd/test/lang/emit.ci:6:[.0617a2, .0617ab) exec(1), time(0.001-0.001 ms): <.main+62>
cmplStd/test/lang/emit.ci:7:[.0617ab, .0617b4) exec(1), time(0.001-0.001 ms): <.main+71>
cmplStd/test/lang/emit.ci:10:[.0617b4, .0617c1) exec(1), time(0.002-0.002 ms): <.main+80>
cmplStd/test/lang/emit.ci:13:[.0617c1, .0617d0) exec(1), time(0.001-0.001 ms): <.main+93>
cmplStd/test/lang/emit.ci:16:[.0617d0, .0617e3) exec(1), time(0.025-0.025 ms): <.main+108>
cmplStd/test/lang/emit.ci:23:[.0617e3, .0617ec) exec(1), time(0.001-0.001 ms): <.main+127>
cmplStd/test/lang/emit.ci:24:[.0617ec, .0617f6) exec(1), time(0.002-0.002 ms): <.main+136>
cmplStd/test/lang/emit.ci:25:[.0617f6, .061804) exec(1), time(0.001-0.001 ms): <.main+146>
cmplStd/test/lang/emit.ci:26:[.061804, .061811) exec(1), time(0.001-0.001 ms): <.main+160>
cmplStd/test/lang/emit.ci:29:[.061811, .06181f) exec(1), time(0.001-0.001 ms): <.main+173>
cmplStd/test/lang/inlineMacros.ci:10:[.06181f, .061828) exec(1), time(0.000 ms): <.main+187>
cmplStd/test/lang/inlineMacros.ci:11:[.061828, .061831) exec(1), time(0.000 ms): <.main+196>
cmplStd/test/lang/inlineMacros.ci:12:[.061831, .06183a) exec(1), time(0.000 ms): <.main+205>
cmplStd/test/lang/inlineMacros.ci:13:[.06183a, .061843) exec(1), time(0.001-0.001 ms): <.main+214>
cmplStd/test/lang/inlineMacros.ci:15:[.061843, .061848) exec(1), time(0.001-0.001 ms): <.main+223>
cmplStd/test/lang/inlineMacros.ci:16:[.061848, .06184d) exec(1), time(0.001-0.001 ms): <.main+228>
cmplStd/test/lang/inlineMacros.ci:17:[.06184d, .061852) exec(1), time(0.001-0.001 ms): <.main+233>
cmplStd/test/lang/inlineMacros.ci:19:[.061852, .06185b) exec(1), time(0.000 ms): <.main+238>
cmplStd/test/lang/inlineMacros.ci:20:[.06185b, .061863) exec(1), time(0.000 ms): <.main+247>
cmplStd/test/lang/inlineMacros.ci:21:[.061863, .061873) exec(1), time(0.002-0.002 ms): <.main+255>
cmplStd/test/lang/inlineMacros.ci:23:[.061873, .061880) exec(1), time(0.001-0.001 ms): <.main+271>
cmplStd/test/lang/inlineMacros.ci:24:[.061880, .06188d) exec(1), time(0.001-0.001 ms): <.main+284>
cmplStd/test/lang/inlineMacros.ci:25:[.06188d, .0618a6) exec(1), time(0.002-0.002 ms): <.main+297>
cmplStd/test/lang/inlineMacros.ci:27:[.0618a6, .0618c2) exec(1), time(0.003-0.003 ms): <.main+322>
cmplStd/test/lang/inlineMacros.ci:28:[.0618c2, .0618dc) exec(1), time(0.003-0.003 ms): <.main+350>
cmplStd/test/lang/inlineMacros.ci:29:[.0618dc, .061902) exec(1), time(0.003-0.003 ms): <.main+376>
cmplStd/test/lang/inlineMacros.ci:31:[.061902, .061927) exec(1), time(0.004-0.004 ms): <.main+414>
cmplStd/test/lang/inlineMacros.ci:32:[.061927, .06194a) exec(1), time(0.005-0.005 ms): <.main+451>
cmplStd/test/lang/inlineMacros.ci:33:[.06194a, .061979) exec(1), time(0.006-0.006 ms): <.main+486>
cmplStd/test/lang/inlineMacros.ci:35:[.061979, .06199e) exec(1), time(0.004-0.004 ms): <.main+533>
cmplStd/test/lang/inlineMacros.ci:36:[.06199e, .0619c1) exec(1), time(0.004-0.004 ms): <.main+570>
cmplStd/test/lang/inlineMacros.ci:37:[.0619c1, .0619f0) exec(1), time(0.005-0.005 ms): <.main+605>
cmplStd/test/lang/inlineMacros.ci:41:[.0619f0, .061a09) exec(1), time(0.002-0.002 ms): <.main+652>
cmplStd/test/lang/inlineMacros.ci:42:[.061a09, .061a1e) exec(1), time(0.002-0.002 ms): <.main+677>
cmplStd/test/lang/inlineMacros.ci:43:[.061a1e, .061a35) exec(1), time(0.003-0.003 ms): <.main+698>
cmplStd/test/lang/inlineMacros.ci:44:[.061a35, .061a4c) exec(1), time(0.003-0.003 ms): <.main+721>
cmplStd/test/lang/inlineMacros.ci:45:[.061a4c, .061a77) exec(1), time(0.005-0.005 ms): <.main+744>
cmplStd/test/lang/inlineMacros.ci:46:[.061a77, .061aa2) exec(1), time(0.006-0.006 ms): <.main+787>
cmplStd/test/lang/inlineMacros.ci:50:[.061aa2, .061ae4) exec(1), time(0.002-0.002 ms): <.main+830>
cmplStd/test/lang/inlineMacros.ci:51:[.061ae4, .061b26) exec(1), time(0.007-0.007 ms): <.main+896>
cmplStd/test/lang/inlineMacros.ci:52:[.061b26, .061b64) exec(1), time(0.003-0.003 ms): <.main+962>
cmplStd/test/lang/inlineMacros.ci:53:[.061b64, .061ba2) exec(1), time(0.008-0.008 ms): <.main+1024>
cmplStd/test/lang/inlineMacros.ci:54:[.061ba2, .061bf4) exec(1), time(0.004-0.004 ms): <.main+1086>
cmplStd/test/lang/inlineMacros.ci:55:[.061bf4, .061c46) exec(1), time(0.009-0.009 ms): <.main+1168>
cmplStd/test/lang/inlineMacros.ci:59:[.061c46, .061ca3) exec(1), time(0.012-0.012 ms): <.main+1250>
cmplStd/test/lang/inlineMacros.ci:60:[.061ca3, .061d00) exec(1), time(0.012-0.012 ms): <.main+1343>
cmplStd/test/lang/inlineMacros.ci:61:[.061d00, .061d59) exec(1), time(0.012-0.012 ms): <.main+1436>
cmplStd/test/lang/inlineMacros.ci:62:[.061d59, .061db2) exec(1), time(0.013-0.013 ms): <.main+1525>
cmplStd/test/lang/inlineMacros.ci:63:[.061db2, .061e1f) exec(1), time(0.015-0.015 ms): <.main+1614>
cmplStd/test/lang/inlineMacros.ci:64:[.061e1f, .061e8c) exec(1), time(0.014-0.014 ms): <.main+1723>
cmplStd/test/lang/inlineMacros.ci:68:[.061e8c, .061ee9) exec(1), time(0.012-0.012 ms): <.main+1832>
cmplStd/test/lang/inlineMacros.ci:69:[.061ee9, .061f46) exec(1), time(0.012-0.012 ms): <.main+1925>
cmplStd/test/lang/inlineMacros.ci:70:[.061f46, .061f9f) exec(1), time(0.012-0.012 ms): <.main+2018>
cmplStd/test/lang/inlineMacros.ci:71:[.061f9f, .061ff8) exec(1), time(0.011-0.011 ms): <.main+2107>
cmplStd/test/lang/inlineMacros.ci:72:[.061ff8, .062065) exec(1), time(0.015-0.015 ms): <.main+2196>
cmplStd/test/lang/inlineMacros.ci:73:[.062065, .0620d2) exec(1), time(0.015-0.015 ms): <.main+2305>
cmplStd/test/lang/overload.inline.ci:9:[.0620d2, .0620db) exec(1), time(0.001-0.001 ms): <.main+2414>
cmplStd/test/lang/overload.inline.ci:10:[.0620db, .0620e4) exec(1), time(0.001-0.001 ms): <.main+2423>
cmplStd/test/lang/overload.inline.ci:11:[.0620e4, .0620ed) exec(1), time(0.000 ms): <.main+2432>
cmplStd/test/lang/overload.inline.ci:12:[.0620ed, .0620f6) exec(1), time(0.000 ms): <.main+2441>
cmplStd/test/lang/overload.inline.ci:13:[.0620f6, .0620ff) exec(1), time(0.001-0.001 ms): <.main+2450>
cmplStd/test/lang/overload.inline.ci:28:[.0620ff, .06210c) exec(1), time(0.001-0.001 ms): <.main+2459>
cmplStd/test/lang/overload.inline.ci:29:[.06210c, .062128) exec(1), time(0.003-0.003 ms): <.main+2472>
cmplStd/test/std/number.ci:3:[.062128, .062135) exec(1), time(0.001-0.001 ms): <.main+2500>
cmplStd/test/std/number.ci:4:[.062135, .062142) exec(1), time(0.000 ms): <.main+2513>
cmplStd/test/std/number.ci:6:[.062142, .06214b) exec(1), time(0.001-0.001 ms): <.main+2526>
cmplStd/test/std/number.ci:7:[.06214b, .062154) exec(1), time(0.001-0.001 ms): <.main+2535>
cmplStd/test/std/number.ci:14:[.062154, .06215f) exec(1), time(0.001-0.001 ms): <.main+2544>
cmplStd/test/std/number.ci:15:[.06215f, .06216a) exec(1), time(0.001-0.001 ms): <.main+2555>
cmplStd/test/std/number.ci:16:[.06216a, .062175) exec(1), time(0.001-0.001 ms): <.main+2566>
cmplStd/test/std/number.ci:18:[.062175, .06219b) exec(1), time(0.007-0.007 ms): <.main+2577>
cmplStd/test/std/number.ci:19:[.06219b, .0621bf) exec(1), time(0.006-0.006 ms): <.main+2615>
cmplStd/test/std/number.ci:21:[.0621bf, .0621d5) exec(1), time(0.018-0.018 ms): <.main+2651>
cmplStd/test/std/number.ci:22:[.0621d5, .0621eb) exec(1), time(0.016-0.016 ms): <.main+2673>
cmplStd/test/std/number.ci:23:[.0621eb, .0621fd) exec(1), time(0.017-0.017 ms): <.main+2695>
cmplStd/test/std/number.ci:25:[.0621fd, .062213) exec(1), time(0.016-0.016 ms): <.main+2713>
cmplStd/test/std/number.ci:26:[.062213, .062229) exec(1), time(0.016-0.016 ms): <.main+2735>
cmplStd/test/std/number.ci:27:[.062229, .06223b) exec(1), time(0.017-0.017 ms): <.main+2757>
cmplStd/test/std/number.ci:29:[.06223b, .062251) exec(1), time(0.017-0.017 ms): <.main+2775>
cmplStd/test/std/number.ci:30:[.062251, .062267) exec(1), time(0.019-0.019 ms): <.main+2797>
cmplStd/test/std/number.ci:31:[.062267, .062279) exec(1), time(0.017-0.017 ms): <.main+2819>
cmplStd/test/std/number.ci:33:[.062279, .06228f) exec(1), time(0.019-0.019 ms): <.main+2837>
cmplStd/test/std/number.ci:34:[.06228f, .0622a5) exec(1), time(0.020-0.020 ms): <.main+2859>
cmplStd/test/std/number.ci:35:[.0622a5, .0622b7) exec(1), time(0.017-0.017 ms): <.main+2881>
cmplStd/test/std/number.ci:37:[.0622b7, .0622cd) exec(1), time(0.024-0.024 ms): <.main+2899>
cmplStd/test/std/number.ci:38:[.0622cd, .0622e3) exec(1), time(0.016-0.016 ms): <.main+2921>
cmplStd/test/std/number.ci:39:[.0622e3, .0622f9) exec(1), time(0.018-0.018 ms): <.main+2943>
cmplStd/test/std/number.ci:40:[.0622f9, .06230f) exec(1), time(0.017-0.017 ms): <.main+2965>
cmplStd/test/std/number.ci:41:[.06230f, .062320) exec(1), time(0.016-0.016 ms): <.main+2987>
cmplStd/test/std/number.ci:42:[.062320, .06233a) exec(1), time(0.017-0.017 ms): <.main+3004>
cmplStd/test/std/number.ci:43:[.06233a, .06234b) exec(1), time(0.016-0.016 ms): <.main+3030>
cmplStd/test/std/number.ci:44:[.06234b, .062360) exec(1), time(0.018-0.018 ms): <.main+3047>
cmplStd/test/std/number.ci:46:[.062360, .062372) exec(1), time(0.017-0.017 ms): <.main+3068>
cmplStd/test/std/number.ci:47:[.062372, .062384) exec(1), time(0.017-0.017 ms): <.main+3086>
cmplStd/test/std/number.ci:48:[.062384, .062396) exec(1), time(0.017-0.017 ms): <.main+3104>
cmplStd/test/std/number.ci:49:[.062396, .0623ac) exec(1), time(0.017-0.017 ms): <.main+3122>
cmplStd/test/std/number.ci:50:[.0623ac, .0623b9) exec(1), time(0.016-0.016 ms): <.main+3144>
cmplStd/test/std/number.ci:51:[.0623b9, .0623cf) exec(1), time(0.019-0.019 ms): <.main+3157>
cmplStd/test/std/number.ci:52:[.0623cf, .0623e0) exec(1), time(0.019-0.019 ms): <.main+3179>
cmplStd/test/std/number.ci:53:[.0623e0, .0623f1) exec(1), time(0.019-0.019 ms): <.main+3196>
cmplStd/test/std/number.ci:55:[.0623f1, .0623fd) exec(1), time(0.016-0.016 ms): <.main+3213>
cmplStd/test/std/number.ci:56:[.0623fd, .062409) exec(1), time(0.015-0.015 ms): <.main+3225>
cmplStd/test/std/number.ci:57:[.062409, .062415) exec(1), time(0.015-0.015 ms): <.main+3237>
cmplStd/test/std/number.ci:58:[.062415, .062421) exec(1), time(0.016-0.016 ms): <.main+3249>
cmplStd/test/std/number.ci:59:[.062421, .06242d) exec(1), time(0.015-0.015 ms): <.main+3261>
cmplStd/test/std/number.ci:60:[.06242d, .062439) exec(1), time(0.018-0.018 ms): <.main+3273>
cmplStd/test/std/number.ci:62:[.062439, .06244b) exec(1), time(0.017-0.017 ms): <.main+3285>
cmplStd/test/std/number.ci:63:[.06244b, .06245d) exec(1), time(0.021-0.021 ms): <.main+3303>
cmplStd/test/std/number.ci:65:[.06245d, .062471) exec(1), time(0.021-0.021 ms): <.main+3321>
cmplStd/test/std/number.ci:66:[.062471, .062485) exec(1), time(0.020-0.020 ms): <.main+3341>
cmplStd/test/std/memory.ci:7:[.062485, .062497) exec(1), time(0.017-0.017 ms): <.main+3361>
cmplStd/test/std/memory.ci:8:[.062497, .0624a9) exec(1), time(0.018-0.018 ms): <.main+3379>
cmplStd/test/std/memory.ci:9:[.0624a9, .0624bb) exec(1), time(0.017-0.017 ms): <.main+3397>
cmplStd/test/std/memory.ci:10:[.0624bb, .0624cd) exec(1), time(0.017-0.017 ms): <.main+3415>
cmplStd/test/std/memory.ci:23:[.0624cd, .0624da) exec(1), time(0.001-0.001 ms): <.main+3433>
cmplStd/test/std/memory.ci:24:[.0624da, .0624e7) exec(1), time(0.000 ms): <.main+3446>
cmplStd/test/std/tryExec.ci:47:[.0624e7, .0624f9) exec(1), time(0.038-0.038 ms): <.main+3459>
cmplStd/test/std/tryExec.ci:48:[.0624f9, .06250b) exec(1), time(0.017-0.017 ms): <.main+3477>
cmplStd/test/std/tryExec.ci:49:[.06250b, .06251d) exec(1), time(1.778-1.778 ms): <.main+3495>
cmplStd/test/std/tryExec.ci:50:[.06251d, .06252f) exec(1), time(0.030-0.030 ms): <.main+3513>
cmplStd/test/std/tryExec.ci:51:[.06252f, .062541) exec(1), time(0.028-0.028 ms): <.main+3531>
cmplStd/test/std/tryExec.ci:52:[.062541, .062553) exec(1), time(0.026-0.026 ms): <.main+3549>
cmplStd/test/std/tryExec.ci:53:[.062553, .062565) exec(1), time(0.111-0.111 ms): <.main+3567>
cmplStd/test/lang/init.reference.ci:7:[.062565, .062572) exec(1), time(0.001-0.001 ms): <.main+3585>
cmplStd/test/lang/init.reference.ci:8:[.062572, .06257b) exec(1), time(0.001-0.001 ms): <.main+3598>
cmplStd/test/lang/init.reference.ci:9:[.06257b, .062584) exec(1), time(0.001-0.001 ms): <.main+3607>
cmplStd/test/lang/init.reference.ci:10:[.062584, .062592) exec(1), time(0.001-0.001 ms): <.main+3616>
cmplStd/test/lang/init.reference.ci:12:[.062592, .06259b) exec(1), time(0.001-0.001 ms): <.main+3630>
cmplStd/test/lang/init.reference.ci:13:[.06259b, .0625a3) exec(1), time(0.000 ms): <.main+3639>
cmplStd/test/lang/init.reference.ci:14:[.0625a3, .0625ab) exec(1), time(0.001-0.001 ms): <.main+3647>
cmplStd/test/lang/init.reference.ci:16:[.0625ab, .0625b4) exec(1), time(0.001-0.001 ms): <.main+3655>
cmplStd/test/lang/init.reference.ci:17:[.0625b4, .0625bd) exec(1), time(0.000 ms): <.main+3664>
cmplStd/test/lang/init.reference.ci:18:[.0625bd, .0625cb) exec(1), time(0.001-0.001 ms): <.main+3673>
cmplStd/test/lang/init.reference.ci:19:[.0625cb, .0625d4) exec(1), time(0.001-0.001 ms): <.main+3687>
cmplStd/test/lang/init.reference.ci:20:[.0625d4, .0625dd) exec(1), time(0.001-0.001 ms): <.main+3696>
cmplStd/test/lang/init.reference.ci:21:[.0625dd, .0625e6) exec(1), time(0.000 ms): <.main+3705>
cmplStd/test/lang/init.reference.ci:23:[.0625e6, .0625ef) exec(1), time(0.001-0.001 ms): <.main+3714>
cmplStd/test/lang/init.reference.ci:24:[.0625ef, .0625fd) exec(1), time(0.001-0.001 ms): <.main+3723>
cmplStd/test/lang/init.reference.ci:25:[.0625fd, .062606) exec(1), time(0.001-0.001 ms): <.main+3737>
cmplStd/test/lang/init.reference.ci:27:[.062606, .06260e) exec(1), time(0.001-0.001 ms): <.main+3746>
cmplStd/test/lang/init.reference.ci:28:[.06260e, .062616) exec(1), time(0.001-0.001 ms): <.main+3754>
cmplStd/test/lang/init.reference.ci:29:[.062616, .06261e) exec(1), time(0.001-0.001 ms): <.main+3762>
cmplStd/test/lang/init.reference.ci:30:[.06261e, .062626) exec(1), time(0.000 ms): <.main+3770>
cmplStd/test/lang/init.reference.ci:31:[.062626, .06262e) exec(1), time(0.001-0.001 ms): <.main+3778>
cmplStd/test/lang/init.reference.ci:32:[.06262e, .062636) exec(1), time(0.001-0.001 ms): <.main+3786>
cmplStd/test/lang/init.reference.ci:35:[.062636, .06263f) exec(1), time(0.000 ms): <.main+3794>
cmplStd/test/lang/init.reference.ci:36:[.06263f, .062648) exec(1), time(0.001-0.001 ms): <.main+3803>
cmplStd/test/lang/init.reference.ci:37:[.062648, .062651) exec(1), time(0.001-0.001 ms): <.main+3812>
cmplStd/test/lang/init.reference.ci:38:[.062651, .06265a) exec(1), time(0.000 ms): <.main+3821>
cmplStd/test/lang/init.reference.ci:39:[.06265a, .062663) exec(1), time(0.001-0.001 ms): <.main+3830>
cmplStd/test/lang/init.reference.ci:40:[.062663, .06266c) exec(1), time(0.001-0.001 ms): <.main+3839>
cmplStd/test/lang/init.reference.ci:41:[.06266c, .062675) exec(1), time(0.000 ms): <.main+3848>
cmplStd/test/lang/init.reference.ci:42:[.062675, .06267e) exec(1), time(0.001-0.001 ms): <.main+3857>
cmplStd/test/lang/init.reference.ci:43:[.06267e, .062687) exec(1), time(0.000 ms): <.main+3866>
cmplStd/test/lang/init.reference.ci:44:[.062687, .062690) exec(1), time(0.000 ms): <.main+3875>
cmplStd/test/lang/init.reference.ci:45:[.062690, .062699) exec(1), time(0.001-0.001 ms): <.main+3884>
cmplStd/test/lang/init.reference.ci:46:[.062699, .0626a2) exec(1), time(0.001-0.001 ms): <.main+3893>
cmplStd/test/lang/init.reference.ci:47:[.0626a2, .0626ab) exec(1), time(0.001-0.001 ms): <.main+3902>
cmplStd/test/lang/init.reference.ci:48:[.0626ab, .0626b4) exec(1), time(0.001-0.001 ms): <.main+3911>
cmplStd/test/lang/init.reference.ci:49:[.0626b4, .0626bd) exec(1), time(0.000 ms): <.main+3920>
cmplStd/test/lang/init.reference.ci:50:[.0626bd, .0626c6) exec(1), time(0.001-0.001 ms): <.main+3929>
cmplStd/test/lang/init.reference.ci:51:[.0626c6, .0626cf) exec(1), time(0.000 ms): <.main+3938>
cmplStd/test/lang/init.reference.ci:52:[.0626cf, .0626d8) exec(1), time(0.001-0.001 ms): <.main+3947>
cmplStd/test/lang/init.reference.ci:55:[.0626d8, .0626e6) exec(1), time(0.001-0.001 ms): <.main+3956>
cmplStd/test/lang/init.reference.ci:56:[.0626e6, .0626f4) exec(1), time(0.001-0.001 ms): <.main+3970>
cmplStd/test/lang/init.reference.ci:57:[.0626f4, .062702) exec(1), time(0.001-0.001 ms): <.main+3984>
cmplStd/test/lang/init.reference.ci:58:[.062702, .062710) exec(1), time(0.001-0.001 ms): <.main+3998>
cmplStd/test/lang/init.reference.ci:59:[.062710, .06271e) exec(1), time(0.001-0.001 ms): <.main+4012>
cmplStd/test/lang/init.reference.ci:60:[.06271e, .06272c) exec(1), time(0.001-0.001 ms): <.main+4026>
cmplStd/test/lang/init.reference.ci:61:[.06272c, .06273a) exec(1), time(0.001-0.001 ms): <.main+4040>
cmplStd/test/lang/init.reference.ci:62:[.06273a, .062748) exec(1), time(0.002-0.002 ms): <.main+4054>
cmplStd/test/lang/init.reference.ci:63:[.062748, .062756) exec(1), time(0.002-0.002 ms): <.main+4068>
cmplStd/test/lang/init.reference.ci:64:[.062756, .062764) exec(1), time(0.001-0.001 ms): <.main+4082>
cmplStd/test/lang/init.reference.ci:65:[.062764, .062772) exec(1), time(0.001-0.001 ms): <.main+4096>
cmplStd/test/lang/init.reference.ci:66:[.062772, .062780) exec(1), time(0.002-0.002 ms): <.main+4110>
cmplStd/test/lang/init.reference.ci:67:[.062780, .06278e) exec(1), time(0.002-0.002 ms): <.main+4124>
cmplStd/test/lang/init.reference.ci:68:[.06278e, .06279c) exec(1), time(0.002-0.002 ms): <.main+4138>
cmplStd/test/lang/init.reference.ci:69:[.06279c, .0627aa) exec(1), time(0.002-0.002 ms): <.main+4152>
cmplStd/test/lang/init.reference.ci:70:[.0627aa, .0627b8) exec(1), time(0.001-0.001 ms): <.main+4166>
cmplStd/test/lang/init.reference.ci:71:[.0627b8, .0627c6) exec(1), time(0.001-0.001 ms): <.main+4180>
cmplStd/test/lang/init.reference.ci:72:[.0627c6, .0627d4) exec(1), time(0.001-0.001 ms): <.main+4194>
cmplStd/test/lang/init.reference.ci:75:[.0627d4, .0627dd) exec(1), time(0.001-0.001 ms): <.main+4208>
cmplStd/test/lang/init.reference.ci:76:[.0627dd, .0627e6) exec(1), time(0.001-0.001 ms): <.main+4217>
cmplStd/test/lang/init.reference.ci:77:[.0627e6, .0627ef) exec(1), time(0.001-0.001 ms): <.main+4226>
cmplStd/test/lang/init.reference.ci:78:[.0627ef, .0627f8) exec(1), time(0.000 ms): <.main+4235>
cmplStd/test/lang/init.reference.ci:79:[.0627f8, .062801) exec(1), time(0.001-0.001 ms): <.main+4244>
cmplStd/test/lang/init.reference.ci:80:[.062801, .06280a) exec(1), time(0.001-0.001 ms): <.main+4253>
cmplStd/test/lang/init.reference.ci:81:[.06280a, .062813) exec(1), time(0.001-0.001 ms): <.main+4262>
cmplStd/test/lang/init.reference.ci:82:[.062813, .06281c) exec(1), time(0.000 ms): <.main+4271>
cmplStd/test/lang/init.reference.ci:83:[.06281c, .062825) exec(1), time(0.001-0.001 ms): <.main+4280>
cmplStd/test/lang/init.reference.ci:84:[.062825, .06282e) exec(1), time(0.001-0.001 ms): <.main+4289>
cmplStd/test/lang/init.reference.ci:85:[.06282e, .062837) exec(1), time(0.000 ms): <.main+4298>
cmplStd/test/lang/init.reference.ci:86:[.062837, .062840) exec(1), time(0.001-0.001 ms): <.main+4307>
cmplStd/test/lang/init.reference.ci:87:[.062840, .062849) exec(1), time(0.000 ms): <.main+4316>
cmplStd/test/lang/init.reference.ci:88:[.062849, .062852) exec(1), time(0.001-0.001 ms): <.main+4325>
cmplStd/test/lang/init.reference.ci:89:[.062852, .06285b) exec(1), time(0.001-0.001 ms): <.main+4334>
cmplStd/test/lang/init.reference.ci:90:[.06285b, .062864) exec(1), time(0.000 ms): <.main+4343>
cmplStd/test/lang/init.reference.ci:91:[.062864, .06286d) exec(1), time(0.001-0.001 ms): <.main+4352>
cmplStd/test/lang/init.reference.ci:92:[.06286d, .062876) exec(1), time(0.000 ms): <.main+4361>
cmplStd/test/lang/init.reference.ci:95:[.062876, .06287f) exec(1), time(0.001-0.001 ms): <.main+4370>
cmplStd/test/lang/init.reference.ci:96:[.06287f, .06288d) exec(1), time(0.002-0.002 ms): <.main+4379>
cmplStd/test/lang/init.reference.ci:97:[.06288d, .062896) exec(1), time(0.001-0.001 ms): <.main+4393>
cmplStd/test/lang/init.reference.ci:99:[.062896, .06289f) exec(1), time(0.001-0.001 ms): <.main+4402>
cmplStd/test/lang/init.reference.ci:105:[.06289f, .0628ac) exec(1), time(0.002-0.002 ms): <.main+4411>
cmplStd/test/lang/init.reference.ci:108:[.0628ac, .0628b4) exec(1), time(0.001-0.001 ms): <.main+4424>
cmplStd/test/lang/init.variable.ci:3:[.0628b4, .0628b9) exec(1), time(0.001-0.001 ms): <.main+4432>
cmplStd/test/lang/init.variable.ci:7:[.0628b9, .0628c2) exec(1), time(0.001-0.001 ms): <.main+4437>
cmplStd/test/lang/init.variable.ci:24:[.0628c2, .0628cf) exec(1), time(0.000 ms): <.main+4446>
::[.0628cf, .0628d4) exec(1), time(0.001-0.001 ms): <.main+4459>
cmplStd/test/lang/init.variable.ci:24:[.0628c2, .0628d4) exec(0), time(0.000 ms): <.main+4446>
cmplStd/test/lang/init.variable.ci:33:[.0628d4, .0628e1) exec(1), time(0.024-0.024 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:33:[.0628e1, .0628f3) exec(1), time(0.002-0.002 ms): <.main+4477>
::[.0628f3, .0628fd) exec(1), time(0.002-0.002 ms): <.main+4495>
cmplStd/test/lang/init.variable.ci:33:[.0628d4, .0628fd) exec(0), time(0.000 ms): <.main+4464>
cmplStd/test/lang/init.variable.ci:41:[.0628fd, .06290a) exec(1), time(0.022-0.022 ms): <.main+4505>
cmplStd/test/lang/init.variable.ci:41:[.06290a, .06291c) exec(1), time(0.002-0.002 ms): <.main+4518>
::[.06291c, .062926) exec(1), time(0.002-0.002 ms): <.main+4536>
cmplStd/test/lang/init.variable.ci:41:[.0628fd, .062926) exec(0), time(0.000 ms): <.main+4505>
cmplStd/test/lang/function.ci:12:[.062926, .06293f) exec(1), time(0.019-0.019 ms): <.main+4546>
cmplStd/test/lang/function.ci:15:[.06293f, .062948) exec(1), time(0.000 ms): <.main+4571>
cmplStd/test/lang/function.ci:18:[.062948, .062960) exec(1), time(0.017-0.017 ms): <.main+4580>
cmplStd/test/lang/function.ci:21:[.062960, .062969) exec(1), time(0.001-0.001 ms): <.main+4604>
cmplStd/test/lang/function.ci:24:[.062969, .062981) exec(1), time(0.017-0.017 ms): <.main+4613>
cmplStd/test/lang/function.ci:27:[.062981, .062989) exec(1), time(0.001-0.001 ms): <.main+4637>
cmplStd/test/lang/function.ci:30:[.062989, .0629a1) exec(1), time(0.018-0.018 ms): <.main+4645>
cmplStd/test/lang/function.ci:46:[.0629a1, .0629b5) exec(1), time(12.962-12.962 ms): <.main+4669>
cmplStd/test/lang/reflect.ci:3:[.0629b5, .0629bd) exec(1), time(0.001-0.001 ms): <.main+4689>
cmplStd/test/lang/reflect.ci:4:[.0629bd, .0629c5) exec(1), time(0.001-0.001 ms): <.main+4697>
cmplStd/test/lang/reflect.ci:5:[.0629c5, .0629cd) exec(1), time(0.001-0.001 ms): <.main+4705>
cmplStd/test/lang/reflect.ci:6:[.0629cd, .0629d5) exec(1), time(0.001-0.001 ms): <.main+4713>
cmplStd/test/lang/reflect.ci:7:[.0629d5, .0629dd) exec(1), time(0.000 ms): <.main+4721>
cmplStd/test/lang/reflect.ci:8:[.0629dd, .0629e5) exec(1), time(0.001-0.001 ms): <.main+4729>
cmplStd/test/lang/reflect.ci:9:[.0629e5, .0629ed) exec(1), time(0.000 ms): <.main+4737>
cmplStd/test/lang/reflect.ci:10:[.0629ed, .0629f5) exec(1), time(0.001-0.001 ms): <.main+4745>
cmplStd/test/lang/reflect.ci:11:[.0629f5, .0629fd) exec(1), time(0.001-0.001 ms): <.main+4753>
cmplStd/test/lang/reflect.ci:12:[.0629fd, .062a05) exec(1), time(0.001-0.001 ms): <.main+4761>
cmplStd/test/lang/reflect.ci:13:[.062a05, .062a0d) exec(1), time(0.001-0.001 ms): <.main+4769>
cmplStd/test/lang/reflect.ci:14:[.062a0d, .062a15) exec(1), time(0.001-0.001 ms): <.main+4777>
cmplStd/test/lang/reflect.ci:15:[.062a15, .062a1d) exec(1), time(0.001-0.001 ms): <.main+4785>
cmplStd/test/lang/reflect.ci:16:[.062a1d, .062a25) exec(1), time(0.001-0.001 ms): <.main+4793>
cmplStd/test/lang/reflect.ci:17:[.062a25, .062a2d) exec(1), time(0.001-0.001 ms): <.main+4801>
cmplStd/test/lang/reflect.ci:18:[.062a2d, .062a35) exec(1), time(0.001-0.001 ms): <.main+4809>
cmplStd/test/lang/reflect.ci:19:[.062a35, .062a3d) exec(1), time(0.001-0.001 ms): <.main+4817>
cmplStd/test/lang/reflect.ci:20:[.062a3d, .062a45) exec(1), time(0.001-0.001 ms): <.main+4825>
cmplStd/test/lang/reflect.ci:30:[.062a45, .062a4e) exec(1), time(0.001-0.001 ms): <.main+4833>
cmplStd/test/lang/reflect.ci:31:[.062a4e, .062a5a) exec(1), time(0.031-0.031 ms): <.main+4842>
cmplStd/test/lang/reflect.ci:32:[.062a5a, .062a67) exec(1), time(0.002-0.002 ms): <.main+4854>
cmplStd/test/lang/reflect.ci:33:[.062a67, .062a74) exec(1), time(0.002-0.002 ms): <.main+4867>
cmplStd/test/lang/reflect.ci:34:[.062a74, .062a80) exec(1), time(0.023-0.023 ms): <.main+4880>
cmplStd/test/lang/reflect.ci:35:[.062a80, .062a8c) exec(1), time(0.022-0.022 ms): <.main+4892>
cmplStd/test/lang/reflect.ci:37:[.062a8c, .062a98) exec(1), time(0.022-0.022 ms): <.main+4904>
cmplStd/test/lang/reflect.ci:38:[.062a98, .062aa4) exec(1), time(0.019-0.019 ms): <.main+4916>
cmplStd/test/lang/reflect.ci:39:[.062aa4, .062ab1) exec(1), time(0.002-0.002 ms): <.main+4928>
cmplStd/test/lang/reflect.ci:40:[.062ab1, .062abe) exec(1), time(0.003-0.003 ms): <.main+4941>
cmplStd/test/lang/reflect.ci:41:[.062abe, .062aca) exec(1), time(0.022-0.022 ms): <.main+4954>
cmplStd/test/lang/reflect.ci:42:[.062aca, .062ad6) exec(1), time(0.022-0.022 ms): <.main+4966>
cmplStd/test/lang/reflect.ci:44:[.062ad6, .062ae2) exec(1), time(0.025-0.025 ms): <.main+4978>
cmplStd/test/lang/reflect.ci:45:[.062ae2, .062aef) exec(1), time(0.002-0.002 ms): <.main+4990>
cmplStd/test/lang/reflect.ci:46:[.062aef, .062afc) exec(1), time(0.002-0.002 ms): <.main+5003>
cmplStd/test/lang/reflect.ci:48:[.062afc, .062b08) exec(1), time(0.019-0.019 ms): <.main+5016>
cmplStd/test/lang/reflect.ci:49:[.062b08, .062b15) exec(1), time(0.002-0.002 ms): <.main+5028>
cmplStd/test/lang/reflect.ci:50:[.062b15, .062b22) exec(1), time(0.002-0.002 ms): <.main+5041>
cmplStd/test/lang/init.member.ci:34:[.062b22, .062b27) exec(1), time(0.001-0.001 ms): <.main+5054>
cmplStd/test/lang/init.member.ci:37:[.062b27, .062b30) exec(1), time(0.000 ms): <.main+5059>
cmplStd/test/lang/init.member.ci:40:[.062b30, .062b39) exec(1), time(0.001-0.001 ms): <.main+5068>
cmplStd/test/lang/init.member.ci:43:[.062b39, .062b42) exec(1), time(0.000 ms): <.main+5077>
::[.062b42, .062b47) exec(1), time(0.001-0.001 ms): <.main+5086>
cmplStd/test/lang/init.member.ci:43:[.062b39, .062b47) exec(0), time(0.000 ms): <.main+5077>
cmplStd/test/lang/init.member.ci:46:[.062b47, .062b50) exec(1), time(0.000 ms): <.main+5091>
cmplStd/test/lang/init.member.ci:46:[.062b50, .062b59) exec(1), time(0.001-0.001 ms): <.main+5100>
cmplStd/test/lang/init.member.ci:46:[.062b47, .062b59) exec(0), time(0.000 ms): <.main+5091>
cmplStd/test/lang/init.member.ci:49:[.062b59, .062b62) exec(1), time(0.001-0.001 ms): <.main+5109>
cmplStd/test/lang/init.member.ci:49:[.062b62, .062b6b) exec(1), time(0.001-0.001 ms): <.main+5118>
cmplStd/test/lang/init.member.ci:49:[.062b59, .062b6b) exec(0), time(0.000 ms): <.main+5109>
cmplStd/test/lang/init.member.ci:53:[.062b6b, .062b74) exec(1), time(0.001-0.001 ms): <.main+5127>
cmplStd/test/lang/init.member.ci:54:[.062b74, .062b7d) exec(1), time(0.000 ms): <.main+5136>
cmplStd/test/lang/init.member.ci:55:[.062b7d, .062b86) exec(1), time(0.001-0.001 ms): <.main+5145>
cmplStd/test/lang/init.member.ci:56:[.062b86, .062b8f) exec(1), time(0.000 ms): <.main+5154>
cmplStd/test/lang/init.member.ci:59:[.062b8f, .062b98) exec(1), time(0.001-0.001 ms): <.main+5163>
cmplStd/test/lang/init.member.ci:60:[.062b98, .062ba1) exec(1), time(0.000 ms): <.main+5172>
cmplStd/test/lang/init.member.ci:64:[.062ba1, .062baa) exec(1), time(0.001-0.001 ms): <.main+5181>
cmplStd/test/lang/init.member.ci:65:[.062baa, .062bb3) exec(1), time(0.001-0.001 ms): <.main+5190>
cmplStd/test/lang/init.member.ci:52:[.062b6b, .062bb3) exec(0), time(0.000 ms): <.main+5127>
cmplStd/test/lang/init.method.ci:18:[.062bb3, .062bbc) exec(1), time(0.001-0.001 ms): <.main+5199>
cmplStd/test/lang/init.method.ci:64:[.062bbc, .062bc5) exec(1), time(0.001-0.001 ms): <.main+5208>
::[.062bc5, .062bcd) exec(1), time(0.000 ms): <.main+5217>
::[.062bcd, .062bd6) exec(1), time(0.001-0.001 ms): <.main+5225>
cmplStd/test/lang/init.method.ci:62:[.062bbc, .062bd6) exec(0), time(0.000 ms): <.main+5208>
cmplStd/test/lang/init.array.ci:11:[.062bd6, .062be3) exec(1), time(0.001-0.001 ms): <.main+5234>
cmplStd/test/lang/init.array.ci:11:[.062be3, .062bf0) exec(1), time(0.001-0.001 ms): <.main+5247>
cmplStd/test/lang/init.array.ci:11:[.062bf0, .062bfd) exec(1), time(0.001-0.001 ms): <.main+5260>
cmplStd/test/lang/init.array.ci:11:[.062bfd, .062c0a) exec(1), time(0.000 ms): <.main+5273>
cmplStd/test/lang/init.array.ci:11:[.062c0a, .062c17) exec(1), time(0.001-0.001 ms): <.main+5286>
cmplStd/test/lang/init.array.ci:11:[.062c17, .062c24) exec(1), time(0.001-0.001 ms): <.main+5299>
cmplStd/test/lang/init.array.ci:11:[.062c24, .062c31) exec(1), time(0.001-0.001 ms): <.main+5312>
cmplStd/test/lang/init.array.ci:11:[.062bd6, .062c31) exec(0), time(0.000 ms): <.main+5234>
cmplStd/test/lang/init.array.ci:18:[.062c31, .062c3a) exec(1), time(0.001-0.001 ms): <.main+5325>
cmplStd/test/lang/init.array.ci:19:[.062c3a, .062c44) exec(1), time(0.001-0.001 ms): <.main+5334>
cmplStd/test/lang/init.array.ci:22:[.062c44, .062c4d) exec(1), time(0.001-0.001 ms): <.main+5344>
cmplStd/test/lang/init.array.ci:23:[.062c4d, .062c5b) exec(1), time(0.002-0.002 ms): <.main+5353>
cmplStd/test/lang/init.array.ci:26:[.062c5b, .062c63) exec(1), time(0.000 ms): <.main+5367>
cmplStd/test/lang/init.array.ci:27:[.062c63, .062c6b) exec(1), time(0.001-0.001 ms): <.main+5375>
cmplStd/test/lang/init.array.ci:30:[.062c6b, .062c73) exec(1), time(0.001-0.001 ms): <.main+5383>
cmplStd/test/lang/init.array.ci:34:[.062c73, .062c7e) exec(1), time(0.002-0.002 ms): <.main+5391>
cmplStd/test/lang/init.array.ci:34:[.062c7e, .062c89) exec(1), time(0.001-0.001 ms): <.main+5402>
cmplStd/test/lang/init.array.ci:34:[.062c89, .062c94) exec(1), time(0.001-0.001 ms): <.main+5413>
cmplStd/test/lang/init.array.ci:34:[.062c94, .062c9f) exec(1), time(0.002-0.002 ms): <.main+5424>
cmplStd/test/lang/init.array.ci:34:[.062c9f, .062caa) exec(1), time(0.001-0.001 ms): <.main+5435>
cmplStd/test/lang/init.array.ci:34:[.062caa, .062cb5) exec(1), time(0.001-0.001 ms): <.main+5446>
cmplStd/test/lang/init.array.ci:34:[.062cb5, .062cbc) exec(1), time(0.002-0.002 ms): <.main+5457>
cmplStd/test/lang/init.array.ci:34:[.062c73, .062cbc) exec(0), time(0.000 ms): <.main+5391>
cmplStd/test/lang/init.array.ci:37:[.062cbc, .062cc5) exec(1), time(0.001-0.001 ms): <.main+5464>
cmplStd/test/lang/init.array.ci:40:[.062cc5, .062cd3) exec(1), time(0.002-0.002 ms): <.main+5473>
cmplStd/test/lang/recUnion.ci:26:[.062cd3, .062cda) exec(1), time(0.002-0.002 ms): <.main+5487>
cmplStd/test/lang/recUnion.ci:26:[.062cda, .062ce1) exec(1), time(0.001-0.001 ms): <.main+5494>
cmplStd/test/lang/recUnion.ci:26:[.062ce1, .062ce8) exec(1), time(0.002-0.002 ms): <.main+5501>
cmplStd/test/lang/recUnion.ci:26:[.062cd3, .062ce8) exec(0), time(0.000 ms): <.main+5487>
cmplStd/test/lang/recUnion.ci:27:[.062ce8, .062cef) exec(1), time(0.002-0.002 ms): <.main+5508>
cmplStd/test/lang/recUnion.ci:27:[.062cef, .062cfa) exec(1), time(0.001-0.001 ms): <.main+5515>
cmplStd/test/lang/recUnion.ci:27:[.062cfa, .062d01) exec(1), time(0.002-0.002 ms): <.main+5526>
cmplStd/test/lang/recUnion.ci:27:[.062ce8, .062d01) exec(0), time(0.000 ms): <.main+5508>
cmplStd/test/lang/recUnion.ci:28:[.062d01, .062d0c) exec(1), time(0.002-0.002 ms): <.main+5533>
cmplStd/test/lang/recUnion.ci:28:[.062d0c, .062d17) exec(1), time(0.001-0.001 ms): <.main+5544>
cmplStd/test/lang/recUnion.ci:28:[.062d17, .062d22) exec(1), time(0.001-0.001 ms): <.main+5555>
cmplStd/test/lang/recUnion.ci:28:[.062d01, .062d22) exec(0), time(0.000 ms): <.main+5533>
cmplStd/test/lang/recUnion.ci:30:[.062d22, .062d2b) exec(1), time(0.001-0.001 ms): <.main+5566>
cmplStd/test/lang/recUnion.ci:30:[.062d22, .062d2b) exec(0), time(0.000 ms): <.main+5566>
cmplStd/test/lang/recUnion.ci:31:[.062d2b, .062d32) exec(1), time(0.001-0.001 ms): <.main+5575>
cmplStd/test/lang/recUnion.ci:31:[.062d32, .062d39) exec(1), time(0.002-0.002 ms): <.main+5582>
cmplStd/test/lang/recUnion.ci:31:[.062d39, .062d44) exec(1), time(0.002-0.002 ms): <.main+5589>
cmplStd/test/lang/recUnion.ci:31:[.062d2b, .062d44) exec(0), time(0.000 ms): <.main+5575>
cmplStd/test/lang/useOperator.ci:5:[.062d44, .062d4d) exec(1), time(0.001-0.001 ms): <.main+5600>
cmplStd/test/lang/useOperator.ci:7:[.062d4d, .062d58) exec(1), time(0.001-0.001 ms): <.main+5609>
cmplStd/test/lang/useOperator.ci:8:[.062d58, .062d63) exec(1), time(0.002-0.002 ms): <.main+5620>
cmplStd/test/lang/useOperator.ci:17:[.062d63, .062d76) exec(1), time(0.005-0.005 ms): <.main+5631>
cmplStd/test/lang/useOperator.ci:18:[.062d76, .062d89) exec(1), time(0.005-0.005 ms): <.main+5650>
cmplStd/test/lang/useOperator.ci:19:[.062d89, .062d9c) exec(1), time(0.004-0.004 ms): <.main+5669>
cmplStd/test/lang/useOperator.ci:22:[.062d9c, .062da9) exec(1), time(0.002-0.002 ms): <.main+5688>
cmplStd/test/lang/useOperator.ci:23:[.062da9, .062dbc) exec(1), time(0.004-0.004 ms): <.main+5701>
cmplStd/test/lang/useOperator.ci:24:[.062dbc, .062dd0) exec(1), time(0.005-0.005 ms): <.main+5720>
cmplStd/test/lang/useOperator.ci:25:[.062dd0, .062de3) exec(1), time(0.004-0.004 ms): <.main+5740>
cmplStd/test/lang/useOperator.ci:26:[.062de3, .062df7) exec(1), time(0.005-0.005 ms): <.main+5759>
cmplStd/test/lang/useOperator.ci:27:[.062df7, .062e0a) exec(1), time(0.004-0.004 ms): <.main+5779>
cmplStd/test/lang/useOperator.ci:28:[.062e0a, .062e1e) exec(1), time(0.005-0.005 ms): <.main+5798>
cmplStd/test/lang/useOperator.ci:30:[.062e1e, .062e29) exec(1), time(0.001-0.001 ms): <.main+5818>
cmplStd/test/lang/useOperator.ci:31:[.062e29, .062e34) exec(1), time(0.002-0.002 ms): <.main+5829>
cmplStd/test/lang/useOperator.ci:32:[.062e34, .062e40) exec(1), time(0.002-0.002 ms): <.main+5840>
cmplStd/test/lang/useOperator.ci:33:[.062e40, .062e4d) exec(1), time(0.003-0.003 ms): <.main+5852>
cmplStd/test/lang/useOperator.ci:34:[.062e4d, .062e5a) exec(1), time(0.003-0.003 ms): <.main+5865>
cmplStd/test/lang/useOperator.ci:35:[.062e5a, .062e6d) exec(1), time(0.004-0.004 ms): <.main+5878>
cmplStd/test/lang/useOperator.ci:36:[.062e6d, .062e80) exec(1), time(0.004-0.004 ms): <.main+5897>
cmplStd/test/lang/useOperator.ci:37:[.062e80, .062e93) exec(1), time(0.004-0.004 ms): <.main+5916>
cmplStd/test/lang/useOperator.ci:38:[.062e93, .062ea6) exec(1), time(0.004-0.004 ms): <.main+5935>
cmplStd/test/lang/useOperator.ci:39:[.062ea6, .062eb9) exec(1), time(0.004-0.004 ms): <.main+5954>
cmplStd/test/lang/useOperator.ci:40:[.062eb9, .062ecc) exec(1), time(0.004-0.004 ms): <.main+5973>
cmplStd/test/lang/useOperator.ci:41:[.062ecc, .062edf) exec(1), time(0.004-0.004 ms): <.main+5992>
cmplStd/test/lang/useOperator.ci:42:[.062edf, .062ef2) exec(1), time(0.004-0.004 ms): <.main+6011>
cmplStd/test/lang/useOperator.ci:43:[.062ef2, .062f03) exec(1), time(0.003-0.003 ms): <.main+6030>
cmplStd/test/lang/useOperator.ci:44:[.062f03, .062f14) exec(1), time(0.004-0.004 ms): <.main+6047>
cmplStd/test/lang/useOperator.ci:45:[.062f14, .062f22) exec(1), time(0.003-0.003 ms): <.main+6064>
cmplStd/test/lang/useOperator.ci:46:[.062f22, .062f35) exec(1), time(0.004-0.004 ms): <.main+6078>
cmplStd/test/lang/useOperator.ci:47:[.062f35, .062f49) exec(1), time(0.005-0.005 ms): <.main+6097>
cmplStd/test/lang/useOperator.ci:48:[.062f49, .062f5c) exec(1), time(0.004-0.004 ms): <.main+6117>
cmplStd/test/lang/useOperator.ci:49:[.062f5c, .062f70) exec(1), time(0.005-0.005 ms): <.main+6136>
cmplStd/test/lang/useOperator.ci:50:[.062f70, .062f83) exec(1), time(0.004-0.004 ms): <.main+6156>
cmplStd/test/lang/useOperator.ci:51:[.062f83, .062f97) exec(1), time(0.005-0.005 ms): <.main+6175>
cmplStd/test/lang/useOperator.ci:53:[.062f97, .062fa2) exec(1), time(0.002-0.002 ms): <.main+6195>
cmplStd/test/lang/useOperator.ci:54:[.062fa2, .062fad) exec(1), time(0.001-0.001 ms): <.main+6206>
cmplStd/test/lang/useOperator.ci:55:[.062fad, .062fb9) exec(1), time(0.002-0.002 ms): <.main+6217>
cmplStd/test/lang/useOperator.ci:56:[.062fb9, .062fc6) exec(1), time(0.003-0.003 ms): <.main+6229>
cmplStd/test/lang/useOperator.ci:57:[.062fc6, .062fd3) exec(1), time(0.003-0.003 ms): <.main+6242>
cmplStd/test/lang/useOperator.ci:58:[.062fd3, .062fe6) exec(1), time(0.004-0.004 ms): <.main+6255>
cmplStd/test/lang/useOperator.ci:59:[.062fe6, .062ff9) exec(1), time(0.004-0.004 ms): <.main+6274>
cmplStd/test/lang/useOperator.ci:60:[.062ff9, .06300c) exec(1), time(0.004-0.004 ms): <.main+6293>
cmplStd/test/lang/useOperator.ci:61:[.06300c, .06301f) exec(1), time(0.005-0.005 ms): <.main+6312>
cmplStd/test/lang/useOperator.ci:62:[.06301f, .063032) exec(1), time(0.005-0.005 ms): <.main+6331>
cmplStd/test/lang/useOperator.ci:63:[.063032, .063045) exec(1), time(0.004-0.004 ms): <.main+6350>
cmplStd/test/lang/useOperator.ci:64:[.063045, .063058) exec(1), time(0.004-0.004 ms): <.main+6369>
cmplStd/test/lang/useOperator.ci:65:[.063058, .06306b) exec(1), time(0.004-0.004 ms): <.main+6388>
cmplStd/test/lang/useOperator.ci:66:[.06306b, .06307c) exec(1), time(0.004-0.004 ms): <.main+6407>
cmplStd/test/lang/useOperator.ci:67:[.06307c, .06308d) exec(1), time(0.003-0.003 ms): <.main+6424>
cmplStd/test/lang/useOperator.ci:68:[.06308d, .06309b) exec(1), time(0.004-0.004 ms): <.main+6441>
cmplStd/test/lang/useOperator.ci:69:[.06309b, .0630ae) exec(1), time(0.006-0.006 ms): <.main+6455>
cmplStd/test/lang/useOperator.ci:70:[.0630ae, .0630c2) exec(1), time(0.005-0.005 ms): <.main+6474>
cmplStd/test/lang/useOperator.ci:71:[.0630c2, .0630d5) exec(1), time(0.004-0.004 ms): <.main+6494>
cmplStd/test/lang/useOperator.ci:72:[.0630d5, .0630e9) exec(1), time(0.005-0.005 ms): <.main+6513>
cmplStd/test/lang/useOperator.ci:73:[.0630e9, .0630fc) exec(1), time(0.004-0.004 ms): <.main+6533>
cmplStd/test/lang/useOperator.ci:74:[.0630fc, .063110) exec(1), time(0.005-0.005 ms): <.main+6552>
cmplStd/test/lang/useOperator.ci:76:[.063110, .06311b) exec(1), time(0.002-0.002 ms): <.main+6572>
cmplStd/test/lang/useOperator.ci:77:[.06311b, .063126) exec(1), time(0.002-0.002 ms): <.main+6583>
cmplStd/test/lang/useOperator.ci:78:[.063126, .063132) exec(1), time(0.002-0.002 ms): <.main+6594>
cmplStd/test/lang/useOperator.ci:79:[.063132, .06313f) exec(1), time(0.003-0.003 ms): <.main+6606>
cmplStd/test/lang/useOperator.ci:80:[.06313f, .06314c) exec(1), time(0.003-0.003 ms): <.main+6619>
cmplStd/test/lang/useOperator.ci:81:[.06314c, .06315f) exec(1), time(0.004-0.004 ms): <.main+6632>
cmplStd/test/lang/useOperator.ci:82:[.06315f, .063172) exec(1), time(0.005-0.005 ms): <.main+6651>
cmplStd/test/lang/useOperator.ci:83:[.063172, .063185) exec(1), time(0.004-0.004 ms): <.main+6670>
cmplStd/test/lang/useOperator.ci:84:[.063185, .063198) exec(1), time(0.004-0.004 ms): <.main+6689>
cmplStd/test/lang/useOperator.ci:85:[.063198, .0631ab) exec(1), time(0.005-0.005 ms): <.main+6708>
cmplStd/test/lang/useOperator.ci:86:[.0631ab, .0631be) exec(1), time(0.005-0.005 ms): <.main+6727>
cmplStd/test/lang/useOperator.ci:87:[.0631be, .0631d1) exec(1), time(0.004-0.004 ms): <.main+6746>
cmplStd/test/lang/useOperator.ci:88:[.0631d1, .0631e4) exec(1), time(0.004-0.004 ms): <.main+6765>
cmplStd/test/lang/useOperator.ci:89:[.0631e4, .0631f5) exec(1), time(0.004-0.004 ms): <.main+6784>
cmplStd/test/lang/useOperator.ci:90:[.0631f5, .063206) exec(1), time(0.003-0.003 ms): <.main+6801>
cmplStd/test/lang/useOperator.ci:91:[.063206, .063214) exec(1), time(0.005-0.005 ms): <.main+6818>
cmplStd/test/lang/useOperator.ci:92:[.063214, .063227) exec(1), time(0.005-0.005 ms): <.main+6832>
cmplStd/test/lang/useOperator.ci:93:[.063227, .06323b) exec(1), time(0.005-0.005 ms): <.main+6851>
cmplStd/test/lang/useOperator.ci:94:[.06323b, .06324e) exec(1), time(0.004-0.004 ms): <.main+6871>
cmplStd/test/lang/useOperator.ci:95:[.06324e, .063262) exec(1), time(0.006-0.006 ms): <.main+6890>
cmplStd/test/lang/useOperator.ci:96:[.063262, .063275) exec(1), time(0.005-0.005 ms): <.main+6910>
cmplStd/test/lang/useOperator.ci:97:[.063275, .063289) exec(1), time(0.006-0.006 ms): <.main+6929>
cmplStd/test/lang/useOperator.ci:99:[.063289, .063294) exec(1), time(0.001-0.001 ms): <.main+6949>
cmplStd/test/lang/useOperator.ci:100:[.063294, .06329f) exec(1), time(0.002-0.002 ms): <.main+6960>
cmplStd/test/lang/useOperator.ci:101:[.06329f, .0632ab) exec(1), time(0.002-0.002 ms): <.main+6971>
cmplStd/test/lang/useOperator.ci:102:[.0632ab, .0632b8) exec(1), time(0.004-0.004 ms): <.main+6983>
cmplStd/test/lang/useOperator.ci:103:[.0632b8, .0632c5) exec(1), time(0.003-0.003 ms): <.main+6996>
cmplStd/test/lang/useOperator.ci:104:[.0632c5, .0632d8) exec(1), time(0.005-0.005 ms): <.main+7009>
cmplStd/test/lang/useOperator.ci:105:[.0632d8, .0632eb) exec(1), time(0.005-0.005 ms): <.main+7028>
cmplStd/test/lang/useOperator.ci:106:[.0632eb, .0632fe) exec(1), time(0.004-0.004 ms): <.main+7047>
cmplStd/test/lang/useOperator.ci:107:[.0632fe, .063311) exec(1), time(0.005-0.005 ms): <.main+7066>
cmplStd/test/lang/useOperator.ci:108:[.063311, .063324) exec(1), time(0.005-0.005 ms): <.main+7085>
cmplStd/test/lang/useOperator.ci:109:[.063324, .063337) exec(1), time(0.005-0.005 ms): <.main+7104>
cmplStd/test/lang/useOperator.ci:110:[.063337, .06334a) exec(1), time(0.004-0.004 ms): <.main+7123>
cmplStd/test/lang/useOperator.ci:111:[.06334a, .06335d) exec(1), time(0.005-0.005 ms): <.main+7142>
cmplStd/test/lang/useOperator.ci:112:[.06335d, .06336e) exec(1), time(0.004-0.004 ms): <.main+7161>
cmplStd/test/lang/useOperator.ci:113:[.06336e, .06337f) exec(1), time(0.004-0.004 ms): <.main+7178>
cmplStd/test/lang/useOperator.ci:114:[.06337f, .06338d) exec(1), time(0.004-0.004 ms): <.main+7195>
cmplStd/test/lang/useOperator.ci:115:[.06338d, .0633a0) exec(1), time(0.005-0.005 ms): <.main+7209>
cmplStd/test/lang/useOperator.ci:116:[.0633a0, .0633b4) exec(1), time(0.005-0.005 ms): <.main+7228>
cmplStd/test/lang/useOperator.ci:117:[.0633b4, .0633c7) exec(1), time(0.006-0.006 ms): <.main+7248>
cmplStd/test/lang/useOperator.ci:118:[.0633c7, .0633db) exec(1), time(0.006-0.006 ms): <.main+7267>
cmplStd/test/lang/useOperator.ci:119:[.0633db, .0633ee) exec(1), time(0.005-0.005 ms): <.main+7287>
cmplStd/test/lang/useOperator.ci:120:[.0633ee, .063402) exec(1), time(0.006-0.006 ms): <.main+7306>
cmplStd/test/lang/useOperator.ci:122:[.063402, .06340d) exec(1), time(0.002-0.002 ms): <.main+7326>
cmplStd/test/lang/useOperator.ci:123:[.06340d, .063418) exec(1), time(0.001-0.001 ms): <.main+7337>
cmplStd/test/lang/useOperator.ci:124:[.063418, .063424) exec(1), time(0.003-0.003 ms): <.main+7348>
cmplStd/test/lang/useOperator.ci:125:[.063424, .063431) exec(1), time(0.004-0.004 ms): <.main+7360>
cmplStd/test/lang/useOperator.ci:126:[.063431, .06343e) exec(1), time(0.003-0.003 ms): <.main+7373>
cmplStd/test/lang/useOperator.ci:127:[.06343e, .063451) exec(1), time(0.004-0.004 ms): <.main+7386>
cmplStd/test/lang/useOperator.ci:128:[.063451, .063464) exec(1), time(0.005-0.005 ms): <.main+7405>
cmplStd/test/lang/useOperator.ci:129:[.063464, .063477) exec(1), time(0.005-0.005 ms): <.main+7424>
cmplStd/test/lang/useOperator.ci:130:[.063477, .06348a) exec(1), time(0.004-0.004 ms): <.main+7443>
cmplStd/test/lang/useOperator.ci:131:[.06348a, .06349d) exec(1), time(0.005-0.005 ms): <.main+7462>
cmplStd/test/lang/useOperator.ci:132:[.06349d, .0634b0) exec(1), time(0.004-0.004 ms): <.main+7481>
cmplStd/test/lang/useOperator.ci:133:[.0634b0, .0634c3) exec(1), time(0.005-0.005 ms): <.main+7500>
cmplStd/test/lang/useOperator.ci:134:[.0634c3, .0634d6) exec(1), time(0.004-0.004 ms): <.main+7519>
cmplStd/test/lang/useOperator.ci:135:[.0634d6, .0634e7) exec(1), time(0.004-0.004 ms): <.main+7538>
cmplStd/test/lang/useOperator.ci:136:[.0634e7, .0634f8) exec(1), time(0.004-0.004 ms): <.main+7555>
cmplStd/test/lang/useOperator.ci:137:[.0634f8, .063506) exec(1), time(0.004-0.004 ms): <.main+7572>
cmplStd/test/lang/useOperator.ci:138:[.063506, .063519) exec(1), time(0.004-0.004 ms): <.main+7586>
cmplStd/test/lang/useOperator.ci:139:[.063519, .06352d) exec(1), time(0.005-0.005 ms): <.main+7605>
cmplStd/test/lang/useOperator.ci:140:[.06352d, .063540) exec(1), time(0.005-0.005 ms): <.main+7625>
cmplStd/test/lang/useOperator.ci:141:[.063540, .063554) exec(1), time(0.005-0.005 ms): <.main+7644>
cmplStd/test/lang/useOperator.ci:142:[.063554, .063567) exec(1), time(0.004-0.004 ms): <.main+7664>
cmplStd/test/lang/useOperator.ci:143:[.063567, .06357b) exec(1), time(0.005-0.005 ms): <.main+7683>
cmplStd/test/lang/useOperator.ci:145:[.06357b, .063584) exec(1), time(0.001-0.001 ms): <.main+7703>
cmplStd/test/lang/useOperator.ci:146:[.063584, .06358d) exec(1), time(0.001-0.001 ms): <.main+7712>
cmplStd/test/lang/useOperator.ci:147:[.06358d, .063595) exec(1), time(0.001-0.001 ms): <.main+7721>
cmplStd/test/lang/useOperator.ci:148:[.063595, .06359e) exec(1), time(0.002-0.002 ms): <.main+7729>
cmplStd/test/lang/useOperator.ci:149:[.06359e, .0635a7) exec(1), time(0.002-0.002 ms): <.main+7738>
cmplStd/test/lang/useOperator.ci:150:[.0635a7, .0635b4) exec(1), time(0.002-0.002 ms): <.main+7747>
cmplStd/test/lang/useOperator.ci:151:[.0635b4, .0635c1) exec(1), time(0.003-0.003 ms): <.main+7760>
cmplStd/test/lang/useOperator.ci:152:[.0635c1, .0635ce) exec(1), time(0.002-0.002 ms): <.main+7773>
cmplStd/test/lang/useOperator.ci:153:[.0635ce, .0635db) exec(1), time(0.003-0.003 ms): <.main+7786>
cmplStd/test/lang/useOperator.ci:154:[.0635db, .0635e8) exec(1), time(0.002-0.002 ms): <.main+7799>
cmplStd/test/lang/useOperator.ci:155:[.0635e8, .0635f5) exec(1), time(0.003-0.003 ms): <.main+7812>
cmplStd/test/lang/useOperator.ci:156:[.0635f5, .063602) exec(1), time(0.002-0.002 ms): <.main+7825>
cmplStd/test/lang/useOperator.ci:157:[.063602, .06360f) exec(1), time(0.002-0.002 ms): <.main+7838>
cmplStd/test/lang/useOperator.ci:158:[.06360f, .06361c) exec(1), time(0.002-0.002 ms): <.main+7851>
cmplStd/test/lang/useOperator.ci:159:[.06361c, .063629) exec(1), time(0.003-0.003 ms): <.main+7864>
cmplStd/test/lang/useOperator.ci:160:[.063629, .063635) exec(1), time(0.003-0.003 ms): <.main+7877>
cmplStd/test/lang/useOperator.ci:161:[.063635, .063644) exec(1), time(0.003-0.003 ms): <.main+7889>
cmplStd/test/lang/useOperator.ci:162:[.063644, .063654) exec(1), time(0.004-0.004 ms): <.main+7904>
cmplStd/test/lang/useOperator.ci:163:[.063654, .063663) exec(1), time(0.003-0.003 ms): <.main+7920>
cmplStd/test/lang/useOperator.ci:164:[.063663, .063673) exec(1), time(0.004-0.004 ms): <.main+7935>
cmplStd/test/lang/useOperator.ci:165:[.063673, .063682) exec(1), time(0.003-0.003 ms): <.main+7951>
cmplStd/test/lang/useOperator.ci:166:[.063682, .063692) exec(1), time(0.004-0.004 ms): <.main+7966>
cmplStd/test/lang/useOperator.ci:168:[.063692, .06369b) exec(1), time(0.001-0.001 ms): <.main+7982>
cmplStd/test/lang/useOperator.ci:169:[.06369b, .0636a4) exec(1), time(0.001-0.001 ms): <.main+7991>
cmplStd/test/lang/useOperator.ci:170:[.0636a4, .0636ac) exec(1), time(0.001-0.001 ms): <.main+8000>
cmplStd/test/lang/useOperator.ci:171:[.0636ac, .0636b5) exec(1), time(0.001-0.001 ms): <.main+8008>
cmplStd/test/lang/useOperator.ci:172:[.0636b5, .0636be) exec(1), time(0.002-0.002 ms): <.main+8017>
cmplStd/test/lang/useOperator.ci:173:[.0636be, .0636cb) exec(1), time(0.002-0.002 ms): <.main+8026>
cmplStd/test/lang/useOperator.ci:174:[.0636cb, .0636d8) exec(1), time(0.003-0.003 ms): <.main+8039>
cmplStd/test/lang/useOperator.ci:175:[.0636d8, .0636e5) exec(1), time(0.002-0.002 ms): <.main+8052>
cmplStd/test/lang/useOperator.ci:176:[.0636e5, .0636f2) exec(1), time(0.003-0.003 ms): <.main+8065>
cmplStd/test/lang/useOperator.ci:177:[.0636f2, .0636ff) exec(1), time(0.002-0.002 ms): <.main+8078>
cmplStd/test/lang/useOperator.ci:178:[.0636ff, .06370c) exec(1), time(0.003-0.003 ms): <.main+8091>
cmplStd/test/lang/useOperator.ci:179:[.06370c, .063719) exec(1), time(0.002-0.002 ms): <.main+8104>
cmplStd/test/lang/useOperator.ci:180:[.063719, .063726) exec(1), time(0.003-0.003 ms): <.main+8117>
cmplStd/test/lang/useOperator.ci:181:[.063726, .063733) exec(1), time(0.002-0.002 ms): <.main+8130>
cmplStd/test/lang/useOperator.ci:182:[.063733, .063740) exec(1), time(0.003-0.003 ms): <.main+8143>
cmplStd/test/lang/useOperator.ci:183:[.063740, .06374c) exec(1), time(0.003-0.003 ms): <.main+8156>
cmplStd/test/lang/useOperator.ci:184:[.06374c, .06375b) exec(1), time(0.004-0.004 ms): <.main+8168>
cmplStd/test/lang/useOperator.ci:185:[.06375b, .06376b) exec(1), time(0.005-0.005 ms): <.main+8183>
cmplStd/test/lang/useOperator.ci:186:[.06376b, .06377a) exec(1), time(0.003-0.003 ms): <.main+8199>
cmplStd/test/lang/useOperator.ci:187:[.06377a, .06378a) exec(1), time(0.004-0.004 ms): <.main+8214>
cmplStd/test/lang/useOperator.ci:188:[.06378a, .063799) exec(1), time(0.003-0.003 ms): <.main+8230>
cmplStd/test/lang/useOperator.ci:189:[.063799, .0637a9) exec(1), time(0.004-0.004 ms): <.main+8245>
cmplStd/test/lang/useOperator.ci:191:[.0637a9, .0637b6) exec(1), time(0.001-0.001 ms): <.main+8261>
cmplStd/test/lang/useOperator.ci:192:[.0637b6, .0637c3) exec(1), time(0.001-0.001 ms): <.main+8274>
cmplStd/test/lang/useOperator.ci:193:[.0637c3, .0637cb) exec(1), time(0.001-0.001 ms): <.main+8287>
cmplStd/test/lang/useOperator.ci:194:[.0637cb, .0637d4) exec(1), time(0.002-0.002 ms): <.main+8295>
cmplStd/test/lang/useOperator.ci:195:[.0637d4, .0637dd) exec(1), time(0.001-0.001 ms): <.main+8304>
cmplStd/test/lang/useOperator.ci:196:[.0637dd, .0637ea) exec(1), time(0.003-0.003 ms): <.main+8313>
cmplStd/test/lang/useOperator.ci:197:[.0637ea, .0637f7) exec(1), time(0.003-0.003 ms): <.main+8326>
cmplStd/test/lang/useOperator.ci:198:[.0637f7, .063804) exec(1), time(0.002-0.002 ms): <.main+8339>
cmplStd/test/lang/useOperator.ci:199:[.063804, .063811) exec(1), time(0.003-0.003 ms): <.main+8352>
cmplStd/test/lang/useOperator.ci:200:[.063811, .06381e) exec(1), time(0.002-0.002 ms): <.main+8365>
cmplStd/test/lang/useOperator.ci:201:[.06381e, .06382b) exec(1), time(0.003-0.003 ms): <.main+8378>
cmplStd/test/lang/useOperator.ci:202:[.06382b, .063838) exec(1), time(0.002-0.002 ms): <.main+8391>
cmplStd/test/lang/useOperator.ci:203:[.063838, .063845) exec(1), time(0.003-0.003 ms): <.main+8404>
cmplStd/test/lang/useOperator.ci:204:[.063845, .063852) exec(1), time(0.002-0.002 ms): <.main+8417>
cmplStd/test/lang/useOperator.ci:205:[.063852, .06385f) exec(1), time(0.003-0.003 ms): <.main+8430>
cmplStd/test/lang/useOperator.ci:206:[.06385f, .06386b) exec(1), time(0.003-0.003 ms): <.main+8443>
cmplStd/test/lang/useOperator.ci:207:[.06386b, .06387a) exec(1), time(0.004-0.004 ms): <.main+8455>
cmplStd/test/lang/useOperator.ci:208:[.06387a, .06388a) exec(1), time(0.004-0.004 ms): <.main+8470>
cmplStd/test/lang/useOperator.ci:209:[.06388a, .063899) exec(1), time(0.003-0.003 ms): <.main+8486>
cmplStd/test/lang/useOperator.ci:210:[.063899, .0638a9) exec(1), time(0.004-0.004 ms): <.main+8501>
cmplStd/test/lang/useOperator.ci:211:[.0638a9, .0638b8) exec(1), time(0.004-0.004 ms): <.main+8517>
cmplStd/test/lang/useOperator.ci:212:[.0638b8, .0638c8) exec(1), time(0.004-0.004 ms): <.main+8532>
cmplStd/test/lang/useOperator.ci:214:[.0638c8, .0638d5) exec(1), time(0.001-0.001 ms): <.main+8548>
cmplStd/test/lang/useOperator.ci:215:[.0638d5, .0638e2) exec(1), time(0.001-0.001 ms): <.main+8561>
cmplStd/test/lang/useOperator.ci:216:[.0638e2, .0638ea) exec(1), time(0.001-0.001 ms): <.main+8574>
cmplStd/test/lang/useOperator.ci:217:[.0638ea, .0638f3) exec(1), time(0.001-0.001 ms): <.main+8582>
cmplStd/test/lang/useOperator.ci:218:[.0638f3, .0638fc) exec(1), time(0.002-0.002 ms): <.main+8591>
cmplStd/test/lang/useOperator.ci:219:[.0638fc, .063909) exec(1), time(0.004-0.004 ms): <.main+8600>
cmplStd/test/lang/useOperator.ci:220:[.063909, .063916) exec(1), time(0.003-0.003 ms): <.main+8613>
cmplStd/test/lang/useOperator.ci:221:[.063916, .063923) exec(1), time(0.002-0.002 ms): <.main+8626>
cmplStd/test/lang/useOperator.ci:222:[.063923, .063930) exec(1), time(0.003-0.003 ms): <.main+8639>
cmplStd/test/lang/useOperator.ci:223:[.063930, .06393d) exec(1), time(0.003-0.003 ms): <.main+8652>
cmplStd/test/lang/useOperator.ci:224:[.06393d, .06394a) exec(1), time(0.002-0.002 ms): <.main+8665>
cmplStd/test/lang/useOperator.ci:225:[.06394a, .063957) exec(1), time(0.003-0.003 ms): <.main+8678>
cmplStd/test/lang/useOperator.ci:226:[.063957, .063964) exec(1), time(0.003-0.003 ms): <.main+8691>
cmplStd/test/lang/useOperator.ci:227:[.063964, .063971) exec(1), time(0.002-0.002 ms): <.main+8704>
cmplStd/test/lang/useOperator.ci:228:[.063971, .06397e) exec(1), time(0.003-0.003 ms): <.main+8717>
cmplStd/test/lang/useOperator.ci:229:[.06397e, .06398a) exec(1), time(0.003-0.003 ms): <.main+8730>
cmplStd/test/lang/useOperator.ci:230:[.06398a, .063999) exec(1), time(0.004-0.004 ms): <.main+8742>
cmplStd/test/lang/useOperator.ci:231:[.063999, .0639a9) exec(1), time(0.004-0.004 ms): <.main+8757>
cmplStd/test/lang/useOperator.ci:232:[.0639a9, .0639b8) exec(1), time(0.004-0.004 ms): <.main+8773>
cmplStd/test/lang/useOperator.ci:233:[.0639b8, .0639c8) exec(1), time(0.004-0.004 ms): <.main+8788>
cmplStd/test/lang/useOperator.ci:234:[.0639c8, .0639d7) exec(1), time(0.003-0.003 ms): <.main+8804>
cmplStd/test/lang/useOperator.ci:235:[.0639d7, .0639e7) exec(1), time(0.005-0.005 ms): <.main+8819>
cmplStd/test/lang/useOperator.ci:237:[.0639e7, .0639f0) exec(1), time(0.002-0.002 ms): <.main+8835>
cmplStd/test/lang/useOperator.ci:238:[.0639f0, .0639f9) exec(1), time(0.001-0.001 ms): <.main+8844>
cmplStd/test/lang/useOperator.ci:239:[.0639f9, .063a01) exec(1), time(0.001-0.001 ms): <.main+8853>
cmplStd/test/lang/useOperator.ci:240:[.063a01, .063a0a) exec(1), time(0.002-0.002 ms): <.main+8861>
cmplStd/test/lang/useOperator.ci:242:[.063a0a, .063a17) exec(1), time(0.003-0.003 ms): <.main+8870>
cmplStd/test/lang/useOperator.ci:243:[.063a17, .063a24) exec(1), time(0.002-0.002 ms): <.main+8883>
cmplStd/test/lang/useOperator.ci:244:[.063a24, .063a31) exec(1), time(0.003-0.003 ms): <.main+8896>
cmplStd/test/lang/useOperator.ci:245:[.063a31, .063a3e) exec(1), time(0.003-0.003 ms): <.main+8909>
cmplStd/test/lang/useOperator.ci:246:[.063a3e, .063a4b) exec(1), time(0.003-0.003 ms): <.main+8922>
cmplStd/test/lang/useOperator.ci:252:[.063a4b, .063a57) exec(1), time(0.005-0.005 ms): <.main+8935>
cmplStd/test/lang/useOperator.ci:253:[.063a57, .063a66) exec(1), time(0.004-0.004 ms): <.main+8947>
cmplStd/test/lang/useOperator.ci:254:[.063a66, .063a76) exec(1), time(0.004-0.004 ms): <.main+8962>
cmplStd/test/lang/useOperator.ci:255:[.063a76, .063a85) exec(1), time(0.004-0.004 ms): <.main+8978>
cmplStd/test/lang/useOperator.ci:256:[.063a85, .063a95) exec(1), time(0.004-0.004 ms): <.main+8993>
cmplStd/test/lang/useOperator.ci:257:[.063a95, .063aa4) exec(1), time(0.003-0.003 ms): <.main+9009>
cmplStd/test/lang/useOperator.ci:258:[.063aa4, .063ab4) exec(1), time(0.005-0.005 ms): <.main+9024>
cmplStd/test/lang/useOperator.ci:260:[.063ab4, .063ac1) exec(1), time(0.002-0.002 ms): <.main+9040>
cmplStd/test/lang/useOperator.ci:261:[.063ac1, .063ace) exec(1), time(0.001-0.001 ms): <.main+9053>
cmplStd/test/lang/useOperator.ci:262:[.063ace, .063ad6) exec(1), time(0.000 ms): <.main+9066>
cmplStd/test/lang/useOperator.ci:263:[.063ad6, .063adf) exec(1), time(0.003-0.003 ms): <.main+9074>
cmplStd/test/lang/useOperator.ci:265:[.063adf, .063aec) exec(1), time(0.003-0.003 ms): <.main+9083>
cmplStd/test/lang/useOperator.ci:266:[.063aec, .063af9) exec(1), time(0.003-0.003 ms): <.main+9096>
cmplStd/test/lang/useOperator.ci:267:[.063af9, .063b06) exec(1), time(0.003-0.003 ms): <.main+9109>
cmplStd/test/lang/useOperator.ci:268:[.063b06, .063b13) exec(1), time(0.003-0.003 ms): <.main+9122>
cmplStd/test/lang/useOperator.ci:269:[.063b13, .063b20) exec(1), time(0.003-0.003 ms): <.main+9135>
cmplStd/test/lang/useOperator.ci:275:[.063b20, .063b2c) exec(1), time(0.004-0.004 ms): <.main+9148>
cmplStd/test/lang/useOperator.ci:276:[.063b2c, .063b3b) exec(1), time(0.004-0.004 ms): <.main+9160>
cmplStd/test/lang/useOperator.ci:277:[.063b3b, .063b4b) exec(1), time(0.005-0.005 ms): <.main+9175>
cmplStd/test/lang/useOperator.ci:278:[.063b4b, .063b5a) exec(1), time(0.004-0.004 ms): <.main+9191>
cmplStd/test/lang/useOperator.ci:279:[.063b5a, .063b6a) exec(1), time(0.004-0.004 ms): <.main+9206>
cmplStd/test/lang/useOperator.ci:280:[.063b6a, .063b79) exec(1), time(0.004-0.004 ms): <.main+9222>
cmplStd/test/lang/useOperator.ci:281:[.063b79, .063b89) exec(1), time(0.004-0.004 ms): <.main+9237>
cmplStd/test/lang/useOperator.ci:283:[.063b89, .063b92) exec(1), time(0.002-0.002 ms): <.main+9253>
cmplStd/test/lang/useOperator.ci:284:[.063b92, .063b9b) exec(1), time(0.001-0.001 ms): <.main+9262>
cmplStd/test/lang/useOperator.ci:299:[.063b9b, .063baa) exec(1), time(0.003-0.003 ms): <.main+9271>
cmplStd/test/lang/useOperator.ci:300:[.063baa, .063bba) exec(1), time(0.005-0.005 ms): <.main+9286>
cmplStd/test/lang/stmt.if.ci:26:[.063bba, .063bbf) exec(1), time(0.001-0.001 ms): <.main+9302>
cmplStd/test/lang/stmt.for.ci:12:[.063bbf, .063bc4) exec(1), time(0.001-0.001 ms): <.main+9307>
cmplStd/test/std/test.math.ci:3:[.063bc4, .063bdc) exec(1), time(0.027-0.027 ms): <.main+9312>
cmplStd/test/std/test.math.ci:4:[.063bdc, .063bf4) exec(1), time(0.022-0.022 ms): <.main+9336>
cmplStd/test/std/test.math.ci:5:[.063bf4, .063c0c) exec(1), time(0.024-0.024 ms): <.main+9360>
cmplStd/test/std/test.math.ci:6:[.063c0c, .063c24) exec(1), time(0.035-0.035 ms): <.main+9384>
cmplStd/test/std/test.math.ci:7:[.063c24, .063c3c) exec(1), time(0.030-0.030 ms): <.main+9408>
cmplStd/test/std/test.math.ci:8:[.063c3c, .063c54) exec(1), time(0.030-0.030 ms): <.main+9432>
cmplStd/test/std/test.math.ci:10:[.063c54, .063c71) exec(1), time(0.010-0.010 ms): <.main+9456>
cmplStd/test/std/test.math.ci:11:[.063c71, .063c86) exec(1), time(0.010-0.010 ms): <.main+9485>
cmplStd/test/std/test.math.ci:12:[.063c86, .063ca3) exec(1), time(0.010-0.010 ms): <.main+9506>
cmplStd/test/std/test.math.ci:13:[.063ca3, .063cb8) exec(1), time(0.011-0.011 ms): <.main+9535>
cmplStd/test/std/test.math.ci:14:[.063cb8, .063cc9) exec(1), time(0.010-0.010 ms): <.main+9556>
cmplStd/test/std/test.math.ci:15:[.063cc9, .063cde) exec(1), time(0.009-0.009 ms): <.main+9573>
cmplStd/test/std/test.math.ci:17:[.063cde, .063cf6) exec(1), time(0.015-0.015 ms): <.main+9594>
cmplStd/test/std/test.math.ci:18:[.063cf6, .063d05) exec(1), time(0.014-0.014 ms): <.main+9618>
cmplStd/test/std/test.math.ci:19:[.063d05, .063d1d) exec(1), time(0.014-0.014 ms): <.main+9633>
cmplStd/test/std/test.math.ci:20:[.063d1d, .063d32) exec(1), time(0.017-0.017 ms): <.main+9657>
cmplStd/test/std/test.math.ci:21:[.063d32, .063d43) exec(1), time(0.017-0.017 ms): <.main+9678>
cmplStd/test/std/test.math.ci:22:[.063d43, .063d58) exec(1), time(0.017-0.017 ms): <.main+9695>
cmplStd/test/std/test.math.ci:24:[.063d58, .063d72) exec(1), time(0.016-0.016 ms): <.main+9716>
cmplStd/test/std/test.math.ci:25:[.063d72, .063d8c) exec(1), time(0.017-0.017 ms): <.main+9742>
cmplStd/test/std/test.math.ci:26:[.063d8c, .063dad) exec(1), time(0.015-0.015 ms): <.main+9768>
cmplStd/test/std/test.math.ci:27:[.063dad, .063dce) exec(1), time(0.015-0.015 ms): <.main+9801>
cmplStd/test/std/test.math.ci:29:[.063dce, .063de9) exec(1), time(0.017-0.017 ms): <.main+9834>
cmplStd/test/std/test.math.ci:30:[.063de9, .063e0b) exec(1), time(0.016-0.016 ms): <.main+9861>
cmplStd/test/std/test.math.ci:32:[.063e0b, .063e24) exec(1), time(0.009-0.009 ms): <.main+9895>
cmplStd/test/std/test.math.ci:33:[.063e24, .063e44) exec(1), time(0.008-0.008 ms): <.main+9920>
cmplStd/test/std/test.math.ci:35:[.063e44, .063e84) exec(1), time(0.033-0.033 ms): <.main+9952>
cmplStd/test/std/test.math.ci:36:[.063e84, .063ed6) exec(1), time(0.034-0.034 ms): <.main+10016>
cmplStd/test/std/test.math.ci:38:[.063ed6, .063eef) exec(1), time(0.021-0.021 ms): <.main+10098>
cmplStd/test/std/test.math.ci:39:[.063eef, .063f5d) exec(1), time(0.046-0.046 ms): <.main+10123>
cmplStd/test/std/test.math.ci:40:[.063f5d, .063f76) exec(1), time(0.019-0.019 ms): <.main+10233>
cmplStd/test/std/test.math.ci:41:[.063f76, .063fe4) exec(1), time(0.042-0.042 ms): <.main+10258>
cmplStd/test/std/test.math.ci:43:[.063fe4, .063ffd) exec(1), time(0.019-0.019 ms): <.main+10368>
cmplStd/test/std/test.math.ci:44:[.063ffd, .064023) exec(1), time(0.021-0.021 ms): <.main+10393>
cmplStd/test/std/test.math.ci:45:[.064023, .064052) exec(1), time(0.025-0.025 ms): <.main+10431>
cmplStd/test/std/test.math.ci:46:[.064052, .0640c9) exec(1), time(0.044-0.044 ms): <.main+10478>
cmplStd/test/std/test.math.ci:48:[.0640c9, .0640d6) exec(1), time(0.001-0.001 ms): <.main+10597>
cmplStd/test/std/test.math.ci:49:[.0640d6, .0640f3) exec(1), time(0.020-0.020 ms): <.main+10610>
cmplStd/test/std/test.math.ci:50:[.0640f3, .064100) exec(1), time(0.001-0.001 ms): <.main+10639>
cmplStd/test/std/test.math.ci:51:[.064100, .06411c) exec(1), time(0.005-0.005 ms): <.main+10652>
cmplStd/test/std/test.math.ci:52:[.06411c, .064149) exec(1), time(0.009-0.009 ms): <.main+10680>
cmplStd/test/std/test.math.ci:53:[.064149, .064187) exec(1), time(0.015-0.015 ms): <.main+10725>
cmplStd/test/std/test.math.ci:54:[.064187, .0641d5) exec(1), time(0.036-0.036 ms): <.main+10787>
cmplStd/test/std/test.math.ci:55:[.0641d5, .06422c) exec(1), time(0.041-0.041 ms): <.main+10865>
cmplStd/test/std/test.math.ci:57:[.06422c, .06424f) exec(1), time(0.034-0.034 ms): <.main+10952>
cmplStd/test/std/test.math.ci:58:[.06424f, .064280) exec(1), time(0.043-0.043 ms): <.main+10987>
cmplStd/test/std/test.math.ci:59:[.064280, .0642a2) exec(1), time(0.040-0.040 ms): <.main+11036>
cmplStd/test/std/test.math.ci:60:[.0642a2, .0642c4) exec(1), time(0.053-0.053 ms): <.main+11070>
cmplStd/test/std/test.math.ci:61:[.0642c4, .0642e6) exec(1), time(0.052-0.052 ms): <.main+11104>
cmplStd/test/std/test.math.ci:63:[.0642e6, .0642fe) exec(1), time(0.056-0.056 ms): <.main+11138>
cmplStd/test/std/test.math.ci:64:[.0642fe, .06432a) exec(1), time(0.053-0.053 ms): <.main+11162>
cmplStd/test/std/test.math.ci:67:[.06432a, .06434c) exec(1), time(0.020-0.020 ms): <.main+11206>
cmplStd/test/std/test.math.ci:68:[.06434c, .06437a) exec(1), time(0.020-0.020 ms): <.main+11240>
cmplStd/test/std/test.math.ci:70:[.06437a, .06439b) exec(1), time(0.016-0.016 ms): <.main+11286>
cmplStd/test/std/test.math.ci:71:[.06439b, .0643b3) exec(1), time(0.014-0.014 ms): <.main+11319>
cmplStd/test/std/test.math.ci:72:[.0643b3, .0643d4) exec(1), time(0.015-0.015 ms): <.main+11343>
cmplStd/test/std/test.math.ci:74:[.0643d4, .0643f5) exec(1), time(0.017-0.017 ms): <.main+11376>
cmplStd/test/std/test.math.ci:75:[.0643f5, .064416) exec(1), time(0.018-0.018 ms): <.main+11409>
cmplStd/test/std/test.math.ci:76:[.064416, .064437) exec(1), time(0.017-0.017 ms): <.main+11442>
cmplStd/test/std/test.math.ci:77:[.064437, .064458) exec(1), time(0.018-0.018 ms): <.main+11475>
cmplStd/test/std/test.math.ci:79:[.064458, .064479) exec(1), time(0.017-0.017 ms): <.main+11508>
cmplStd/test/std/test.math.ci:80:[.064479, .06449a) exec(1), time(0.016-0.016 ms): <.main+11541>
cmplStd/test/std/test.math.ci:81:[.06449a, .0644bb) exec(1), time(0.017-0.017 ms): <.main+11574>
cmplStd/test/std/test.math.ci:82:[.0644bb, .0644dc) exec(1), time(0.018-0.018 ms): <.main+11607>
cmplStd/test/std/test.math.ci:84:[.0644dc, .0644f5) exec(1), time(0.016-0.016 ms): <.main+11640>
cmplStd/test/std/test.math.ci:85:[.0644f5, .06450a) exec(1), time(0.017-0.017 ms): <.main+11665>
cmplStd/test/std/test.math.ci:86:[.06450a, .064523) exec(1), time(0.015-0.015 ms): <.main+11686>
cmplStd/test/std/test.math.ci:88:[.064523, .06453c) exec(1), time(0.018-0.018 ms): <.main+11711>
cmplStd/test/std/test.math.ci:89:[.06453c, .064555) exec(1), time(0.015-0.015 ms): <.main+11736>
cmplStd/test/std/test.math.ci:90:[.064555, .06456e) exec(1), time(0.015-0.015 ms): <.main+11761>
cmplStd/test/std/test.math.ci:91:[.06456e, .064587) exec(1), time(0.014-0.014 ms): <.main+11786>
cmplStd/test/std/test.math.ci:93:[.064587, .0645a0) exec(1), time(0.015-0.015 ms): <.main+11811>
cmplStd/test/std/test.math.ci:94:[.0645a0, .0645b9) exec(1), time(0.015-0.015 ms): <.main+11836>
cmplStd/test/std/test.math.ci:95:[.0645b9, .0645d2) exec(1), time(0.015-0.015 ms): <.main+11861>
cmplStd/test/std/test.math.ci:96:[.0645d2, .0645eb) exec(1), time(0.014-0.014 ms): <.main+11886>
cmplStd/test/std/memory.ci:13:[.0645eb, .0645fd) exec(1), time(0.022-0.022 ms): <.main+11911>
cmplStd/test/std/memory.ci:14:[.0645fd, .064612) exec(1), time(0.021-0.021 ms): <.main+11929>
cmplStd/test/std/memory.ci:17:[.064612, .06461f) exec(1), time(0.022-0.022 ms): <.main+11950>
cmplStd/test/std/memory.ci:18:[.06461f, .06462c) exec(1), time(0.022-0.022 ms): <.main+11963>
cmplStd/test/std/memory.ci:19:[.06462c, .064639) exec(1), time(0.020-0.020 ms): <.main+11976>
cmplStd/test/std/memory.ci:20:[.064639, .064646) exec(1), time(0.019-0.019 ms): <.main+11989>
cmplStd/test/std/memory.ci:26:[.064646, .064669) exec(1), time(0.031-0.031 ms): <.main+12002>
cmplStd/test/std/memory.ci:27:[.064669, .06468c) exec(1), time(0.024-0.024 ms): <.main+12037>
cmplStd/test/std/memory.ci:29:[.06468c, .0646a2) exec(1), time(0.022-0.022 ms): <.main+12072>
cmplStd/test/std/memory.ci:30:[.0646a2, .0646b4) exec(1), time(0.023-0.023 ms): <.main+12094>
cmplStd/test/std/memory.ci:32:[.0646b4, .0646d7) exec(1), time(0.028-0.028 ms): <.main+12112>
cmplStd/test/std/memory.ci:33:[.0646d7, .0646fa) exec(1), time(0.024-0.024 ms): <.main+12147>
cmplStd/test/lang/init.method.ci:78:[.0646fa, .06470f) exec(1), time(0.098-0.098 ms): <.main+12182>
cmplStd/test/lang/init.method.ci:79:[.06470f, .064723) exec(1), time(0.096-0.096 ms): <.main+12203>
cmplStd/test/lang/init.method.ci:97:[.064723, .064736) exec(1), time(0.140-0.140 ms): <.main+12223>
cmplStd/test/lang/init.method.ci:98:[.064736, .064749) exec(1), time(0.134-0.134 ms): <.main+12242>
cmplStd/test/lang/init.method.ci:101:[.064749, .06475e) exec(1), time(0.091-0.091 ms): <.main+12261>
cmplStd/test/lang/init.method.ci:102:[.06475e, .064773) exec(1), time(0.090-0.090 ms): <.main+12282>
cmplStd/test/lang/init.method.ci:103:[.064773, .064787) exec(1), time(0.101-0.101 ms): <.main+12303>
cmplStd/test/lang/init.array.ci:35:[.064787, .0647aa) exec(1), time(0.055-0.055 ms): <.main+12323>
cmplStd/test/lang/init.array.ci:38:[.0647aa, .0647cc) exec(1), time(0.028-0.028 ms): <.main+12358>
cmplStd/test/lang/init.array.ci:41:[.0647cc, .0647ee) exec(1), time(0.025-0.025 ms): <.main+12392>
cmplStd/test/lang/init.array.ci:48:[.0647ee, .064823) exec(1), time(0.004-0.004 ms): <.main+12426>
cmplStd/test/lang/init.array.ci:49:[.064823, .064860) exec(1), time(0.004-0.004 ms): <.main+12479>
cmplStd/test/lang/init.array.ci:56:[.064860, .064879) exec(1), time(0.015-0.015 ms): <.main+12540>
cmplStd/test/lang/init.array.ci:57:[.064879, .064891) exec(1), time(0.015-0.015 ms): <.main+12565>
cmplStd/test/lang/init.array.ci:58:[.064891, .0648a9) exec(1), time(0.015-0.015 ms): <.main+12589>
cmplStd/test/lang/init.array.ci:60:[.0648a9, .0648c9) exec(1), time(0.034-0.034 ms): <.main+12613>
cmplStd/test/lang/init.array.ci:61:[.0648c9, .0648e8) exec(1), time(0.034-0.034 ms): <.main+12645>
cmplStd/test/lang/init.array.ci:62:[.0648e8, .064911) exec(1), time(0.036-0.036 ms): <.main+12676>
cmplStd/test/lang/init.array.ci:63:[.064911, .064934) exec(1), time(0.036-0.036 ms): <.main+12717>
cmplStd/test/lang/init.array.ci:64:[.064934, .064957) exec(1), time(0.034-0.034 ms): <.main+12752>
cmplStd/test/lang/init.array.ci:67:[.06495c, .064965) exec(7), time(0.022-0.022 ms): <.main+12792>
cmplStd/test/lang/init.array.ci:68:[.064965, .0649a3) exec(7), time(0.050-0.050 ms): <.main+12801>
cmplStd/test/lang/init.array.ci:69:[.0649a3, .0649e0) exec(7), time(0.048-0.048 ms): <.main+12863>
cmplStd/test/lang/init.array.ci:70:[.0649e0, .064a1d) exec(7), time(0.053-0.053 ms): <.main+12924>
cmplStd/test/lang/init.array.ci:72:[.064a1d, .064a61) exec(7), time(0.195-0.195 ms): <.main+12985>
cmplStd/test/lang/init.array.ci:73:[.064a61, .064aa4) exec(7), time(0.185-0.185 ms): <.main+13053>
cmplStd/test/lang/init.array.ci:74:[.064aa4, .064ae7) exec(7), time(0.191-0.191 ms): <.main+13120>
cmplStd/test/lang/init.array.ci:76:[.064ae7, .064b2b) exec(7), time(0.184-0.184 ms): <.main+13187>
cmplStd/test/lang/init.array.ci:77:[.064b2b, .064b6e) exec(7), time(0.184-0.184 ms): <.main+13255>
cmplStd/test/lang/init.array.ci:78:[.064b6e, .064bb1) exec(7), time(0.193-0.193 ms): <.main+13322>
cmplStd/test/lang/init.array.ci:80:[.064bb1, .064bfa) exec(7), time(0.189-0.189 ms): <.main+13389>
cmplStd/test/lang/init.array.ci:82:[.064bfa, .064c3d) exec(7), time(0.197-0.197 ms): <.main+13462>
cmplStd/test/lang/init.array.ci:84:[.064c3d, .064c7a) exec(7), time(0.049-0.049 ms): <.main+13529>
cmplStd/test/lang/init.array.ci:66:[.064c7e, .064c82) exec(7), time(0.001-0.001 ms): <.main+13594>
cmplStd/test/lang/init.array.ci:66:[.064c82, .064c8e) exec(8), time(0.025-0.025 ms): <.main+13598>
cmplStd/test/lang/init.array.ci:66:[.064957, .064c92) exec(1), time(0.004-0.004 ms): <.main+12787>
cmplStd/test/lang/stmt.if.ci:4:[.064c92, .064cb9) exec(1), time(0.024-0.024 ms): <.main+13614>
cmplStd/test/lang/stmt.if.ci:12:[.064cb9, .064ce0) exec(1), time(0.024-0.024 ms): <.main+13653>
cmplStd/test/lang/stmt.if.ci:22:[.064ce0, .064d07) exec(1), time(0.025-0.025 ms): <.main+13692>
cmplStd/test/lang/stmt.if.ci:29:[.064d11, .064d38) exec(1), time(0.028-0.028 ms): <.main+13741>
cmplStd/test/lang/stmt.if.ci:28:[.064d07, .064d38) exec(1-1), time(0.000 ms): <.main+13731>
cmplStd/test/lang/stmt.if.ci:33:[.064d42, .064d69) exec(0), time(0.000 ms): <.main+13790>
cmplStd/test/lang/stmt.if.ci:32:[.064d38, .064d69) exec(1), time(0.003-0.003 ms): <.main+13780>
cmplStd/test/lang/stmt.if.ci:37:[.064d73, .064d9a) exec(1), time(0.027-0.027 ms): <.main+13839>
cmplStd/test/lang/stmt.if.ci:40:[.064d9e, .064dc5) exec(0), time(0.000 ms): <.main+13882>
cmplStd/test/lang/stmt.if.ci:36:[.064d69, .064dc5) exec(1), time(0.029-0.029 ms): <.main+13829>
cmplStd/test/lang/stmt.if.ci:44:[.064dcf, .064df6) exec(0), time(0.000 ms): <.main+13931>
cmplStd/test/lang/stmt.if.ci:47:[.064dfa, .064e21) exec(1), time(0.027-0.027 ms): <.main+13974>
cmplStd/test/lang/stmt.if.ci:43:[.064dc5, .064e21) exec(1-1), time(0.000 ms): <.main+13921>
cmplStd/test/lang/stmt.if.ci:51:[.064e2b, .064e52) exec(1), time(0.027-0.027 ms): <.main+14023>
cmplStd/test/lang/stmt.if.ci:54:[.064e64, .064e8b) exec(0), time(0.000 ms): <.main+14080>
cmplStd/test/lang/stmt.if.ci:57:[.064e9d, .064ec4) exec(0), time(0.000 ms): <.main+14137>
cmplStd/test/lang/stmt.if.ci:60:[.064ed6, .064efd) exec(0), time(0.000 ms): <.main+14194>
cmplStd/test/lang/stmt.if.ci:63:[.064f0f, .064f36) exec(0), time(0.000 ms): <.main+14251>
cmplStd/test/lang/stmt.if.ci:66:[.064f48, .064f6f) exec(0), time(0.000 ms): <.main+14308>
cmplStd/test/lang/stmt.if.ci:69:[.064f73, .064f9a) exec(0), time(0.000 ms): <.main+14351>
cmplStd/test/lang/stmt.if.ci:65:[.064f3a, .064f9a) exec(0), time(0.000 ms): <.main+14294>
cmplStd/test/lang/stmt.if.ci:62:[.064f01, .064f9a) exec(0), time(0.000 ms): <.main+14237>
cmplStd/test/lang/stmt.if.ci:59:[.064ec8, .064f9a) exec(0), time(0.000 ms): <.main+14180>
cmplStd/test/lang/stmt.if.ci:56:[.064e8f, .064f9a) exec(0), time(0.000 ms): <.main+14123>
cmplStd/test/lang/stmt.if.ci:53:[.064e56, .064f9a) exec(0), time(0.000 ms): <.main+14066>
cmplStd/test/lang/stmt.if.ci:50:[.064e21, .064f9a) exec(1), time(0.029-0.029 ms): <.main+14013>
cmplStd/test/lang/stmt.for.ci:4:[.064f9e, .064fc1) exec(1), time(0.021-0.021 ms): <.main+14394>
cmplStd/test/lang/stmt.for.ci:5:[.064fc1, .064fc5) exec(1), time(0.000 ms): <.main+14429>
::[.064fc5, .064fc9) exec(1), time(0.000 ms): <.main+14433>
cmplStd/test/lang/stmt.for.ci:3:[.064f9a, .064fc9) exec(1-1), time(0.000 ms): <.main+14390>
cmplStd/test/lang/stmt.for.ci:9:[.064fce, .064ff0) exec(2), time(0.051-0.051 ms): <.main+14442>
cmplStd/test/lang/stmt.for.ci:8:[.064ff0, .064ff4) exec(2), time(0.002-0.002 ms): <.main+14476>
cmplStd/test/lang/stmt.for.ci:8:[.064ff4, .065000) exec(3), time(0.010-0.010 ms): <.main+14480>
cmplStd/test/lang/stmt.for.ci:8:[.064fc9, .065004) exec(1), time(0.006-0.006 ms): <.main+14437>
cmplStd/test/lang/stmt.for.ci:14:[.06500d, .065030) exec(2), time(0.049-0.049 ms): <.main+14505>
cmplStd/test/lang/stmt.for.ci:13:[.065030, .06503c) exec(2), time(0.005-0.005 ms): <.main+14540>
cmplStd/test/lang/stmt.for.ci:13:[.06503c, .06504a) exec(3), time(0.012-0.012 ms): <.main+14552>
cmplStd/test/lang/stmt.for.ci:13:[.065004, .06504a) exec(1-1), time(0.000 ms): <.main+14496>
cmplStd/test/lang/stmt.for.ci:19:[.06505b, .06505f) exec(2), time(0.001-0.001 ms): <.main+14583>
cmplStd/test/lang/stmt.for.ci:18:[.06504f, .06505f) exec(7-2), time(0.016-0.016 ms): <.main+14571>
cmplStd/test/lang/stmt.for.ci:21:[.06505f, .065081) exec(5), time(0.127-0.127 ms): <.main+14587>
cmplStd/test/lang/stmt.for.ci:17:[.065081, .065085) exec(7), time(0.003-0.003 ms): <.main+14621>
cmplStd/test/lang/stmt.for.ci:17:[.065085, .065091) exec(8), time(0.025-0.025 ms): <.main+14625>
cmplStd/test/lang/stmt.for.ci:17:[.06504a, .065095) exec(1), time(0.004-0.004 ms): <.main+14566>
cmplStd/test/lang/stmt.for.ci:26:[.0650a6, .0650aa) exec(1), time(0.000 ms): <.main+14658>
cmplStd/test/lang/stmt.for.ci:25:[.06509a, .0650aa) exec(4-1), time(0.009-0.009 ms): <.main+14646>
cmplStd/test/lang/stmt.for.ci:28:[.0650aa, .0650cc) exec(3), time(0.077-0.077 ms): <.main+14662>
cmplStd/test/lang/stmt.for.ci:24:[.0650cc, .0650d0) exec(3), time(0.001-0.001 ms): <.main+14696>
cmplStd/test/lang/stmt.for.ci:24:[.0650d0, .0650dc) exec(4), time(0.013-0.013 ms): <.main+14700>
cmplStd/test/lang/stmt.for.ci:24:[.065095, .0650e0) exec(1), time(0.001-0.001 ms): <.main+14641>

---------- Exitcode: 0, time: 23.602 ms
