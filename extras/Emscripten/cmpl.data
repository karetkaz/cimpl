// standard library extension

static if (typename(raise) == function) {

inline verbose(char message[*], variant inspect) = raise(raise.verbose, raise.noTrace, message, inspect);
inline verbose(char message[*]) = raise(raise.verbose, raise.noTrace, message, null);

inline trace(char message[*], variant inspect) = raise(raise.debug, raise.defTrace, message, inspect);
inline trace(char message[*]) = raise(raise.debug, raise.defTrace, message, null);

inline debug(char message[*], variant inspect) = raise(raise.debug, raise.noTrace, message, inspect);
inline debug(char message[*]) = raise(raise.debug, raise.noTrace, message, null);

inline info(char message[*], variant inspect) = raise(raise.info, raise.noTrace, message, inspect);
inline info(char message[*]) = raise(raise.info, raise.noTrace, message, null);

inline warn(char message[*], variant inspect) = raise(raise.warn, raise.noTrace, message, inspect);
inline warn(char message[*]) = raise(raise.warn, raise.noTrace, message, null);

inline error(char message[*], variant inspect) = raise(raise.error, raise.defTrace, message, inspect);
inline error(char message[*]) = raise(raise.error, raise.defTrace, message, null);

inline abort(char message[*], variant inspect) = raise(raise.abort, raise.defTrace, message, inspect);
inline abort(char message[*]) = raise(raise.abort, raise.defTrace, message, null);
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!", null);

inline assert(bool condition, char message[*], variant inspect) = void(condition ? void(0) : abort(message, inspect));
inline assert(bool condition, char message[*]) = void(condition ? void(0) : abort(message));
inline assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

}

inline sizeof(typename type) = int(type.size);
// test builtin native functions

double pi64 = 3.14159265358979323846264338327950288419716939937510582097494459;
double e64 = 2.71828182845904523536028747135266249775724709369995957496696763;

float pi32 = pi64;
float e32 = e64;

/// pack 8 bit color components (0 .. 255) to R8G8B8 color format
inline rgb888(int r, int g, int b) = r << 16 & 0xff0000 | g << 8 & 0x00ff00 | b & 0x0000ff;
/// pack 8 bit color components (0 .. 255) to R5G6B5 color format
inline rgb565(int r, int g, int b) = r << 8 & 0xf800 | g << 3 & 0x07e0 | b >> 3 & 0x001f;

int r_comp = 14 << 3;
int g_comp = 63 << 2;
int b_comp = 31 << 3;

int32 r5g6b5 = rgb565(r_comp, g_comp, b_comp);
int32 r8g8b8 = rgb888(r_comp, g_comp, b_comp);

int32 zxtR5 = uint32.zxt(r5g6b5, 11, 5);
int32 zxtG6 = uint32.zxt(r5g6b5, 5, 6);
int32 zxtB5 = uint32.zxt(r5g6b5, 0, 5);

int32 sxtR5 = uint32.sxt(r5g6b5, 11, 5);
int32 sxtG6 = uint32.sxt(r5g6b5, 5, 6);
int32 sxtB5 = uint32.sxt(r5g6b5, 0, 5);

int32 zxtR8 = uint32.zxt(r8g8b8, 16, 8);
int32 zxtG8 = uint32.zxt(r8g8b8, 8, 8);
int32 zxtB8 = uint32.zxt(r8g8b8, 0, 8);

int32 sxtR8 = uint32.sxt(r8g8b8, 16, 8);
int32 sxtG8 = uint32.sxt(r8g8b8, 8, 8);
int32 sxtB8 = uint32.sxt(r8g8b8, 0, 8);

float64 sinF64 = float64.sin(pi64 / 2);
float64 cosF64 = float64.cos(pi64 / 2);
float64 tanF64 = float64.tan(pi64 / 4);
float64 logF64 = float64.log(e64 * e64 * e64);
float64 expF64 = float64.exp(1F);
float64 powF64 = float64.pow(pi64 * pi64, .5F);
float64 sqrtF64 = float64.sqrt(pi64 * pi64);
float64 atanF64 = float64.atan2(pi64, 1F);

float32 sinF32 = float32.sin(pi32 / 2);
float32 cosF32 = float32.cos(pi32 / 2);
float32 tanF32 = float32.tan(pi32 / 4);
float32 logF32 = float32.log(e32 * e32 * e32);
float32 expF32 = float32.exp(1f);
float32 powF32 = float32.pow(pi32 * pi32, .5f);
float32 sqrtF32 = float32.sqrt(pi32 * pi32);
float32 atanF32 = float32.atan2(pi32, 1f);
// test the emit intrinsic of the language

int32 emitldz32 = emit(load.z32);
int64 emitldz64 = emit(load.z64);

int32 emitA = 42;
int32 emitB = 96;

int32 emitAddI32 = emit(int32(emitA), int32(emitB), add.i32);
int32 emitDivI32 = emit(int32(10), int32(5), div.i32);
float32 emitNfcF32 = emit(float32(3.14/2), float32.sin);

// emit a floating point number and interpret it as an integer
inline floatAsInt32(float32 value) = int32(emit(float32(value)));
inline floatAsInt64(float64 value) = int64(emit(float64(value)));

int32 emitFloatAsInt1 = floatAsInt32(500);
int64 emitFloatAsInt2 = floatAsInt32(500);
int32 emitFloatAsInt3 = floatAsInt64(500);
int64 emitFloatAsInt4 = floatAsInt64(500);

// create a slice with runtime length set to 3, from the given character sequence
char emitSlice[] = emit(int(3), pointer("string"));

// these should not compile
//int64 i64Zero = emit(load.z32);	// error: invalid assignment/initialization: size of variable is different from the value's
//int32 i32Zero = emit(load.z64);	// error: invalid assignment/initialization: size of variable is different from the value's

// test if functions are correctly generated and executed

void empty() {}

// function with implementation
int funAdd(int x, int y) {
	return x + y;
}

// function invocation
int funAddResult = funAdd(2, 7);

// initialized function reference
int funAddRef(int x, int y) = funAdd;

// function reference invocation
int funAddRefResult = funAddRef(2, 8);

// forward function reference (must be implemented somewhere)
int funMul(int x, int y);

// forward function invocation
int funMulResult = funMul(2, 6);

// initialized forward function reference (copy address)
int funMulRef(int x, int y) = funMul;

// forward function reference invocation
int funMulRefResult = funMulRef(2, 7);

// forward function implementation
int funMul(int x, int y) {
	return x * y;
}

// recursive function implementation
uint32 fib(uint32 n) {
	if (n <= 1) {
		return n;
	}
	return fib(n-1) + fib(n-2);
}

// recursive function invocation
uint32 fibonacci_13 = fib(13);
// test basic reflection

int sizeofVoid = sizeof(void);
int sizeofBool = sizeof(bool);
int sizeofChar = sizeof(char);
int sizeofInt8 = sizeof(int8);
int sizeofInt16 = sizeof(int16);
int sizeofInt32 = sizeof(int32);
int sizeofInt64 = sizeof(int64);
int sizeofUint8 = sizeof(uint8);
int sizeofUint16 = sizeof(uint16);
int sizeofUint32 = sizeof(uint32);
int sizeofUint64 = sizeof(uint64);
int sizeofFloat32 = sizeof(float32);
int sizeofFloat64 = sizeof(float64);
int sizeofPointer = sizeof(pointer);
int sizeofVariant = sizeof(variant);
int sizeofTypename = sizeof(typename);
int sizeofFunction = sizeof(function);
int sizeofObject = sizeof(object);

struct RecordSizeof: object {
	int64 x = 0;
}

struct RecordSizeofExt: RecordSizeof {
	int32 y = 0;
}

typename typeofRecord = RecordSizeofExt;
char nameOfRecord[*] = typename.name(typeofRecord);
int offsetOfRecord = typeofRecord.offset;
int sizeOfRecord = sizeof(typeofRecord);
char fileOfRecord[*] = typename.file(typeofRecord);
int lineOfRecord = typename.line(typeofRecord);

typename typeofBase = typename.base(typeofRecord);
char nameOfBase[*] = typename.name(typeofBase);
int offsetOfBase = typeofBase.offset;
int sizeOfBase = sizeof(typeofBase);
char fileOfBase[*] = typename.file(typeofBase);
int lineOfBase = typename.line(typeofBase);

typename typeofBase1 = typename.base(typeofBase);
int offsetOfBase1 = typeofBase1.offset;
int sizeOfBase1 = typeofBase1.size;

typename typeofBase2 = typename.base(typeofBase1);
int offsetOfBase2 = typeofBase2.offset;
int sizeOfBase2 = typeofBase2.size;
// run with `-debug/L` switch to trace caught errors
/* known errors:
	Invalid state
	Invalid memory access
	Invalid instruction
	Stack Overflow
	Division by Zero
	External call aborted execution
*/

void noError(pointer ptr) {
}

void stackOverflow(pointer ptr) {
	byte data[1 << 10];		// speed up the overflow allocating 1 kb memory in each call
	stackOverflow(ptr);
}

void divisionByZero(pointer args) {
	int value = 3 / 0;
}

void abortExecution(pointer args) {
	struct NotEquals {
		char message[*];
		int expected;
		int returned;
	}
	NotEquals details = {
		message: "assertion failed";
		expected: 97;
		returned: 77;
	};
	raise(raise.abort, raise.noTrace, "fatal error", details);
}

void invalidMemoryAccess(pointer args) {
	int32 i32Ref& = null;
	int i32Val = i32Ref;
}

void invalidInstruction(pointer args) {
	emit(load.z32, ret);
}

int tryExecErr0 = tryExec(null, noError);
int tryExecErr1 = tryExec(null, null);
int tryExecErr2 = tryExec(null, stackOverflow);
int tryExecErr3 = tryExec(null, divisionByZero);
int tryExecErr4 = tryExec(null, invalidInstruction);
int tryExecErr5 = tryExec(null, invalidMemoryAccess);
int tryExecErr6 = tryExec(null, abortExecution);
// test memory related functions

inline realloc(pointer data, int size) = pointer.alloc(data, size);
inline malloc(int size) = pointer.alloc(null, size);
inline free(pointer data) = pointer.alloc(data, 0);

pointer p1 = malloc(1024);
pointer p2 = malloc(80);
pointer p3 = malloc(160);
pointer p4 = malloc(820);

// clear and copy memory
pointer.fill(p1, 0, 1024);
pointer.copy(p1, p3, 160);

// free memory
free(p1);
free(p2);
free(p3);
free(p4);

// copy and clear memory
int64 val1 = 42;
int64 val2 = 96;

debug("val1", val1);
debug("val2", val2);

pointer.copy(pointer(val2), pointer(val1), 8);
pointer.fill(pointer(val1), 0, 8);

debug("val1", val1);
debug("val2", val2);
