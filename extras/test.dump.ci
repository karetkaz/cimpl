
---------- Compile: `lib/stdlib.ci`
lib/stdlib.ci:31: warn: padding `NotEquals` with 4 bytes: (20 -> 24)
lib/stdlib.ci:43: warn: adding implicit cast variant(expected: int32)
lib/stdlib.ci:44: warn: adding implicit cast variant(returned: int32)
lib/stdlib.ci:45: warn: adding implicit cast char[*](message: char[*])
lib/math.ci:18: warn: adding implicit cast float64(0: int32)
lib/math.ci:19: warn: adding implicit cast float64(1: int32)
lib/math.ci:23: warn: adding implicit cast float64(1: int32)
lib/math.ci:24: warn: adding implicit cast float64(0: int32)
lib/math.ci:29: warn: adding implicit cast float64(0: int32)
lib/math.ci:32: warn: adding implicit cast float64(1: int32)
lib/math.ci:72: warn: adding implicit cast float32(0: int32)
lib/math.ci:75: warn: adding implicit cast float32(0: int32)
lib/math.ci:81: warn: adding implicit cast float64(0: int32)
lib/math.ci:84: warn: adding implicit cast float64(0: int32)
lib/math.ci:91: warn: adding implicit cast float32(0: int32)
lib/math.ci:97: warn: adding implicit cast float64(0: int32)
lib/math.ci:157: warn: adding implicit cast float32(2: int32)
lib/math.ci:157: warn: adding implicit cast float32(3: int32)
lib/math.ci:161: warn: adding implicit cast float64(2: int32)
lib/math.ci:161: warn: adding implicit cast float64(3: int32)
lib/math.ci:281: warn: adding implicit cast float64(0: int32)
lib/math.ci:287: warn: adding implicit cast float64(1: int32)
lib/math.ci:288: warn: adding implicit cast float64(32764: int32)
lib/math.ci:291: warn: adding implicit cast float64(quad: int32)
lib/math.ci:295: warn: adding implicit cast float64(4: int32)
lib/math.ci:295: warn: adding implicit cast int32(e - (4) * f: float64)
lib/math.ci:299: warn: adding implicit cast float64(k: int32)
lib/math.ci:304: warn: adding implicit cast float64(1: int32)
lib/math.ci:339: warn: adding implicit cast float64(0: int32)
lib/math.ci:343: warn: adding implicit cast float64(2: int32)
lib/math.ci:351: warn: adding implicit cast float64(1: int32)
lib/math.ci:359: warn: adding implicit cast float64(1: int32)
lib/math.ci:358: warn: statement should be a block statement {if (i == 3)}
lib/math.ci:354: warn: statement should be a block statement {if (i == 2)}
lib/math.ci:350: warn: statement should be a block statement {if (i == 1)}
lib/math.ci:368: warn: adding implicit cast float64(0: int32)
lib/math.ci:371: warn: adding implicit cast float64(1: int32)
lib/math.ci:393: warn: adding implicit cast float64(0: int32)
lib/math.ci:398: warn: adding implicit cast float64(21: int32)
lib/math.ci:399: warn: adding implicit cast float64(2: int32)
lib/math.ci:404: warn: adding implicit cast float64(2: int32)
lib/math.ci:420: warn: adding implicit cast float64(0: int32)
lib/math.ci:423: warn: adding implicit cast float64(21: int32)
lib/math.ci:424: warn: adding implicit cast float64(2: int32)
lib/math.ci:426: warn: adding implicit cast float64(2: int32)
lib/math.ci:436: warn: adding implicit cast float64(0: int32)
lib/math.ci:442: warn: adding implicit cast float64(0: int32)
lib/math.ci:447: warn: adding implicit cast float64(1: int32)
lib/math.ci:452: warn: adding implicit cast float64(1: int32)
lib/math.ci:454: warn: adding implicit cast float64(2: int32)
lib/math.ci:470: warn: adding implicit cast float64(2: int32)
lib/math.ci:493: warn: adding implicit cast float64(180: int32)
lib/math.ci:494: warn: adding implicit cast float64(180: int32)
lib/math.Complex.ci:20: debug: using default field initializer: Complex.im := 0
lib/math.Complex.ci:5: warn: adding implicit cast float64(0: int32)
lib/string.ci:4: warn: adding implicit cast pointer(str: char[*])
lib/string.ci:36: warn: adding implicit cast int32(with[i]: char)
lib/string.ci:62: warn: adding implicit cast int32(str[i]: char)
lib/string.ci:108: warn: padding `FormatFlags.padLen` with 2 bytes: (6 -> 8)
lib/string.ci:114: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:121: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:122: warn: adding implicit cast uint32(1: int32)
lib/string.ci:122: warn: adding implicit cast int32(output.length - (1): uint32)
lib/string.ci:124: warn: adding implicit cast char(0: int32)
lib/string.ci:136: warn: adding implicit cast int32(radixDigits.length: uint32)
lib/string.ci:139: warn: adding implicit cast uint32(0: int32)
lib/string.ci:139: warn: adding implicit cast uint32(radix: int32)
lib/string.ci:140: warn: adding implicit cast uint32(radix: int32)
lib/string.ci:159: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:164: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:171: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:178: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:183: warn: adding implicit cast int32(output.length: uint32)
lib/string.ci:184: warn: adding implicit cast uint32(1: int32)
lib/string.ci:184: warn: adding implicit cast int32(output.length - (1): uint32)
lib/string.ci:186: warn: adding implicit cast char(0: int32)
lib/string.ci:206: warn: statement should be a block statement {if (forceSign)}

---------- Compile: `test.ci`
test/lang.inlineEmit.ci:11: warn: adding implicit cast float64(2: int32)
test/lang.inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
test/test.inlineOverload.ci:12: warn: using overload `overload(a: float32): int32` of 2 declared symbols
test/test.inlineOverload.ci:25: warn: adding implicit cast float64(32: int32)
test/test.inlineOverload.ci:26: warn: adding implicit cast float64(32: int32)
test/lang.initByRef.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
test/lang.function.ci:38: warn: adding implicit cast uint32(1: int32)
test/lang.function.ci:41: warn: adding implicit cast uint32(1: int32)
test/lang.function.ci:41: warn: adding implicit cast uint32(2: int32)
test/stdc.number.ci:37: warn: adding implicit cast float64(2: int32)
test/stdc.number.ci:38: warn: adding implicit cast float64(2: int32)
test/stdc.number.ci:39: warn: adding implicit cast float64(4: int32)
test/stdc.number.ci:46: warn: adding implicit cast float32(2: int32)
test/stdc.number.ci:47: warn: adding implicit cast float32(2: int32)
test/stdc.number.ci:48: warn: adding implicit cast float32(4: int32)
test/stdc.execute.ci:24: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
test/stdc.execute.ci:30: warn: adding implicit cast char[*]("assertion failed": .cstr)
test/lang.array.ci:44: warn: adding implicit cast pointer(typename(int64): typename)
test/lang.array.ci:55: warn: adding implicit cast int64(42 + i: int32)
test/lang.array.ci:98: warn: adding implicit cast uint32(0: int32)
test/lang.array.ci:99: warn: adding implicit cast uint32(0: int32)
test/lang.array.ci:101: warn: adding implicit cast int64(42: int32)
test/lang.member.ci:82: warn: ignoring nested comment
test/lang.method.ci:53: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/lang.method.ci:53: debug: using default field initializer: RecordMethodTest.print(this: RecordMethodTest): void := print
test/lang.method.ci:63: debug: using default field initializer: RecordMethodTest.delegateMethod(x: int32, y: int32): int32 := forwardMethod
test/lang.method.ci:63: debug: using default field initializer: RecordMethodTest.virtualMethod(x: int32, y: int32): int32 := virtualMethod
test/lang.recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
test/lang.recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
test/lang.recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang.recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang.recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
test/lang.recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
test/lang.recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
test/lang.recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
test/lang.recUnion.ci:31: warn: partial union initialization with `blue.rgb`
test/lang.recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
test/lang.recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
test/lang.recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
test/lang.recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
test/lang.recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
test/lang.recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
test/lang.recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
test/lang.recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
test/lang.recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
test/lang.recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
test/lang.recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
test/lang.recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
test/lang.recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
test/lang.recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
test/lang.useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
test/lang.useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
test/lang.useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
test/lang.useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
test/lang.useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
test/lang.useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
test/lang.useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
test/lang.useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
test/lang.useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
test/lang.useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
test/lang.useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
test/lang.useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
test/lang.useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
test/lang.useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
test/lang.useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
test/lang.useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
test/lang.useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
test/lang.useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
test/lang.useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
test/lang.useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
test/lang.useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
test/lang.statementIf.ci:65: warn: statement should be a block statement {if (t == 5)}
test/lang.statementIf.ci:62: warn: statement should be a block statement {if (t == 4)}
test/lang.statementIf.ci:59: warn: statement should be a block statement {if (t == 3)}
test/lang.statementIf.ci:56: warn: statement should be a block statement {if (t == 2)}
test/lang.statementIf.ci:53: warn: statement should be a block statement {if (t == 1)}
test/lang.statementIf.ci:73: warn: adding implicit cast pointer(typename(int64): typename)

---------- Generate: byte-code
lib/math.ci:60: warn: using default type initializer: Math.floor.result := 0
lib/math.ci:286: warn: using default type initializer: Math.sinCos.y := 0
lib/math.ci:289: warn: using default type initializer: e := 0
lib/math.ci:293: warn: using default type initializer: f := 0
lib/math.ci:345: warn: using default type initializer: Math.tan.e := 0
lib/math.ci:402: warn: using default type initializer: Math.sinh.result := 0
lib/string.ci:72: warn: operators `&&` and `||` does not short-circuit yet
lib/string.ci:133: warn: uninitialized variable `append.digits`
lib/string.ci:136: warn: operators `&&` and `||` does not short-circuit yet
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/stdc.execute.ci:15: warn: uninitialized variable `stackOverflow.data`
test/lang.member.ci:35: warn: using default type initializer: RecordMemberTest.global := 0
test/lang.member.ci:44: warn: uninitialized variable `RecordMemberTest.globalRec`
test/lang.array.ci:49: warn: uninitialized variable `arrFixedNoInit`
test/lang.array.ci:50: warn: uninitialized variable `arrArrayNoInit`
test/lang.array.ci:51: warn: uninitialized variable `arrSliceNoInit`
test/lang.array.ci:81: warn: uninitialized variable `strFixed`
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
lib/stdlib.ci:29: warn: no code will be generated for statement: 0
test/lang.method.ci:73: warn: accessing static member using instance variable `RecordMethodTest.printStatic(this: RecordMethodTest): void`/ RecordMethodTest
test/lang.useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang.useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang.useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang.useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang.useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang.useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang.useOperator.ci:3: warn: using signed cast for unsigned value: `96.300000`
test/lang.useOperator.ci:4: warn: using signed cast for unsigned value: `42.140000`
test/lang.statementFor.ci:12: warn: using default type initializer: forIdx := 0

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 136
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4 -> const variable)
.field offset: int32 (size: 4 -> const variable)
.field base: function (size: 0 -> static const inline)
.field file: function (size: 0 -> static const inline)
.field line: function (size: 0 -> static const inline)
.field name: function (size: 0 -> static const inline)
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(1)
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(2)
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(3)
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4 -> inline)
.param type: typename (size: 4 -> variable(ref))
.value: nfc(4)
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.value: 0
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.value: 0
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.value: 0
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.value: 0
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.value: 0
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.value: 0
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.value: 0
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.value: 0
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.field pop: function (size: 0 -> static const inline)
.field swap: function (size: 0 -> static const inline)
.field bsr: function (size: 0 -> static const inline)
.field bsf: function (size: 0 -> static const inline)
.field hib: function (size: 0 -> static const inline)
.field lob: function (size: 0 -> static const inline)
.value: 0
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(18)
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(19)
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(20)
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(21)
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(22)
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(23)
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(24)
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4 -> inline)
.param value: int32 (size: 4 -> variable(i32))
.value: nfc(25)
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0 -> static const inline)
.field sxt: function (size: 0 -> static const inline)
.value: 0
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(26)
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8 -> inline)
.param value: int64 (size: 8 -> variable(i64))
.param offs: int32 (size: 4 -> variable(i32))
.param count: int32 (size: 4 -> variable(i32))
.value: nfc(27)
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(28)
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(29)
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(30)
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(31)
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(32)
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(33)
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.value: nfc(34)
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4 -> inline)
.param x: float32 (size: 4 -> variable(f32))
.param y: float32 (size: 4 -> variable(f32))
.value: nfc(35)
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0 -> static const inline)
.field cos: function (size: 0 -> static const inline)
.field tan: function (size: 0 -> static const inline)
.field log: function (size: 0 -> static const inline)
.field exp: function (size: 0 -> static const inline)
.field pow: function (size: 0 -> static const inline)
.field sqrt: function (size: 0 -> static const inline)
.field atan2: function (size: 0 -> static const inline)
.value: 0
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(36)
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(37)
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(38)
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(39)
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(40)
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(41)
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.value: nfc(42)
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8 -> inline)
.param x: float64 (size: 8 -> variable(f64))
.param y: float64 (size: 8 -> variable(f64))
.value: nfc(43)
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0 -> static const inline)
.field fill: function (size: 0 -> static const inline)
.field copy: function (size: 0 -> static const inline)
.field move: function (size: 0 -> static const inline)
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param ptr: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(7)
}
pointer.fill(dst: pointer, value: int32, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param value: int32 (size: 4 -> variable(i32))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(8)
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(9)
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4 -> inline)
.param dst: pointer (size: 4 -> variable(ref))
.param src: pointer (size: 4 -> variable(ref))
.param size: int32 (size: 4 -> variable(i32))
.value: nfc(10)
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.value: {pointer @0}
}
true: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'true'
.value: 1
}
false: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'false'
.value: 0
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
byte: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'byte'
.value: uint8
}
float: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'float'
.value: float32
}
double: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'double'
.value: float64
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0 -> static const inline)
.field not: bool (size: 0 -> static const inline)
.field set: void (size: 0 -> static const inline)
.field ret: void (size: 0 -> static const inline)
.field call: void (size: 0 -> static const inline)
.field p4x: typename (size: 16 -> static const typename(val))
.field dup: void (size: 0 -> static const typename(void))
.field load: void (size: 0 -> static const typename(void))
.field store: void (size: 0 -> static const typename(void))
.field cmt: void (size: 0 -> static const typename(void))
.field and: void (size: 0 -> static const typename(void))
.field or: void (size: 0 -> static const typename(void))
.field xor: void (size: 0 -> static const typename(void))
.field shl: void (size: 0 -> static const typename(void))
.field shr: void (size: 0 -> static const typename(void))
.field neg: void (size: 0 -> static const typename(void))
.field add: void (size: 0 -> static const typename(void))
.field sub: void (size: 0 -> static const typename(void))
.field mul: void (size: 0 -> static const typename(void))
.field div: void (size: 0 -> static const typename(void))
.field mod: void (size: 0 -> static const typename(void))
.field ceq: void (size: 0 -> static const typename(void))
.field clt: void (size: 0 -> static const typename(void))
.field cgt: void (size: 0 -> static const typename(void))
.field min: void (size: 0 -> static const typename(void))
.field max: void (size: 0 -> static const typename(void))
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.value: set.x1 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.value: ret
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0 -> static const inline)
.field dp4: float32 (size: 0 -> static const inline)
.field dph: float32 (size: 0 -> static const inline)
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.value: dp3.v4f
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.value: dp4.v4f
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.value: dph.v4f
}
emit.dup: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0 -> static const inline)
.field x2: int64 (size: 0 -> static const inline)
.field x4: emit.p4x (size: 0 -> static const inline)
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.value: dup.x1 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.value: dup.x2 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.value: dup.x4 sp(0)
}
emit.load: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0 -> static const inline)
.field z64: int64 (size: 0 -> static const inline)
.field z128: emit.p4x (size: 0 -> static const inline)
.field i8: int32 (size: 0 -> static const inline)
.field i16: int32 (size: 0 -> static const inline)
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field i128: emit.p4x (size: 0 -> static const inline)
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.value: load.z32
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.value: load.z64
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.value: load.i8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.value: load.i16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.value: load.i128
}
emit.store: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0 -> static const inline)
.field i16: void (size: 0 -> static const inline)
.field i32: void (size: 0 -> static const inline)
.field i64: void (size: 0 -> static const inline)
.field i128: void (size: 0 -> static const inline)
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.value: store.i128
}
emit.cmt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.value: cmt.b64
}
emit.and: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.value: and.b64
}
emit.or: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.value: or.b64
}
emit.xor: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.value: xor.b64
}
emit.shl: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.value: shl.b64
}
emit.shr: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint64 (size: 0 -> static const inline)
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.value: shr.b64
}
emit.neg: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.value: neg.v4f
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.value: neg.v2d
}
emit.add: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.value: add.i32
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.value: add.i64
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.value: add.f64
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.value: add.v4f
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.value: add.v2d
}
emit.sub: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.value: sub.f64
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.value: sub.v4f
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.value: sub.v2d
}
emit.mul: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.value: mul.u32
}
emit.mul.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mul
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.value: mul.v4f
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.value: mul.v2d
}
emit.div: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.value: div.i32
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.value: div.u32
}
emit.div.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.div
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.value: div.f32
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.value: div.v4f
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.value: div.v2d
}
emit.mod: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0 -> static const inline)
.field i64: int64 (size: 0 -> static const inline)
.field u32: uint32 (size: 0 -> static const inline)
.field u64: uint32 (size: 0 -> static const inline)
.field f32: float32 (size: 0 -> static const inline)
.field f64: float64 (size: 0 -> static const inline)
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.value: mod.u32
}
emit.mod.u64: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u64'
.owner: emit.mod
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.value: mod.f64
}
emit.ceq: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
.field p4f: bool (size: 0 -> static const inline)
.field p2d: bool (size: 0 -> static const inline)
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.value: ceq.v2d
}
emit.clt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.value: clt.f64
}
emit.cgt: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0 -> static const inline)
.field i64: bool (size: 0 -> static const inline)
.field u32: bool (size: 0 -> static const inline)
.field u64: bool (size: 0 -> static const inline)
.field f32: bool (size: 0 -> static const inline)
.field f64: bool (size: 0 -> static const inline)
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.value: cgt.f64
}
emit.min: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.value: min.v4f
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.value: min.v2d
}
emit.max: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0 -> static const inline)
.field p2d: emit.p4x (size: 0 -> static const inline)
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.value: max.v4f
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.value: max.v2d
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0 -> inline)
.value: nfc(0)
}
CLOCKS_PER_SEC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'CLOCKS_PER_SEC'
.value: 1000000
}
RAND_MAX: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'RAND_MAX'
.value: 2147483647
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0 -> static const i64)
.field error: int64 (size: 0 -> static const i64)
.field warn: int64 (size: 0 -> static const i64)
.field info: int64 (size: 0 -> static const i64)
.field debug: int64 (size: 0 -> static const i64)
.field verbose: int64 (size: 0 -> static const i64)
.field noTrace: int64 (size: 0 -> static const i64)
.field defTrace: int64 (size: 0 -> static const i64)
.param .result: void (size: 0 -> inline)
.param file: char[*] (size: 4 -> variable(ref))
.param line: int32 (size: 4 -> variable(i32))
.param level: int32 (size: 4 -> variable(i32))
.param trace: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.param inspect: variant (size: 8 -> variable(var))
.value: nfc(5)
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -2
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: -1
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 1
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 13
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 14
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 15
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 0
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
.value: 128
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4 -> inline)
.param args: pointer (size: 4 -> variable(ref))
.param action: function (size: 4 -> variable(ref))
.value: nfc(6)
}
System: void {
.kind: static const typename(void)
.base: `void`
.size: 0
.name: 'System'
.field exit: function (size: 0 -> static const inline)
.field srand: function (size: 0 -> static const inline)
.field rand: function (size: 0 -> static const inline)
.field time: function (size: 0 -> static const inline)
.field clock: function (size: 0 -> static const inline)
.field millis: function (size: 0 -> static const inline)
.field sleep: function (size: 0 -> static const inline)
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0 -> inline)
.param code: int32 (size: 4 -> variable(i32))
.value: nfc(11)
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0 -> inline)
.param seed: int32 (size: 4 -> variable(i32))
.value: nfc(12)
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(13)
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(14)
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.param .result: int32 (size: 4 -> inline)
.value: nfc(15)
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8 -> inline)
.value: nfc(16)
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0 -> inline)
.param millis: int64 (size: 8 -> variable(i64))
.value: nfc(17)
}
verbose(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:5'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.verbose, raise.noTrace, message, inspect)
}
verbose(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'lib/stdlib.ci:6'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.verbose, raise.noTrace, message, null)
}
trace(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:8'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.defTrace, message, inspect)
}
trace(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'lib/stdlib.ci:9'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.defTrace, message, null)
}
debug(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:11'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.debug, raise.noTrace, message, inspect)
}
debug(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'lib/stdlib.ci:12'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.debug, raise.noTrace, message, null)
}
info(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:14'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.info, raise.noTrace, message, inspect)
}
info(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'lib/stdlib.ci:15'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.info, raise.noTrace, message, null)
}
warn(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:17'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.warn, raise.noTrace, message, inspect)
}
warn(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'lib/stdlib.ci:18'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.warn, raise.noTrace, message, null)
}
error(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:20'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.error, raise.defTrace, message, inspect)
}
error(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'lib/stdlib.ci:21'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.error, raise.defTrace, message, null)
}
abort(message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:23'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: raise(raise.abort, raise.defTrace, message, inspect)
}
abort(message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:24'
.param .result: void (size: 0 -> void)
.param message: char[*] (size: 4 -> ref)
.value: raise(raise.abort, raise.defTrace, message, null)
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'lib/stdlib.ci:25'
.param .result: void (size: 0 -> void)
.value: raise(raise.abort, raise.defTrace, "execution aborted!", null)
}
assert(condition: bool, message: char[*], inspect: variant): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:27'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.param inspect: variant (size: 8 -> var)
.value: void(condition ? void(0) : abort(message, inspect))
}
assert(condition: bool, message: char[*]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:28'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.param message: char[*] (size: 4 -> ref)
.value: void(condition ? void(0) : abort(message))
}
assert(condition: bool): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'lib/stdlib.ci:29'
.param .result: void (size: 0 -> void)
.param condition: bool (size: 4 -> bool)
.value: void(condition ? void(0) : abort("assertion failed!"))
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'NotEquals'
.file: 'lib/stdlib.ci:31'
.field expected: variant (size: 8 -> const variable(var))
.field returned: variant (size: 8 -> const variable(var))
.field message: char[*] (size: 4 -> const variable(ref))
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'lib/stdlib.ci:32'
.owner: NotEquals
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'lib/stdlib.ci:33'
.owner: NotEquals
}
NotEquals.message: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'message'
.file: 'lib/stdlib.ci:34'
.owner: NotEquals
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static const function
.base: `function`
.size: 83
.name: 'assertEq'
.file: 'lib/stdlib.ci:38'
.param .result: void (size: 0 -> variable(void))
.param expected: int32 (size: 4 -> variable(i32))
.param returned: int32 (size: 4 -> variable(i32))
.param message: char[*] (size: 4 -> variable(ref))
.value: {
	if (returned == expected) {
		return;
	}
	details: NotEquals := {
		details.expected := (expected);
		details.returned := (returned);
		details.message := (message);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
.instructions: (83 bytes)
	lib/stdlib.ci:39: (10 bytes): if (returned == expected)
	<assertEq+?>:    dup.x1 sp(2)
	<assertEq+?>:    dup.x1 sp(4)
	<assertEq+?>:    ceq.i32
	<assertEq+?>:    jz <assertEq+?>
	lib/stdlib.ci:40: (1 bytes): return;
	<assertEq+?>:    ret
	lib/stdlib.ci:42: (30 bytes): details: NotEquals := {...}
	<assertEq+?>:    inc.sp(+24)
	lib/stdlib.ci:43: (11 bytes): details.expected := (expected);
	<assertEq+?>:    load.ref .?????? ;int32
	<assertEq+?>:    load.sp(+40)
	<assertEq+?>:    set.x2 sp(2)
	lib/stdlib.ci:44: (11 bytes): details.returned := (returned);
	<assertEq+?>:    load.ref .?????? ;int32
	<assertEq+?>:    load.sp(+36)
	<assertEq+?>:    set.x2 sp(4)
	lib/stdlib.ci:45: (4 bytes): details.message := (message);
	<assertEq+?>:    dup.x1 sp(7)
	<assertEq+?>:    set.x1 sp(5)
	lib/stdlib.ci:47: (38 bytes): raise(raise.abort, raise.defTrace, "assertion failed", details);
	<assertEq+?>:    load.ref .?????? ;"lib/stdlib.ci"
	<assertEq+?>:    load.c32 47
	<assertEq+?>:    load.c32 -2
	<assertEq+?>:    load.c32 128
	<assertEq+?>:    load.ref .?????? ;"assertion failed"
	<assertEq+?>:    load.ref .?????? ;NotEquals
	<assertEq+?>:    load.sp(+24)
	<assertEq+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<assertEq+?>:    inc.sp(-24)
	<assertEq+?>:    ret
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'lib/stdlib.ci:49'
.param .result: void (size: 0 -> void)
.param expected: int32 (size: 4 -> i32)
.param returned: int32 (size: 4 -> i32)
.value: assertEq(expected, returned, null)
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'lib/stdlib.ci:53'
.param .result: int32 (size: 4 -> i32)
.param type: typename (size: 4 -> ref)
.value: int32(type.size)
}
Math: typename {
.kind: static const typename(val)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'lib/math.ci:3'
.field pi: float64 (size: 8 -> static const val)
.field e: float64 (size: 8 -> static const val)
.field ln2: float64 (size: 8 -> static const val)
.field log2E: float64 (size: 8 -> static const val)
.field ln10: float64 (size: 8 -> static const val)
.field log10E: float64 (size: 8 -> static const val)
.field phi: float64 (size: 8 -> static const val)
.field sqrt2: float64 (size: 8 -> static const val)
.field sqrtE: float64 (size: 8 -> static const val)
.field sqrtPi: float64 (size: 8 -> static const val)
.field sqrtPhi: float64 (size: 8 -> static const val)
.field nan: float64 (size: 8 -> static const val)
.field inf: float64 (size: 8 -> static const val)
.field modf: function (size: 104 -> static const function)
.field floor: function (size: 35 -> static const function)
.field ceil: function (size: 0 -> static inline)
.field round: function (size: 0 -> static inline)
.field sign: function (size: 36 -> static const function)
.field sign: function (size: 36 -> static const function)
.field abs: function (size: 19 -> static const function)
.field abs: function (size: 19 -> static const function)
.field min: function (size: 19 -> static const function)
.field min: function (size: 19 -> static const function)
.field max: function (size: 19 -> static const function)
.field max: function (size: 19 -> static const function)
.field clamp: function (size: 33 -> static const function)
.field clamp: function (size: 33 -> static const function)
.field lerp: function (size: 14 -> static const function)
.field lerp: function (size: 14 -> static const function)
.field smooth: function (size: 57 -> static const function)
.field smooth: function (size: 73 -> static const function)
.field cmp: function (size: 57 -> static const function)
.field cmp: function (size: 57 -> static const function)
.field sinCos: function (size: 348 -> static const function)
.field sin: function (size: 0 -> static inline)
.field cos: function (size: 0 -> static inline)
.field tan: function (size: 387 -> static const function)
.field sinh: function (size: 248 -> static const function)
.field cosh: function (size: 75 -> static const function)
.field asin: function (size: 183 -> static const function)
.field acos: function (size: 0 -> static inline)
.field deg2rad: function (size: 0 -> static inline)
.field rad2deg: function (size: 0 -> static inline)
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'pi'
.file: 'lib/math.ci:7'
.owner: Math
.value: 3.141593
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'e'
.file: 'lib/math.ci:8'
.owner: Math
.value: 2.718282
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln2'
.file: 'lib/math.ci:9'
.owner: Math
.value: 0.693147
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log2E'
.file: 'lib/math.ci:10'
.owner: Math
.value: 1.000000 / ln2
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'ln10'
.file: 'lib/math.ci:11'
.owner: Math
.value: 2.302585
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'log10E'
.file: 'lib/math.ci:12'
.owner: Math
.value: 1.000000 / ln10
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'phi'
.file: 'lib/math.ci:13'
.owner: Math
.value: 1.618034
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrt2'
.file: 'lib/math.ci:14'
.owner: Math
.value: 1.414214
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtE'
.file: 'lib/math.ci:15'
.owner: Math
.value: 1.648721
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPi'
.file: 'lib/math.ci:16'
.owner: Math
.value: 1.772454
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'sqrtPhi'
.file: 'lib/math.ci:17'
.owner: Math
.value: 1.272020
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'nan'
.file: 'lib/math.ci:18'
.owner: Math
.value: (0) / 0.000000
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 8
.name: 'inf'
.file: 'lib/math.ci:19'
.owner: Math
.value: (1) / 0.000000
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static const function
.base: `function`
.size: 104
.name: 'modf'
.file: 'lib/math.ci:22'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.param intPart: float64 (size: 4 -> variable(ref))
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := -modf(-x, intPart);
			intPart := -intPart;
			return .result := result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (104 bytes)
	lib/math.ci:23: (70 bytes): if (x < (1))
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.f64 1.000000
	<modf+?>:    clt.f64
	<modf+?>:    jz <modf+?>
	lib/math.ci:24: (45 bytes): if (x < (0))
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.z64
	<modf+?>:    clt.f64
	<modf+?>:    jz <modf+?>
	lib/math.ci:25: (17 bytes): result: float64 := -modf(-x, intPart)
	<modf+?>:    load.z64
	<modf+?>:    dup.x2 sp(4)
	<modf+?>:    neg.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>:    call
	<modf+?>:    inc.sp(-12)
	<modf+?>:    neg.f64
	lib/math.ci:26: (7 bytes): intPart := -intPart;
	<modf+?>:    dup.x1 sp(3)
	<modf+?>:    load.i64
	<modf+?>:    neg.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    store.i64
	lib/math.ci:27: (9 bytes): return .result := result;
	<modf+?>:    dup.x2 sp(0)
	<modf+?>:    set.x2 sp(8)
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
	<modf+?>:    inc.sp(-8)
	lib/math.ci:29: (4 bytes): intPart := (0);
	<modf+?>:    load.z64
	<modf+?>:    dup.x1 sp(3)
	<modf+?>:    store.i64
	lib/math.ci:30: (5 bytes): return .result := x;
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    set.x2 sp(6)
	<modf+?>:    ret
	lib/math.ci:32: (12 bytes): result: float64 := x % (1)
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    load.f64 1.000000
	<modf+?>:    mod.f64
	lib/math.ci:33: (8 bytes): intPart := x - result;
	<modf+?>:    dup.x2 sp(4)
	<modf+?>:    dup.x2 sp(2)
	<modf+?>:    sub.f64
	<modf+?>:    dup.x1 sp(5)
	<modf+?>:    store.i64
	lib/math.ci:34: (9 bytes): return .result := result;
	<modf+?>:    dup.x2 sp(0)
	<modf+?>:    set.x2 sp(8)
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
	<modf+?>:    inc.sp(-8)
	<modf+?>:    ret
}
Math.floor(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 35
.name: 'floor'
.file: 'lib/math.ci:59'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	result: float64;
	modf(x, result);
	return .result := result;
}
.instructions: (35 bytes)
	lib/math.ci:60: (1 bytes): result: float64
	<floor+?>:    load.z128
	lib/math.ci:61: (20 bytes): modf(x, result);
	<floor+?>:    dup.x2 sp(5)
	<floor+?>:    load.sp(+16)
	<floor+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<floor+?>:    call
	<floor+?>:    inc.sp(-12)
	<floor+?>:    inc.sp(-8)
	lib/math.ci:62: (9 bytes): return .result := result;
	<floor+?>:    dup.x2 sp(0)
	<floor+?>:    set.x2 sp(7)
	<floor+?>:    inc.sp(-8)
	<floor+?>:    ret
	<floor+?>:    inc.sp(-8)
	<floor+?>:    ret
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'lib/math.ci:64'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: -floor(-x)
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'lib/math.ci:65'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: floor(x + 0.500000)
}
Math.sign(x: float32): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/math.ci:71'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param x: float32 (size: 4 -> variable(f32))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/math.ci:72: (12 bytes): if (x == (0))
	<sign+?>:    dup.x1 sp(1)
	<sign+?>:    load.z32
	<sign+?>:    ceq.f32
	<sign+?>:    jz <sign+?>
	lib/math.ci:73: (4 bytes): return .result := 0;
	<sign+?>:    load.z32
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
	lib/math.ci:75: (16 bytes): if (x < (0))
	<sign+?>:    dup.x1 sp(1)
	<sign+?>:    load.z32
	<sign+?>:    clt.f32
	<sign+?>:    jz <sign+?>
	lib/math.ci:76: (8 bytes): return .result := -1;
	<sign+?>:    load.c32 -1
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
	lib/math.ci:78: (8 bytes): return .result := 1;
	<sign+?>:    load.c32 1
	<sign+?>:    set.x1 sp(3)
	<sign+?>:    ret
}
Math.sign(x: float64): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'sign'
.file: 'lib/math.ci:80'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x == (0)) {
		return .result := 0;
	}
	if (x < (0)) {
		return .result := -1;
	}
	return .result := 1;
}
.instructions: (36 bytes)
	lib/math.ci:81: (12 bytes): if (x == (0))
	<sign+?>:    dup.x2 sp(1)
	<sign+?>:    load.z64
	<sign+?>:    ceq.f64
	<sign+?>:    jz <sign+?>
	lib/math.ci:82: (4 bytes): return .result := 0;
	<sign+?>:    load.z32
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
	lib/math.ci:84: (16 bytes): if (x < (0))
	<sign+?>:    dup.x2 sp(1)
	<sign+?>:    load.z64
	<sign+?>:    clt.f64
	<sign+?>:    jz <sign+?>
	lib/math.ci:85: (8 bytes): return .result := -1;
	<sign+?>:    load.c32 -1
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
	lib/math.ci:87: (8 bytes): return .result := 1;
	<sign+?>:    load.c32 1
	<sign+?>:    set.x1 sp(4)
	<sign+?>:    ret
}
Math.abs(x: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'abs'
.file: 'lib/math.ci:90'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param x: float32 (size: 4 -> variable(f32))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (19 bytes)
	lib/math.ci:91: (14 bytes): if (x < (0))
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    load.z32
	<abs+?>:    clt.f32
	<abs+?>:    jz <abs+?>
	lib/math.ci:92: (6 bytes): return .result := -x;
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    neg.f32
	<abs+?>:    set.x1 sp(3)
	<abs+?>:    ret
	lib/math.ci:94: (5 bytes): return .result := x;
	<abs+?>:    dup.x1 sp(1)
	<abs+?>:    set.x1 sp(3)
	<abs+?>:    ret
}
Math.abs(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'abs'
.file: 'lib/math.ci:96'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x < (0)) {
		return .result := -x;
	}
	return .result := x;
}
.instructions: (19 bytes)
	lib/math.ci:97: (14 bytes): if (x < (0))
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    load.z64
	<abs+?>:    clt.f64
	<abs+?>:    jz <abs+?>
	lib/math.ci:98: (6 bytes): return .result := -x;
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    neg.f64
	<abs+?>:    set.x2 sp(5)
	<abs+?>:    ret
	lib/math.ci:100: (5 bytes): return .result := x;
	<abs+?>:    dup.x2 sp(1)
	<abs+?>:    set.x2 sp(5)
	<abs+?>:    ret
}
Math.min(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'min'
.file: 'lib/math.ci:103'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:104: (14 bytes): if (a < b)
	<min+?>:    dup.x1 sp(2)
	<min+?>:    dup.x1 sp(2)
	<min+?>:    clt.f32
	<min+?>:    jz <min+?>
	lib/math.ci:105: (5 bytes): return .result := a;
	<min+?>:    dup.x1 sp(2)
	<min+?>:    set.x1 sp(4)
	<min+?>:    ret
	lib/math.ci:107: (5 bytes): return .result := b;
	<min+?>:    dup.x1 sp(1)
	<min+?>:    set.x1 sp(4)
	<min+?>:    ret
}
Math.min(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'min'
.file: 'lib/math.ci:109'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (a < b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:110: (14 bytes): if (a < b)
	<min+?>:    dup.x2 sp(3)
	<min+?>:    dup.x2 sp(3)
	<min+?>:    clt.f64
	<min+?>:    jz <min+?>
	lib/math.ci:111: (5 bytes): return .result := a;
	<min+?>:    dup.x2 sp(3)
	<min+?>:    set.x2 sp(7)
	<min+?>:    ret
	lib/math.ci:113: (5 bytes): return .result := b;
	<min+?>:    dup.x2 sp(1)
	<min+?>:    set.x2 sp(7)
	<min+?>:    ret
}
Math.max(a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'max'
.file: 'lib/math.ci:116'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:117: (14 bytes): if (a > b)
	<max+?>:    dup.x1 sp(2)
	<max+?>:    dup.x1 sp(2)
	<max+?>:    cgt.f32
	<max+?>:    jz <max+?>
	lib/math.ci:118: (5 bytes): return .result := a;
	<max+?>:    dup.x1 sp(2)
	<max+?>:    set.x1 sp(4)
	<max+?>:    ret
	lib/math.ci:120: (5 bytes): return .result := b;
	<max+?>:    dup.x1 sp(1)
	<max+?>:    set.x1 sp(4)
	<max+?>:    ret
}
Math.max(a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 19
.name: 'max'
.file: 'lib/math.ci:122'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (a > b) {
		return .result := a;
	}
	return .result := b;
}
.instructions: (19 bytes)
	lib/math.ci:123: (14 bytes): if (a > b)
	<max+?>:    dup.x2 sp(3)
	<max+?>:    dup.x2 sp(3)
	<max+?>:    cgt.f64
	<max+?>:    jz <max+?>
	lib/math.ci:124: (5 bytes): return .result := a;
	<max+?>:    dup.x2 sp(3)
	<max+?>:    set.x2 sp(7)
	<max+?>:    ret
	lib/math.ci:126: (5 bytes): return .result := b;
	<max+?>:    dup.x2 sp(1)
	<max+?>:    set.x2 sp(7)
	<max+?>:    ret
}
Math.clamp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 33
.name: 'clamp'
.file: 'lib/math.ci:129'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (33 bytes)
	lib/math.ci:130: (14 bytes): if (t < a)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    clt.f32
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:131: (5 bytes): return .result := a;
	<clamp+?>:    dup.x1 sp(2)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
	lib/math.ci:133: (14 bytes): if (t > b)
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    dup.x1 sp(2)
	<clamp+?>:    cgt.f32
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:134: (5 bytes): return .result := b;
	<clamp+?>:    dup.x1 sp(1)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
	lib/math.ci:136: (5 bytes): return .result := t;
	<clamp+?>:    dup.x1 sp(3)
	<clamp+?>:    set.x1 sp(5)
	<clamp+?>:    ret
}
Math.clamp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 33
.name: 'clamp'
.file: 'lib/math.ci:138'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	if (t < a) {
		return .result := a;
	}
	if (t > b) {
		return .result := b;
	}
	return .result := t;
}
.instructions: (33 bytes)
	lib/math.ci:139: (14 bytes): if (t < a)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    clt.f64
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:140: (5 bytes): return .result := a;
	<clamp+?>:    dup.x2 sp(3)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
	lib/math.ci:142: (14 bytes): if (t > b)
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    dup.x2 sp(3)
	<clamp+?>:    cgt.f64
	<clamp+?>:    jz <clamp+?>
	lib/math.ci:143: (5 bytes): return .result := b;
	<clamp+?>:    dup.x2 sp(1)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
	lib/math.ci:145: (5 bytes): return .result := t;
	<clamp+?>:    dup.x2 sp(5)
	<clamp+?>:    set.x2 sp(9)
	<clamp+?>:    ret
}
Math.lerp(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'lerp'
.file: 'lib/math.ci:148'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	return .result := a + t * (b - a);
}
.instructions: (14 bytes)
	lib/math.ci:149: (14 bytes): return .result := a + t * (b - a);
	<lerp+?>:    dup.x1 sp(2)
	<lerp+?>:    dup.x1 sp(4)
	<lerp+?>:    dup.x1 sp(3)
	<lerp+?>:    dup.x1 sp(5)
	<lerp+?>:    sub.f32
	<lerp+?>:    mul.f32
	<lerp+?>:    add.f32
	<lerp+?>:    set.x1 sp(5)
	<lerp+?>:    ret
}
Math.lerp(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'lerp'
.file: 'lib/math.ci:151'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	return .result := a + t * (b - a);
}
.instructions: (14 bytes)
	lib/math.ci:152: (14 bytes): return .result := a + t * (b - a);
	<lerp+?>:    dup.x2 sp(3)
	<lerp+?>:    dup.x2 sp(7)
	<lerp+?>:    dup.x2 sp(5)
	<lerp+?>:    dup.x2 sp(9)
	<lerp+?>:    sub.f64
	<lerp+?>:    mul.f64
	<lerp+?>:    add.f64
	<lerp+?>:    set.x2 sp(9)
	<lerp+?>:    ret
}
Math.smooth(t: float32, a: float32, b: float32): float32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'smooth'
.file: 'lib/math.ci:155'
.owner: Math
.param .result: float32 (size: 4 -> variable(f32))
.param t: float32 (size: 4 -> variable(f32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.value: {
	t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	return .result := t * t * ((3) - (2) * t);
}
.instructions: (57 bytes)
	lib/math.ci:156: (34 bytes): t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	<smooth+?>:    load.z32
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    sub.f32
	<smooth+?>:    dup.x1 sp(3)
	<smooth+?>:    dup.x1 sp(5)
	<smooth+?>:    sub.f32
	<smooth+?>:    div.f32
	<smooth+?>:    load.f32 0.000000
	<smooth+?>:    load.f32 1.000000
	<smooth+?>:    load.ref .?????? ;Math.clamp(t: float32, a: float32, b: float32): float32
	<smooth+?>:    call
	<smooth+?>:    inc.sp(-12)
	<smooth+?>:    set.x1 sp(4)
	lib/math.ci:157: (23 bytes): return .result := t * t * ((3) - (2) * t);
	<smooth+?>:    dup.x1 sp(3)
	<smooth+?>:    dup.x1 sp(4)
	<smooth+?>:    mul.f32
	<smooth+?>:    load.f32 3.000000
	<smooth+?>:    load.f32 2.000000
	<smooth+?>:    dup.x1 sp(6)
	<smooth+?>:    mul.f32
	<smooth+?>:    sub.f32
	<smooth+?>:    mul.f32
	<smooth+?>:    set.x1 sp(5)
	<smooth+?>:    ret
}
Math.smooth(t: float64, a: float64, b: float64): float64: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'smooth'
.file: 'lib/math.ci:159'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param t: float64 (size: 8 -> variable(f64))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.value: {
	t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	return .result := t * t * ((3) - (2) * t);
}
.instructions: (73 bytes)
	lib/math.ci:160: (42 bytes): t := clamp((t - a) / (b - a), 0.000000, 1.000000);
	<smooth+?>:    load.z64
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    sub.f64
	<smooth+?>:    dup.x2 sp(5)
	<smooth+?>:    dup.x2 sp(9)
	<smooth+?>:    sub.f64
	<smooth+?>:    div.f64
	<smooth+?>:    load.f64 0.000000
	<smooth+?>:    load.f64 1.000000
	<smooth+?>:    load.ref .?????? ;Math.clamp(t: float64, a: float64, b: float64): float64
	<smooth+?>:    call
	<smooth+?>:    inc.sp(-24)
	<smooth+?>:    set.x2 sp(7)
	lib/math.ci:161: (31 bytes): return .result := t * t * ((3) - (2) * t);
	<smooth+?>:    dup.x2 sp(5)
	<smooth+?>:    dup.x2 sp(7)
	<smooth+?>:    mul.f64
	<smooth+?>:    load.f64 3.000000
	<smooth+?>:    load.f64 2.000000
	<smooth+?>:    dup.x2 sp(11)
	<smooth+?>:    mul.f64
	<smooth+?>:    sub.f64
	<smooth+?>:    mul.f64
	<smooth+?>:    set.x2 sp(9)
	<smooth+?>:    ret
}
Math.cmp(a: float32, b: float32, eps: float32): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/math.ci:239'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param a: float32 (size: 4 -> variable(f32))
.param b: float32 (size: 4 -> variable(f32))
.param eps: float32 (size: 4 -> variable(f32))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/math.ci:240: (53 bytes): if (a < b)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:241: (20 bytes): if (eps < (b - a))
	<cmp+?>:    dup.x1 sp(1)
	<cmp+?>:    dup.x1 sp(3)
	<cmp+?>:    dup.x1 sp(5)
	<cmp+?>:    sub.f32
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:242: (8 bytes): return .result := -1;
	<cmp+?>:    load.c32 -1
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
	<cmp+?>:    jmp <cmp+?>
	lib/math.ci:246: (20 bytes): if (eps < (a - b))
	<cmp+?>:    dup.x1 sp(1)
	<cmp+?>:    dup.x1 sp(4)
	<cmp+?>:    dup.x1 sp(4)
	<cmp+?>:    sub.f32
	<cmp+?>:    clt.f32
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:247: (8 bytes): return .result := +1;
	<cmp+?>:    load.c32 1
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
	lib/math.ci:250: (4 bytes): return .result := 0;
	<cmp+?>:    load.z32
	<cmp+?>:    set.x1 sp(5)
	<cmp+?>:    ret
}
Math.cmp(a: float64, b: float64, eps: float64): int32: function {
.kind: static const function
.base: `function`
.size: 57
.name: 'cmp'
.file: 'lib/math.ci:252'
.owner: Math
.param .result: int32 (size: 4 -> variable(i32))
.param a: float64 (size: 8 -> variable(f64))
.param b: float64 (size: 8 -> variable(f64))
.param eps: float64 (size: 8 -> variable(f64))
.value: {
	if (a < b) {
		if (eps < (b - a)) {
			return .result := -1;
		}
	}
	else {
		if (eps < (a - b)) {
			return .result := +1;
		}
	}
	return .result := 0;
}
.instructions: (57 bytes)
	lib/math.ci:253: (53 bytes): if (a < b)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:254: (20 bytes): if (eps < (b - a))
	<cmp+?>:    dup.x2 sp(1)
	<cmp+?>:    dup.x2 sp(5)
	<cmp+?>:    dup.x2 sp(9)
	<cmp+?>:    sub.f64
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:255: (8 bytes): return .result := -1;
	<cmp+?>:    load.c32 -1
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
	<cmp+?>:    jmp <cmp+?>
	lib/math.ci:259: (20 bytes): if (eps < (a - b))
	<cmp+?>:    dup.x2 sp(1)
	<cmp+?>:    dup.x2 sp(7)
	<cmp+?>:    dup.x2 sp(7)
	<cmp+?>:    sub.f64
	<cmp+?>:    clt.f64
	<cmp+?>:    jz <cmp+?>
	lib/math.ci:260: (8 bytes): return .result := +1;
	<cmp+?>:    load.c32 1
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
	lib/math.ci:263: (4 bytes): return .result := 0;
	<cmp+?>:    load.z32
	<cmp+?>:    set.x1 sp(8)
	<cmp+?>:    ret
}
Math.sinCos(arg: float64, quad: int32): float64: function {
.kind: static const function
.base: `function`
.size: 348
.name: 'sinCos'
.file: 'lib/math.ci:266'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param arg: float64 (size: 8 -> variable(f64))
.param quad: int32 (size: 4 -> variable(i32))
.value: {
	x: float64 := arg;
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (1) / PIO2;
	if (x > (32764)) {
		e: float64;
		y := modf(x, e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
	temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
	return .result := temp1 / temp2;
}
.instructions: (348 bytes)
	lib/math.ci:280: (2 bytes): x: float64 := arg
	<sinCos+?>:    dup.x2 sp(2)
	lib/math.ci:281: (21 bytes): if (x < (0))
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    load.z64
	<sinCos+?>:    clt.f64
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:282: (5 bytes): x := -x;
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    neg.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:283: (8 bytes): quad := quad + 2;
	<sinCos+?>:    dup.x1 sp(3)
	<sinCos+?>:    inc.i32(+2)
	<sinCos+?>:    set.x1 sp(4)
	lib/math.ci:286: (1 bytes): y: float64
	<sinCos+?>:    load.z64
	lib/math.ci:287: (24 bytes): x := x * (1) / PIO2;
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 1.000000
	<sinCos+?>:    load.f64 1.570796
	<sinCos+?>:    div.f64
	<sinCos+?>:    mul.f64
	<sinCos+?>:    set.x2 sp(4)
	lib/math.ci:288: (124 bytes): if (x > (32764))
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 32764.000000
	<sinCos+?>:    cgt.f64
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:289: (1 bytes): e: float64
	<sinCos+?>:    load.z128
	lib/math.ci:290: (18 bytes): y := modf(x, e);
	<sinCos+?>:    dup.x2 sp(6)
	<sinCos+?>:    load.sp(+16)
	<sinCos+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>:    call
	<sinCos+?>:    inc.sp(-12)
	<sinCos+?>:    set.x2 sp(4)
	lib/math.ci:291: (4 bytes): e := e + (quad);
	<sinCos+?>:    dup.x1 sp(7)
	<sinCos+?>:    i32.2f64
	<sinCos+?>:    add.f64
	lib/math.ci:293: (1 bytes): f: float64
	<sinCos+?>:    load.z128
	lib/math.ci:294: (30 bytes): modf(0.250000 * e, f);
	<sinCos+?>:    load.f64 0.250000
	<sinCos+?>:    dup.x2 sp(6)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.sp(+16)
	<sinCos+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<sinCos+?>:    call
	<sinCos+?>:    inc.sp(-12)
	<sinCos+?>:    inc.sp(-8)
	lib/math.ci:295: (18 bytes): quad := (e - (4) * f);
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 4.000000
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    sub.f64
	<sinCos+?>:    f64.2i32
	<sinCos+?>:    set.x1 sp(10)
	<sinCos+?>:    inc.sp(-16)
	<sinCos+?>:    jmp <sinCos+?>
	lib/math.ci:298: (3 bytes): k: int32 := x
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    f64.2i32
	lib/math.ci:299: (8 bytes): y := x - (k);
	<sinCos+?>:    dup.x2 sp(3)
	<sinCos+?>:    dup.x1 sp(2)
	<sinCos+?>:    i32.2f64
	<sinCos+?>:    sub.f64
	<sinCos+?>:    set.x2 sp(3)
	lib/math.ci:300: (7 bytes): quad := quad + k;
	<sinCos+?>:    dup.x1 sp(6)
	<sinCos+?>:    dup.x1 sp(1)
	<sinCos+?>:    add.i32
	<sinCos+?>:    set.x1 sp(7)
	lib/math.ci:301: (6 bytes): quad := quad & 3;
	<sinCos+?>:    dup.x1 sp(6)
	<sinCos+?>:    b32.and 0x003
	<sinCos+?>:    set.x1 sp(7)
	<sinCos+?>:    inc.sp(-4)
	lib/math.ci:303: (22 bytes): if (quad & 1)
	<sinCos+?>:    dup.x1 sp(5)
	<sinCos+?>:    b32.and 0x001
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:304: (14 bytes): y := (1) - y;
	<sinCos+?>:    load.f64 1.000000
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    sub.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:306: (17 bytes): if (quad > 1)
	<sinCos+?>:    dup.x1 sp(5)
	<sinCos+?>:    load.c32 1
	<sinCos+?>:    cgt.i32
	<sinCos+?>:    jz <sinCos+?>
	lib/math.ci:307: (5 bytes): y := -y;
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    neg.f64
	<sinCos+?>:    set.x2 sp(2)
	lib/math.ci:310: (5 bytes): ysq: float64 := y * y
	<sinCos+?>:    dup.x2 sp(0)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	lib/math.ci:311: (64 bytes): temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y
	<sinCos+?>:    load.f64 145.968841
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 -13847.272500
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 440103.053538
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 -4942908.100903
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 13578840.978774
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	lib/math.ci:312: (51 bytes): temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    load.f64 132.653491
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 9463.096102
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 408179.225234
	<sinCos+?>:    add.f64
	<sinCos+?>:    dup.x2 sp(4)
	<sinCos+?>:    mul.f64
	<sinCos+?>:    load.f64 8644558.652923
	<sinCos+?>:    add.f64
	lib/math.ci:313: (12 bytes): return .result := temp1 / temp2;
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    dup.x2 sp(2)
	<sinCos+?>:    div.f64
	<sinCos+?>:    set.x2 sp(16)
	<sinCos+?>:    inc.sp(-40)
	<sinCos+?>:    ret
	<sinCos+?>:    inc.sp(-40)
	<sinCos+?>:    ret
}
Math.sin(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/math.ci:317'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param arg: float64 (size: 8 -> f64)
.value: sinCos(arg, 0)
}
Math.cos(arg: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/math.ci:320'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param arg: float64 (size: 8 -> f64)
.value: sinCos(abs(arg), 1)
}
Math.tan(arg: float64): float64: function {
.kind: static const function
.base: `function`
.size: 387
.name: 'tan'
.file: 'lib/math.ci:323'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param arg: float64 (size: 8 -> variable(f64))
.value: {
	complement: bool := false;
	negate: bool := false;
	if (arg < (0)) {
		arg := -arg;
		negate := true;
	}
	arg := (2) * arg / PIO2;
	e: float64;
	x: float64 := modf(arg, e);
	i: int32 := int32(e) % 4;
	if (i == 0) ;
	else {
		if (i == 1) {
			x := (1) - x;
			complement := true;
		}
		else {
			if (i == 2) {
				negate := !negate;
				complement := true;
			}
			else {
				if (i == 3) {
					x := (1) - x;
					negate := !negate;
				}
			}
		}
	}
	xsq: float64 := x * x;
	result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
	result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	if (complement) {
		if (result == (0)) {
			return .result := nan;
		}
		result := (1) / result;
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (387 bytes)
	lib/math.ci:336: (1 bytes): complement: bool := false
	<tan+?>:    load.z32
	lib/math.ci:337: (1 bytes): negate: bool := false
	<tan+?>:    load.z32
	lib/math.ci:339: (23 bytes): if (arg < (0))
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    load.z64
	<tan+?>:    clt.f64
	<tan+?>:    jz <tan+?>
	lib/math.ci:340: (5 bytes): arg := -arg;
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    neg.f64
	<tan+?>:    set.x2 sp(5)
	lib/math.ci:341: (10 bytes): negate := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+4)
	<tan+?>:    store.i8
	lib/math.ci:343: (24 bytes): arg := (2) * arg / PIO2;
	<tan+?>:    load.f64 2.000000
	<tan+?>:    dup.x2 sp(5)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 1.570796
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(5)
	lib/math.ci:345: (1 bytes): e: float64
	<tan+?>:    load.z128
	lib/math.ci:346: (16 bytes): x: float64 := modf(arg, e)
	<tan+?>:    dup.x2 sp(7)
	<tan+?>:    load.sp(+16)
	<tan+?>:    load.ref .?????? ;Math.modf(x: float64, intPart: float64): float64
	<tan+?>:    call
	<tan+?>:    inc.sp(-12)
	lib/math.ci:347: (9 bytes): i: int32 := int32(e) % 4
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    f64.2i32
	<tan+?>:    load.c32 4
	<tan+?>:    mod.i32
	lib/math.ci:349: (122 bytes): if (i == 0)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.z32
	<tan+?>:    ceq.i32
	<tan+?>:    jnz <tan+?>
	lib/math.ci:350: (114 bytes): if (i == 1)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 1
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:351: (14 bytes): x := (1) - x;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    sub.f64
	<tan+?>:    set.x2 sp(3)
	lib/math.ci:352: (10 bytes): complement := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+28)
	<tan+?>:    store.i8
	<tan+?>:    jmp <tan+?>
	lib/math.ci:354: (74 bytes): if (i == 2)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 2
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:355: (11 bytes): negate := !negate;
	<tan+?>:    load.sp(+20)
	<tan+?>:    load.i8
	<tan+?>:    not.b32
	<tan+?>:    load.sp(+24)
	<tan+?>:    store.i8
	lib/math.ci:356: (10 bytes): complement := true;
	<tan+?>:    load.c32 1
	<tan+?>:    load.sp(+28)
	<tan+?>:    store.i8
	<tan+?>:    jmp <tan+?>
	lib/math.ci:358: (37 bytes): if (i == 3)
	<tan+?>:    dup.x1 sp(0)
	<tan+?>:    load.c32 3
	<tan+?>:    ceq.i32
	<tan+?>:    jz <tan+?>
	lib/math.ci:359: (14 bytes): x := (1) - x;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    sub.f64
	<tan+?>:    set.x2 sp(3)
	lib/math.ci:360: (11 bytes): negate := !negate;
	<tan+?>:    load.sp(+20)
	<tan+?>:    load.i8
	<tan+?>:    not.b32
	<tan+?>:    load.sp(+24)
	<tan+?>:    store.i8
	lib/math.ci:363: (5 bytes): xsq: float64 := x * x
	<tan+?>:    dup.x2 sp(1)
	<tan+?>:    dup.x2 sp(3)
	<tan+?>:    mul.f64
	lib/math.ci:364: (64 bytes): result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x
	<tan+?>:    load.f64 0.000034
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 0.034226
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -15.506857
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 1055.970902
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -13068.202648
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(5)
	<tan+?>:    mul.f64
	lib/math.ci:365: (39 bytes): result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    load.f64 -155.503316
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(4)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 4765.751363
	<tan+?>:    add.f64
	<tan+?>:    dup.x2 sp(4)
	<tan+?>:    mul.f64
	<tan+?>:    load.f64 -16638.952389
	<tan+?>:    add.f64
	<tan+?>:    div.f64
	lib/math.ci:367: (49 bytes): if (complement)
	<tan+?>:    load.sp(+40)
	<tan+?>:    load.i8
	<tan+?>:    jz <tan+?>
	lib/math.ci:368: (26 bytes): if (result == (0))
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    load.z64
	<tan+?>:    ceq.f64
	<tan+?>:    jz <tan+?>
	lib/math.ci:369: (18 bytes): return .result := nan;
	<tan+?>:    load.z64
	<tan+?>:    load.f64 0.000000
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	lib/math.ci:371: (14 bytes): result := (1) / result;
	<tan+?>:    load.f64 1.000000
	<tan+?>:    dup.x2 sp(2)
	<tan+?>:    div.f64
	<tan+?>:    set.x2 sp(2)
	lib/math.ci:373: (19 bytes): if (negate)
	<tan+?>:    load.sp(+36)
	<tan+?>:    load.i8
	<tan+?>:    jz <tan+?>
	lib/math.ci:374: (10 bytes): return .result := -result;
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    neg.f64
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	lib/math.ci:376: (9 bytes): return .result := result;
	<tan+?>:    dup.x2 sp(0)
	<tan+?>:    set.x2 sp(16)
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
	<tan+?>:    inc.sp(-44)
	<tan+?>:    ret
}
Math.sinh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 248
.name: 'sinh'
.file: 'lib/math.ci:380'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	negate: bool := false;
	if (x < (0)) {
		x := -x;
		negate := true;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	result: float64;
	if (x > 0.500000) {
		result := (float64.exp(x) - float64.exp(-x)) / (2);
	}
	else {
		sq: float64 := x * x;
		result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (248 bytes)
	lib/math.ci:392: (1 bytes): negate: bool := false
	<sinh+?>:    load.z32
	lib/math.ci:393: (23 bytes): if (x < (0))
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.z64
	<sinh+?>:    clt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:394: (5 bytes): x := -x;
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    neg.f64
	<sinh+?>:    set.x2 sp(4)
	lib/math.ci:395: (10 bytes): negate := true;
	<sinh+?>:    load.c32 1
	<sinh+?>:    load.sp(+4)
	<sinh+?>:    store.i8
	lib/math.ci:398: (39 bytes): if (x > (21))
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.f64 21.000000
	<sinh+?>:    cgt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:399: (23 bytes): return .result := float64.exp(x) / (2);
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    load.f64 2.000000
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(6)
	<sinh+?>:    inc.sp(-4)
	<sinh+?>:    ret
	lib/math.ci:402: (1 bytes): result: float64
	<sinh+?>:    load.z64
	lib/math.ci:403: (151 bytes): if (x > 0.500000)
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    load.f64 0.500000
	<sinh+?>:    cgt.f64
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:404: (26 bytes): result := (float64.exp(x) - float64.exp(-x)) / (2);
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    dup.x2 sp(6)
	<sinh+?>:    neg.f64
	<sinh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<sinh+?>:    sub.f64
	<sinh+?>:    load.f64 2.000000
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(2)
	<sinh+?>:    jmp <sinh+?>
	lib/math.ci:407: (5 bytes): sq: float64 := x * x
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    dup.x2 sp(6)
	<sinh+?>:    mul.f64
	lib/math.ci:408: (53 bytes): result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
	<sinh+?>:    load.f64 -26.305632
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -2894.211356
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -89912.720220
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -630767.364050
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(8)
	<sinh+?>:    mul.f64
	<sinh+?>:    set.x2 sp(4)
	lib/math.ci:409: (43 bytes): result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    dup.x2 sp(2)
	<sinh+?>:    load.f64 -173.678954
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 15215.173788
	<sinh+?>:    add.f64
	<sinh+?>:    dup.x2 sp(4)
	<sinh+?>:    mul.f64
	<sinh+?>:    load.f64 -630767.364050
	<sinh+?>:    add.f64
	<sinh+?>:    div.f64
	<sinh+?>:    set.x2 sp(4)
	<sinh+?>:    inc.sp(-8)
	lib/math.ci:412: (19 bytes): if (negate)
	<sinh+?>:    load.sp(+8)
	<sinh+?>:    load.i8
	<sinh+?>:    jz <sinh+?>
	lib/math.ci:413: (10 bytes): return .result := -result;
	<sinh+?>:    dup.x2 sp(0)
	<sinh+?>:    neg.f64
	<sinh+?>:    set.x2 sp(8)
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
	lib/math.ci:415: (9 bytes): return .result := result;
	<sinh+?>:    dup.x2 sp(0)
	<sinh+?>:    set.x2 sp(8)
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
	<sinh+?>:    inc.sp(-12)
	<sinh+?>:    ret
}
Math.cosh(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 75
.name: 'cosh'
.file: 'lib/math.ci:419'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x < (0)) {
		x := -x;
	}
	if (x > (21)) {
		return .result := float64.exp(x) / (2);
	}
	return .result := (float64.exp(x) + float64.exp(-x)) / (2);
}
.instructions: (75 bytes)
	lib/math.ci:420: (13 bytes): if (x < (0))
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    load.z64
	<cosh+?>:    clt.f64
	<cosh+?>:    jz <cosh+?>
	lib/math.ci:421: (5 bytes): x := -x;
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    neg.f64
	<cosh+?>:    set.x2 sp(3)
	lib/math.ci:423: (35 bytes): if (x > (21))
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    load.f64 21.000000
	<cosh+?>:    cgt.f64
	<cosh+?>:    jz <cosh+?>
	lib/math.ci:424: (19 bytes): return .result := float64.exp(x) / (2);
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    load.f64 2.000000
	<cosh+?>:    div.f64
	<cosh+?>:    set.x2 sp(5)
	<cosh+?>:    ret
	lib/math.ci:426: (27 bytes): return .result := (float64.exp(x) + float64.exp(-x)) / (2);
	<cosh+?>:    dup.x2 sp(1)
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    dup.x2 sp(3)
	<cosh+?>:    neg.f64
	<cosh+?>:    nfc(40) ;float64.exp(x: float64): float64
	<cosh+?>:    add.f64
	<cosh+?>:    load.f64 2.000000
	<cosh+?>:    div.f64
	<cosh+?>:    set.x2 sp(5)
	<cosh+?>:    ret
}
Math.asin(x: float64): float64: function {
.kind: static const function
.base: `function`
.size: 183
.name: 'asin'
.file: 'lib/math.ci:435'
.owner: Math
.param .result: float64 (size: 8 -> variable(f64))
.param x: float64 (size: 8 -> variable(f64))
.value: {
	if (x == (0)) {
		return .result := x;
	}
	negate: bool := false;
	if (x < (0)) {
		negate := true;
		x := -x;
	}
	if (x > (1)) {
		return .result := nan;
	}
	result: float64 := float64.sqrt((1) - x * x);
	if (x > 0.700000) {
		result := pi / (2) - float64.atan2(result, x);
	}
	else {
		result := float64.atan2(x, result);
	}
	if (negate) {
		return .result := -result;
	}
	return .result := result;
}
.instructions: (183 bytes)
	lib/math.ci:436: (13 bytes): if (x == (0))
	<asin+?>:    dup.x2 sp(1)
	<asin+?>:    load.z64
	<asin+?>:    ceq.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:438: (5 bytes): return .result := x;
	<asin+?>:    dup.x2 sp(1)
	<asin+?>:    set.x2 sp(5)
	<asin+?>:    ret
	lib/math.ci:441: (1 bytes): negate: bool := false
	<asin+?>:    load.z32
	lib/math.ci:442: (23 bytes): if (x < (0))
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    load.z64
	<asin+?>:    clt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:443: (10 bytes): negate := true;
	<asin+?>:    load.c32 1
	<asin+?>:    load.sp(+4)
	<asin+?>:    store.i8
	lib/math.ci:444: (5 bytes): x := -x;
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    neg.f64
	<asin+?>:    set.x2 sp(4)
	lib/math.ci:447: (34 bytes): if (x > (1))
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    load.f64 1.000000
	<asin+?>:    cgt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:449: (18 bytes): return .result := nan;
	<asin+?>:    load.z64
	<asin+?>:    load.f64 0.000000
	<asin+?>:    div.f64
	<asin+?>:    set.x2 sp(6)
	<asin+?>:    inc.sp(-4)
	<asin+?>:    ret
	lib/math.ci:452: (19 bytes): result: float64 := float64.sqrt((1) - x * x)
	<asin+?>:    load.f64 1.000000
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    dup.x2 sp(6)
	<asin+?>:    mul.f64
	<asin+?>:    sub.f64
	<asin+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	lib/math.ci:453: (60 bytes): if (x > 0.700000)
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    load.f64 0.700000
	<asin+?>:    cgt.f64
	<asin+?>:    jz <asin+?>
	lib/math.ci:454: (30 bytes): result := pi / (2) - float64.atan2(result, x);
	<asin+?>:    load.f64 3.141593
	<asin+?>:    load.f64 2.000000
	<asin+?>:    div.f64
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    dup.x2 sp(8)
	<asin+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>:    sub.f64
	<asin+?>:    set.x2 sp(2)
	<asin+?>:    jmp <asin+?>
	lib/math.ci:457: (10 bytes): result := float64.atan2(x, result);
	<asin+?>:    dup.x2 sp(4)
	<asin+?>:    dup.x2 sp(2)
	<asin+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<asin+?>:    set.x2 sp(2)
	lib/math.ci:460: (19 bytes): if (negate)
	<asin+?>:    load.sp(+8)
	<asin+?>:    load.i8
	<asin+?>:    jz <asin+?>
	lib/math.ci:461: (10 bytes): return .result := -result;
	<asin+?>:    dup.x2 sp(0)
	<asin+?>:    neg.f64
	<asin+?>:    set.x2 sp(8)
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
	lib/math.ci:463: (9 bytes): return .result := result;
	<asin+?>:    dup.x2 sp(0)
	<asin+?>:    set.x2 sp(8)
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
	<asin+?>:    inc.sp(-12)
	<asin+?>:    ret
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'lib/math.ci:470'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: (pi / (2) - asin(x))
}
Math.deg2rad(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'deg2rad'
.file: 'lib/math.ci:493'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: float64(x * pi / (180))
}
Math.rad2deg(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'rad2deg'
.file: 'lib/math.ci:494'
.owner: Math
.param .result: float64 (size: 8 -> f64)
.param x: float64 (size: 8 -> f64)
.value: float64(x * (180) / pi)
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'lib/math.Complex.ci:3'
.field re: float64 (size: 8 -> const variable(f64))
.field im: float64 (size: 8 -> const variable(f64))
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'lib/math.Complex.ci:4'
.owner: Complex
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'lib/math.Complex.ci:5'
.owner: Complex
.value: 0
}
Complex(re: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'Complex'
.file: 'lib/math.Complex.ci:20'
.param .result: Complex (size: 16 -> variable(val))
.param re: float64 (size: 8 -> variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := (0);
		};
}
.instructions: (8 bytes)
	lib/math.Complex.ci:21: (8 bytes): return .result := {...};
	<Complex+?>:    dup.x2 sp(1)
	<Complex+?>:    set.x2 sp(5)
	:: (3 bytes): .result.im := (0)
	<Complex+?>:    load.z64
	<Complex+?>:    set.x2 sp(7)
	<Complex+?>:    ret
}
Complex(re: float64, im: float64): Complex: function {
.kind: static const function
.base: `function`
.size: 9
.name: 'Complex'
.file: 'lib/math.Complex.ci:25'
.param .result: Complex (size: 16 -> variable(val))
.param re: float64 (size: 8 -> variable(f64))
.param im: float64 (size: 8 -> variable(f64))
.value: {
	return .result := {
			.result.re := re;
			.result.im := im;
		};
}
.instructions: (9 bytes)
	lib/math.Complex.ci:26: (9 bytes): return .result := {...};
	<Complex+?>:    dup.x2 sp(3)
	<Complex+?>:    set.x2 sp(7)
	lib/math.Complex.ci:28: (4 bytes): .result.im := im;
	<Complex+?>:    dup.x2 sp(1)
	<Complex+?>:    set.x2 sp(9)
	<Complex+?>:    ret
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'lib/math.Complex.ci:52'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(-a.re, -a.im)
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:54'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re + b.re, a.im + b.im)
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:55'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> f64)
.value: Complex(a.re + b, a.im)
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'lib/math.Complex.ci:56'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a + b.re, b.im)
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:58'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re - b.re, a.im - b.im)
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:59'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> f64)
.value: Complex(a.re - b, a.im)
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'lib/math.Complex.ci:60'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a - b.re, b.im)
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:62'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:63'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.param b: float64 (size: 8 -> variable(f64))
.value: Complex(a.re * b, a.im * b)
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'lib/math.Complex.ci:64'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> variable(f64))
.param b: Complex (size: 16 -> variable(val))
.value: Complex(a * b.re, a * b.im)
}
div(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 128
.name: 'div'
.file: 'lib/math.Complex.ci:66'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (128 bytes)
	lib/math.Complex.ci:70: (79 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div+?>:    load.z64
	<div+?>:    dup.x2 sp(3)
	<div+?>:    load.ref .?????? ;Math.abs(x: float64): float64
	<div+?>:    call
	<div+?>:    inc.sp(-8)
	<div+?>:    load.z64
	<div+?>:    dup.x2 sp(7)
	<div+?>:    load.ref .?????? ;Math.abs(x: float64): float64
	<div+?>:    call
	<div+?>:    inc.sp(-8)
	<div+?>:    clt.f64
	<div+?>:    jnz <div+?>
	lib/math.Complex.ci:71: (5 bytes): r: float64 := b.im / b.re
	<div+?>:    dup.x2 sp(3)
	<div+?>:    dup.x2 sp(3)
	<div+?>:    div.f64
	lib/math.Complex.ci:72: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>:    dup.x2 sp(3)
	<div+?>:    dup.x2 sp(2)
	<div+?>:    dup.x2 sp(9)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	lib/math.Complex.ci:73: (31 bytes): return .result := {...};
	<div+?>:    dup.x2 sp(9)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    dup.x2 sp(15)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(15)
	lib/math.Complex.ci:75: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>:    dup.x2 sp(11)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    dup.x2 sp(13)
	<div+?>:    mul.f64
	<div+?>:    sub.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(17)
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
	<div+?>:    inc.sp(-16)
	lib/math.Complex.ci:78: (5 bytes): r: float64 := b.re / b.im
	<div+?>:    dup.x2 sp(1)
	<div+?>:    dup.x2 sp(5)
	<div+?>:    div.f64
	lib/math.Complex.ci:79: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>:    dup.x2 sp(5)
	<div+?>:    dup.x2 sp(2)
	<div+?>:    dup.x2 sp(7)
	<div+?>:    mul.f64
	<div+?>:    add.f64
	lib/math.Complex.ci:80: (31 bytes): return .result := {...};
	<div+?>:    dup.x2 sp(9)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    mul.f64
	<div+?>:    dup.x2 sp(13)
	<div+?>:    add.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(15)
	lib/math.Complex.ci:82: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>:    dup.x2 sp(11)
	<div+?>:    dup.x2 sp(4)
	<div+?>:    mul.f64
	<div+?>:    dup.x2 sp(11)
	<div+?>:    sub.f64
	<div+?>:    dup.x2 sp(2)
	<div+?>:    div.f64
	<div+?>:    set.x2 sp(17)
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
	<div+?>:    inc.sp(-16)
	<div+?>:    ret
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/math.Complex.ci:86'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.param b: float64 (size: 8 -> f64)
.value: div(a, Complex(b))
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'lib/math.Complex.ci:87'
.param .result: Complex (size: 16 -> val)
.param a: float64 (size: 8 -> f64)
.param b: Complex (size: 16 -> val)
.value: div(Complex(a), b)
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'lib/math.Complex.ci:89'
.param .result: float64 (size: 8 -> f64)
.param a: Complex (size: 16 -> variable(val))
.value: float64.sqrt(a.re * a.re + a.im * a.im)
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'lib/math.Complex.ci:90'
.param .result: float64 (size: 8 -> f64)
.param a: Complex (size: 16 -> variable(val))
.value: float64.atan2(a.re, a.im)
}
inv(a: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'inv'
.file: 'lib/math.Complex.ci:93'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.value: {
	d: float64 := (a.re * a.re + a.im * a.im);
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (36 bytes)
	lib/math.Complex.ci:94: (11 bytes): d: float64 := (a.re * a.re + a.im * a.im)
	<inv+?>:    dup.x2 sp(1)
	<inv+?>:    dup.x2 sp(3)
	<inv+?>:    mul.f64
	<inv+?>:    dup.x2 sp(5)
	<inv+?>:    dup.x2 sp(7)
	<inv+?>:    mul.f64
	<inv+?>:    add.f64
	lib/math.Complex.ci:95: (20 bytes): return .result := {...};
	<inv+?>:    dup.x2 sp(3)
	<inv+?>:    dup.x2 sp(2)
	<inv+?>:    div.f64
	<inv+?>:    set.x2 sp(9)
	lib/math.Complex.ci:97: (8 bytes): .result.im := -a.im / d;
	<inv+?>:    dup.x2 sp(5)
	<inv+?>:    neg.f64
	<inv+?>:    dup.x2 sp(2)
	<inv+?>:    div.f64
	<inv+?>:    set.x2 sp(11)
	<inv+?>:    inc.sp(-8)
	<inv+?>:    ret
	<inv+?>:    inc.sp(-8)
	<inv+?>:    ret
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'lib/math.Complex.ci:101'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(a.re, -a.im)
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'lib/math.Complex.ci:103'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im))
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'lib/math.Complex.ci:105'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.log(abs(a)), arg(a))
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static const function
.base: `function`
.size: 105
.name: 'pow'
.file: 'lib/math.Complex.ci:107'
.param .result: Complex (size: 16 -> variable(val))
.param a: Complex (size: 16 -> variable(val))
.param b: Complex (size: 16 -> variable(val))
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * float64.log(r);
	v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
	return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
}
.instructions: (105 bytes)
	lib/math.Complex.ci:108: (23 bytes): r: float64 := abs(a)
	<pow+?>:    dup.x4 sp(5)
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(2)
	<pow+?>:    mul.f64
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    mul.f64
	<pow+?>:    add.f64
	<pow+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	<pow+?>:    set.x2 sp(4)
	<pow+?>:    inc.sp(-8)
	lib/math.Complex.ci:109: (16 bytes): t: float64 := arg(a)
	<pow+?>:    dup.x4 sp(7)
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	<pow+?>:    set.x2 sp(4)
	<pow+?>:    inc.sp(-8)
	lib/math.Complex.ci:110: (15 bytes): u: float64 := b.re * t + b.im * float64.log(r)
	<pow+?>:    dup.x2 sp(5)
	<pow+?>:    dup.x2 sp(2)
	<pow+?>:    mul.f64
	<pow+?>:    dup.x2 sp(9)
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    nfc(39) ;float64.log(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    add.f64
	lib/math.Complex.ci:111: (19 bytes): v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    dup.x2 sp(9)
	<pow+?>:    nfc(41) ;float64.pow(x: float64, y: float64): float64
	<pow+?>:    dup.x2 sp(11)
	<pow+?>:    neg.f64
	<pow+?>:    dup.x2 sp(6)
	<pow+?>:    mul.f64
	<pow+?>:    nfc(40) ;float64.exp(x: float64): float64
	<pow+?>:    mul.f64
	lib/math.Complex.ci:112: (27 bytes): return .result := {...};
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(37) ;float64.cos(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    set.x2 sp(19)
	lib/math.Complex.ci:114: (11 bytes): .result.im := v * float64.sin(u);
	<pow+?>:    dup.x2 sp(0)
	<pow+?>:    dup.x2 sp(4)
	<pow+?>:    nfc(36) ;float64.sin(x: float64): float64
	<pow+?>:    mul.f64
	<pow+?>:    set.x2 sp(21)
	<pow+?>:    inc.sp(-32)
	<pow+?>:    ret
	<pow+?>:    inc.sp(-32)
	<pow+?>:    ret
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'lib/math.Complex.ci:117'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.param b: float64 (size: 8 -> f64)
.value: pow(a, Complex(b))
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'lib/math.Complex.ci:119'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im))
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'lib/math.Complex.ci:120'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im))
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'lib/math.Complex.ci:132'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sin(a), cos(a))
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'lib/math.Complex.ci:133'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(cos(a), sin(a))
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'lib/math.Complex.ci:135'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sub(exp(a), exp(neg(a))), 2)
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'lib/math.Complex.ci:136'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(add(exp(a), exp(neg(a))), 2)
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'lib/math.Complex.ci:137'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'lib/math.Complex.ci:138'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> variable(val))
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'lib/math.Complex.ci:140'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(cos(a))
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'lib/math.Complex.ci:141'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(sin(a))
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'lib/math.Complex.ci:142'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(cosh(a))
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'lib/math.Complex.ci:143'
.param .result: Complex (size: 16 -> val)
.param a: Complex (size: 16 -> val)
.value: inv(sinh(a))
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'lib/math.Complex.ci:145'
.param .result: Complex (size: 16 -> val)
.param x: Complex (size: 16 -> variable(val))
.value: Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im))
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'lib/math.Complex.ci:146'
.param .result: Complex (size: 16 -> val)
.param x: Complex (size: 16 -> variable(val))
.value: Complex(abs(x), arg(x))
}
length(str: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 49
.name: 'length'
.file: 'lib/string.ci:3'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (49 bytes)
	lib/string.ci:4: (16 bytes): if ((str) == null)
	<length+?>:    dup.x1 sp(1)
	<length+?>:    load.ref .?????? ;null
	<length+?>:    ceq.i32
	<length+?>:    jz <length+?>
	lib/string.ci:5: (4 bytes): return .result := 0;
	<length+?>:    load.z32
	<length+?>:    set.x1 sp(3)
	<length+?>:    ret
	lib/string.ci:7: (1 bytes): result: int32 := 0
	<length+?>:    load.z32
	lib/string.ci:8: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>:    jmp <length+?>
	lib/string.ci:8: (4 bytes): result := result + 1
	<length+?>:    inc.i32(+1)
	lib/string.ci:8: (10 bytes): str[result]
	<length+?>:    dup.x1 sp(2)
	<length+?>:    dup.x1 sp(1)
	<length+?>:    add.i32
	<length+?>:    load.i8
	<length+?>:    jnz <length+?>
	lib/string.ci:10: (9 bytes): return .result := result;
	<length+?>:    dup.x1 sp(0)
	<length+?>:    set.x1 sp(4)
	<length+?>:    inc.sp(-4)
	<length+?>:    ret
	<length+?>:    inc.sp(-4)
	<length+?>:    ret
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 56
.name: 'indexOf'
.file: 'lib/string.ci:14'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param chr: char (size: 4 -> variable(i32))
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (56 bytes)
	lib/string.ci:15: (48 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf+?>:    load.z32
	<indexOf+?>:    jmp <indexOf+?>
	lib/string.ci:16: (25 bytes): if (str[i] == chr)
	<indexOf+?>:    dup.x1 sp(3)
	<indexOf+?>:    dup.x1 sp(1)
	<indexOf+?>:    add.i32
	<indexOf+?>:    load.i8
	<indexOf+?>:    load.sp(+12)
	<indexOf+?>:    load.i8
	<indexOf+?>:    ceq.i32
	<indexOf+?>:    jz <indexOf+?>
	lib/string.ci:17: (9 bytes): return .result := i;
	<indexOf+?>:    dup.x1 sp(0)
	<indexOf+?>:    set.x1 sp(5)
	<indexOf+?>:    inc.sp(-4)
	<indexOf+?>:    ret
	lib/string.ci:15: (4 bytes): i := i + 1
	<indexOf+?>:    inc.i32(+1)
	lib/string.ci:15: (10 bytes): str[i]
	<indexOf+?>:    dup.x1 sp(3)
	<indexOf+?>:    dup.x1 sp(1)
	<indexOf+?>:    add.i32
	<indexOf+?>:    load.i8
	<indexOf+?>:    jnz <indexOf+?>
	<indexOf+?>:    inc.sp(-4)
	lib/string.ci:20: (8 bytes): return .result := -1;
	<indexOf+?>:    load.c32 -1
	<indexOf+?>:    set.x1 sp(4)
	<indexOf+?>:    ret
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static const function
.base: `function`
.size: 62
.name: 'lastIndexOf'
.file: 'lib/string.ci:24'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param chr: char (size: 4 -> variable(i32))
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (62 bytes)
	lib/string.ci:25: (5 bytes): result: int32 := -1
	<lastIndexOf+?>:    load.c32 -1
	lib/string.ci:26: (43 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>:    load.z32
	<lastIndexOf+?>:    jmp <lastIndexOf+?>
	lib/string.ci:27: (20 bytes): if (str[i] == chr)
	<lastIndexOf+?>:    dup.x1 sp(4)
	<lastIndexOf+?>:    dup.x1 sp(1)
	<lastIndexOf+?>:    add.i32
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    load.sp(+16)
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    ceq.i32
	<lastIndexOf+?>:    jz <lastIndexOf+?>
	lib/string.ci:28: (4 bytes): result := i;
	<lastIndexOf+?>:    dup.x1 sp(0)
	<lastIndexOf+?>:    set.x1 sp(2)
	lib/string.ci:26: (4 bytes): i := i + 1
	<lastIndexOf+?>:    inc.i32(+1)
	lib/string.ci:26: (10 bytes): str[i]
	<lastIndexOf+?>:    dup.x1 sp(4)
	<lastIndexOf+?>:    dup.x1 sp(1)
	<lastIndexOf+?>:    add.i32
	<lastIndexOf+?>:    load.i8
	<lastIndexOf+?>:    jnz <lastIndexOf+?>
	<lastIndexOf+?>:    inc.sp(-4)
	lib/string.ci:31: (9 bytes): return .result := result;
	<lastIndexOf+?>:    dup.x1 sp(0)
	<lastIndexOf+?>:    set.x1 sp(5)
	<lastIndexOf+?>:    inc.sp(-4)
	<lastIndexOf+?>:    ret
	<lastIndexOf+?>:    inc.sp(-4)
	<lastIndexOf+?>:    ret
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'lib/string.ci:35'
.param .result: bool (size: 4 -> variable(bool))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	lib/string.ci:36: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith+?>:    load.z32
	<startsWith+?>:    jmp <startsWith+?>
	lib/string.ci:37: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>:    load.z32
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    dup.x1 sp(2)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    dup.x1 sp(3)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    dup.x1 sp(5)
	<startsWith+?>:    call
	<startsWith+?>:    inc.sp(-8)
	<startsWith+?>:    load.z32
	<startsWith+?>:    ceq.i32
	<startsWith+?>:    jnz <startsWith+?>
	lib/string.ci:38: (11 bytes): return .result := false;
	<startsWith+?>:    load.z32
	<startsWith+?>:    load.sp(+24)
	<startsWith+?>:    store.i8
	<startsWith+?>:    inc.sp(-4)
	<startsWith+?>:    ret
	lib/string.ci:36: (4 bytes): i := i + 1
	<startsWith+?>:    inc.i32(+1)
	lib/string.ci:36: (12 bytes): (with[i]) != 0
	<startsWith+?>:    dup.x1 sp(3)
	<startsWith+?>:    dup.x1 sp(1)
	<startsWith+?>:    add.i32
	<startsWith+?>:    load.i8
	<startsWith+?>:    load.z32
	<startsWith+?>:    ceq.i32
	<startsWith+?>:    jz <startsWith+?>
	<startsWith+?>:    inc.sp(-4)
	lib/string.ci:41: (11 bytes): return .result := true;
	<startsWith+?>:    load.c32 1
	<startsWith+?>:    load.sp(+20)
	<startsWith+?>:    store.i8
	<startsWith+?>:    ret
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static const function
.base: `function`
.size: 131
.name: 'endsWith'
.file: 'lib/string.ci:44'
.param .result: bool (size: 4 -> variable(bool))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (131 bytes)
	lib/string.ci:45: (13 bytes): withLen: int32 := length(with)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    load.ref .?????? ;length(str: char[*]): int32
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:46: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(5)
	<endsWith+?>:    load.ref .?????? ;length(str: char[*]): int32
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:47: (20 bytes): if (strLen < withLen)
	<endsWith+?>:    dup.x1 sp(0)
	<endsWith+?>:    dup.x1 sp(2)
	<endsWith+?>:    clt.i32
	<endsWith+?>:    jz <endsWith+?>
	lib/string.ci:48: (11 bytes): return .result := false;
	<endsWith+?>:    load.z32
	<endsWith+?>:    load.sp(+28)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
	lib/string.ci:50: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>:    load.z32
	<endsWith+?>:    jmp <endsWith+?>
	lib/string.ci:51: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>:    load.z32
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    dup.x1 sp(5)
	<endsWith+?>:    sub.i32
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    add.i32
	<endsWith+?>:    add.i32
	<endsWith+?>:    load.i8
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    add.i32
	<endsWith+?>:    load.i8
	<endsWith+?>:    dup.x1 sp(7)
	<endsWith+?>:    call
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    load.z32
	<endsWith+?>:    ceq.i32
	<endsWith+?>:    jnz <endsWith+?>
	lib/string.ci:52: (11 bytes): return .result := false;
	<endsWith+?>:    load.z32
	<endsWith+?>:    load.sp(+32)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-12)
	<endsWith+?>:    ret
	lib/string.ci:50: (4 bytes): i := i + 1
	<endsWith+?>:    inc.i32(+1)
	lib/string.ci:50: (9 bytes): i < withLen
	<endsWith+?>:    dup.x1 sp(0)
	<endsWith+?>:    dup.x1 sp(3)
	<endsWith+?>:    clt.i32
	<endsWith+?>:    jnz <endsWith+?>
	<endsWith+?>:    inc.sp(-4)
	lib/string.ci:55: (15 bytes): return .result := true;
	<endsWith+?>:    load.c32 1
	<endsWith+?>:    load.sp(+28)
	<endsWith+?>:    store.i8
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
	<endsWith+?>:    inc.sp(-8)
	<endsWith+?>:    ret
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static const function
.base: `function`
.size: 74
.name: 'compare'
.file: 'lib/string.ci:58'
.param .result: int32 (size: 4 -> variable(i32))
.param str: char[*] (size: 4 -> variable(ref))
.param with: char[*] (size: 4 -> variable(ref))
.param cmp: function (size: 4 -> variable(ref))
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (74 bytes)
	lib/string.ci:59: (1 bytes): result: int32 := 0
	<compare+?>:    load.z32
	lib/string.ci:60: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>:    load.z32
	<compare+?>:    jmp <compare+?>
	lib/string.ci:61: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>:    load.z32
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    dup.x1 sp(2)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    dup.x1 sp(3)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    dup.x1 sp(6)
	<compare+?>:    call
	<compare+?>:    inc.sp(-8)
	<compare+?>:    set.x1 sp(2)
	lib/string.ci:62: (16 bytes): if ((str[i]) == 0)
	<compare+?>:    dup.x1 sp(5)
	<compare+?>:    dup.x1 sp(1)
	<compare+?>:    add.i32
	<compare+?>:    load.i8
	<compare+?>:    load.z32
	<compare+?>:    ceq.i32
	<compare+?>:    jz <compare+?>
	lib/string.ci:63: (4 bytes): break;
	<compare+?>:    jmp <compare+?>
	lib/string.ci:60: (4 bytes): i := i + 1
	<compare+?>:    inc.i32(+1)
	lib/string.ci:60: (8 bytes): result == 0
	<compare+?>:    dup.x1 sp(1)
	<compare+?>:    load.z32
	<compare+?>:    ceq.i32
	<compare+?>:    jnz <compare+?>
	<compare+?>:    inc.sp(-4)
	lib/string.ci:66: (9 bytes): return .result := result;
	<compare+?>:    dup.x1 sp(0)
	<compare+?>:    set.x1 sp(6)
	<compare+?>:    inc.sp(-4)
	<compare+?>:    ret
	<compare+?>:    inc.sp(-4)
	<compare+?>:    ret
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'lib/string.ci:70'
.param .result: int32 (size: 4 -> variable(i32))
.param chr: char (size: 4 -> variable(i32))
.param with: char (size: 4 -> variable(i32))
.value: {
	static const ignCase(chr: char): char := {
		if (chr >= 'A' && chr <= 'Z') {
			chr := chr - 'A';
			chr := chr + 'a';
		}
		return .result := chr;
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	lib/string.ci:79: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp+?>:    load.z32
	<ignCaseCmp+?>:    load.sp(+12)
	<ignCaseCmp+?>:    load.i8
	<ignCaseCmp+?>:    load.ref .?????? ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>:    call
	<ignCaseCmp+?>:    inc.sp(-4)
	<ignCaseCmp+?>:    load.z32
	<ignCaseCmp+?>:    load.sp(+12)
	<ignCaseCmp+?>:    load.i8
	<ignCaseCmp+?>:    load.ref .?????? ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>:    call
	<ignCaseCmp+?>:    inc.sp(-4)
	<ignCaseCmp+?>:    sub.i32
	<ignCaseCmp+?>:    set.x1 sp(4)
	<ignCaseCmp+?>:    ret
}
caseCmp(chr: char, with: char): int32: function {
.kind: static const function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'lib/string.ci:82'
.param .result: int32 (size: 4 -> variable(i32))
.param chr: char (size: 4 -> variable(i32))
.param with: char (size: 4 -> variable(i32))
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	lib/string.ci:83: (14 bytes): return .result := chr - with;
	<caseCmp+?>:    load.sp(+8)
	<caseCmp+?>:    load.i8
	<caseCmp+?>:    load.sp(+8)
	<caseCmp+?>:    load.i8
	<caseCmp+?>:    sub.i32
	<caseCmp+?>:    set.x1 sp(4)
	<caseCmp+?>:    ret
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'lib/string.ci:86'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: startsWith(str, with, caseCmp)
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'lib/string.ci:87'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: endsWith(str, with, caseCmp)
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'lib/string.ci:88'
.param .result: int32 (size: 4 -> i32)
.param str: char[*] (size: 4 -> ref)
.param with: char[*] (size: 4 -> ref)
.value: compare(str, with, caseCmp)
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'lib/string.ci:90'
.param .result: bool (size: 1 -> bool)
.param str: char[*] (size: 4 -> ref)
.param chr: char (size: 4 -> i32)
.value: indexOf(str, chr) >= 0
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'lib/string.ci:104'
.field radix: int32 (size: 4 -> const variable(i32))
.field sign: char (size: 1 -> const variable(i32))
.field padChr: char (size: 1 -> const variable(i32))
.field padLen: int32 (size: 4 -> const variable(i32))
.field precision: int32 (size: 4 -> const variable(i32))
}
FormatFlags.radix: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'radix'
.file: 'lib/string.ci:105'
.owner: FormatFlags
}
FormatFlags.sign: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'sign'
.file: 'lib/string.ci:106'
.owner: FormatFlags
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'lib/string.ci:107'
.owner: FormatFlags
}
FormatFlags.padLen: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padLen'
.file: 'lib/string.ci:108'
.owner: FormatFlags
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'lib/string.ci:109'
.owner: FormatFlags
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static const function
.base: `function`
.size: 85
.name: 'append'
.file: 'lib/string.ci:112'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: char[*] (size: 4 -> variable(ref))
.value: {
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (85 bytes)
	lib/string.ci:113: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append+?>:    load.z32
	<append+?>:    jmp <append+?>
	lib/string.ci:114: (13 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(3)
	<append+?>:    dup.x1 sp(6)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:115: (4 bytes): break;
	<append+?>:    jmp <append+?>
	lib/string.ci:117: (12 bytes): output[pos] := value[i];
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(5)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:118: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(3)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(4)
	lib/string.ci:113: (4 bytes): i := i + 1
	<append+?>:    inc.i32(+1)
	lib/string.ci:113: (10 bytes): value[i]
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    jnz <append+?>
	<append+?>:    inc.sp(-4)
	lib/string.ci:121: (17 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(2)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:122: (8 bytes): pos := (output.length - (1));
	<append+?>:    dup.x1 sp(4)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(3)
	lib/string.ci:124: (7 bytes): output[pos] := (0);
	<append+?>:    load.z32
	<append+?>:    dup.x1 sp(4)
	<append+?>:    dup.x1 sp(4)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:125: (5 bytes): return .result := pos;
	<append+?>:    dup.x1 sp(2)
	<append+?>:    set.x1 sp(6)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: static const function
.base: `function`
.size: 623
.name: 'append'
.file: 'lib/string.ci:128'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: uint32 (size: 4 -> variable(u32))
.param format: FormatFlags (size: 4 -> variable(ref))
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80];
	radix: int32 := format.radix;
	assert(radix > 1 && radix < (radixDigits.length));
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.padLen - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if (format.sign != '') {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := format.sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (623 bytes)
	lib/string.ci:132: (1 bytes): len: int32 := 0
	<append+?>:    load.z32
	lib/string.ci:133: (4 bytes): digits: char[80]
	<append+?>:    inc.sp(+80)
	lib/string.ci:135: (3 bytes): radix: int32 := format.radix
	<append+?>:    dup.x1 sp(22)
	<append+?>:    load.i32
	lib/string.ci:136: (63 bytes): assert(radix > 1 && radix < (radixDigits.length));
	<append+?>:    dup.x1 sp(0)
	<append+?>:    load.c32 1
	<append+?>:    cgt.i32
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.m32 .?????? ;append.radixDigits+4
	<append+?>:    clt.i32
	<append+?>:    and.b32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 136
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:139: (46 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>:    jmp <append+?>
	lib/string.ci:140: (27 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>:    load.m32 .?????? ;append.radixDigits
	<append+?>:    dup.x1 sp(25)
	<append+?>:    dup.x1 sp(2)
	<append+?>:    mod.u32
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    load.sp(+8)
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+1)
	<append+?>:    dup.x1 sp(0)
	<append+?>:    set.x1 sp(25)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:139: (7 bytes): value := value / (radix)
	<append+?>:    dup.x1 sp(24)
	<append+?>:    dup.x1 sp(1)
	<append+?>:    div.u32
	<append+?>:    set.x1 sp(25)
	lib/string.ci:139: (8 bytes): value > (0)
	<append+?>:    dup.x1 sp(24)
	<append+?>:    load.z32
	<append+?>:    cgt.u32
	<append+?>:    jnz <append+?>
	lib/string.ci:142: (29 bytes): if (len == 0)
	<append+?>:    dup.x1 sp(21)
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jz <append+?>
	lib/string.ci:143: (21 bytes): digits[len := len + 1] := '0';
	<append+?>:    load.c32 48
	<append+?>:    load.sp(+8)
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+1)
	<append+?>:    dup.x1 sp(0)
	<append+?>:    set.x1 sp(25)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:146: (10 bytes): maxLen: int32 := format.padLen - len
	<append+?>:    dup.x1 sp(23)
	<append+?>:    inc.i32(+8)
	<append+?>:    load.i32
	<append+?>:    dup.x1 sp(22)
	<append+?>:    sub.i32
	lib/string.ci:148: (7 bytes): padChr: char := format.padChr
	<append+?>:    dup.x1 sp(24)
	<append+?>:    inc.i32(+5)
	<append+?>:    load.i8
	lib/string.ci:149: (21 bytes): if (padChr == '')
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jz <append+?>
	lib/string.ci:150: (10 bytes): padChr := ' ';
	<append+?>:    load.c32 32
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	lib/string.ci:154: (211 bytes): if (format.sign != '')
	<append+?>:    dup.x1 sp(25)
	<append+?>:    inc.i32(+4)
	<append+?>:    load.i8
	<append+?>:    load.z32
	<append+?>:    ceq.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:155: (8 bytes): maxLen := maxLen - 1;
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:156: (117 bytes): if (contains(whiteSpace, padChr))
	<append+?>:    load.z32
	<append+?>:    load.m32 .?????? ;append.whiteSpace
	<append+?>:    load.sp(+8)
	<append+?>:    load.i8
	<append+?>:    load.ref .?????? ;indexOf(str: char[*], chr: char): int32
	<append+?>:    call
	<append+?>:    inc.sp(-8)
	<append+?>:    load.z32
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:158: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>:    jmp <append+?>
	lib/string.ci:159: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 159
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:160: (11 bytes): output[pos] := padChr;
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:161: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:158: (8 bytes): maxLen := maxLen - 1
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:158: (8 bytes): maxLen > 0
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.z32
	<append+?>:    cgt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:164: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 164
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:165: (13 bytes): output[pos] := format.sign;
	<append+?>:    dup.x1 sp(25)
	<append+?>:    inc.i32(+4)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:166: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:170: (91 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>:    jmp <append+?>
	lib/string.ci:171: (52 bytes): assert(pos < (output.length));
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 171
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:172: (11 bytes): output[pos] := padChr;
	<append+?>:    load.sp(+0)
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:173: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:170: (8 bytes): maxLen := maxLen - 1
	<append+?>:    dup.x1 sp(1)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(2)
	lib/string.ci:170: (8 bytes): maxLen > 0
	<append+?>:    dup.x1 sp(1)
	<append+?>:    load.z32
	<append+?>:    cgt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:177: (99 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>:    load.z32
	<append+?>:    jmp <append+?>
	lib/string.ci:178: (52 bytes): assert(i < (output.length));
	<append+?>:    dup.x1 sp(0)
	<append+?>:    dup.x1 sp(31)
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	<append+?>:    jmp <append+?>
	<append+?>:    load.ref .?????? ;"lib/string.ci"
	<append+?>:    load.c32 178
	<append+?>:    load.c32 -2
	<append+?>:    load.c32 128
	<append+?>:    load.ref .?????? ;"assertion failed!"
	<append+?>:    load.ref .?????? ;pointer
	<append+?>:    load.ref .?????? ;null
	<append+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	lib/string.ci:179: (17 bytes): output[pos] := digits[len - i];
	<append+?>:    load.sp(+16)
	<append+?>:    dup.x1 sp(25)
	<append+?>:    dup.x1 sp(2)
	<append+?>:    sub.i32
	<append+?>:    add.i32
	<append+?>:    load.i8
	<append+?>:    dup.x1 sp(30)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:180: (8 bytes): pos := pos + 1;
	<append+?>:    dup.x1 sp(28)
	<append+?>:    inc.i32(+1)
	<append+?>:    set.x1 sp(29)
	lib/string.ci:177: (4 bytes): i := i + 1
	<append+?>:    inc.i32(+1)
	lib/string.ci:177: (9 bytes): i < len
	<append+?>:    dup.x1 sp(0)
	<append+?>:    dup.x1 sp(25)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	<append+?>:    inc.sp(-4)
	lib/string.ci:183: (17 bytes): if (pos >= (output.length))
	<append+?>:    dup.x1 sp(27)
	<append+?>:    dup.x1 sp(30)
	<append+?>:    clt.i32
	<append+?>:    jnz <append+?>
	lib/string.ci:184: (8 bytes): pos := (output.length - (1));
	<append+?>:    dup.x1 sp(29)
	<append+?>:    inc.i32(-1)
	<append+?>:    set.x1 sp(28)
	lib/string.ci:186: (7 bytes): output[pos] := (0);
	<append+?>:    load.z32
	<append+?>:    dup.x1 sp(29)
	<append+?>:    dup.x1 sp(29)
	<append+?>:    add.i32
	<append+?>:    store.i8
	lib/string.ci:187: (9 bytes): return .result := pos;
	<append+?>:    dup.x1 sp(27)
	<append+?>:    set.x1 sp(31)
	<append+?>:    inc.sp(-96)
	<append+?>:    ret
	<append+?>:    inc.sp(-96)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: uint32): int32: function {
.kind: static const function
.base: `function`
.size: 25
.name: 'append'
.file: 'lib/string.ci:190'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: uint32 (size: 4 -> variable(u32))
.value: {
	static const format: FormatFlags := {
		format.radix := 10;
		format.sign := '';
		format.padChr := ' ';
		format.padLen := 0;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (25 bytes)
	lib/string.ci:198: (25 bytes): return .result := append(output, pos, value, format);
	<append+?>:    load.z32
	<append+?>:    dup.x2 sp(4)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    dup.x1 sp(5)
	<append+?>:    load.ref .?????? ;append.format
	<append+?>:    load.ref .?????? ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>:    call
	<append+?>:    inc.sp(-20)
	<append+?>:    set.x1 sp(6)
	<append+?>:    ret
}
append(output: char[], pos: int32, value: int32, forceSign: bool, pad: int32): int32: function {
.kind: static const function
.base: `function`
.size: 118
.name: 'append'
.file: 'lib/string.ci:200'
.param .result: int32 (size: 4 -> variable(i32))
.param output: char[] (size: 8 -> variable(arr))
.param pos: int32 (size: 4 -> variable(i32))
.param value: int32 (size: 4 -> variable(i32))
.param forceSign: bool (size: 4 -> variable(bool))
.param pad: int32 (size: 4 -> variable(i32))
.value: {
	sign: char := 0;
	if (value < 0) {
		value := -value;
		sign := '-';
	}
	else {
		if (forceSign) {
			sign := '+';
		}
	}
	const format: FormatFlags := {
		format.radix := 10;
		format.sign := sign;
		format.padChr := '0';
		format.padLen := pad;
		format.precision := 0;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (118 bytes)
	lib/string.ci:201: (1 bytes): sign: char := 0
	<append+?>:    load.z32
	lib/string.ci:202: (46 bytes): if (value < 0)
	<append+?>:    dup.x1 sp(4)
	<append+?>:    load.z32
	<append+?>:    clt.i32
	<append+?>:    jz <append+?>
	lib/string.ci:203: (5 bytes): value := -value;
	<append+?>:    dup.x1 sp(4)
	<append+?>:    neg.i32
	<append+?>:    set.x1 sp(5)
	lib/string.ci:204: (10 bytes): sign := '-';
	<append+?>:    load.c32 45
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	<append+?>:    jmp <append+?>
	lib/string.ci:206: (19 bytes): if (forceSign)
	<append+?>:    load.sp(+12)
	<append+?>:    load.i8
	<append+?>:    jz <append+?>
	lib/string.ci:207: (10 bytes): sign := '+';
	<append+?>:    load.c32 43
	<append+?>:    load.sp(+4)
	<append+?>:    store.i8
	lib/string.ci:209: (38 bytes): const format: FormatFlags := {...}
	<append+?>:    inc.sp(+16)
	lib/string.ci:210: (7 bytes): format.radix := 10;
	<append+?>:    load.c32 10
	<append+?>:    set.x1 sp(1)
	lib/string.ci:211: (10 bytes): format.sign := sign;
	<append+?>:    load.sp(+16)
	<append+?>:    load.i8
	<append+?>:    load.sp(+8)
	<append+?>:    store.i8
	lib/string.ci:212: (10 bytes): format.padChr := '0';
	<append+?>:    load.c32 48
	<append+?>:    load.sp(+9)
	<append+?>:    store.i8
	lib/string.ci:213: (4 bytes): format.padLen := pad;
	<append+?>:    dup.x1 sp(6)
	<append+?>:    set.x1 sp(3)
	lib/string.ci:214: (3 bytes): format.precision := 0;
	<append+?>:    load.z32
	<append+?>:    set.x1 sp(4)
	lib/string.ci:216: (28 bytes): return .result := append(output, pos, value, format);
	<append+?>:    load.z32
	<append+?>:    dup.x2 sp(11)
	<append+?>:    dup.x1 sp(12)
	<append+?>:    dup.x1 sp(12)
	<append+?>:    load.sp(+20)
	<append+?>:    load.ref .?????? ;append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
	<append+?>:    call
	<append+?>:    inc.sp(-20)
	<append+?>:    set.x1 sp(13)
	<append+?>:    inc.sp(-20)
	<append+?>:    ret
	<append+?>:    inc.sp(-20)
	<append+?>:    ret
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'integer'
.file: 'test.ci:4'
.value: int64
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitldz32'
.file: 'test/lang.inlineEmit.ci:3'
.value: emit(load.z32)
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitldz64'
.file: 'test/lang.inlineEmit.ci:4'
.value: emit(load.z64)
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitA'
.file: 'test/lang.inlineEmit.ci:6'
.value: 42
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitB'
.file: 'test/lang.inlineEmit.ci:7'
.value: 96
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitAddI32'
.file: 'test/lang.inlineEmit.ci:9'
.value: emit(int32(emitA), int32(emitB), add.i32)
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitDivI32'
.file: 'test/lang.inlineEmit.ci:10'
.value: emit(int32(10), int32(5), div.i32)
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'emitNfcF32'
.file: 'test/lang.inlineEmit.ci:11'
.value: emit(float32(3.140000 / (2)), float32.sin)
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt32'
.file: 'test/lang.inlineEmit.ci:14'
.param .result: int32 (size: 4 -> i32)
.param value: float32 (size: 4 -> f32)
.value: int32(emit(float32(value)))
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt64'
.file: 'test/lang.inlineEmit.ci:15'
.param .result: int64 (size: 8 -> i64)
.param value: float64 (size: 8 -> f64)
.value: int64(emit(float64(value)))
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt1'
.file: 'test/lang.inlineEmit.ci:17'
.value: floatAsInt32(500)
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt2'
.file: 'test/lang.inlineEmit.ci:18'
.value: floatAsInt32(500)
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt3'
.file: 'test/lang.inlineEmit.ci:19'
.value: floatAsInt64(500)
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt4'
.file: 'test/lang.inlineEmit.ci:20'
.value: floatAsInt64(500)
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'emitSlice'
.file: 'test/lang.inlineEmit.ci:23'
.value: emit(int32(3), pointer("string"))
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'zero'
.file: 'test/lang.inlineMacros.ci:3'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: 0
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'last'
.file: 'test/lang.inlineMacros.ci:4'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: b
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'test/lang.inlineMacros.ci:5'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: a + b
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'test/lang.inlineMacros.ci:6'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> variable(i32))
.param b: int32 (size: 4 -> i32)
.value: (a) ? a : b
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'test/lang.inlineMacros.ci:7'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> variable(i32))
.param b: int32 (size: 4 -> variable(i32))
.value: a < b ? a : b
}
sum(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'test/lang.inlineMacros.ci:9'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: sum(sum(a, b), c)
}
any(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'test/lang.inlineMacros.ci:10'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: any(any(a, b), c)
}
min(a: int32, b: int32, c: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'test/lang.inlineMacros.ci:11'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.param c: int32 (size: 4 -> i32)
.value: min(min(a, b), c)
}
ma: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'ma'
.file: 'test/lang.inlineMacros.ci:13'
.value: 3
}
mb: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'mb'
.file: 'test/lang.inlineMacros.ci:14'
.value: 6
}
mc: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'mc'
.file: 'test/lang.inlineMacros.ci:15'
.value: 9
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVal'
.file: 'test/lang.inlineMacros.ci:17'
.value: zero(2, 3)
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVar'
.file: 'test/lang.inlineMacros.ci:18'
.value: zero(ma, mb)
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroXpr'
.file: 'test/lang.inlineMacros.ci:19'
.value: zero(ma + mb, mb + mc)
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVal'
.file: 'test/lang.inlineMacros.ci:21'
.value: last(2, 3)
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVar'
.file: 'test/lang.inlineMacros.ci:22'
.value: last(ma, mb)
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastXpr'
.file: 'test/lang.inlineMacros.ci:23'
.value: last(ma + mb, mb + mc)
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Val'
.file: 'test/lang.inlineMacros.ci:25'
.value: sum(3, 12)
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Var'
.file: 'test/lang.inlineMacros.ci:26'
.value: sum(ma, mb)
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Xpr'
.file: 'test/lang.inlineMacros.ci:27'
.value: sum(ma + mb, mb + mc)
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Val'
.file: 'test/lang.inlineMacros.ci:29'
.value: any(3, 12)
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Var'
.file: 'test/lang.inlineMacros.ci:30'
.value: any(ma, mb)
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Xpr'
.file: 'test/lang.inlineMacros.ci:31'
.value: any(ma + mb, mb + mc)
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Val'
.file: 'test/lang.inlineMacros.ci:33'
.value: min(3, 12)
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Var'
.file: 'test/lang.inlineMacros.ci:34'
.value: min(ma, mb)
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Xpr'
.file: 'test/lang.inlineMacros.ci:35'
.value: min(ma + mb, mb + mc)
}
sum3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Val'
.file: 'test/lang.inlineMacros.ci:37'
.value: sum(3, 2, 6)
}
sum3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Var'
.file: 'test/lang.inlineMacros.ci:38'
.value: sum(ma, mb, mc)
}
sum3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum3Xpr'
.file: 'test/lang.inlineMacros.ci:39'
.value: sum(ma + mb, mb + mc, mc + ma)
}
any3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Val'
.file: 'test/lang.inlineMacros.ci:41'
.value: any(3, 2, 6)
}
any3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Var'
.file: 'test/lang.inlineMacros.ci:42'
.value: any(ma, mb, mc)
}
any3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any3Xpr'
.file: 'test/lang.inlineMacros.ci:43'
.value: any(ma + mb, mb + mc, mc + ma)
}
min3Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Val'
.file: 'test/lang.inlineMacros.ci:45'
.value: min(3, 2, 6)
}
min3Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Var'
.file: 'test/lang.inlineMacros.ci:46'
.value: min(ma, mb, mc)
}
min3Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min3Xpr'
.file: 'test/lang.inlineMacros.ci:47'
.value: min(ma + mb, mb + mc, mc + ma)
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci:3'
.value: 1
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci:4'
.param .result: int32 (size: 4 -> i32)
.value: 2
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci:5'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.value: 3
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci:6'
.param .result: int32 (size: 4 -> i32)
.param a: float32 (size: 4 -> f32)
.value: 4
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'test/test.inlineOverload.ci:7'
.param .result: int32 (size: 4 -> i32)
.param a: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: 5
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload1'
.file: 'test/test.inlineOverload.ci:9'
.value: overload
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload2'
.file: 'test/test.inlineOverload.ci:10'
.value: overload()
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload3'
.file: 'test/test.inlineOverload.ci:11'
.value: overload(0)
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload4'
.file: 'test/test.inlineOverload.ci:12'
.value: overload(0.000000)
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload5'
.file: 'test/test.inlineOverload.ci:13'
.value: overload(0, 0)
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci:15'
.field degrees: float64 (size: 8 -> variable(f64))
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'test/test.inlineOverload.ci:15'
.owner: Celsius
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci:16'
.field degrees: float64 (size: 8 -> variable(f64))
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'test/test.inlineOverload.ci:16'
.owner: Fahrenheit
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci:21'
.param .result: Celsius (size: 8 -> val)
.param value: float64 (size: 8 -> f64)
.value: Celsius(emit(float64(value)))
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci:22'
.param .result: Fahrenheit (size: 8 -> val)
.param value: float64 (size: 8 -> f64)
.value: Fahrenheit(emit(float64(value)))
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'test/test.inlineOverload.ci:25'
.param .result: Celsius (size: 8 -> val)
.param value: Fahrenheit (size: 8 -> val)
.value: Celsius((value.degrees - (32)) / 1.800000)
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'test/test.inlineOverload.ci:26'
.param .result: Fahrenheit (size: 8 -> val)
.param value: Celsius (size: 8 -> val)
.value: Fahrenheit(value.degrees * 1.800000 + (32))
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.name: 'boilC'
.file: 'test/test.inlineOverload.ci:28'
.value: Celsius(100.000000)
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.name: 'boilF'
.file: 'test/test.inlineOverload.ci:29'
.value: Fahrenheit(boilC)
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'test/lang.initByRef.ci:7'
.value: 42
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'valueRef'
.file: 'test/lang.initByRef.ci:8'
.value: value
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valuePtr'
.file: 'test/lang.initByRef.ci:9'
.value: value
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueVar'
.file: 'test/lang.initByRef.ci:10'
.value: value
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'fromRef'
.file: 'test/lang.initByRef.ci:12'
.value: valueRef
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromPtr'
.file: 'test/lang.initByRef.ci:13'
.value: valuePtr
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromVar'
.file: 'test/lang.initByRef.ci:14'
.value: valueVar
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'nullRef'
.file: 'test/lang.initByRef.ci:16'
.value: null
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'nullPtr'
.file: 'test/lang.initByRef.ci:17'
.value: null
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'nullVar'
.file: 'test/lang.initByRef.ci:18'
.value: null
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'nullTyp'
.file: 'test/lang.initByRef.ci:19'
.value: null
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'nullFun'
.file: 'test/lang.initByRef.ci:20'
.value: null
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'nullObj'
.file: 'test/lang.initByRef.ci:21'
.value: null
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'typePtr'
.file: 'test/lang.initByRef.ci:23'
.value: int64
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'typeVar'
.file: 'test/lang.initByRef.ci:24'
.value: int64
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeTyp'
.file: 'test/lang.initByRef.ci:25'
.value: int64
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'local'
.file: 'test/lang.initByRef.ci:27'
.value: value
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'copyVal'
.file: 'test/lang.initByRef.ci:28'
.value: local
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'copyRef'
.file: 'test/lang.initByRef.ci:29'
.value: valueRef
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyPtr'
.file: 'test/lang.initByRef.ci:30'
.value: valuePtr
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyVar'
.file: 'test/lang.initByRef.ci:31'
.value: valueVar
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'copyTyp'
.file: 'test/lang.initByRef.ci:32'
.value: typeTyp
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVoid'
.file: 'test/lang.initByRef.ci:35'
.value: void
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrBool'
.file: 'test/lang.initByRef.ci:36'
.value: bool
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrChar'
.file: 'test/lang.initByRef.ci:37'
.value: char
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt8'
.file: 'test/lang.initByRef.ci:38'
.value: int8
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt16'
.file: 'test/lang.initByRef.ci:39'
.value: int16
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt32'
.file: 'test/lang.initByRef.ci:40'
.value: int32
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt64'
.file: 'test/lang.initByRef.ci:41'
.value: int64
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint8'
.file: 'test/lang.initByRef.ci:42'
.value: uint8
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint16'
.file: 'test/lang.initByRef.ci:43'
.value: uint16
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint32'
.file: 'test/lang.initByRef.ci:44'
.value: uint32
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint64'
.file: 'test/lang.initByRef.ci:45'
.value: uint64
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat32'
.file: 'test/lang.initByRef.ci:46'
.value: float32
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat64'
.file: 'test/lang.initByRef.ci:47'
.value: float64
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrTypename'
.file: 'test/lang.initByRef.ci:48'
.value: typename
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFunction'
.file: 'test/lang.initByRef.ci:49'
.value: function
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrPointer'
.file: 'test/lang.initByRef.ci:50'
.value: pointer
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVariant'
.file: 'test/lang.initByRef.ci:51'
.value: variant
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrObject'
.file: 'test/lang.initByRef.ci:52'
.value: object
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVoid'
.file: 'test/lang.initByRef.ci:55'
.value: void
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varBool'
.file: 'test/lang.initByRef.ci:56'
.value: bool
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varChar'
.file: 'test/lang.initByRef.ci:57'
.value: char
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt8'
.file: 'test/lang.initByRef.ci:58'
.value: int8
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt16'
.file: 'test/lang.initByRef.ci:59'
.value: int16
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt32'
.file: 'test/lang.initByRef.ci:60'
.value: int32
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt64'
.file: 'test/lang.initByRef.ci:61'
.value: int64
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint8'
.file: 'test/lang.initByRef.ci:62'
.value: uint8
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint16'
.file: 'test/lang.initByRef.ci:63'
.value: uint16
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint32'
.file: 'test/lang.initByRef.ci:64'
.value: uint32
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint64'
.file: 'test/lang.initByRef.ci:65'
.value: uint64
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat32'
.file: 'test/lang.initByRef.ci:66'
.value: float32
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat64'
.file: 'test/lang.initByRef.ci:67'
.value: float64
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varTypename'
.file: 'test/lang.initByRef.ci:68'
.value: typename
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFunction'
.file: 'test/lang.initByRef.ci:69'
.value: function
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varPointer'
.file: 'test/lang.initByRef.ci:70'
.value: pointer
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVariant'
.file: 'test/lang.initByRef.ci:71'
.value: variant
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varObject'
.file: 'test/lang.initByRef.ci:72'
.value: object
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVoid'
.file: 'test/lang.initByRef.ci:75'
.value: void
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typBool'
.file: 'test/lang.initByRef.ci:76'
.value: bool
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typChar'
.file: 'test/lang.initByRef.ci:77'
.value: char
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt8'
.file: 'test/lang.initByRef.ci:78'
.value: int8
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt16'
.file: 'test/lang.initByRef.ci:79'
.value: int16
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt32'
.file: 'test/lang.initByRef.ci:80'
.value: int32
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt64'
.file: 'test/lang.initByRef.ci:81'
.value: int64
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint8'
.file: 'test/lang.initByRef.ci:82'
.value: uint8
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint16'
.file: 'test/lang.initByRef.ci:83'
.value: uint16
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint32'
.file: 'test/lang.initByRef.ci:84'
.value: uint32
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint64'
.file: 'test/lang.initByRef.ci:85'
.value: uint64
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat32'
.file: 'test/lang.initByRef.ci:86'
.value: float32
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat64'
.file: 'test/lang.initByRef.ci:87'
.value: float64
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typTypename'
.file: 'test/lang.initByRef.ci:88'
.value: typename
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFunction'
.file: 'test/lang.initByRef.ci:89'
.value: function
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typPointer'
.file: 'test/lang.initByRef.ci:90'
.value: pointer
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVariant'
.file: 'test/lang.initByRef.ci:91'
.value: variant
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typObject'
.file: 'test/lang.initByRef.ci:92'
.value: object
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valueOfPtr'
.file: 'test/lang.initByRef.ci:95'
.value: pointer(value)
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueOfVar'
.file: 'test/lang.initByRef.ci:96'
.value: variant(value)
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'valueOfTyp'
.file: 'test/lang.initByRef.ci:97'
.value: typename(value)
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeOfValue'
.file: 'test/lang.initByRef.ci:99'
.value: typename(value)
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyPtrFloat64'
.file: 'test/lang.initByRef.ci:105'
.value: ptrFloat64
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyVarFloat64'
.file: 'test/lang.initByRef.ci:108'
.value: varFloat64
}
empty(): void: function {
.kind: static const function
.base: `function`
.size: 1
.name: 'empty'
.file: 'test/lang.function.ci:3'
.param .result: void (size: 0 -> variable(void))
.value: {
}
.instructions: (1 bytes)
	<empty+?>:    ret
}
funAdd(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'funAdd'
.file: 'test/lang.function.ci:6'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	test/lang.function.ci:7: (8 bytes): return .result := x + y;
	<funAdd+?>:    dup.x1 sp(2)
	<funAdd+?>:    dup.x1 sp(2)
	<funAdd+?>:    add.i32
	<funAdd+?>:    set.x1 sp(4)
	<funAdd+?>:    ret
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddResult'
.file: 'test/lang.function.ci:11'
.value: funAdd(2, 7)
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funAddRef'
.file: 'test/lang.function.ci:14'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funAdd
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddRefResult'
.file: 'test/lang.function.ci:17'
.value: funAddRef(2, 8)
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMul'
.file: 'test/lang.function.ci:20'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funMul
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulResult'
.file: 'test/lang.function.ci:23'
.value: funMul(2, 6)
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMulRef'
.file: 'test/lang.function.ci:26'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: funMul
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulRefResult'
.file: 'test/lang.function.ci:29'
.value: funMulRef(2, 7)
}
funMul(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'funMul'
.file: 'test/lang.function.ci:32'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.function.ci:33: (8 bytes): return .result := x * y;
	<funMul+?>:    dup.x1 sp(2)
	<funMul+?>:    dup.x1 sp(2)
	<funMul+?>:    mul.i32
	<funMul+?>:    set.x1 sp(4)
	<funMul+?>:    ret
}
fib(n: uint32): uint32: function {
.kind: static const function
.base: `function`
.size: 55
.name: 'fib'
.file: 'test/lang.function.ci:37'
.param .result: uint32 (size: 4 -> variable(u32))
.param n: uint32 (size: 4 -> variable(u32))
.value: {
	if (n <= (1)) {
		return .result := n;
	}
	return .result := fib(n - (1)) + fib(n - (2));
}
.instructions: (55 bytes)
	test/lang.function.ci:38: (17 bytes): if (n <= (1))
	<fib+?>:    dup.x1 sp(1)
	<fib+?>:    load.c32 1
	<fib+?>:    cgt.u32
	<fib+?>:    jnz <fib+?>
	test/lang.function.ci:39: (5 bytes): return .result := n;
	<fib+?>:    dup.x1 sp(1)
	<fib+?>:    set.x1 sp(3)
	<fib+?>:    ret
	test/lang.function.ci:41: (38 bytes): return .result := fib(n - (1)) + fib(n - (2));
	<fib+?>:    load.z32
	<fib+?>:    dup.x1 sp(2)
	<fib+?>:    inc.i32(-1)
	<fib+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<fib+?>:    call
	<fib+?>:    inc.sp(-4)
	<fib+?>:    load.z32
	<fib+?>:    dup.x1 sp(3)
	<fib+?>:    inc.i32(-2)
	<fib+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<fib+?>:    call
	<fib+?>:    inc.sp(-4)
	<fib+?>:    add.i32
	<fib+?>:    set.x1 sp(3)
	<fib+?>:    ret
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'fibonacci_13'
.file: 'test/lang.function.ci:45'
.value: fib(13)
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVoid'
.file: 'test/lang.reflect.ci:3'
.value: sizeof(void)
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofBool'
.file: 'test/lang.reflect.ci:4'
.value: sizeof(bool)
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofChar'
.file: 'test/lang.reflect.ci:5'
.value: sizeof(char)
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt8'
.file: 'test/lang.reflect.ci:6'
.value: sizeof(int8)
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt16'
.file: 'test/lang.reflect.ci:7'
.value: sizeof(int16)
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt32'
.file: 'test/lang.reflect.ci:8'
.value: sizeof(int32)
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt64'
.file: 'test/lang.reflect.ci:9'
.value: sizeof(int64)
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint8'
.file: 'test/lang.reflect.ci:10'
.value: sizeof(uint8)
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint16'
.file: 'test/lang.reflect.ci:11'
.value: sizeof(uint16)
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint32'
.file: 'test/lang.reflect.ci:12'
.value: sizeof(uint32)
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint64'
.file: 'test/lang.reflect.ci:13'
.value: sizeof(uint64)
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat32'
.file: 'test/lang.reflect.ci:14'
.value: sizeof(float32)
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat64'
.file: 'test/lang.reflect.ci:15'
.value: sizeof(float64)
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofPointer'
.file: 'test/lang.reflect.ci:16'
.value: sizeof(pointer)
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVariant'
.file: 'test/lang.reflect.ci:17'
.value: sizeof(variant)
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofTypename'
.file: 'test/lang.reflect.ci:18'
.value: sizeof(typename)
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFunction'
.file: 'test/lang.reflect.ci:19'
.value: sizeof(function)
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofObject'
.file: 'test/lang.reflect.ci:20'
.value: sizeof(object)
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.name: 'RecordSizeof'
.file: 'test/lang.reflect.ci:22'
.field x: int64 (size: 8 -> variable(i64))
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'x'
.file: 'test/lang.reflect.ci:23'
.owner: RecordSizeof
.value: 0
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.name: 'RecordSizeofExt'
.file: 'test/lang.reflect.ci:26'
.field y: int32 (size: 4 -> variable(i32))
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'test/lang.reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofRecord'
.file: 'test/lang.reflect.ci:30'
.value: RecordSizeofExt
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfRecord'
.file: 'test/lang.reflect.ci:31'
.value: typename.name(typeofRecord)
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfRecord'
.file: 'test/lang.reflect.ci:32'
.value: typeofRecord.offset
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfRecord'
.file: 'test/lang.reflect.ci:33'
.value: sizeof(typeofRecord)
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfRecord'
.file: 'test/lang.reflect.ci:34'
.value: typename.file(typeofRecord)
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfRecord'
.file: 'test/lang.reflect.ci:35'
.value: typename.line(typeofRecord)
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase'
.file: 'test/lang.reflect.ci:37'
.value: typename.base(typeofRecord)
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfBase'
.file: 'test/lang.reflect.ci:38'
.value: typename.name(typeofBase)
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase'
.file: 'test/lang.reflect.ci:39'
.value: typeofBase.offset
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase'
.file: 'test/lang.reflect.ci:40'
.value: sizeof(typeofBase)
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfBase'
.file: 'test/lang.reflect.ci:41'
.value: typename.file(typeofBase)
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfBase'
.file: 'test/lang.reflect.ci:42'
.value: typename.line(typeofBase)
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase1'
.file: 'test/lang.reflect.ci:44'
.value: typename.base(typeofBase)
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase1'
.file: 'test/lang.reflect.ci:45'
.value: typeofBase1.offset
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase1'
.file: 'test/lang.reflect.ci:46'
.value: typeofBase1.size
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase2'
.file: 'test/lang.reflect.ci:48'
.value: typename.base(typeofBase1)
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase2'
.file: 'test/lang.reflect.ci:49'
.value: typeofBase2.offset
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase2'
.file: 'test/lang.reflect.ci:50'
.value: typeofBase2.size
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'pi64'
.file: 'test/stdc.number.ci:3'
.value: 3.141593
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'e64'
.file: 'test/stdc.number.ci:4'
.value: 2.718282
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'pi32'
.file: 'test/stdc.number.ci:6'
.value: pi64
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'e32'
.file: 'test/stdc.number.ci:7'
.value: e64
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb888'
.file: 'test/stdc.number.ci:10'
.param .result: int32 (size: 4 -> i32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb565'
.file: 'test/stdc.number.ci:12'
.param .result: int32 (size: 4 -> i32)
.param r: int32 (size: 4 -> i32)
.param g: int32 (size: 4 -> i32)
.param b: int32 (size: 4 -> i32)
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r_comp'
.file: 'test/stdc.number.ci:14'
.value: 14 << 3
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'g_comp'
.file: 'test/stdc.number.ci:15'
.value: 63 << 2
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'b_comp'
.file: 'test/stdc.number.ci:16'
.value: 31 << 3
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r5g6b5'
.file: 'test/stdc.number.ci:18'
.value: rgb565(r_comp, g_comp, b_comp)
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r8g8b8'
.file: 'test/stdc.number.ci:19'
.value: rgb888(r_comp, g_comp, b_comp)
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR5'
.file: 'test/stdc.number.ci:21'
.value: uint32.zxt(r5g6b5, 11, 5)
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG6'
.file: 'test/stdc.number.ci:22'
.value: uint32.zxt(r5g6b5, 5, 6)
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB5'
.file: 'test/stdc.number.ci:23'
.value: uint32.zxt(r5g6b5, 0, 5)
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR5'
.file: 'test/stdc.number.ci:25'
.value: uint32.sxt(r5g6b5, 11, 5)
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG6'
.file: 'test/stdc.number.ci:26'
.value: uint32.sxt(r5g6b5, 5, 6)
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB5'
.file: 'test/stdc.number.ci:27'
.value: uint32.sxt(r5g6b5, 0, 5)
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR8'
.file: 'test/stdc.number.ci:29'
.value: uint32.zxt(r8g8b8, 16, 8)
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG8'
.file: 'test/stdc.number.ci:30'
.value: uint32.zxt(r8g8b8, 8, 8)
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB8'
.file: 'test/stdc.number.ci:31'
.value: uint32.zxt(r8g8b8, 0, 8)
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR8'
.file: 'test/stdc.number.ci:33'
.value: uint32.sxt(r8g8b8, 16, 8)
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG8'
.file: 'test/stdc.number.ci:34'
.value: uint32.sxt(r8g8b8, 8, 8)
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB8'
.file: 'test/stdc.number.ci:35'
.value: uint32.sxt(r8g8b8, 0, 8)
}
sinF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'sinF64'
.file: 'test/stdc.number.ci:37'
.value: float64.sin(pi64 / (2))
}
cosF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'cosF64'
.file: 'test/stdc.number.ci:38'
.value: float64.cos(pi64 / (2))
}
tanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'tanF64'
.file: 'test/stdc.number.ci:39'
.value: float64.tan(pi64 / (4))
}
logF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'logF64'
.file: 'test/stdc.number.ci:40'
.value: float64.log(e64 * e64 * e64)
}
expF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'expF64'
.file: 'test/stdc.number.ci:41'
.value: float64.exp(1.000000)
}
powF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'powF64'
.file: 'test/stdc.number.ci:42'
.value: float64.pow(pi64 * pi64, 0.500000)
}
sqrtF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'sqrtF64'
.file: 'test/stdc.number.ci:43'
.value: float64.sqrt(pi64 * pi64)
}
atanF64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'atanF64'
.file: 'test/stdc.number.ci:44'
.value: float64.atan2(pi64, 1.000000)
}
sinF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'sinF32'
.file: 'test/stdc.number.ci:46'
.value: float32.sin(pi32 / (2))
}
cosF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'cosF32'
.file: 'test/stdc.number.ci:47'
.value: float32.cos(pi32 / (2))
}
tanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'tanF32'
.file: 'test/stdc.number.ci:48'
.value: float32.tan(pi32 / (4))
}
logF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'logF32'
.file: 'test/stdc.number.ci:49'
.value: float32.log(e32 * e32 * e32)
}
expF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'expF32'
.file: 'test/stdc.number.ci:50'
.value: float32.exp(1.000000)
}
powF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'powF32'
.file: 'test/stdc.number.ci:51'
.value: float32.pow(pi32 * pi32, 0.500000)
}
sqrtF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'sqrtF32'
.file: 'test/stdc.number.ci:52'
.value: float32.sqrt(pi32 * pi32)
}
atanF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'atanF32'
.file: 'test/stdc.number.ci:53'
.value: float32.atan2(pi32, 1.000000)
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'realloc'
.file: 'test/stdc.memory.ci:3'
.param .result: pointer (size: 4 -> ref)
.param data: pointer (size: 4 -> ref)
.param size: int32 (size: 4 -> i32)
.value: pointer.alloc(data, size)
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'malloc'
.file: 'test/stdc.memory.ci:4'
.param .result: pointer (size: 4 -> ref)
.param size: int32 (size: 4 -> i32)
.value: pointer.alloc(null, size)
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'free'
.file: 'test/stdc.memory.ci:5'
.param .result: pointer (size: 4 -> ref)
.param data: pointer (size: 4 -> ref)
.value: pointer.alloc(data, 0)
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p1'
.file: 'test/stdc.memory.ci:7'
.value: malloc(1024)
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p2'
.file: 'test/stdc.memory.ci:8'
.value: malloc(80)
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p3'
.file: 'test/stdc.memory.ci:9'
.value: malloc(160)
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p4'
.file: 'test/stdc.memory.ci:10'
.value: malloc(820)
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val1'
.file: 'test/stdc.memory.ci:23'
.value: 42
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val2'
.file: 'test/stdc.memory.ci:24'
.value: 96
}
noError(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 1
.name: 'noError'
.file: 'test/stdc.execute.ci:11'
.param .result: void (size: 0 -> variable(void))
.param ptr: pointer (size: 4 -> variable(ref))
.value: {
}
.instructions: (1 bytes)
	<noError+?>:    ret
}
stackOverflow(ptr: pointer): void: function {
.kind: static const function
.base: `function`
.size: 24
.name: 'stackOverflow'
.file: 'test/stdc.execute.ci:14'
.param .result: void (size: 0 -> variable(void))
.param ptr: pointer (size: 4 -> variable(ref))
.value: {
	data: uint8[8192];
	stackOverflow(ptr);
}
.instructions: (24 bytes)
	test/stdc.execute.ci:15: (4 bytes): data: uint8[8192]
	<stackOverflow+?>:    inc.sp(+8192)
	test/stdc.execute.ci:16: (15 bytes): stackOverflow(ptr);
	<stackOverflow+?>:    load.sp(+8196)
	<stackOverflow+?>:    load.i32
	<stackOverflow+?>:    load.ref .?????? ;stackOverflow(ptr: pointer): void
	<stackOverflow+?>:    call
	<stackOverflow+?>:    inc.sp(-4)
	<stackOverflow+?>:    inc.sp(-8192)
	<stackOverflow+?>:    ret
}
divisionByZero(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'divisionByZero'
.file: 'test/stdc.execute.ci:19'
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	value: int32 := 3 / 0;
}
.instructions: (12 bytes)
	test/stdc.execute.ci:20: (7 bytes): value: int32 := 3 / 0
	<divisionByZero+?>:    load.c32 3
	<divisionByZero+?>:    load.z32
	<divisionByZero+?>:    div.i32
	<divisionByZero+?>:    inc.sp(-4)
	<divisionByZero+?>:    ret
}
abortExecution(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 68
.name: 'abortExecution'
.file: 'test/stdc.execute.ci:23'
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		details.message := ("assertion failed");
		details.expected := 97;
		details.returned := 77;
	};
	abort("fatal error", details);
}
.instructions: (68 bytes)
	test/stdc.execute.ci:29: (25 bytes): details: NotEquals := {...}
	<abortExecution+?>:    inc.sp(+16)
	test/stdc.execute.ci:30: (7 bytes): details.message := ("assertion failed");
	<abortExecution+?>:    load.ref .?????? ;"assertion failed"
	<abortExecution+?>:    set.x1 sp(1)
	test/stdc.execute.ci:31: (7 bytes): details.expected := 97;
	<abortExecution+?>:    load.c32 97
	<abortExecution+?>:    set.x1 sp(2)
	test/stdc.execute.ci:32: (7 bytes): details.returned := 77;
	<abortExecution+?>:    load.c32 77
	<abortExecution+?>:    set.x1 sp(3)
	test/stdc.execute.ci:34: (38 bytes): abort("fatal error", details);
	<abortExecution+?>:    load.ref .?????? ;"test/stdc.execute.ci"
	<abortExecution+?>:    load.c32 34
	<abortExecution+?>:    load.c32 -2
	<abortExecution+?>:    load.c32 128
	<abortExecution+?>:    load.ref .?????? ;"fatal error"
	<abortExecution+?>:    load.ref .?????? ;abortExecution.NotEquals
	<abortExecution+?>:    load.sp(+24)
	<abortExecution+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<abortExecution+?>:    inc.sp(-16)
	<abortExecution+?>:    ret
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 13
.name: 'invalidMemoryAccess'
.file: 'test/stdc.execute.ci:37'
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes)
	test/stdc.execute.ci:38: (5 bytes): i32Ref: int32 := null
	<invalidMemoryAccess+?>:    load.ref .?????? ;null
	test/stdc.execute.ci:39: (3 bytes): i32Val: int32 := i32Ref
	<invalidMemoryAccess+?>:    dup.x1 sp(0)
	<invalidMemoryAccess+?>:    load.i32
	<invalidMemoryAccess+?>:    inc.sp(-8)
	<invalidMemoryAccess+?>:    ret
}
invalidInstruction(args: pointer): void: function {
.kind: static const function
.base: `function`
.size: 2
.name: 'invalidInstruction'
.file: 'test/stdc.execute.ci:42'
.param .result: void (size: 0 -> variable(void))
.param args: pointer (size: 4 -> variable(ref))
.value: {
	emit(load.z32, ret);
}
.instructions: (2 bytes)
	test/stdc.execute.ci:43: (2 bytes): emit(load.z32, ret);
	<invalidInstruction+?>:    load.z32
	<invalidInstruction+?>:    ret
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr0'
.file: 'test/stdc.execute.ci:46'
.value: tryExec(null, noError)
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr1'
.file: 'test/stdc.execute.ci:47'
.value: tryExec(null, null)
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr2'
.file: 'test/stdc.execute.ci:48'
.value: tryExec(null, stackOverflow)
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr3'
.file: 'test/stdc.execute.ci:49'
.value: tryExec(null, divisionByZero)
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr4'
.file: 'test/stdc.execute.ci:50'
.value: tryExec(null, invalidInstruction)
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr5'
.file: 'test/stdc.execute.ci:51'
.value: tryExec(null, invalidMemoryAccess)
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr6'
.file: 'test/stdc.execute.ci:52'
.value: tryExec(null, abortExecution)
}
arrFixedNoInit: int64[7] {
.kind: variable(val)
.base: `int64[7]`
.size: 56
.name: 'arrFixedNoInit'
.file: 'test/lang.array.ci:49'
}
arrArrayNoInit: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayNoInit'
.file: 'test/lang.array.ci:50'
}
arrSliceNoInit: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceNoInit'
.file: 'test/lang.array.ci:51'
}
arrArrayInitNull: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitNull'
.file: 'test/lang.array.ci:59'
.value: null
}
arrSliceInitNull: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitNull'
.file: 'test/lang.array.ci:60'
.value: null
}
arrArrayInitFixed: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitFixed'
.file: 'test/lang.array.ci:63'
.value: arrFixedNoInit
}
arrSliceInitFixed: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitFixed'
.file: 'test/lang.array.ci:64'
.value: arrFixedNoInit
}
arrArrayInitSlice: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitSlice'
.file: 'test/lang.array.ci:67'
.value: arrSliceInitFixed
}
arrSliceInitSlice: int64[] {
.kind: variable(arr)
.base: `int64[]`
.size: 8
.name: 'arrSliceInitSlice'
.file: 'test/lang.array.ci:68'
.value: arrSliceInitFixed
}
arrArrayInitPtr: int64[*] {
.kind: variable(ref)
.base: `int64[*]`
.size: 4
.name: 'arrArrayInitPtr'
.file: 'test/lang.array.ci:71'
.value: arrArrayInitFixed
}
strFixed: char[7] {
.kind: variable(val)
.base: `char[7]`
.size: 7
.name: 'strFixed'
.file: 'test/lang.array.ci:81'
}
strArray: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'strArray'
.file: 'test/lang.array.ci:86'
.value: "string"
}
strSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'strSlice'
.file: 'test/lang.array.ci:90'
.value: "string"
}
lenSlice(values: int64[]): int32: function {
.kind: static const function
.base: `function`
.size: 5
.name: 'lenSlice'
.file: 'test/lang.array.ci:103'
.param .result: int32 (size: 4 -> variable(i32))
.param values: int64[] (size: 8 -> variable(arr))
.value: {
	return .result := values.length;
}
.instructions: (5 bytes)
	test/lang.array.ci:103: (5 bytes): return .result := values.length;
	<lenSlice+?>:    dup.x1 sp(2)
	<lenSlice+?>:    set.x1 sp(4)
	<lenSlice+?>:    ret
}
nthFixed(idx: int32, values: int64[7]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthFixed'
.file: 'test/lang.array.ci:104'
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[7] (size: 4 -> variable(ref))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:104: (12 bytes): return .result := values[idx];
	<nthFixed+?>:    dup.x1 sp(1)
	<nthFixed+?>:    dup.x1 sp(3)
	<nthFixed+?>:    mad.u32 8
	<nthFixed+?>:    load.i64
	<nthFixed+?>:    set.x2 sp(5)
	<nthFixed+?>:    ret
}
nthArray(idx: int32, values: int64[*]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthArray'
.file: 'test/lang.array.ci:105'
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[*] (size: 4 -> variable(ref))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:105: (12 bytes): return .result := values[idx];
	<nthArray+?>:    dup.x1 sp(1)
	<nthArray+?>:    dup.x1 sp(3)
	<nthArray+?>:    mad.u32 8
	<nthArray+?>:    load.i64
	<nthArray+?>:    set.x2 sp(5)
	<nthArray+?>:    ret
}
nthSlice(idx: int32, values: int64[]): int64: function {
.kind: static const function
.base: `function`
.size: 12
.name: 'nthSlice'
.file: 'test/lang.array.ci:106'
.param .result: int64 (size: 8 -> variable(i64))
.param idx: int32 (size: 4 -> variable(i32))
.param values: int64[] (size: 8 -> variable(arr))
.value: {
	return .result := values[idx];
}
.instructions: (12 bytes)
	test/lang.array.ci:106: (12 bytes): return .result := values[idx];
	<nthSlice+?>:    dup.x1 sp(1)
	<nthSlice+?>:    dup.x1 sp(4)
	<nthSlice+?>:    mad.u32 8
	<nthSlice+?>:    load.i64
	<nthSlice+?>:    set.x2 sp(6)
	<nthSlice+?>:    ret
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'RecordMemberTest'
.file: 'test/lang.member.ci:3'
.field Inner: typename (size: 8 -> static const typename(val))
.field member: int32 (size: 4 -> variable(i32))
.field constant: int32 (size: 4 -> const variable(i32))
.field memberInit: int32 (size: 4 -> variable(i32))
.field constantInit: int32 (size: 4 -> const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8 -> variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8 -> const variable(val))
.field global: int32 (size: 4 -> static variable(i32))
.field globalInit: int32 (size: 4 -> static variable(i32))
.field globalConstant: int32 (size: 4 -> static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8 -> static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8 -> static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8 -> static const variable(val))
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Inner'
.file: 'test/lang.member.ci:5'
.owner: RecordMemberTest
.field member: int32 (size: 4 -> variable(i32))
.field constant: int32 (size: 4 -> const variable(i32))
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'test/lang.member.ci:6'
.owner: RecordMemberTest.Inner
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'test/lang.member.ci:7'
.owner: RecordMemberTest.Inner
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'test/lang.member.ci:11'
.owner: RecordMemberTest
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'test/lang.member.ci:14'
.owner: RecordMemberTest
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'memberInit'
.file: 'test/lang.member.ci:17'
.owner: RecordMemberTest
.value: 2
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constantInit'
.file: 'test/lang.member.ci:20'
.owner: RecordMemberTest
.value: 3
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'memberRec'
.file: 'test/lang.member.ci:23'
.owner: RecordMemberTest
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'constantRec'
.file: 'test/lang.member.ci:26'
.owner: RecordMemberTest
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'global'
.file: 'test/lang.member.ci:35'
.owner: RecordMemberTest
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'globalInit'
.file: 'test/lang.member.ci:38'
.owner: RecordMemberTest
.value: 5
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'globalConstant'
.file: 'test/lang.member.ci:41'
.owner: RecordMemberTest
.value: 6
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRec'
.file: 'test/lang.member.ci:44'
.owner: RecordMemberTest
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRecInit'
.file: 'test/lang.member.ci:47'
.owner: RecordMemberTest
.value: {
	globalRecInit.member := 51;
	globalRecInit.constant := 52;
}
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalConstantRec'
.file: 'test/lang.member.ci:50'
.owner: RecordMemberTest
.value: {
	globalConstantRec.member := 61;
	globalConstantRec.constant := 62;
}
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.name: 'recordMemberTest'
.file: 'test/lang.member.ci:53'
.value: {
	recordMemberTest.member := 6;
	recordMemberTest.constant := 7;
	recordMemberTest.memberInit := 8;
	recordMemberTest.constantInit := 9;
	recordMemberTest.memberRec.member := 61;
	recordMemberTest.memberRec.constant := 62;
	recordMemberTest.constantRec.member := 71;
	recordMemberTest.constantRec.constant := 72;
}
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'RecordMethodTest'
.file: 'test/lang.method.ci:3'
.field staticMethod: function (size: 8 -> static const function)
.field forwardMethod: function (size: 4 -> static variable(ref))
.field abstractMethod: function (size: 4 -> variable(ref))
.field delegateMethod: function (size: 4 -> variable(ref))
.field virtualMethod: function (size: 4 -> const variable(ref))
.field virtualMethod: function (size: 8 -> static const function)
.field forwardMethod: function (size: 8 -> static const function)
.field print: function (size: 4 -> const variable(ref))
.field print: function (size: 40 -> static const function)
.field printStatic: function (size: 40 -> static const function)
}
RecordMethodTest.staticMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'staticMethod'
.file: 'test/lang.method.ci:6'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	test/lang.method.ci:7: (8 bytes): return .result := x + y;
	<staticMethod+?>:    dup.x1 sp(2)
	<staticMethod+?>:    dup.x1 sp(2)
	<staticMethod+?>:    add.i32
	<staticMethod+?>:    set.x1 sp(4)
	<staticMethod+?>:    ret
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'forwardMethod'
.file: 'test/lang.method.ci:12'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: forwardMethod
}
RecordMethodTest.abstractMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'abstractMethod'
.file: 'test/lang.method.ci:16'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
}
RecordMethodTest.delegateMethod(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'delegateMethod'
.file: 'test/lang.method.ci:20'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: forwardMethod
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'virtualMethod'
.file: 'test/lang.method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: virtualMethod
}
RecordMethodTest.virtualMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'virtualMethod'
.file: 'test/lang.method.ci:26'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:27: (8 bytes): return .result := x * y;
	<virtualMethod+?>:    dup.x1 sp(2)
	<virtualMethod+?>:    dup.x1 sp(2)
	<virtualMethod+?>:    mul.i32
	<virtualMethod+?>:    set.x1 sp(4)
	<virtualMethod+?>:    ret
}
RecordMethodTest.forwardMethod(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'forwardMethod'
.file: 'test/lang.method.ci:31'
.owner: RecordMethodTest
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:32: (8 bytes): return .result := x * y;
	<forwardMethod+?>:    dup.x1 sp(2)
	<forwardMethod+?>:    dup.x1 sp(2)
	<forwardMethod+?>:    mul.i32
	<forwardMethod+?>:    set.x1 sp(4)
	<forwardMethod+?>:    ret
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'print'
.file: 'test/lang.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: print
}
RecordMethodTest.print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'print'
.file: 'test/lang.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: {
	trace("virtual");
}
.instructions: (40 bytes)
	test/lang.method.ci:41: (39 bytes): trace("virtual");
	<print+?>:    load.ref .?????? ;"test/lang.method.ci"
	<print+?>:    load.c32 41
	<print+?>:    load.c32 14
	<print+?>:    load.c32 128
	<print+?>:    load.ref .?????? ;"virtual"
	<print+?>:    load.ref .?????? ;pointer
	<print+?>:    load.ref .?????? ;null
	<print+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+?>:    ret
}
RecordMethodTest.printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'printStatic'
.file: 'test/lang.method.ci:44'
.owner: RecordMethodTest
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: {
	trace("static");
}
.instructions: (40 bytes)
	test/lang.method.ci:45: (39 bytes): trace("static");
	<printStatic+?>:    load.ref .?????? ;"test/lang.method.ci"
	<printStatic+?>:    load.c32 45
	<printStatic+?>:    load.c32 14
	<printStatic+?>:    load.c32 128
	<printStatic+?>:    load.ref .?????? ;"static"
	<printStatic+?>:    load.ref .?????? ;pointer
	<printStatic+?>:    load.ref .?????? ;null
	<printStatic+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+?>:    ret
}
globalFunction(x: int32, y: int32): int32: function {
.kind: static const function
.base: `function`
.size: 8
.name: 'globalFunction'
.file: 'test/lang.method.ci:49'
.param .result: int32 (size: 4 -> variable(i32))
.param x: int32 (size: 4 -> variable(i32))
.param y: int32 (size: 4 -> variable(i32))
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	test/lang.method.ci:50: (8 bytes): return .result := x * y;
	<globalFunction+?>:    dup.x1 sp(2)
	<globalFunction+?>:    dup.x1 sp(2)
	<globalFunction+?>:    mul.i32
	<globalFunction+?>:    set.x1 sp(4)
	<globalFunction+?>:    ret
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.name: 'recordMethodTest'
.file: 'test/lang.method.ci:53'
.value: {
	recordMethodTest.delegateMethod := globalFunction;
	recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
	recordMethodTest.virtualMethod := virtualMethod;
	recordMethodTest.print := print;
}
}
customPrint(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'customPrint'
.file: 'test/lang.method.ci:59'
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: {
	trace("override");
}
.instructions: (40 bytes)
	test/lang.method.ci:60: (39 bytes): trace("override");
	<customPrint+?>:    load.ref .?????? ;"test/lang.method.ci"
	<customPrint+?>:    load.c32 60
	<customPrint+?>:    load.c32 14
	<customPrint+?>:    load.c32 128
	<customPrint+?>:    load.ref .?????? ;"override"
	<customPrint+?>:    load.ref .?????? ;pointer
	<customPrint+?>:    load.ref .?????? ;null
	<customPrint+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<customPrint+?>:    ret
}
recordMethodTestCustomPrint: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.name: 'recordMethodTestCustomPrint'
.file: 'test/lang.method.ci:63'
.value: {
	recordMethodTestCustomPrint.abstractMethod := globalFunction;
	recordMethodTestCustomPrint.print := customPrint;
	recordMethodTestCustomPrint.delegateMethod := forwardMethod;
	recordMethodTestCustomPrint.virtualMethod := virtualMethod;
}
}
print(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'print'
.file: 'test/lang.method.ci:75'
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes)
	test/lang.method.ci:76: (39 bytes): trace("extension");
	<print+?>:    load.ref .?????? ;"test/lang.method.ci"
	<print+?>:    load.c32 76
	<print+?>:    load.c32 14
	<print+?>:    load.c32 128
	<print+?>:    load.ref .?????? ;"extension"
	<print+?>:    load.ref .?????? ;pointer
	<print+?>:    load.ref .?????? ;null
	<print+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<print+?>:    ret
}
printStatic(this: RecordMethodTest): void: function {
.kind: static const function
.base: `function`
.size: 40
.name: 'printStatic'
.file: 'test/lang.method.ci:79'
.param .result: void (size: 0 -> variable(void))
.param this: RecordMethodTest (size: 16 -> variable(val))
.value: {
	trace("extension");
}
.instructions: (40 bytes)
	test/lang.method.ci:80: (39 bytes): trace("extension");
	<printStatic+?>:    load.ref .?????? ;"test/lang.method.ci"
	<printStatic+?>:    load.c32 80
	<printStatic+?>:    load.c32 14
	<printStatic+?>:    load.c32 128
	<printStatic+?>:    load.ref .?????? ;"extension"
	<printStatic+?>:    load.ref .?????? ;pointer
	<printStatic+?>:    load.ref .?????? ;null
	<printStatic+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<printStatic+?>:    ret
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'rgbF32'
.file: 'test/lang.recUnion.ci:2'
.field r: float32 (size: 4 -> variable(f32))
.field g: float32 (size: 4 -> variable(f32))
.field b: float32 (size: 4 -> variable(f32))
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'r'
.file: 'test/lang.recUnion.ci:3'
.owner: rgbF32
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'g'
.file: 'test/lang.recUnion.ci:4'
.owner: rgbF32
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'b'
.file: 'test/lang.recUnion.ci:5'
.owner: rgbF32
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.name: 'rgbU8'
.file: 'test/lang.recUnion.ci:9'
.field b: uint8 (size: 1 -> variable(u32))
.field g: uint8 (size: 1 -> variable(u32))
.field r: uint8 (size: 1 -> variable(u32))
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'test/lang.recUnion.ci:10'
.owner: rgbU8
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'test/lang.recUnion.ci:11'
.owner: rgbU8
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'test/lang.recUnion.ci:12'
.owner: rgbU8
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'color'
.file: 'test/lang.recUnion.ci:16'
.field col: uint32 (size: 4 -> variable(u32))
.field rgb: rgbU8 (size: 3 -> variable(val))
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'col'
.file: 'test/lang.recUnion.ci:17'
.owner: color
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'rgb'
.file: 'test/lang.recUnion.ci:18'
.owner: color
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'Color'
.file: 'test/lang.recUnion.ci:22'
.field value: rgbF32 (size: 16 -> variable(val))
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.name: 'value'
.file: 'test/lang.recUnion.ci:23'
.owner: Color
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'black'
.file: 'test/lang.recUnion.ci:26'
.value: {
	black.r := (0);
	black.g := (0);
	black.b := (0);
}
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'green'
.file: 'test/lang.recUnion.ci:27'
.value: {
	green.r := (0);
	green.g := (255);
	green.b := (0);
}
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'white'
.file: 'test/lang.recUnion.ci:28'
.value: {
	white.r := (255);
	white.g := (255);
	white.b := (255);
}
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'cyan'
.file: 'test/lang.recUnion.ci:30'
.value: {
	cyan.col := (65535);
}
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'blue'
.file: 'test/lang.recUnion.ci:31'
.value: {
	blue.rgb.r := (0);
	blue.rgb.g := (0);
	blue.rgb.b := (255);
}
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'record_pack0'
.file: 'test/lang.recPacking.ci:2'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:3'
.owner: record_pack0
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:4'
.owner: record_pack0
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:5'
.owner: record_pack0
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:6'
.owner: record_pack0
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:7'
.owner: record_pack0
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:8'
.owner: record_pack0
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.name: 'record_pack1'
.file: 'test/lang.recPacking.ci:12'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:13'
.owner: record_pack1
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:14'
.owner: record_pack1
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:15'
.owner: record_pack1
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:16'
.owner: record_pack1
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:17'
.owner: record_pack1
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:18'
.owner: record_pack1
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.name: 'record_pack2'
.file: 'test/lang.recPacking.ci:22'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:23'
.owner: record_pack2
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:24'
.owner: record_pack2
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:25'
.owner: record_pack2
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:26'
.owner: record_pack2
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:27'
.owner: record_pack2
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:28'
.owner: record_pack2
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'record_pack4'
.file: 'test/lang.recPacking.ci:32'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:33'
.owner: record_pack4
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:34'
.owner: record_pack4
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:35'
.owner: record_pack4
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:36'
.owner: record_pack4
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:37'
.owner: record_pack4
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:38'
.owner: record_pack4
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_pack8'
.file: 'test/lang.recPacking.ci:42'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:43'
.owner: record_pack8
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:44'
.owner: record_pack8
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:45'
.owner: record_pack8
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:46'
.owner: record_pack8
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:47'
.owner: record_pack8
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:48'
.owner: record_pack8
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_packDef'
.file: 'test/lang.recPacking.ci:52'
.field _0: uint8 (size: 1 -> variable(u32))
.field a: uint64 (size: 8 -> variable(u64))
.field _1: uint8 (size: 1 -> variable(u32))
.field b: uint32 (size: 4 -> variable(u32))
.field _2: uint8 (size: 1 -> variable(u32))
.field c: uint16 (size: 2 -> variable(u32))
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'test/lang.recPacking.ci:53'
.owner: record_packDef
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'test/lang.recPacking.ci:54'
.owner: record_packDef
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'test/lang.recPacking.ci:55'
.owner: record_packDef
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'test/lang.recPacking.ci:56'
.owner: record_packDef
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'test/lang.recPacking.ci:57'
.owner: record_packDef
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'test/lang.recPacking.ci:58'
.owner: record_packDef
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'a'
.file: 'test/lang.useOperator.ci:3'
.value: 96.300000
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'b'
.file: 'test/lang.useOperator.ci:4'
.value: 42.140000
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'shift'
.file: 'test/lang.useOperator.ci:5'
.value: 2
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolA'
.file: 'test/lang.useOperator.ci:7'
.value: true
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolB'
.file: 'test/lang.useOperator.ci:8'
.value: !false
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolAnd'
.file: 'test/lang.useOperator.ci:17'
.value: boolA & boolB
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolIor'
.file: 'test/lang.useOperator.ci:18'
.value: boolA | boolB
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolXor'
.file: 'test/lang.useOperator.ci:19'
.value: boolA ^ boolB
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolNot'
.file: 'test/lang.useOperator.ci:22'
.value: !boolB
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCeq'
.file: 'test/lang.useOperator.ci:23'
.value: boolA == boolB
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCne'
.file: 'test/lang.useOperator.ci:24'
.value: boolA != boolB
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolClt'
.file: 'test/lang.useOperator.ci:25'
.value: boolA < boolB
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCle'
.file: 'test/lang.useOperator.ci:26'
.value: boolA <= boolB
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCgt'
.file: 'test/lang.useOperator.ci:27'
.value: boolA > boolB
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCge'
.file: 'test/lang.useOperator.ci:28'
.value: boolA >= boolB
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrA'
.file: 'test/lang.useOperator.ci:30'
.value: 'a'
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrB'
.file: 'test/lang.useOperator.ci:31'
.value: 'b'
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrPls'
.file: 'test/lang.useOperator.ci:32'
.value: +chrB
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrNeg'
.file: 'test/lang.useOperator.ci:33'
.value: -chrB
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrCmt'
.file: 'test/lang.useOperator.ci:34'
.value: ~chrB
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAdd'
.file: 'test/lang.useOperator.ci:35'
.value: chrA + chrB
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrSub'
.file: 'test/lang.useOperator.ci:36'
.value: chrA - chrB
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMul'
.file: 'test/lang.useOperator.ci:37'
.value: chrA * chrB
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrDiv'
.file: 'test/lang.useOperator.ci:38'
.value: chrA / chrB
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMod'
.file: 'test/lang.useOperator.ci:39'
.value: chrA % chrB
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAnd'
.file: 'test/lang.useOperator.ci:40'
.value: chrA & chrB
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrIor'
.file: 'test/lang.useOperator.ci:41'
.value: chrA | chrB
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrXor'
.file: 'test/lang.useOperator.ci:42'
.value: chrA ^ chrB
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShl'
.file: 'test/lang.useOperator.ci:43'
.value: (chrA) << shift
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShr'
.file: 'test/lang.useOperator.ci:44'
.value: (chrA) >> shift
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrNot'
.file: 'test/lang.useOperator.ci:45'
.value: !(chrB)
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCeq'
.file: 'test/lang.useOperator.ci:46'
.value: chrA == chrB
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCne'
.file: 'test/lang.useOperator.ci:47'
.value: chrA != chrB
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrClt'
.file: 'test/lang.useOperator.ci:48'
.value: chrA < chrB
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCle'
.file: 'test/lang.useOperator.ci:49'
.value: chrA <= chrB
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCgt'
.file: 'test/lang.useOperator.ci:50'
.value: chrA > chrB
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCge'
.file: 'test/lang.useOperator.ci:51'
.value: chrA >= chrB
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8A'
.file: 'test/lang.useOperator.ci:53'
.value: a
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8B'
.file: 'test/lang.useOperator.ci:54'
.value: b
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Pls'
.file: 'test/lang.useOperator.ci:55'
.value: +i8B
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Neg'
.file: 'test/lang.useOperator.ci:56'
.value: -i8B
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Cmt'
.file: 'test/lang.useOperator.ci:57'
.value: ~i8B
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Add'
.file: 'test/lang.useOperator.ci:58'
.value: i8A + i8B
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Sub'
.file: 'test/lang.useOperator.ci:59'
.value: i8A - i8B
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mul'
.file: 'test/lang.useOperator.ci:60'
.value: i8A * i8B
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Div'
.file: 'test/lang.useOperator.ci:61'
.value: i8A / i8B
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mod'
.file: 'test/lang.useOperator.ci:62'
.value: i8A % i8B
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8And'
.file: 'test/lang.useOperator.ci:63'
.value: i8A & i8B
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Ior'
.file: 'test/lang.useOperator.ci:64'
.value: i8A | i8B
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Xor'
.file: 'test/lang.useOperator.ci:65'
.value: i8A ^ i8B
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shl'
.file: 'test/lang.useOperator.ci:66'
.value: (i8A) << shift
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shr'
.file: 'test/lang.useOperator.ci:67'
.value: (i8A) >> shift
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Not'
.file: 'test/lang.useOperator.ci:68'
.value: !(i8B)
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Ceq'
.file: 'test/lang.useOperator.ci:69'
.value: i8A == i8B
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cne'
.file: 'test/lang.useOperator.ci:70'
.value: i8A != i8B
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Clt'
.file: 'test/lang.useOperator.ci:71'
.value: i8A < i8B
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cle'
.file: 'test/lang.useOperator.ci:72'
.value: i8A <= i8B
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cgt'
.file: 'test/lang.useOperator.ci:73'
.value: i8A > i8B
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cge'
.file: 'test/lang.useOperator.ci:74'
.value: i8A >= i8B
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8A'
.file: 'test/lang.useOperator.ci:76'
.value: a
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8B'
.file: 'test/lang.useOperator.ci:77'
.value: b
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Pls'
.file: 'test/lang.useOperator.ci:78'
.value: +u8B
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Neg'
.file: 'test/lang.useOperator.ci:79'
.value: -u8B
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Cmt'
.file: 'test/lang.useOperator.ci:80'
.value: ~u8B
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Add'
.file: 'test/lang.useOperator.ci:81'
.value: u8A + u8B
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Sub'
.file: 'test/lang.useOperator.ci:82'
.value: u8A - u8B
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mul'
.file: 'test/lang.useOperator.ci:83'
.value: u8A * u8B
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Div'
.file: 'test/lang.useOperator.ci:84'
.value: u8A / u8B
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mod'
.file: 'test/lang.useOperator.ci:85'
.value: u8A % u8B
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8And'
.file: 'test/lang.useOperator.ci:86'
.value: u8A & u8B
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Ior'
.file: 'test/lang.useOperator.ci:87'
.value: u8A | u8B
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Xor'
.file: 'test/lang.useOperator.ci:88'
.value: u8A ^ u8B
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shl'
.file: 'test/lang.useOperator.ci:89'
.value: (u8A) << shift
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shr'
.file: 'test/lang.useOperator.ci:90'
.value: (u8A) >> shift
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Not'
.file: 'test/lang.useOperator.ci:91'
.value: !(u8B)
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Ceq'
.file: 'test/lang.useOperator.ci:92'
.value: u8A == u8B
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cne'
.file: 'test/lang.useOperator.ci:93'
.value: u8A != u8B
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Clt'
.file: 'test/lang.useOperator.ci:94'
.value: u8A < u8B
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cle'
.file: 'test/lang.useOperator.ci:95'
.value: u8A <= u8B
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cgt'
.file: 'test/lang.useOperator.ci:96'
.value: u8A > u8B
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cge'
.file: 'test/lang.useOperator.ci:97'
.value: u8A >= u8B
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16A'
.file: 'test/lang.useOperator.ci:99'
.value: a
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16B'
.file: 'test/lang.useOperator.ci:100'
.value: b
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Pls'
.file: 'test/lang.useOperator.ci:101'
.value: +i16B
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Neg'
.file: 'test/lang.useOperator.ci:102'
.value: -i16B
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Cmt'
.file: 'test/lang.useOperator.ci:103'
.value: ~i16B
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Add'
.file: 'test/lang.useOperator.ci:104'
.value: i16A + i16B
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Sub'
.file: 'test/lang.useOperator.ci:105'
.value: i16A - i16B
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mul'
.file: 'test/lang.useOperator.ci:106'
.value: i16A * i16B
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Div'
.file: 'test/lang.useOperator.ci:107'
.value: i16A / i16B
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mod'
.file: 'test/lang.useOperator.ci:108'
.value: i16A % i16B
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16And'
.file: 'test/lang.useOperator.ci:109'
.value: i16A & i16B
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Ior'
.file: 'test/lang.useOperator.ci:110'
.value: i16A | i16B
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Xor'
.file: 'test/lang.useOperator.ci:111'
.value: i16A ^ i16B
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shl'
.file: 'test/lang.useOperator.ci:112'
.value: (i16A) << shift
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shr'
.file: 'test/lang.useOperator.ci:113'
.value: (i16A) >> shift
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Not'
.file: 'test/lang.useOperator.ci:114'
.value: !(i16B)
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Ceq'
.file: 'test/lang.useOperator.ci:115'
.value: i16A == i16B
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cne'
.file: 'test/lang.useOperator.ci:116'
.value: i16A != i16B
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Clt'
.file: 'test/lang.useOperator.ci:117'
.value: i16A < i16B
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cle'
.file: 'test/lang.useOperator.ci:118'
.value: i16A <= i16B
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cgt'
.file: 'test/lang.useOperator.ci:119'
.value: i16A > i16B
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cge'
.file: 'test/lang.useOperator.ci:120'
.value: i16A >= i16B
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16A'
.file: 'test/lang.useOperator.ci:122'
.value: a
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16B'
.file: 'test/lang.useOperator.ci:123'
.value: b
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Pls'
.file: 'test/lang.useOperator.ci:124'
.value: +u16B
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Neg'
.file: 'test/lang.useOperator.ci:125'
.value: -u16B
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Cmt'
.file: 'test/lang.useOperator.ci:126'
.value: ~u16B
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Add'
.file: 'test/lang.useOperator.ci:127'
.value: u16A + u16B
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Sub'
.file: 'test/lang.useOperator.ci:128'
.value: u16A - u16B
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mul'
.file: 'test/lang.useOperator.ci:129'
.value: u16A * u16B
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Div'
.file: 'test/lang.useOperator.ci:130'
.value: u16A / u16B
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mod'
.file: 'test/lang.useOperator.ci:131'
.value: u16A % u16B
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16And'
.file: 'test/lang.useOperator.ci:132'
.value: u16A & u16B
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Ior'
.file: 'test/lang.useOperator.ci:133'
.value: u16A | u16B
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Xor'
.file: 'test/lang.useOperator.ci:134'
.value: u16A ^ u16B
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shl'
.file: 'test/lang.useOperator.ci:135'
.value: (u16A) << shift
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shr'
.file: 'test/lang.useOperator.ci:136'
.value: (u16A) >> shift
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Not'
.file: 'test/lang.useOperator.ci:137'
.value: !(u16B)
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Ceq'
.file: 'test/lang.useOperator.ci:138'
.value: u16A == u16B
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cne'
.file: 'test/lang.useOperator.ci:139'
.value: u16A != u16B
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Clt'
.file: 'test/lang.useOperator.ci:140'
.value: u16A < u16B
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cle'
.file: 'test/lang.useOperator.ci:141'
.value: u16A <= u16B
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cgt'
.file: 'test/lang.useOperator.ci:142'
.value: u16A > u16B
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cge'
.file: 'test/lang.useOperator.ci:143'
.value: u16A >= u16B
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32A'
.file: 'test/lang.useOperator.ci:145'
.value: a
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32B'
.file: 'test/lang.useOperator.ci:146'
.value: b
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Pls'
.file: 'test/lang.useOperator.ci:147'
.value: +i32B
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Neg'
.file: 'test/lang.useOperator.ci:148'
.value: -i32B
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Cmt'
.file: 'test/lang.useOperator.ci:149'
.value: ~i32B
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Add'
.file: 'test/lang.useOperator.ci:150'
.value: i32A + i32B
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Sub'
.file: 'test/lang.useOperator.ci:151'
.value: i32A - i32B
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mul'
.file: 'test/lang.useOperator.ci:152'
.value: i32A * i32B
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Div'
.file: 'test/lang.useOperator.ci:153'
.value: i32A / i32B
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mod'
.file: 'test/lang.useOperator.ci:154'
.value: i32A % i32B
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32And'
.file: 'test/lang.useOperator.ci:155'
.value: i32A & i32B
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Ior'
.file: 'test/lang.useOperator.ci:156'
.value: i32A | i32B
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Xor'
.file: 'test/lang.useOperator.ci:157'
.value: i32A ^ i32B
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shl'
.file: 'test/lang.useOperator.ci:158'
.value: i32A << shift
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shr'
.file: 'test/lang.useOperator.ci:159'
.value: i32A >> shift
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Not'
.file: 'test/lang.useOperator.ci:160'
.value: !(i32B)
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Ceq'
.file: 'test/lang.useOperator.ci:161'
.value: i32A == i32B
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cne'
.file: 'test/lang.useOperator.ci:162'
.value: i32A != i32B
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Clt'
.file: 'test/lang.useOperator.ci:163'
.value: i32A < i32B
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cle'
.file: 'test/lang.useOperator.ci:164'
.value: i32A <= i32B
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cgt'
.file: 'test/lang.useOperator.ci:165'
.value: i32A > i32B
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cge'
.file: 'test/lang.useOperator.ci:166'
.value: i32A >= i32B
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32A'
.file: 'test/lang.useOperator.ci:168'
.value: a
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32B'
.file: 'test/lang.useOperator.ci:169'
.value: b
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Pls'
.file: 'test/lang.useOperator.ci:170'
.value: +u32B
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Neg'
.file: 'test/lang.useOperator.ci:171'
.value: -u32B
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Cmt'
.file: 'test/lang.useOperator.ci:172'
.value: ~u32B
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Add'
.file: 'test/lang.useOperator.ci:173'
.value: u32A + u32B
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Sub'
.file: 'test/lang.useOperator.ci:174'
.value: u32A - u32B
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mul'
.file: 'test/lang.useOperator.ci:175'
.value: u32A * u32B
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Div'
.file: 'test/lang.useOperator.ci:176'
.value: u32A / u32B
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mod'
.file: 'test/lang.useOperator.ci:177'
.value: u32A % u32B
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32And'
.file: 'test/lang.useOperator.ci:178'
.value: u32A & u32B
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Ior'
.file: 'test/lang.useOperator.ci:179'
.value: u32A | u32B
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Xor'
.file: 'test/lang.useOperator.ci:180'
.value: u32A ^ u32B
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shl'
.file: 'test/lang.useOperator.ci:181'
.value: u32A << shift
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shr'
.file: 'test/lang.useOperator.ci:182'
.value: u32A >> shift
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Not'
.file: 'test/lang.useOperator.ci:183'
.value: !(u32B)
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Ceq'
.file: 'test/lang.useOperator.ci:184'
.value: u32A == u32B
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cne'
.file: 'test/lang.useOperator.ci:185'
.value: u32A != u32B
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Clt'
.file: 'test/lang.useOperator.ci:186'
.value: u32A < u32B
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cle'
.file: 'test/lang.useOperator.ci:187'
.value: u32A <= u32B
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cgt'
.file: 'test/lang.useOperator.ci:188'
.value: u32A > u32B
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cge'
.file: 'test/lang.useOperator.ci:189'
.value: u32A >= u32B
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64A'
.file: 'test/lang.useOperator.ci:191'
.value: a
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64B'
.file: 'test/lang.useOperator.ci:192'
.value: b
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Pls'
.file: 'test/lang.useOperator.ci:193'
.value: +i64B
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Neg'
.file: 'test/lang.useOperator.ci:194'
.value: -i64B
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Cmt'
.file: 'test/lang.useOperator.ci:195'
.value: ~i64B
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Add'
.file: 'test/lang.useOperator.ci:196'
.value: i64A + i64B
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Sub'
.file: 'test/lang.useOperator.ci:197'
.value: i64A - i64B
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mul'
.file: 'test/lang.useOperator.ci:198'
.value: i64A * i64B
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Div'
.file: 'test/lang.useOperator.ci:199'
.value: i64A / i64B
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mod'
.file: 'test/lang.useOperator.ci:200'
.value: i64A % i64B
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64And'
.file: 'test/lang.useOperator.ci:201'
.value: i64A & i64B
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Ior'
.file: 'test/lang.useOperator.ci:202'
.value: i64A | i64B
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Xor'
.file: 'test/lang.useOperator.ci:203'
.value: i64A ^ i64B
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shl'
.file: 'test/lang.useOperator.ci:204'
.value: i64A << shift
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shr'
.file: 'test/lang.useOperator.ci:205'
.value: i64A >> shift
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Not'
.file: 'test/lang.useOperator.ci:206'
.value: !(i64B)
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Ceq'
.file: 'test/lang.useOperator.ci:207'
.value: i64A == i64B
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cne'
.file: 'test/lang.useOperator.ci:208'
.value: i64A != i64B
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Clt'
.file: 'test/lang.useOperator.ci:209'
.value: i64A < i64B
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cle'
.file: 'test/lang.useOperator.ci:210'
.value: i64A <= i64B
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cgt'
.file: 'test/lang.useOperator.ci:211'
.value: i64A > i64B
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cge'
.file: 'test/lang.useOperator.ci:212'
.value: i64A >= i64B
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64A'
.file: 'test/lang.useOperator.ci:214'
.value: a
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64B'
.file: 'test/lang.useOperator.ci:215'
.value: b
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Pls'
.file: 'test/lang.useOperator.ci:216'
.value: +u64B
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Neg'
.file: 'test/lang.useOperator.ci:217'
.value: -u64B
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Cmt'
.file: 'test/lang.useOperator.ci:218'
.value: ~u64B
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Add'
.file: 'test/lang.useOperator.ci:219'
.value: u64A + u64B
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Sub'
.file: 'test/lang.useOperator.ci:220'
.value: u64A - u64B
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mul'
.file: 'test/lang.useOperator.ci:221'
.value: u64A * u64B
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Div'
.file: 'test/lang.useOperator.ci:222'
.value: u64A / u64B
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mod'
.file: 'test/lang.useOperator.ci:223'
.value: u64A % u64B
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64And'
.file: 'test/lang.useOperator.ci:224'
.value: u64A & u64B
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Ior'
.file: 'test/lang.useOperator.ci:225'
.value: u64A | u64B
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Xor'
.file: 'test/lang.useOperator.ci:226'
.value: u64A ^ u64B
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shl'
.file: 'test/lang.useOperator.ci:227'
.value: u64A << shift
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shr'
.file: 'test/lang.useOperator.ci:228'
.value: u64A >> shift
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Not'
.file: 'test/lang.useOperator.ci:229'
.value: !(u64B)
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Ceq'
.file: 'test/lang.useOperator.ci:230'
.value: u64A == u64B
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cne'
.file: 'test/lang.useOperator.ci:231'
.value: u64A != u64B
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Clt'
.file: 'test/lang.useOperator.ci:232'
.value: u64A < u64B
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cle'
.file: 'test/lang.useOperator.ci:233'
.value: u64A <= u64B
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cgt'
.file: 'test/lang.useOperator.ci:234'
.value: u64A > u64B
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cge'
.file: 'test/lang.useOperator.ci:235'
.value: u64A >= u64B
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32A'
.file: 'test/lang.useOperator.ci:237'
.value: a
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32B'
.file: 'test/lang.useOperator.ci:238'
.value: b
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Pls'
.file: 'test/lang.useOperator.ci:239'
.value: +f32B
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Neg'
.file: 'test/lang.useOperator.ci:240'
.value: -f32B
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Add'
.file: 'test/lang.useOperator.ci:242'
.value: f32A + f32B
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Sub'
.file: 'test/lang.useOperator.ci:243'
.value: f32A - f32B
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mul'
.file: 'test/lang.useOperator.ci:244'
.value: f32A * f32B
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Div'
.file: 'test/lang.useOperator.ci:245'
.value: f32A / f32B
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mod'
.file: 'test/lang.useOperator.ci:246'
.value: f32A % f32B
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Not'
.file: 'test/lang.useOperator.ci:252'
.value: !(f32B)
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Ceq'
.file: 'test/lang.useOperator.ci:253'
.value: f32A == f32B
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cne'
.file: 'test/lang.useOperator.ci:254'
.value: f32A != f32B
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Clt'
.file: 'test/lang.useOperator.ci:255'
.value: f32A < f32B
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cle'
.file: 'test/lang.useOperator.ci:256'
.value: f32A <= f32B
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cgt'
.file: 'test/lang.useOperator.ci:257'
.value: f32A > f32B
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cge'
.file: 'test/lang.useOperator.ci:258'
.value: f32A >= f32B
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64A'
.file: 'test/lang.useOperator.ci:260'
.value: a
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64B'
.file: 'test/lang.useOperator.ci:261'
.value: b
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Pls'
.file: 'test/lang.useOperator.ci:262'
.value: +f64B
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Neg'
.file: 'test/lang.useOperator.ci:263'
.value: -f64B
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Add'
.file: 'test/lang.useOperator.ci:265'
.value: f64A + f64B
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Sub'
.file: 'test/lang.useOperator.ci:266'
.value: f64A - f64B
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mul'
.file: 'test/lang.useOperator.ci:267'
.value: f64A * f64B
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Div'
.file: 'test/lang.useOperator.ci:268'
.value: f64A / f64B
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mod'
.file: 'test/lang.useOperator.ci:269'
.value: f64A % f64B
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Not'
.file: 'test/lang.useOperator.ci:275'
.value: !(f64B)
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Ceq'
.file: 'test/lang.useOperator.ci:276'
.value: f64A == f64B
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cne'
.file: 'test/lang.useOperator.ci:277'
.value: f64A != f64B
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Clt'
.file: 'test/lang.useOperator.ci:278'
.value: f64A < f64B
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cle'
.file: 'test/lang.useOperator.ci:279'
.value: f64A <= f64B
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cgt'
.file: 'test/lang.useOperator.ci:280'
.value: f64A > f64B
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cge'
.file: 'test/lang.useOperator.ci:281'
.value: f64A >= f64B
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrA'
.file: 'test/lang.useOperator.ci:283'
.value: null
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrB'
.file: 'test/lang.useOperator.ci:284'
.value: pointer(shift)
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCeq'
.file: 'test/lang.useOperator.ci:299'
.value: ptrA == ptrB
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCne'
.file: 'test/lang.useOperator.ci:300'
.value: ptrA != ptrB
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 't'
.file: 'test/lang.statementIf.ci:26'
.value: 0
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'forIdx'
.file: 'test/lang.statementFor.ci:12'
}
.main: function {
.kind: static function
.base: `function`
.size: 7233
.name: '.main'
.print: '.main'
.field typename: typename (size: 136 -> static const typename(ref))
.field void: typename (size: 0 -> static const typename(void))
.field bool: typename (size: 1 -> static const typename(bool))
.field char: typename (size: 1 -> static const typename(i32))
.field int8: typename (size: 1 -> static const typename(i32))
.field int16: typename (size: 2 -> static const typename(i32))
.field int32: typename (size: 4 -> static const typename(i32))
.field int64: typename (size: 8 -> static const typename(i64))
.field uint8: typename (size: 1 -> static const typename(u32))
.field uint16: typename (size: 2 -> static const typename(u32))
.field uint32: typename (size: 4 -> static const typename(u32))
.field uint64: typename (size: 8 -> static const typename(u64))
.field float32: typename (size: 4 -> static const typename(f32))
.field float64: typename (size: 8 -> static const typename(f64))
.field pointer: typename (size: 4 -> static const typename(ref))
.field variant: typename (size: 8 -> static const typename(var))
.field function: typename (size: 4 -> static const typename(ref))
.field object: typename (size: 4 -> static const typename(ref))
.field null: pointer (size: 0 -> static const inline)
.field true: bool (size: 0 -> static const inline)
.field false: bool (size: 0 -> static const inline)
.field int: typename (size: 0 -> static const inline)
.field byte: typename (size: 0 -> static const inline)
.field float: typename (size: 0 -> static const inline)
.field double: typename (size: 0 -> static const inline)
.field .cstr: char (size: 4 -> static const typename(arr))
.field emit: function (size: 0 -> static const typename(void))
.field halt: function (size: 0 -> static const inline)
.field CLOCKS_PER_SEC: int64 (size: 0 -> static const i64)
.field RAND_MAX: int64 (size: 0 -> static const i64)
.field raise: function (size: 0 -> static const inline)
.field tryExec: function (size: 0 -> static const inline)
.field System: void (size: 0 -> static const typename(void))
.field verbose: function (size: 0 -> inline)
.field verbose: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field trace: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field debug: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field info: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field warn: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field error: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field abort: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field assert: function (size: 0 -> inline)
.field NotEquals: typename (size: 24 -> static const typename(val))
.field assertEq: function (size: 83 -> static const function)
.field assertEq: function (size: 0 -> inline)
.field sizeof: function (size: 0 -> inline)
.field Math: typename (size: 0 -> static const typename(val))
.field Complex: typename (size: 16 -> static const typename(val))
.field Complex: function (size: 8 -> static const function)
.field Complex: function (size: 9 -> static const function)
.field neg: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field add: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field sub: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field mul: function (size: 0 -> inline)
.field div: function (size: 128 -> static const function)
.field div: function (size: 0 -> inline)
.field div: function (size: 0 -> inline)
.field abs: function (size: 0 -> inline)
.field arg: function (size: 0 -> inline)
.field inv: function (size: 36 -> static const function)
.field conj: function (size: 0 -> inline)
.field exp: function (size: 0 -> inline)
.field log: function (size: 0 -> inline)
.field pow: function (size: 105 -> static const function)
.field pow: function (size: 0 -> inline)
.field sin: function (size: 0 -> inline)
.field cos: function (size: 0 -> inline)
.field tan: function (size: 0 -> inline)
.field cot: function (size: 0 -> inline)
.field sinh: function (size: 0 -> inline)
.field cosh: function (size: 0 -> inline)
.field tanh: function (size: 0 -> inline)
.field coth: function (size: 0 -> inline)
.field sec: function (size: 0 -> inline)
.field csc: function (size: 0 -> inline)
.field sech: function (size: 0 -> inline)
.field csch: function (size: 0 -> inline)
.field toCartesian: function (size: 0 -> inline)
.field toPolar: function (size: 0 -> inline)
.field length: function (size: 49 -> static const function)
.field indexOf: function (size: 56 -> static const function)
.field lastIndexOf: function (size: 62 -> static const function)
.field startsWith: function (size: 73 -> static const function)
.field endsWith: function (size: 131 -> static const function)
.field compare: function (size: 74 -> static const function)
.field ignCaseCmp: function (size: 36 -> static const function)
.field caseCmp: function (size: 14 -> static const function)
.field startsWith: function (size: 0 -> inline)
.field endsWith: function (size: 0 -> inline)
.field compare: function (size: 0 -> inline)
.field contains: function (size: 0 -> inline)
.field FormatFlags: typename (size: 16 -> static const typename(val))
.field append: function (size: 85 -> static const function)
.field append: function (size: 623 -> static const function)
.field append: function (size: 25 -> static const function)
.field append: function (size: 118 -> static const function)
.field integer: typename (size: 0 -> inline)
.field emitldz32: int32 (size: 4 -> variable(i32))
.field emitldz64: int64 (size: 8 -> variable(i64))
.field emitA: int32 (size: 4 -> variable(i32))
.field emitB: int32 (size: 4 -> variable(i32))
.field emitAddI32: int32 (size: 4 -> variable(i32))
.field emitDivI32: int32 (size: 4 -> variable(i32))
.field emitNfcF32: float32 (size: 4 -> variable(f32))
.field floatAsInt32: function (size: 0 -> inline)
.field floatAsInt64: function (size: 0 -> inline)
.field emitFloatAsInt1: int32 (size: 4 -> variable(i32))
.field emitFloatAsInt2: int64 (size: 8 -> variable(i64))
.field emitFloatAsInt3: int32 (size: 4 -> variable(i32))
.field emitFloatAsInt4: int64 (size: 8 -> variable(i64))
.field emitSlice: char[] (size: 8 -> variable(arr))
.field zero: function (size: 0 -> inline)
.field last: function (size: 0 -> inline)
.field sum: function (size: 0 -> inline)
.field any: function (size: 0 -> inline)
.field min: function (size: 0 -> inline)
.field sum: function (size: 0 -> inline)
.field any: function (size: 0 -> inline)
.field min: function (size: 0 -> inline)
.field ma: int32 (size: 4 -> variable(i32))
.field mb: int32 (size: 4 -> variable(i32))
.field mc: int32 (size: 4 -> variable(i32))
.field zeroVal: int32 (size: 4 -> variable(i32))
.field zeroVar: int32 (size: 4 -> variable(i32))
.field zeroXpr: int32 (size: 4 -> variable(i32))
.field lastVal: int32 (size: 4 -> variable(i32))
.field lastVar: int32 (size: 4 -> variable(i32))
.field lastXpr: int32 (size: 4 -> variable(i32))
.field sum2Val: int32 (size: 4 -> variable(i32))
.field sum2Var: int32 (size: 4 -> variable(i32))
.field sum2Xpr: int32 (size: 4 -> variable(i32))
.field any2Val: int32 (size: 4 -> variable(i32))
.field any2Var: int32 (size: 4 -> variable(i32))
.field any2Xpr: int32 (size: 4 -> variable(i32))
.field min2Val: int32 (size: 4 -> variable(i32))
.field min2Var: int32 (size: 4 -> variable(i32))
.field min2Xpr: int32 (size: 4 -> variable(i32))
.field sum3Val: int32 (size: 4 -> variable(i32))
.field sum3Var: int32 (size: 4 -> variable(i32))
.field sum3Xpr: int32 (size: 4 -> variable(i32))
.field any3Val: int32 (size: 4 -> variable(i32))
.field any3Var: int32 (size: 4 -> variable(i32))
.field any3Xpr: int32 (size: 4 -> variable(i32))
.field min3Val: int32 (size: 4 -> variable(i32))
.field min3Var: int32 (size: 4 -> variable(i32))
.field min3Xpr: int32 (size: 4 -> variable(i32))
.field overload: typename (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload: function (size: 0 -> inline)
.field overload1: float32 (size: 4 -> variable(f32))
.field overload2: float32 (size: 4 -> variable(f32))
.field overload3: float32 (size: 4 -> variable(f32))
.field overload4: float32 (size: 4 -> variable(f32))
.field overload5: float32 (size: 4 -> variable(f32))
.field Celsius: typename (size: 8 -> static const typename(val))
.field Fahrenheit: typename (size: 8 -> static const typename(val))
.field Celsius: function (size: 0 -> inline)
.field Fahrenheit: function (size: 0 -> inline)
.field Celsius: function (size: 0 -> inline)
.field Fahrenheit: function (size: 0 -> inline)
.field boilC: Celsius (size: 8 -> variable(val))
.field boilF: Fahrenheit (size: 8 -> variable(val))
.field value: int64 (size: 8 -> static variable(i64))
.field valueRef: int64 (size: 4 -> variable(ref))
.field valuePtr: pointer (size: 4 -> variable(ref))
.field valueVar: variant (size: 8 -> variable(var))
.field fromRef: int64 (size: 8 -> variable(i64))
.field fromPtr: int64 (size: 4 -> variable(ref))
.field fromVar: int64 (size: 4 -> variable(ref))
.field nullRef: int64 (size: 4 -> variable(ref))
.field nullPtr: pointer (size: 4 -> variable(ref))
.field nullVar: variant (size: 8 -> variable(var))
.field nullTyp: typename (size: 4 -> variable(ref))
.field nullFun: function (size: 4 -> variable(ref))
.field nullObj: object (size: 4 -> variable(ref))
.field typePtr: pointer (size: 4 -> variable(ref))
.field typeVar: variant (size: 8 -> variable(var))
.field typeTyp: typename (size: 4 -> variable(ref))
.field local: int64 (size: 8 -> variable(i64))
.field copyVal: int64 (size: 8 -> variable(i64))
.field copyRef: int64 (size: 4 -> variable(ref))
.field copyPtr: pointer (size: 4 -> variable(ref))
.field copyVar: variant (size: 8 -> variable(var))
.field copyTyp: typename (size: 4 -> variable(ref))
.field ptrVoid: pointer (size: 4 -> variable(ref))
.field ptrBool: pointer (size: 4 -> variable(ref))
.field ptrChar: pointer (size: 4 -> variable(ref))
.field ptrInt8: pointer (size: 4 -> variable(ref))
.field ptrInt16: pointer (size: 4 -> variable(ref))
.field ptrInt32: pointer (size: 4 -> variable(ref))
.field ptrInt64: pointer (size: 4 -> variable(ref))
.field ptrUint8: pointer (size: 4 -> variable(ref))
.field ptrUint16: pointer (size: 4 -> variable(ref))
.field ptrUint32: pointer (size: 4 -> variable(ref))
.field ptrUint64: pointer (size: 4 -> variable(ref))
.field ptrFloat32: pointer (size: 4 -> variable(ref))
.field ptrFloat64: pointer (size: 4 -> variable(ref))
.field ptrTypename: pointer (size: 4 -> variable(ref))
.field ptrFunction: pointer (size: 4 -> variable(ref))
.field ptrPointer: pointer (size: 4 -> variable(ref))
.field ptrVariant: pointer (size: 4 -> variable(ref))
.field ptrObject: pointer (size: 4 -> variable(ref))
.field varVoid: variant (size: 8 -> variable(var))
.field varBool: variant (size: 8 -> variable(var))
.field varChar: variant (size: 8 -> variable(var))
.field varInt8: variant (size: 8 -> variable(var))
.field varInt16: variant (size: 8 -> variable(var))
.field varInt32: variant (size: 8 -> variable(var))
.field varInt64: variant (size: 8 -> variable(var))
.field varUint8: variant (size: 8 -> variable(var))
.field varUint16: variant (size: 8 -> variable(var))
.field varUint32: variant (size: 8 -> variable(var))
.field varUint64: variant (size: 8 -> variable(var))
.field varFloat32: variant (size: 8 -> variable(var))
.field varFloat64: variant (size: 8 -> variable(var))
.field varTypename: variant (size: 8 -> variable(var))
.field varFunction: variant (size: 8 -> variable(var))
.field varPointer: variant (size: 8 -> variable(var))
.field varVariant: variant (size: 8 -> variable(var))
.field varObject: variant (size: 8 -> variable(var))
.field typVoid: typename (size: 4 -> variable(ref))
.field typBool: typename (size: 4 -> variable(ref))
.field typChar: typename (size: 4 -> variable(ref))
.field typInt8: typename (size: 4 -> variable(ref))
.field typInt16: typename (size: 4 -> variable(ref))
.field typInt32: typename (size: 4 -> variable(ref))
.field typInt64: typename (size: 4 -> variable(ref))
.field typUint8: typename (size: 4 -> variable(ref))
.field typUint16: typename (size: 4 -> variable(ref))
.field typUint32: typename (size: 4 -> variable(ref))
.field typUint64: typename (size: 4 -> variable(ref))
.field typFloat32: typename (size: 4 -> variable(ref))
.field typFloat64: typename (size: 4 -> variable(ref))
.field typTypename: typename (size: 4 -> variable(ref))
.field typFunction: typename (size: 4 -> variable(ref))
.field typPointer: typename (size: 4 -> variable(ref))
.field typVariant: typename (size: 4 -> variable(ref))
.field typObject: typename (size: 4 -> variable(ref))
.field valueOfPtr: pointer (size: 4 -> variable(ref))
.field valueOfVar: variant (size: 8 -> variable(var))
.field valueOfTyp: typename (size: 4 -> variable(ref))
.field typeOfValue: typename (size: 4 -> variable(ref))
.field copyPtrFloat64: variant (size: 8 -> variable(var))
.field copyVarFloat64: pointer (size: 4 -> variable(ref))
.field empty: function (size: 1 -> static const function)
.field funAdd: function (size: 8 -> static const function)
.field funAddResult: int32 (size: 4 -> variable(i32))
.field funAddRef: function (size: 4 -> variable(ref))
.field funAddRefResult: int32 (size: 4 -> variable(i32))
.field funMul: function (size: 4 -> variable(ref))
.field funMulResult: int32 (size: 4 -> variable(i32))
.field funMulRef: function (size: 4 -> variable(ref))
.field funMulRefResult: int32 (size: 4 -> variable(i32))
.field funMul: function (size: 8 -> static const function)
.field fib: function (size: 55 -> static const function)
.field fibonacci_13: uint32 (size: 4 -> variable(u32))
.field sizeofVoid: int32 (size: 4 -> variable(i32))
.field sizeofBool: int32 (size: 4 -> variable(i32))
.field sizeofChar: int32 (size: 4 -> variable(i32))
.field sizeofInt8: int32 (size: 4 -> variable(i32))
.field sizeofInt16: int32 (size: 4 -> variable(i32))
.field sizeofInt32: int32 (size: 4 -> variable(i32))
.field sizeofInt64: int32 (size: 4 -> variable(i32))
.field sizeofUint8: int32 (size: 4 -> variable(i32))
.field sizeofUint16: int32 (size: 4 -> variable(i32))
.field sizeofUint32: int32 (size: 4 -> variable(i32))
.field sizeofUint64: int32 (size: 4 -> variable(i32))
.field sizeofFloat32: int32 (size: 4 -> variable(i32))
.field sizeofFloat64: int32 (size: 4 -> variable(i32))
.field sizeofPointer: int32 (size: 4 -> variable(i32))
.field sizeofVariant: int32 (size: 4 -> variable(i32))
.field sizeofTypename: int32 (size: 4 -> variable(i32))
.field sizeofFunction: int32 (size: 4 -> variable(i32))
.field sizeofObject: int32 (size: 4 -> variable(i32))
.field RecordSizeof: object (size: 12 -> static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16 -> static const typename(ref))
.field typeofRecord: typename (size: 4 -> variable(ref))
.field nameOfRecord: char[*] (size: 4 -> variable(ref))
.field offsetOfRecord: int32 (size: 4 -> variable(i32))
.field sizeOfRecord: int32 (size: 4 -> variable(i32))
.field fileOfRecord: char[*] (size: 4 -> variable(ref))
.field lineOfRecord: int32 (size: 4 -> variable(i32))
.field typeofBase: typename (size: 4 -> variable(ref))
.field nameOfBase: char[*] (size: 4 -> variable(ref))
.field offsetOfBase: int32 (size: 4 -> variable(i32))
.field sizeOfBase: int32 (size: 4 -> variable(i32))
.field fileOfBase: char[*] (size: 4 -> variable(ref))
.field lineOfBase: int32 (size: 4 -> variable(i32))
.field typeofBase1: typename (size: 4 -> variable(ref))
.field offsetOfBase1: int32 (size: 4 -> variable(i32))
.field sizeOfBase1: int32 (size: 4 -> variable(i32))
.field typeofBase2: typename (size: 4 -> variable(ref))
.field offsetOfBase2: int32 (size: 4 -> variable(i32))
.field sizeOfBase2: int32 (size: 4 -> variable(i32))
.field pi64: float64 (size: 8 -> variable(f64))
.field e64: float64 (size: 8 -> variable(f64))
.field pi32: float32 (size: 4 -> variable(f32))
.field e32: float32 (size: 4 -> variable(f32))
.field rgb888: function (size: 0 -> inline)
.field rgb565: function (size: 0 -> inline)
.field r_comp: int32 (size: 4 -> variable(i32))
.field g_comp: int32 (size: 4 -> variable(i32))
.field b_comp: int32 (size: 4 -> variable(i32))
.field r5g6b5: int32 (size: 4 -> variable(i32))
.field r8g8b8: int32 (size: 4 -> variable(i32))
.field zxtR5: int32 (size: 4 -> variable(i32))
.field zxtG6: int32 (size: 4 -> variable(i32))
.field zxtB5: int32 (size: 4 -> variable(i32))
.field sxtR5: int32 (size: 4 -> variable(i32))
.field sxtG6: int32 (size: 4 -> variable(i32))
.field sxtB5: int32 (size: 4 -> variable(i32))
.field zxtR8: int32 (size: 4 -> variable(i32))
.field zxtG8: int32 (size: 4 -> variable(i32))
.field zxtB8: int32 (size: 4 -> variable(i32))
.field sxtR8: int32 (size: 4 -> variable(i32))
.field sxtG8: int32 (size: 4 -> variable(i32))
.field sxtB8: int32 (size: 4 -> variable(i32))
.field sinF64: float64 (size: 8 -> variable(f64))
.field cosF64: float64 (size: 8 -> variable(f64))
.field tanF64: float64 (size: 8 -> variable(f64))
.field logF64: float64 (size: 8 -> variable(f64))
.field expF64: float64 (size: 8 -> variable(f64))
.field powF64: float64 (size: 8 -> variable(f64))
.field sqrtF64: float64 (size: 8 -> variable(f64))
.field atanF64: float64 (size: 8 -> variable(f64))
.field sinF32: float32 (size: 4 -> variable(f32))
.field cosF32: float32 (size: 4 -> variable(f32))
.field tanF32: float32 (size: 4 -> variable(f32))
.field logF32: float32 (size: 4 -> variable(f32))
.field expF32: float32 (size: 4 -> variable(f32))
.field powF32: float32 (size: 4 -> variable(f32))
.field sqrtF32: float32 (size: 4 -> variable(f32))
.field atanF32: float32 (size: 4 -> variable(f32))
.field realloc: function (size: 0 -> inline)
.field malloc: function (size: 0 -> inline)
.field free: function (size: 0 -> inline)
.field p1: pointer (size: 4 -> variable(ref))
.field p2: pointer (size: 4 -> variable(ref))
.field p3: pointer (size: 4 -> variable(ref))
.field p4: pointer (size: 4 -> variable(ref))
.field val1: int64 (size: 8 -> variable(i64))
.field val2: int64 (size: 8 -> variable(i64))
.field noError: function (size: 1 -> static const function)
.field stackOverflow: function (size: 24 -> static const function)
.field divisionByZero: function (size: 12 -> static const function)
.field abortExecution: function (size: 68 -> static const function)
.field invalidMemoryAccess: function (size: 13 -> static const function)
.field invalidInstruction: function (size: 2 -> static const function)
.field tryExecErr0: int32 (size: 4 -> variable(i32))
.field tryExecErr1: int32 (size: 4 -> variable(i32))
.field tryExecErr2: int32 (size: 4 -> variable(i32))
.field tryExecErr3: int32 (size: 4 -> variable(i32))
.field tryExecErr4: int32 (size: 4 -> variable(i32))
.field tryExecErr5: int32 (size: 4 -> variable(i32))
.field tryExecErr6: int32 (size: 4 -> variable(i32))
.field arrFixedNoInit: int64[7] (size: 56 -> variable(val))
.field arrArrayNoInit: int64[*] (size: 4 -> variable(ref))
.field arrSliceNoInit: int64[] (size: 8 -> variable(arr))
.field arrArrayInitNull: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitNull: int64[] (size: 8 -> variable(arr))
.field arrArrayInitFixed: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitFixed: int64[] (size: 8 -> variable(arr))
.field arrArrayInitSlice: int64[*] (size: 4 -> variable(ref))
.field arrSliceInitSlice: int64[] (size: 8 -> variable(arr))
.field arrArrayInitPtr: int64[*] (size: 4 -> variable(ref))
.field strFixed: char[7] (size: 7 -> variable(val))
.field strArray: char[*] (size: 4 -> variable(ref))
.field strSlice: char[] (size: 8 -> variable(arr))
.field lenSlice: function (size: 5 -> static const function)
.field nthFixed: function (size: 12 -> static const function)
.field nthArray: function (size: 12 -> static const function)
.field nthSlice: function (size: 12 -> static const function)
.field RecordMemberTest: typename (size: 32 -> static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32 -> variable(val))
.field RecordMethodTest: typename (size: 16 -> static const typename(val))
.field globalFunction: function (size: 8 -> static const function)
.field recordMethodTest: RecordMethodTest (size: 16 -> variable(val))
.field customPrint: function (size: 40 -> static const function)
.field recordMethodTestCustomPrint: RecordMethodTest (size: 16 -> variable(val))
.field print: function (size: 40 -> static const function)
.field printStatic: function (size: 40 -> static const function)
.field rgbF32: typename (size: 16 -> static const typename(val))
.field rgbU8: typename (size: 3 -> static const typename(val))
.field color: typename (size: 4 -> static const typename(val))
.field Color: object (size: 20 -> static const typename(ref))
.field black: rgbU8 (size: 3 -> variable(val))
.field green: rgbU8 (size: 3 -> variable(val))
.field white: rgbU8 (size: 3 -> variable(val))
.field cyan: color (size: 4 -> variable(val))
.field blue: color (size: 4 -> variable(val))
.field record_pack0: typename (size: 8 -> static const typename(val))
.field record_pack1: typename (size: 17 -> static const typename(val))
.field record_pack2: typename (size: 20 -> static const typename(val))
.field record_pack4: typename (size: 24 -> static const typename(val))
.field record_pack8: typename (size: 32 -> static const typename(val))
.field record_packDef: typename (size: 32 -> static const typename(val))
.field a: typename (size: 0 -> inline)
.field b: typename (size: 0 -> inline)
.field shift: int32 (size: 4 -> variable(i32))
.field boolA: bool (size: 1 -> variable(bool))
.field boolB: bool (size: 1 -> variable(bool))
.field boolAnd: bool (size: 1 -> variable(bool))
.field boolIor: bool (size: 1 -> variable(bool))
.field boolXor: bool (size: 1 -> variable(bool))
.field boolNot: bool (size: 1 -> variable(bool))
.field boolCeq: bool (size: 1 -> variable(bool))
.field boolCne: bool (size: 1 -> variable(bool))
.field boolClt: bool (size: 1 -> variable(bool))
.field boolCle: bool (size: 1 -> variable(bool))
.field boolCgt: bool (size: 1 -> variable(bool))
.field boolCge: bool (size: 1 -> variable(bool))
.field chrA: char (size: 1 -> variable(i32))
.field chrB: char (size: 1 -> variable(i32))
.field chrPls: char (size: 1 -> variable(i32))
.field chrNeg: char (size: 1 -> variable(i32))
.field chrCmt: char (size: 1 -> variable(i32))
.field chrAdd: char (size: 1 -> variable(i32))
.field chrSub: char (size: 1 -> variable(i32))
.field chrMul: char (size: 1 -> variable(i32))
.field chrDiv: char (size: 1 -> variable(i32))
.field chrMod: char (size: 1 -> variable(i32))
.field chrAnd: char (size: 1 -> variable(i32))
.field chrIor: char (size: 1 -> variable(i32))
.field chrXor: char (size: 1 -> variable(i32))
.field chrShl: char (size: 1 -> variable(i32))
.field chrShr: char (size: 1 -> variable(i32))
.field chrNot: bool (size: 1 -> variable(bool))
.field chrCeq: bool (size: 1 -> variable(bool))
.field chrCne: bool (size: 1 -> variable(bool))
.field chrClt: bool (size: 1 -> variable(bool))
.field chrCle: bool (size: 1 -> variable(bool))
.field chrCgt: bool (size: 1 -> variable(bool))
.field chrCge: bool (size: 1 -> variable(bool))
.field i8A: int8 (size: 1 -> variable(i32))
.field i8B: int8 (size: 1 -> variable(i32))
.field i8Pls: int8 (size: 1 -> variable(i32))
.field i8Neg: int8 (size: 1 -> variable(i32))
.field i8Cmt: int8 (size: 1 -> variable(i32))
.field i8Add: int8 (size: 1 -> variable(i32))
.field i8Sub: int8 (size: 1 -> variable(i32))
.field i8Mul: int8 (size: 1 -> variable(i32))
.field i8Div: int8 (size: 1 -> variable(i32))
.field i8Mod: int8 (size: 1 -> variable(i32))
.field i8And: int8 (size: 1 -> variable(i32))
.field i8Ior: int8 (size: 1 -> variable(i32))
.field i8Xor: int8 (size: 1 -> variable(i32))
.field i8Shl: int8 (size: 1 -> variable(i32))
.field i8Shr: int8 (size: 1 -> variable(i32))
.field i8Not: bool (size: 1 -> variable(bool))
.field i8Ceq: bool (size: 1 -> variable(bool))
.field i8Cne: bool (size: 1 -> variable(bool))
.field i8Clt: bool (size: 1 -> variable(bool))
.field i8Cle: bool (size: 1 -> variable(bool))
.field i8Cgt: bool (size: 1 -> variable(bool))
.field i8Cge: bool (size: 1 -> variable(bool))
.field u8A: uint8 (size: 1 -> variable(u32))
.field u8B: uint8 (size: 1 -> variable(u32))
.field u8Pls: uint8 (size: 1 -> variable(u32))
.field u8Neg: uint8 (size: 1 -> variable(u32))
.field u8Cmt: uint8 (size: 1 -> variable(u32))
.field u8Add: uint8 (size: 1 -> variable(u32))
.field u8Sub: uint8 (size: 1 -> variable(u32))
.field u8Mul: uint8 (size: 1 -> variable(u32))
.field u8Div: uint8 (size: 1 -> variable(u32))
.field u8Mod: uint8 (size: 1 -> variable(u32))
.field u8And: uint8 (size: 1 -> variable(u32))
.field u8Ior: uint8 (size: 1 -> variable(u32))
.field u8Xor: uint8 (size: 1 -> variable(u32))
.field u8Shl: uint8 (size: 1 -> variable(u32))
.field u8Shr: uint8 (size: 1 -> variable(u32))
.field u8Not: bool (size: 1 -> variable(bool))
.field u8Ceq: bool (size: 1 -> variable(bool))
.field u8Cne: bool (size: 1 -> variable(bool))
.field u8Clt: bool (size: 1 -> variable(bool))
.field u8Cle: bool (size: 1 -> variable(bool))
.field u8Cgt: bool (size: 1 -> variable(bool))
.field u8Cge: bool (size: 1 -> variable(bool))
.field i16A: int16 (size: 2 -> variable(i32))
.field i16B: int16 (size: 2 -> variable(i32))
.field i16Pls: int16 (size: 2 -> variable(i32))
.field i16Neg: int16 (size: 2 -> variable(i32))
.field i16Cmt: int16 (size: 2 -> variable(i32))
.field i16Add: int16 (size: 2 -> variable(i32))
.field i16Sub: int16 (size: 2 -> variable(i32))
.field i16Mul: int16 (size: 2 -> variable(i32))
.field i16Div: int16 (size: 2 -> variable(i32))
.field i16Mod: int16 (size: 2 -> variable(i32))
.field i16And: int16 (size: 2 -> variable(i32))
.field i16Ior: int16 (size: 2 -> variable(i32))
.field i16Xor: int16 (size: 2 -> variable(i32))
.field i16Shl: int16 (size: 2 -> variable(i32))
.field i16Shr: int16 (size: 2 -> variable(i32))
.field i16Not: bool (size: 1 -> variable(bool))
.field i16Ceq: bool (size: 1 -> variable(bool))
.field i16Cne: bool (size: 1 -> variable(bool))
.field i16Clt: bool (size: 1 -> variable(bool))
.field i16Cle: bool (size: 1 -> variable(bool))
.field i16Cgt: bool (size: 1 -> variable(bool))
.field i16Cge: bool (size: 1 -> variable(bool))
.field u16A: uint16 (size: 2 -> variable(u32))
.field u16B: uint16 (size: 2 -> variable(u32))
.field u16Pls: uint16 (size: 2 -> variable(u32))
.field u16Neg: uint16 (size: 2 -> variable(u32))
.field u16Cmt: uint16 (size: 2 -> variable(u32))
.field u16Add: uint16 (size: 2 -> variable(u32))
.field u16Sub: uint16 (size: 2 -> variable(u32))
.field u16Mul: uint16 (size: 2 -> variable(u32))
.field u16Div: uint16 (size: 2 -> variable(u32))
.field u16Mod: uint16 (size: 2 -> variable(u32))
.field u16And: uint16 (size: 2 -> variable(u32))
.field u16Ior: uint16 (size: 2 -> variable(u32))
.field u16Xor: uint16 (size: 2 -> variable(u32))
.field u16Shl: uint16 (size: 2 -> variable(u32))
.field u16Shr: uint16 (size: 2 -> variable(u32))
.field u16Not: bool (size: 1 -> variable(bool))
.field u16Ceq: bool (size: 1 -> variable(bool))
.field u16Cne: bool (size: 1 -> variable(bool))
.field u16Clt: bool (size: 1 -> variable(bool))
.field u16Cle: bool (size: 1 -> variable(bool))
.field u16Cgt: bool (size: 1 -> variable(bool))
.field u16Cge: bool (size: 1 -> variable(bool))
.field i32A: int32 (size: 4 -> variable(i32))
.field i32B: int32 (size: 4 -> variable(i32))
.field i32Pls: int32 (size: 4 -> variable(i32))
.field i32Neg: int32 (size: 4 -> variable(i32))
.field i32Cmt: int32 (size: 4 -> variable(i32))
.field i32Add: int32 (size: 4 -> variable(i32))
.field i32Sub: int32 (size: 4 -> variable(i32))
.field i32Mul: int32 (size: 4 -> variable(i32))
.field i32Div: int32 (size: 4 -> variable(i32))
.field i32Mod: int32 (size: 4 -> variable(i32))
.field i32And: int32 (size: 4 -> variable(i32))
.field i32Ior: int32 (size: 4 -> variable(i32))
.field i32Xor: int32 (size: 4 -> variable(i32))
.field i32Shl: int32 (size: 4 -> variable(i32))
.field i32Shr: int32 (size: 4 -> variable(i32))
.field i32Not: bool (size: 1 -> variable(bool))
.field i32Ceq: bool (size: 1 -> variable(bool))
.field i32Cne: bool (size: 1 -> variable(bool))
.field i32Clt: bool (size: 1 -> variable(bool))
.field i32Cle: bool (size: 1 -> variable(bool))
.field i32Cgt: bool (size: 1 -> variable(bool))
.field i32Cge: bool (size: 1 -> variable(bool))
.field u32A: uint32 (size: 4 -> variable(u32))
.field u32B: uint32 (size: 4 -> variable(u32))
.field u32Pls: uint32 (size: 4 -> variable(u32))
.field u32Neg: uint32 (size: 4 -> variable(u32))
.field u32Cmt: uint32 (size: 4 -> variable(u32))
.field u32Add: uint32 (size: 4 -> variable(u32))
.field u32Sub: uint32 (size: 4 -> variable(u32))
.field u32Mul: uint32 (size: 4 -> variable(u32))
.field u32Div: uint32 (size: 4 -> variable(u32))
.field u32Mod: uint32 (size: 4 -> variable(u32))
.field u32And: uint32 (size: 4 -> variable(u32))
.field u32Ior: uint32 (size: 4 -> variable(u32))
.field u32Xor: uint32 (size: 4 -> variable(u32))
.field u32Shl: uint32 (size: 4 -> variable(u32))
.field u32Shr: uint32 (size: 4 -> variable(u32))
.field u32Not: bool (size: 1 -> variable(bool))
.field u32Ceq: bool (size: 1 -> variable(bool))
.field u32Cne: bool (size: 1 -> variable(bool))
.field u32Clt: bool (size: 1 -> variable(bool))
.field u32Cle: bool (size: 1 -> variable(bool))
.field u32Cgt: bool (size: 1 -> variable(bool))
.field u32Cge: bool (size: 1 -> variable(bool))
.field i64A: int64 (size: 8 -> variable(i64))
.field i64B: int64 (size: 8 -> variable(i64))
.field i64Pls: int64 (size: 8 -> variable(i64))
.field i64Neg: int64 (size: 8 -> variable(i64))
.field i64Cmt: int64 (size: 8 -> variable(i64))
.field i64Add: int64 (size: 8 -> variable(i64))
.field i64Sub: int64 (size: 8 -> variable(i64))
.field i64Mul: int64 (size: 8 -> variable(i64))
.field i64Div: int64 (size: 8 -> variable(i64))
.field i64Mod: int64 (size: 8 -> variable(i64))
.field i64And: int64 (size: 8 -> variable(i64))
.field i64Ior: int64 (size: 8 -> variable(i64))
.field i64Xor: int64 (size: 8 -> variable(i64))
.field i64Shl: int64 (size: 8 -> variable(i64))
.field i64Shr: int64 (size: 8 -> variable(i64))
.field i64Not: bool (size: 1 -> variable(bool))
.field i64Ceq: bool (size: 1 -> variable(bool))
.field i64Cne: bool (size: 1 -> variable(bool))
.field i64Clt: bool (size: 1 -> variable(bool))
.field i64Cle: bool (size: 1 -> variable(bool))
.field i64Cgt: bool (size: 1 -> variable(bool))
.field i64Cge: bool (size: 1 -> variable(bool))
.field u64A: uint64 (size: 8 -> variable(u64))
.field u64B: uint64 (size: 8 -> variable(u64))
.field u64Pls: uint64 (size: 8 -> variable(u64))
.field u64Neg: uint64 (size: 8 -> variable(u64))
.field u64Cmt: uint64 (size: 8 -> variable(u64))
.field u64Add: uint64 (size: 8 -> variable(u64))
.field u64Sub: uint64 (size: 8 -> variable(u64))
.field u64Mul: uint64 (size: 8 -> variable(u64))
.field u64Div: uint64 (size: 8 -> variable(u64))
.field u64Mod: uint64 (size: 8 -> variable(u64))
.field u64And: uint64 (size: 8 -> variable(u64))
.field u64Ior: uint64 (size: 8 -> variable(u64))
.field u64Xor: uint64 (size: 8 -> variable(u64))
.field u64Shl: uint64 (size: 8 -> variable(u64))
.field u64Shr: uint64 (size: 8 -> variable(u64))
.field u64Not: bool (size: 1 -> variable(bool))
.field u64Ceq: bool (size: 1 -> variable(bool))
.field u64Cne: bool (size: 1 -> variable(bool))
.field u64Clt: bool (size: 1 -> variable(bool))
.field u64Cle: bool (size: 1 -> variable(bool))
.field u64Cgt: bool (size: 1 -> variable(bool))
.field u64Cge: bool (size: 1 -> variable(bool))
.field f32A: float32 (size: 4 -> variable(f32))
.field f32B: float32 (size: 4 -> variable(f32))
.field f32Pls: float32 (size: 4 -> variable(f32))
.field f32Neg: float32 (size: 4 -> variable(f32))
.field f32Add: float32 (size: 4 -> variable(f32))
.field f32Sub: float32 (size: 4 -> variable(f32))
.field f32Mul: float32 (size: 4 -> variable(f32))
.field f32Div: float32 (size: 4 -> variable(f32))
.field f32Mod: float32 (size: 4 -> variable(f32))
.field f32Not: bool (size: 1 -> variable(bool))
.field f32Ceq: bool (size: 1 -> variable(bool))
.field f32Cne: bool (size: 1 -> variable(bool))
.field f32Clt: bool (size: 1 -> variable(bool))
.field f32Cle: bool (size: 1 -> variable(bool))
.field f32Cgt: bool (size: 1 -> variable(bool))
.field f32Cge: bool (size: 1 -> variable(bool))
.field f64A: float64 (size: 8 -> variable(f64))
.field f64B: float64 (size: 8 -> variable(f64))
.field f64Pls: float64 (size: 8 -> variable(f64))
.field f64Neg: float64 (size: 8 -> variable(f64))
.field f64Add: float64 (size: 8 -> variable(f64))
.field f64Sub: float64 (size: 8 -> variable(f64))
.field f64Mul: float64 (size: 8 -> variable(f64))
.field f64Div: float64 (size: 8 -> variable(f64))
.field f64Mod: float64 (size: 8 -> variable(f64))
.field f64Not: bool (size: 1 -> variable(bool))
.field f64Ceq: bool (size: 1 -> variable(bool))
.field f64Cne: bool (size: 1 -> variable(bool))
.field f64Clt: bool (size: 1 -> variable(bool))
.field f64Cle: bool (size: 1 -> variable(bool))
.field f64Cgt: bool (size: 1 -> variable(bool))
.field f64Cge: bool (size: 1 -> variable(bool))
.field ptrA: pointer (size: 4 -> variable(ref))
.field ptrB: pointer (size: 4 -> variable(ref))
.field ptrCeq: bool (size: 1 -> variable(bool))
.field ptrCne: bool (size: 1 -> variable(bool))
.field t: int32 (size: 4 -> variable(i32))
.field forIdx: int32 (size: 4 -> variable(i32))
.field .main: function (size: 7233 -> static function)
.value: {
	{
		static if (typename(raise) == function) {
			verbose(message: char[*], inspect: variant): void := raise(raise.verbose, raise.noTrace, message, inspect);
			verbose(message: char[*]): void := raise(raise.verbose, raise.noTrace, message, null);
			trace(message: char[*], inspect: variant): void := raise(raise.debug, raise.defTrace, message, inspect);
			trace(message: char[*]): void := raise(raise.debug, raise.defTrace, message, null);
			debug(message: char[*], inspect: variant): void := raise(raise.debug, raise.noTrace, message, inspect);
			debug(message: char[*]): void := raise(raise.debug, raise.noTrace, message, null);
			info(message: char[*], inspect: variant): void := raise(raise.info, raise.noTrace, message, inspect);
			info(message: char[*]): void := raise(raise.info, raise.noTrace, message, null);
			warn(message: char[*], inspect: variant): void := raise(raise.warn, raise.noTrace, message, inspect);
			warn(message: char[*]): void := raise(raise.warn, raise.noTrace, message, null);
			error(message: char[*], inspect: variant): void := raise(raise.error, raise.defTrace, message, inspect);
			error(message: char[*]): void := raise(raise.error, raise.defTrace, message, null);
			abort(message: char[*], inspect: variant): void := raise(raise.abort, raise.defTrace, message, inspect);
			abort(message: char[*]): void := raise(raise.abort, raise.defTrace, message, null);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!", null);
			assert(condition: bool, message: char[*], inspect: variant): void := void(condition ? void(0) : abort(message, inspect));
			assert(condition: bool, message: char[*]): void := void(condition ? void(0) : abort(message));
			assert(condition: bool): void := void(condition ? void(0) : abort("assertion failed!"));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const message: char[*];
			};
			static const assertEq(expected: int32, returned: int32, message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				details: NotEquals := {
					details.expected := (expected);
					details.returned := (returned);
					details.message := (message);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", details);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		sizeof(type: typename): int32 := int32(type.size);
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.000000 / ln2;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 1.000000 / ln10;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := (0) / 0.000000;
			static const inf: float64 := (1) / 0.000000;
			static const modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := -modf(-x, intPart);
						intPart := -intPart;
						return .result := result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static const floor(x: float64): float64 := {
				result: float64;
				modf(x, result);
				return .result := result;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static const sign(x: float32): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const sign(x: float64): int32 := {
				if (x == (0)) {
					return .result := 0;
				}
				if (x < (0)) {
					return .result := -1;
				}
				return .result := 1;
			};
			static const abs(x: float32): float32 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const abs(x: float64): float64 := {
				if (x < (0)) {
					return .result := -x;
				}
				return .result := x;
			};
			static const min(a: float32, b: float32): float32 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const min(a: float64, b: float64): float64 := {
				if (a < b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float32, b: float32): float32 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const max(a: float64, b: float64): float64 := {
				if (a > b) {
					return .result := a;
				}
				return .result := b;
			};
			static const clamp(t: float32, a: float32, b: float32): float32 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const clamp(t: float64, a: float64, b: float64): float64 := {
				if (t < a) {
					return .result := a;
				}
				if (t > b) {
					return .result := b;
				}
				return .result := t;
			};
			static const lerp(t: float32, a: float32, b: float32): float32 := {
				return .result := a + t * (b - a);
			};
			static const lerp(t: float64, a: float64, b: float64): float64 := {
				return .result := a + t * (b - a);
			};
			static const smooth(t: float32, a: float32, b: float32): float32 := {
				t := clamp((t - a) / (b - a), 0.000000, 1.000000);
				return .result := t * t * ((3) - (2) * t);
			};
			static const smooth(t: float64, a: float64, b: float64): float64 := {
				t := clamp((t - a) / (b - a), 0.000000, 1.000000);
				return .result := t * t * ((3) - (2) * t);
			};
			static const cmp(a: float32, b: float32, eps: float32): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const cmp(a: float64, b: float64, eps: float64): int32 := {
				if (a < b) {
					if (eps < (b - a)) {
						return .result := -1;
					}
				}
				else {
					if (eps < (a - b)) {
						return .result := +1;
					}
				}
				return .result := 0;
			};
			static const sinCos(arg: float64, quad: int32): float64 := {
				x: float64 := arg;
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (1) / PIO2;
				if (x > (32764)) {
					e: float64;
					y := modf(x, e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				temp1: float64 := ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
				temp2: float64 := ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
				return .result := temp1 / temp2;
			};
			static sin(arg: float64): float64 := sinCos(arg, 0);
			static cos(arg: float64): float64 := sinCos(abs(arg), 1);
			static const tan(arg: float64): float64 := {
				complement: bool := false;
				negate: bool := false;
				if (arg < (0)) {
					arg := -arg;
					negate := true;
				}
				arg := (2) * arg / PIO2;
				e: float64;
				x: float64 := modf(arg, e);
				i: int32 := int32(e) % 4;
				if (i == 0) ;
				else {
					if (i == 1) {
						x := (1) - x;
						complement := true;
					}
					else {
						if (i == 2) {
							negate := !negate;
							complement := true;
						}
						else {
							if (i == 3) {
								x := (1) - x;
								negate := !negate;
							}
						}
					}
				}
				xsq: float64 := x * x;
				result: float64 := ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
				result := result / (((xsq + q2) * xsq + q1) * xsq + q0);
				if (complement) {
					if (result == (0)) {
						return .result := nan;
					}
					result := (1) / result;
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const sinh(x: float64): float64 := {
				negate: bool := false;
				if (x < (0)) {
					x := -x;
					negate := true;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				result: float64;
				if (x > 0.500000) {
					result := (float64.exp(x) - float64.exp(-x)) / (2);
				}
				else {
					sq: float64 := x * x;
					result := (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
					result := result / (((sq + Q2) * sq + Q1) * sq + Q0);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static const cosh(x: float64): float64 := {
				if (x < (0)) {
					x := -x;
				}
				if (x > (21)) {
					return .result := float64.exp(x) / (2);
				}
				return .result := (float64.exp(x) + float64.exp(-x)) / (2);
			};
			static const asin(x: float64): float64 := {
				if (x == (0)) {
					return .result := x;
				}
				negate: bool := false;
				if (x < (0)) {
					negate := true;
					x := -x;
				}
				if (x > (1)) {
					return .result := nan;
				}
				result: float64 := float64.sqrt((1) - x * x);
				if (x > 0.700000) {
					result := pi / (2) - float64.atan2(result, x);
				}
				else {
					result := float64.atan2(x, result);
				}
				if (negate) {
					return .result := -result;
				}
				return .result := result;
			};
			static acos(x: float64): float64 := (pi / (2) - asin(x));
			static deg2rad(x: float64): float64 := float64(x * pi / (180));
			static rad2deg(x: float64): float64 := float64(x * (180) / pi);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const Complex(re: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := (0);
		};
		};
		static const Complex(re: float64, im: float64): Complex := {
			return .result := {
			.result.re := re;
			.result.im := im;
		};
		};
		neg(a: Complex): Complex := Complex(-a.re, -a.im);
		add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static const div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := float64.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := float64.atan2(a.re, a.im);
		static const inv(a: Complex): Complex := {
			d: float64 := (a.re * a.re + a.im * a.im);
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));
		log(a: Complex): Complex := Complex(float64.log(abs(a)), arg(a));
		static const pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * float64.log(r);
			v: float64 := float64.pow(r, b.re) * float64.exp(-b.im * t);
			return .result := {
			.result.re := v * float64.cos(u);
			.result.im := v * float64.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const length(str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static const indexOf(str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static const lastIndexOf(str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static const startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static const compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static const ignCaseCmp(chr: char, with: char): int32 := {
			static const ignCase(chr: char): char := {
				if (chr >= 'A' && chr <= 'Z') {
					chr := chr - 'A';
					chr := chr + 'a';
				}
				return .result := chr;
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static const caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		startsWith(str: char[*], with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(str: char[*], with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(str: char[*], with: char[*]): int32 := compare(str, with, caseCmp);
		contains(str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static const FormatFlags: struct {
			const radix: int32;
			const sign: char;
			const padChr: char;
			const padLen: int32;
			const precision: int32;
		};
		static const append(output: char[], pos: int32, value: char[*]): int32 := {
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80];
			radix: int32 := format.radix;
			assert(radix > 1 && radix < (radixDigits.length));
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.padLen - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if (format.sign != '') {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := format.sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static const append(output: char[], pos: int32, value: uint32): int32 := {
			static const format: FormatFlags := {
				format.radix := 10;
				format.sign := '';
				format.padChr := ' ';
				format.padLen := 0;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
		static const append(output: char[], pos: int32, value: int32, forceSign: bool, pad: int32): int32 := {
			sign: char := 0;
			if (value < 0) {
				value := -value;
				sign := '-';
			}
			else {
				if (forceSign) {
					sign := '+';
				}
			}
			const format: FormatFlags := {
				format.radix := 10;
				format.sign := sign;
				format.padChr := '0';
				format.padLen := pad;
				format.precision := 0;
			};
			return .result := append(output, pos, value, format);
		};
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32);
		emitDivI32: int32 := emit(int32(10), int32(5), div.i32);
		emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin);
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(int32(3), pointer("string"));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		sum(a: int32, b: int32, c: int32): int32 := sum(sum(a, b), c);
		any(a: int32, b: int32, c: int32): int32 := any(any(a, b), c);
		min(a: int32, b: int32, c: int32): int32 := min(min(a, b), c);
		ma: int32 := 3;
		mb: int32 := 6;
		mc: int32 := 9;
		zeroVal: int32 := zero(2, 3);
		zeroVar: int32 := zero(ma, mb);
		zeroXpr: int32 := zero(ma + mb, mb + mc);
		lastVal: int32 := last(2, 3);
		lastVar: int32 := last(ma, mb);
		lastXpr: int32 := last(ma + mb, mb + mc);
		sum2Val: int32 := sum(3, 12);
		sum2Var: int32 := sum(ma, mb);
		sum2Xpr: int32 := sum(ma + mb, mb + mc);
		any2Val: int32 := any(3, 12);
		any2Var: int32 := any(ma, mb);
		any2Xpr: int32 := any(ma + mb, mb + mc);
		min2Val: int32 := min(3, 12);
		min2Var: int32 := min(ma, mb);
		min2Xpr: int32 := min(ma + mb, mb + mc);
		sum3Val: int32 := sum(3, 2, 6);
		sum3Var: int32 := sum(ma, mb, mc);
		sum3Xpr: int32 := sum(ma + mb, mb + mc, mc + ma);
		any3Val: int32 := any(3, 2, 6);
		any3Var: int32 := any(ma, mb, mc);
		any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma);
		min3Val: int32 := min(3, 2, 6);
		min3Var: int32 := min(ma, mb, mc);
		min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma);
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(0, 0);
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius((value.degrees - (32)) / 1.800000);
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(value.degrees * 1.800000 + (32));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		static if ((typename(int64)) == null) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		static const empty(): void := {
		};
		static const funAdd(x: int32, y: int32): int32 := {
			return .result := x + y;
		};
		funAddResult: int32 := funAdd(2, 7);
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(2, 8);
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(2, 6);
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(2, 7);
		static const funMul(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		static const fib(n: uint32): uint32 := {
			if (n <= (1)) {
				return .result := n;
			}
			return .result := fib(n - (1)) + fib(n - (2));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := sizeof(typeofRecord);
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := sizeof(typeofBase);
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5);
		zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6);
		zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5);
		sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5);
		sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6);
		sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5);
		zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8);
		zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8);
		zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8);
		sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8);
		sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8);
		sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8);
		sinF64: float64 := float64.sin(pi64 / (2));
		cosF64: float64 := float64.cos(pi64 / (2));
		tanF64: float64 := float64.tan(pi64 / (4));
		logF64: float64 := float64.log(e64 * e64 * e64);
		expF64: float64 := float64.exp(1.000000);
		powF64: float64 := float64.pow(pi64 * pi64, 0.500000);
		sqrtF64: float64 := float64.sqrt(pi64 * pi64);
		atanF64: float64 := float64.atan2(pi64, 1.000000);
		sinF32: float32 := float32.sin(pi32 / (2));
		cosF32: float32 := float32.cos(pi32 / (2));
		tanF32: float32 := float32.tan(pi32 / (4));
		logF32: float32 := float32.log(e32 * e32 * e32);
		expF32: float32 := float32.exp(1.000000);
		powF32: float32 := float32.pow(pi32 * pi32, 0.500000);
		sqrtF32: float32 := float32.sqrt(pi32 * pi32);
		atanF32: float32 := float32.atan2(pi32, 1.000000);
		realloc(data: pointer, size: int32): pointer := pointer.alloc(data, size);
		malloc(size: int32): pointer := pointer.alloc(null, size);
		free(data: pointer): pointer := pointer.alloc(data, 0);
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(p1, 0, 1024);
		pointer.copy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug("val1", val1);
		debug("val2", val2);
		pointer.move(pointer(val2), pointer(val1), sizeof(int64));
		pointer.fill(pointer(val1), 0, sizeof(int64));
		debug("val1", val1);
		debug("val2", val2);
		static const noError(ptr: pointer): void := {
		};
		static const stackOverflow(ptr: pointer): void := {
			data: uint8[8192];
			stackOverflow(ptr);
		};
		static const divisionByZero(args: pointer): void := {
			value: int32 := 3 / 0;
		};
		static const abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				details.message := ("assertion failed");
				details.expected := 97;
				details.returned := 77;
			};
			abort("fatal error", details);
		};
		static const invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static const invalidInstruction(args: pointer): void := {
			emit(load.z32, ret);
		};
		tryExecErr0: int32 := tryExec(null, noError);
		tryExecErr1: int32 := tryExec(null, null);
		tryExecErr2: int32 := tryExec(null, stackOverflow);
		tryExecErr3: int32 := tryExec(null, divisionByZero);
		tryExecErr4: int32 := tryExec(null, invalidInstruction);
		tryExecErr5: int32 := tryExec(null, invalidMemoryAccess);
		tryExecErr6: int32 := tryExec(null, abortExecution);
		static if ((typename(int64)) == null) {
			integer: typename := int32;
		}
		arrFixedNoInit: int64[7];
		arrArrayNoInit: int64[*];
		arrSliceNoInit: int64[];
		for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1) {
			arrFixedNoInit[i] := (42 + i);
		}
		arrArrayInitNull: int64[*] := null;
		arrSliceInitNull: int64[] := null;
		arrArrayInitFixed: int64[*] := arrFixedNoInit;
		arrSliceInitFixed: int64[] := arrFixedNoInit;
		arrArrayInitSlice: int64[*] := arrSliceInitFixed;
		arrSliceInitSlice: int64[] := arrSliceInitFixed;
		arrArrayInitPtr: int64[*] := arrArrayInitFixed;
		strFixed: char[7];
		pointer.copy(strFixed, pointer("string"), 7);
		debug("string as variant", strFixed);
		debug("string to variant", variant(strFixed));
		strArray: char[*] := "string";
		debug("string as variant", strArray);
		debug("string to variant", variant(strArray));
		strSlice: char[] := "string";
		debug("string as variant", strSlice);
		debug("string to variant", variant(strSlice));
		assert(arrSliceNoInit.length >= (0));
		assert(arrSliceInitNull.length == (0));
		assert(arrFixedNoInit[0] == (42));
		static const lenSlice(values: int64[]): int32 := {
			return .result := values.length;
		};
		static const nthFixed(idx: int32, values: int64[7]): int64 := {
			return .result := values[idx];
		};
		static const nthArray(idx: int32, values: int64[*]): int64 := {
			return .result := values[idx];
		};
		static const nthSlice(idx: int32, values: int64[]): int64 := {
			return .result := values[idx];
		};
		assertEq(7, arrFixedNoInit.length);
		assertEq(arrFixedNoInit.length, arrSliceInitFixed.length);
		assertEq(arrFixedNoInit.length, arrSliceInitSlice.length);
		assertEq(0, lenSlice(null));
		assertEq(0, lenSlice(arrSliceInitNull));
		assertEq(arrFixedNoInit.length, lenSlice(arrFixedNoInit));
		assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitFixed));
		assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitSlice));
		for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1) {
			expected: int64 := 42 + i;
			assert(expected == arrFixedNoInit[i]);
			assert(expected == arrArrayInitFixed[i]);
			assert(expected == arrSliceInitFixed[i]);
			assert(expected == nthFixed(i, arrFixedNoInit));
			assert(expected == nthFixed(i, arrArrayInitFixed));
			assert(expected == nthFixed(i, arrSliceInitFixed));
			assert(expected == nthArray(i, arrFixedNoInit));
			assert(expected == nthArray(i, arrArrayInitFixed));
			assert(expected == nthArray(i, arrSliceInitFixed));
			assert(expected == nthSlice(i, arrFixedNoInit));
			assert(expected == nthSlice(i, arrSliceInitFixed));
			assert(expected == arrSliceInitSlice[i]);
		}
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 5;
			static const globalConstant: int32 := 6;
			static globalRec: Inner;
			static globalRecInit: Inner := {
				globalRecInit.member := 51;
				globalRecInit.constant := 52;
			};
			static const globalConstantRec: Inner := {
				globalConstantRec.member := 61;
				globalConstantRec.constant := 62;
			};
		};
		recordMemberTest: RecordMemberTest := {
			recordMemberTest.member := 6;
			recordMemberTest.constant := 7;
			recordMemberTest.memberInit := 8;
			recordMemberTest.constantInit := 9;
			recordMemberTest.memberRec.member := 61;
			recordMemberTest.memberRec.constant := 62;
			recordMemberTest.constantRec.member := 71;
			recordMemberTest.constantRec.constant := 72;
		};
		static const RecordMethodTest: struct {
			static const staticMethod(x: int32, y: int32): int32 := {
				return .result := x + y;
			};
			static forwardMethod(x: int32, y: int32): int32 := forwardMethod;
			abstractMethod(x: int32, y: int32): int32;
			delegateMethod(x: int32, y: int32): int32 := forwardMethod;
			const virtualMethod(x: int32, y: int32): int32 := virtualMethod;
			static const virtualMethod(x: int32, y: int32): int32 := {
				return .result := x * y;
			};
			static const forwardMethod(x: int32, y: int32): int32 := {
				return .result := x * y;
			};
			const print(this: RecordMethodTest): void := print;
			static const print(this: RecordMethodTest): void := {
				trace("virtual");
			};
			static const printStatic(this: RecordMethodTest): void := {
				trace("static");
			};
		};
		static const globalFunction(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		recordMethodTest: RecordMethodTest := {
			recordMethodTest.delegateMethod := globalFunction;
			recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
			recordMethodTest.virtualMethod := virtualMethod;
			recordMethodTest.print := print;
		};
		static const customPrint(this: RecordMethodTest): void := {
			trace("override");
		};
		recordMethodTestCustomPrint: RecordMethodTest := {
			recordMethodTestCustomPrint.abstractMethod := globalFunction;
			recordMethodTestCustomPrint.print := customPrint;
			recordMethodTestCustomPrint.delegateMethod := forwardMethod;
			recordMethodTestCustomPrint.virtualMethod := virtualMethod;
		};
		recordMethodTest.print(recordMethodTest);
		recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
		recordMethodTest.printStatic(recordMethodTest);
		static const print(this: RecordMethodTest): void := {
			trace("extension");
		};
		static const printStatic(this: RecordMethodTest): void := {
			trace("extension");
		};
		print(recordMethodTest);
		printStatic(recordMethodTest);
		print(recordMethodTestCustomPrint);
		RecordMethodTest.print(recordMethodTest);
		RecordMethodTest.printStatic(recordMethodTest);
		RecordMethodTest.print(recordMethodTestCustomPrint);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
		};
		black: rgbU8 := {
			black.r := (0);
			black.g := (0);
			black.b := (0);
		};
		green: rgbU8 := {
			green.r := (0);
			green.g := (255);
			green.b := (0);
		};
		white: rgbU8 := {
			white.r := (255);
			white.g := (255);
			white.b := (255);
		};
		cyan: color := {
			cyan.col := (65535);
		};
		blue: color := {
			blue.rgb.r := (0);
			blue.rgb.g := (0);
			blue.rgb.b := (255);
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !(chrB);
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !(i8B);
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !(u8B);
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !(i16B);
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !(u16B);
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !(i32B);
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !(u32B);
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !(i64B);
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !(u64B);
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !(f32B);
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !(f64B);
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := ptrA == ptrB;
		ptrCne: bool := ptrA != ptrB;
		static if (0 == 0) {
			raise(raise.debug, 1, "0 == 0", null);
		}
		static if (0 != 0) {
			raise(raise.debug, 2, "0 != 0", null);
		}
		static if (0 == 0) {
			raise(raise.debug, 3, "0 == 0", null);
		}
		else {
			raise(raise.debug, 4, "0 != 0", null);
		}
		static if (0 != 0) {
			raise(raise.debug, 5, "0 != 0", null);
		}
		else {
			raise(raise.debug, 6, "0 == 0", null);
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(raise.debug, 7, "t == 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 8, "t != 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				raise(raise.debug, 10, "t != 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 11, "t != 0", t);
			}
			else {
				raise(raise.debug, 12, "t == 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				if (t == 1) {
					raise(raise.debug, 10, "t == 1", t);
				}
				else {
					if (t == 2) {
						raise(raise.debug, 10, "t == 2", t);
					}
					else {
						if (t == 3) {
							raise(raise.debug, 10, "t == 3", t);
						}
						else {
							if (t == 4) {
								raise(raise.debug, 10, "t == 4", t);
							}
							else {
								if (t == 5) {
									raise(raise.debug, 10, "t == 5", t);
								}
								else {
									raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
								}
							}
						}
					}
				}
			}
		}
		static if ((typename(int64)) == null) {
			error("integer is not declared");
		}
		static if (typename(int64) != typename) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; i < 2; i := i + 1) {
			debug("for (int i = 0; i < 2; i += 1)", i);
		}
		forIdx: int32;
		for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1) {
			debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i < 2) {
				continue;
			}
			debug("for with continue", i);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i > 2) {
				break;
			}
			debug("for with break", i);
		}
	}
}
.instructions: (7233 bytes)
	lib/string.ci:129: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main+?>:    load.c32 4
	<.main+?>:    load.ref .?????? ;" \t\n\r"
	<.main+?>:    store.m64 .?????? ;append.whiteSpace
	lib/string.ci:130: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>:    load.c32 36
	<.main+?>:    load.ref .?????? ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>:    store.m64 .?????? ;append.radixDigits
	lib/string.ci:191: (37 bytes): static const format: FormatFlags := {...}
	<.main+?>:    load.c32 10
	<.main+?>:    store.m32 .?????? ;append.format
	lib/string.ci:193: (7 bytes): format.sign := '';
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;append.format+4
	<.main+?>:    store.i8
	lib/string.ci:194: (11 bytes): format.padChr := ' ';
	<.main+?>:    load.c32 32
	<.main+?>:    load.ref .?????? ;append.format+5
	<.main+?>:    store.i8
	lib/string.ci:195: (5 bytes): format.padLen := 0;
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;append.format+8
	lib/string.ci:196: (5 bytes): format.precision := 0;
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;append.format+12
	test/lang.initByRef.ci:7: (13 bytes): static value: int64 := 42
	<.main+?>:    load.c64 42
	<.main+?>:    store.m64 .?????? ;value
	test/lang.member.ci:35: (5 bytes): static global: int32
	<.main+?>:    load.z32
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.global
	test/lang.member.ci:38: (9 bytes): static globalInit: int32 := 5
	<.main+?>:    load.c32 5
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalInit
	test/lang.member.ci:41: (9 bytes): static const globalConstant: int32 := 6
	<.main+?>:    load.c32 6
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstant
	test/lang.member.ci:47: (18 bytes): static globalRecInit: Inner := {...}
	<.main+?>:    load.c32 51
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalRecInit
	test/lang.member.ci:47: (9 bytes): globalRecInit.constant := 52;
	<.main+?>:    load.c32 52
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalRecInit+4
	test/lang.member.ci:50: (18 bytes): static const globalConstantRec: Inner := {...}
	<.main+?>:    load.c32 61
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstantRec
	test/lang.member.ci:50: (9 bytes): globalConstantRec.constant := 62;
	<.main+?>:    load.c32 62
	<.main+?>:    store.m32 .?????? ;RecordMemberTest.globalConstantRec+4
	test/lang.method.ci:12: (9 bytes): static forwardMethod(x: int32, y: int32): int32 := forwardMethod
	<.main+?>:    load.ref .?????? ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+?>:    store.m32 .?????? ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	test/lang.inlineEmit.ci:3: (1 bytes): emitldz32: int32 := emit(load.z32)
	<.main+?>:    load.z32
	test/lang.inlineEmit.ci:4: (1 bytes): emitldz64: int64 := emit(load.z64)
	<.main+?>:    load.z64
	test/lang.inlineEmit.ci:6: (5 bytes): emitA: int32 := 42
	<.main+?>:    load.c32 42
	test/lang.inlineEmit.ci:7: (5 bytes): emitB: int32 := 96
	<.main+?>:    load.c32 96
	test/lang.inlineEmit.ci:9: (5 bytes): emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	test/lang.inlineEmit.ci:10: (11 bytes): emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+?>:    load.c32 10
	<.main+?>:    load.c32 5
	<.main+?>:    div.i32
	test/lang.inlineEmit.ci:11: (24 bytes): emitNfcF32: float32 := emit(float32(3.140000 / (2)), float32.sin)
	<.main+?>:    load.f64 3.140000
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    f64.2f32
	<.main+?>:    nfc(28) ;float32.sin(x: float32): float32
	test/lang.inlineEmit.ci:17: (5 bytes): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+?>:    load.f32 500.000000
	test/lang.inlineEmit.ci:18: (6 bytes): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+?>:    load.f32 500.000000
	<.main+?>:    i32.2i64
	test/lang.inlineEmit.ci:19: (10 bytes): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+?>:    load.f64 500.000000
	<.main+?>:    i64.2i32
	test/lang.inlineEmit.ci:20: (9 bytes): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+?>:    load.f64 500.000000
	test/lang.inlineEmit.ci:23: (10 bytes): emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+?>:    load.c32 3
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.inlineMacros.ci:13: (5 bytes): ma: int32 := 3
	<.main+?>:    load.c32 3
	test/lang.inlineMacros.ci:14: (5 bytes): mb: int32 := 6
	<.main+?>:    load.c32 6
	test/lang.inlineMacros.ci:15: (5 bytes): mc: int32 := 9
	<.main+?>:    load.c32 9
	test/lang.inlineMacros.ci:17: (1 bytes): zeroVal: int32 := zero(2, 3)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:18: (1 bytes): zeroVar: int32 := zero(ma, mb)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:19: (1 bytes): zeroXpr: int32 := zero(ma + mb, mb + mc)
	<.main+?>:    load.z32
	test/lang.inlineMacros.ci:21: (5 bytes): lastVal: int32 := last(2, 3)
	<.main+?>:    load.c32 3
	test/lang.inlineMacros.ci:22: (2 bytes): lastVar: int32 := last(ma, mb)
	<.main+?>:    dup.x1 sp(5)
	test/lang.inlineMacros.ci:23: (5 bytes): lastXpr: int32 := last(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:25: (9 bytes): sum2Val: int32 := sum(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    inc.i32(+12)
	test/lang.inlineMacros.ci:26: (5 bytes): sum2Var: int32 := sum(ma, mb)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:27: (11 bytes): sum2Xpr: int32 := sum(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:29: (24 bytes): any2Val: int32 := any(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 12
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:30: (18 bytes): any2Var: int32 := any(ma, mb)
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:31: (24 bytes): any2Xpr: int32 := any(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:33: (33 bytes): min2Val: int32 := min(3, 12)
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 12
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:34: (27 bytes): min2Var: int32 := min(ma, mb)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:35: (33 bytes): min2Xpr: int32 := min(ma + mb, mb + mc)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:37: (13 bytes): sum3Val: int32 := sum(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    inc.i32(+2)
	<.main+?>:    inc.i32(+6)
	test/lang.inlineMacros.ci:38: (8 bytes): sum3Var: int32 := sum(ma, mb, mc)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:39: (17 bytes): sum3Xpr: int32 := sum(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    add.i32
	<.main+?>:    add.i32
	test/lang.inlineMacros.ci:41: (43 bytes): any3Val: int32 := any(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 2
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.c32 6
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:42: (34 bytes): any3Var: int32 := any(ma, mb, mc)
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:43: (43 bytes): any3Xpr: int32 := any(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    dup.x1 sp(22)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(21)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    add.i32
	<.main+?>:    set.x1 sp(1)
	test/lang.inlineMacros.ci:45: (61 bytes): min3Val: int32 := min(3, 2, 6)
	<.main+?>:    load.c32 3
	<.main+?>:    load.c32 2
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    load.c32 6
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:46: (52 bytes): min3Var: int32 := min(ma, mb, mc)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    dup.x1 sp(23)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/lang.inlineMacros.ci:47: (61 bytes): min3Xpr: int32 := min(ma + mb, mb + mc, mc + ma)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    dup.x1 sp(25)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	<.main+?>:    dup.x1 sp(24)
	<.main+?>:    dup.x1 sp(27)
	<.main+?>:    add.i32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    set.x1 sp(2)
	<.main+?>:    inc.sp(-4)
	test/test.inlineOverload.ci:9: (5 bytes): overload1: float32 := overload
	<.main+?>:    load.f32 1.000000
	test/test.inlineOverload.ci:10: (5 bytes): overload2: float32 := overload()
	<.main+?>:    load.f32 2.000000
	test/test.inlineOverload.ci:11: (5 bytes): overload3: float32 := overload(0)
	<.main+?>:    load.f32 3.000000
	test/test.inlineOverload.ci:12: (5 bytes): overload4: float32 := overload(0.000000)
	<.main+?>:    load.f32 4.000000
	test/test.inlineOverload.ci:13: (5 bytes): overload5: float32 := overload(0, 0)
	<.main+?>:    load.f32 5.000000
	test/test.inlineOverload.ci:28: (9 bytes): boilC: Celsius := Celsius(100.000000)
	<.main+?>:    load.f64 100.000000
	test/test.inlineOverload.ci:29: (22 bytes): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.f64 1.800000
	<.main+?>:    mul.f64
	<.main+?>:    load.f64 32.000000
	<.main+?>:    add.f64
	test/lang.initByRef.ci:8: (5 bytes): valueRef: int64 := value
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:9: (5 bytes): valuePtr: pointer := value
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:10: (10 bytes): valueVar: variant := value
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:12: (3 bytes): fromRef: int64 := valueRef
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.i64
	test/lang.initByRef.ci:13: (2 bytes): fromPtr: int64 := valuePtr
	<.main+?>:    dup.x1 sp(4)
	test/lang.initByRef.ci:14: (2 bytes): fromVar: int64 := valueVar
	<.main+?>:    dup.x1 sp(3)
	test/lang.initByRef.ci:16: (5 bytes): nullRef: int64 := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:17: (5 bytes): nullPtr: pointer := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:18: (10 bytes): nullVar: variant := null
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:19: (5 bytes): nullTyp: typename := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:20: (5 bytes): nullFun: function := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:21: (5 bytes): nullObj: object := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.initByRef.ci:23: (5 bytes): typePtr: pointer := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:24: (10 bytes): typeVar: variant := int64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:25: (5 bytes): typeTyp: typename := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:27: (4 bytes): local: int64 := value
	<.main+?>:    load.m64 .?????? ;value
	test/lang.initByRef.ci:28: (2 bytes): copyVal: int64 := local
	<.main+?>:    dup.x2 sp(0)
	test/lang.initByRef.ci:29: (2 bytes): copyRef: int64 := valueRef
	<.main+?>:    dup.x1 sp(22)
	test/lang.initByRef.ci:30: (2 bytes): copyPtr: pointer := valuePtr
	<.main+?>:    dup.x1 sp(22)
	test/lang.initByRef.ci:31: (2 bytes): copyVar: variant := valueVar
	<.main+?>:    dup.x2 sp(21)
	test/lang.initByRef.ci:32: (2 bytes): copyTyp: typename := typeTyp
	<.main+?>:    dup.x1 sp(8)
	test/lang.initByRef.ci:35: (5 bytes): ptrVoid: pointer := void
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:36: (5 bytes): ptrBool: pointer := bool
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:37: (5 bytes): ptrChar: pointer := char
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:38: (5 bytes): ptrInt8: pointer := int8
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:39: (5 bytes): ptrInt16: pointer := int16
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:40: (5 bytes): ptrInt32: pointer := int32
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:41: (5 bytes): ptrInt64: pointer := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:42: (5 bytes): ptrUint8: pointer := uint8
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:43: (5 bytes): ptrUint16: pointer := uint16
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:44: (5 bytes): ptrUint32: pointer := uint32
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:45: (5 bytes): ptrUint64: pointer := uint64
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:46: (5 bytes): ptrFloat32: pointer := float32
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:47: (5 bytes): ptrFloat64: pointer := float64
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:48: (5 bytes): ptrTypename: pointer := typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:49: (5 bytes): ptrFunction: pointer := function
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:50: (5 bytes): ptrPointer: pointer := pointer
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:51: (5 bytes): ptrVariant: pointer := variant
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:52: (5 bytes): ptrObject: pointer := object
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:55: (10 bytes): varVoid: variant := void
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:56: (10 bytes): varBool: variant := bool
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:57: (10 bytes): varChar: variant := char
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:58: (10 bytes): varInt8: variant := int8
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:59: (10 bytes): varInt16: variant := int16
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:60: (10 bytes): varInt32: variant := int32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:61: (10 bytes): varInt64: variant := int64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:62: (10 bytes): varUint8: variant := uint8
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:63: (10 bytes): varUint16: variant := uint16
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:64: (10 bytes): varUint32: variant := uint32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:65: (10 bytes): varUint64: variant := uint64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:66: (10 bytes): varFloat32: variant := float32
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:67: (10 bytes): varFloat64: variant := float64
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:68: (10 bytes): varTypename: variant := typename
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:69: (10 bytes): varFunction: variant := function
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:70: (10 bytes): varPointer: variant := pointer
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:71: (10 bytes): varVariant: variant := variant
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:72: (10 bytes): varObject: variant := object
	<.main+?>:    load.ref .?????? ;typename
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:75: (5 bytes): typVoid: typename := void
	<.main+?>:    load.ref .?????? ;void
	test/lang.initByRef.ci:76: (5 bytes): typBool: typename := bool
	<.main+?>:    load.ref .?????? ;bool
	test/lang.initByRef.ci:77: (5 bytes): typChar: typename := char
	<.main+?>:    load.ref .?????? ;char
	test/lang.initByRef.ci:78: (5 bytes): typInt8: typename := int8
	<.main+?>:    load.ref .?????? ;int8
	test/lang.initByRef.ci:79: (5 bytes): typInt16: typename := int16
	<.main+?>:    load.ref .?????? ;int16
	test/lang.initByRef.ci:80: (5 bytes): typInt32: typename := int32
	<.main+?>:    load.ref .?????? ;int32
	test/lang.initByRef.ci:81: (5 bytes): typInt64: typename := int64
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:82: (5 bytes): typUint8: typename := uint8
	<.main+?>:    load.ref .?????? ;uint8
	test/lang.initByRef.ci:83: (5 bytes): typUint16: typename := uint16
	<.main+?>:    load.ref .?????? ;uint16
	test/lang.initByRef.ci:84: (5 bytes): typUint32: typename := uint32
	<.main+?>:    load.ref .?????? ;uint32
	test/lang.initByRef.ci:85: (5 bytes): typUint64: typename := uint64
	<.main+?>:    load.ref .?????? ;uint64
	test/lang.initByRef.ci:86: (5 bytes): typFloat32: typename := float32
	<.main+?>:    load.ref .?????? ;float32
	test/lang.initByRef.ci:87: (5 bytes): typFloat64: typename := float64
	<.main+?>:    load.ref .?????? ;float64
	test/lang.initByRef.ci:88: (5 bytes): typTypename: typename := typename
	<.main+?>:    load.ref .?????? ;typename
	test/lang.initByRef.ci:89: (5 bytes): typFunction: typename := function
	<.main+?>:    load.ref .?????? ;function
	test/lang.initByRef.ci:90: (5 bytes): typPointer: typename := pointer
	<.main+?>:    load.ref .?????? ;pointer
	test/lang.initByRef.ci:91: (5 bytes): typVariant: typename := variant
	<.main+?>:    load.ref .?????? ;variant
	test/lang.initByRef.ci:92: (5 bytes): typObject: typename := object
	<.main+?>:    load.ref .?????? ;object
	test/lang.initByRef.ci:95: (5 bytes): valueOfPtr: pointer := pointer(value)
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:96: (10 bytes): valueOfVar: variant := variant(value)
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.ref .?????? ;value
	test/lang.initByRef.ci:97: (5 bytes): valueOfTyp: typename := typename(value)
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:99: (5 bytes): typeOfValue: typename := typename(value)
	<.main+?>:    load.ref .?????? ;int64
	test/lang.initByRef.ci:105: (7 bytes): copyPtrFloat64: variant := ptrFloat64
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    dup.x1 sp(65)
	test/lang.initByRef.ci:108: (2 bytes): copyVarFloat64: pointer := varFloat64
	<.main+?>:    dup.x1 sp(35)
	test/lang.function.ci:11: (21 bytes): funAddResult: int32 := funAdd(2, 7)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;funAdd(x: int32, y: int32): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:14: (5 bytes): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+?>:    load.ref .?????? ;funAdd(x: int32, y: int32): int32
	test/lang.function.ci:17: (18 bytes): funAddRefResult: int32 := funAddRef(2, 8)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 8
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:20: (5 bytes): funMul(x: int32, y: int32): int32 := funMul
	<.main+?>:    load.ref .?????? ;funMul(x: int32, y: int32): int32
	test/lang.function.ci:23: (18 bytes): funMulResult: int32 := funMul(2, 6)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 6
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:26: (2 bytes): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+?>:    dup.x1 sp(1)
	test/lang.function.ci:29: (18 bytes): funMulRefResult: int32 := funMulRef(2, 7)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 2
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	test/lang.function.ci:45: (16 bytes): fibonacci_13: uint32 := fib(13)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 13
	<.main+?>:    load.ref .?????? ;fib(n: uint32): uint32
	<.main+?>:    call
	<.main+?>:    inc.sp(-4)
	test/lang.reflect.ci:3: (4 bytes): sizeofVoid: int32 := sizeof(void)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:4: (4 bytes): sizeofBool: int32 := sizeof(bool)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:5: (4 bytes): sizeofChar: int32 := sizeof(char)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:6: (4 bytes): sizeofInt8: int32 := sizeof(int8)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:7: (4 bytes): sizeofInt16: int32 := sizeof(int16)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:8: (4 bytes): sizeofInt32: int32 := sizeof(int32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:9: (4 bytes): sizeofInt64: int32 := sizeof(int64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:10: (4 bytes): sizeofUint8: int32 := sizeof(uint8)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:11: (4 bytes): sizeofUint16: int32 := sizeof(uint16)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:12: (4 bytes): sizeofUint32: int32 := sizeof(uint32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:13: (4 bytes): sizeofUint64: int32 := sizeof(uint64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:14: (4 bytes): sizeofFloat32: int32 := sizeof(float32)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:15: (4 bytes): sizeofFloat64: int32 := sizeof(float64)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:16: (4 bytes): sizeofPointer: int32 := sizeof(pointer)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:17: (4 bytes): sizeofVariant: int32 := sizeof(variant)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:18: (4 bytes): sizeofTypename: int32 := sizeof(typename)
	<.main+?>:    load.m32 .?????? ;typename+24
	test/lang.reflect.ci:19: (4 bytes): sizeofFunction: int32 := sizeof(function)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:20: (4 bytes): sizeofObject: int32 := sizeof(object)
	<.main+?>:    load.m32 .??????
	test/lang.reflect.ci:30: (5 bytes): typeofRecord: typename := RecordSizeofExt
	<.main+?>:    load.ref .?????? ;RecordSizeofExt
	test/lang.reflect.ci:31: (6 bytes): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    nfc(4) ;typename.name(type: typename): .cstr
	test/lang.reflect.ci:32: (7 bytes): offsetOfRecord: int32 := typeofRecord.offset
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:33: (7 bytes): sizeOfRecord: int32 := sizeof(typeofRecord)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:34: (6 bytes): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    nfc(2) ;typename.file(type: typename): .cstr
	test/lang.reflect.ci:35: (6 bytes): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    nfc(3) ;typename.line(type: typename): int32
	test/lang.reflect.ci:37: (6 bytes): typeofBase: typename := typename.base(typeofRecord)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:38: (6 bytes): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    nfc(4) ;typename.name(type: typename): .cstr
	test/lang.reflect.ci:39: (7 bytes): offsetOfBase: int32 := typeofBase.offset
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:40: (7 bytes): sizeOfBase: int32 := sizeof(typeofBase)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:41: (6 bytes): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    nfc(2) ;typename.file(type: typename): .cstr
	test/lang.reflect.ci:42: (6 bytes): lineOfBase: int32 := typename.line(typeofBase)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    nfc(3) ;typename.line(type: typename): int32
	test/lang.reflect.ci:44: (6 bytes): typeofBase1: typename := typename.base(typeofBase)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:45: (7 bytes): offsetOfBase1: int32 := typeofBase1.offset
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:46: (7 bytes): sizeOfBase1: int32 := typeofBase1.size
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/lang.reflect.ci:48: (6 bytes): typeofBase2: typename := typename.base(typeofBase1)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    nfc(1) ;typename.base(type: typename): typename
	test/lang.reflect.ci:49: (7 bytes): offsetOfBase2: int32 := typeofBase2.offset
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    inc.i32(+32)
	<.main+?>:    load.i32
	test/lang.reflect.ci:50: (7 bytes): sizeOfBase2: int32 := typeofBase2.size
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    inc.i32(+24)
	<.main+?>:    load.i32
	test/stdc.number.ci:3: (9 bytes): pi64: float64 := 3.141593
	<.main+?>:    load.f64 3.141593
	test/stdc.number.ci:4: (9 bytes): e64: float64 := 2.718282
	<.main+?>:    load.f64 2.718282
	test/stdc.number.ci:6: (3 bytes): pi32: float32 := pi64
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    f64.2f32
	test/stdc.number.ci:7: (3 bytes): e32: float32 := e64
	<.main+?>:    dup.x2 sp(1)
	<.main+?>:    f64.2f32
	test/stdc.number.ci:14: (7 bytes): r_comp: int32 := 14 << 3
	<.main+?>:    load.c32 14
	<.main+?>:    b32.shl 0x003
	test/stdc.number.ci:15: (7 bytes): g_comp: int32 := 63 << 2
	<.main+?>:    load.c32 63
	<.main+?>:    b32.shl 0x002
	test/stdc.number.ci:16: (7 bytes): b_comp: int32 := 31 << 3
	<.main+?>:    load.c32 31
	<.main+?>:    b32.shl 0x003
	test/stdc.number.ci:18: (28 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.shl 0x008
	<.main+?>:    load.c32 63488
	<.main+?>:    and.b32
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.shl 0x003
	<.main+?>:    load.c32 2016
	<.main+?>:    and.b32
	<.main+?>:    or.b32
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    b32.sar 0x003
	<.main+?>:    b32.and 0x01f
	<.main+?>:    or.b32
	test/stdc.number.ci:19: (26 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    b32.shl 0x010
	<.main+?>:    load.c32 16711680
	<.main+?>:    and.b32
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    b32.shl 0x008
	<.main+?>:    load.c32 65280
	<.main+?>:    and.b32
	<.main+?>:    or.b32
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    b32.and 0x0ff
	<.main+?>:    or.b32
	test/stdc.number.ci:21: (16 bytes): zxtR5: int32 := uint32.zxt(r5g6b5, 11, 5)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    load.c32 11
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:22: (16 bytes): zxtG6: int32 := uint32.zxt(r5g6b5, 5, 6)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.c32 5
	<.main+?>:    load.c32 6
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:23: (12 bytes): zxtB5: int32 := uint32.zxt(r5g6b5, 0, 5)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:25: (16 bytes): sxtR5: int32 := uint32.sxt(r5g6b5, 11, 5)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    load.c32 11
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:26: (16 bytes): sxtG6: int32 := uint32.sxt(r5g6b5, 5, 6)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    load.c32 5
	<.main+?>:    load.c32 6
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:27: (12 bytes): sxtB5: int32 := uint32.sxt(r5g6b5, 0, 5)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 5
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:29: (16 bytes): zxtR8: int32 := uint32.zxt(r8g8b8, 16, 8)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.c32 16
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:30: (16 bytes): zxtG8: int32 := uint32.zxt(r8g8b8, 8, 8)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    load.c32 8
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:31: (12 bytes): zxtB8: int32 := uint32.zxt(r8g8b8, 0, 8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(18) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:33: (16 bytes): sxtR8: int32 := uint32.sxt(r8g8b8, 16, 8)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    load.c32 16
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:34: (16 bytes): sxtG8: int32 := uint32.sxt(r8g8b8, 8, 8)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    load.c32 8
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:35: (12 bytes): sxtB8: int32 := uint32.sxt(r8g8b8, 0, 8)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 8
	<.main+?>:    nfc(19) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	test/stdc.number.ci:37: (16 bytes): sinF64: float64 := float64.sin(pi64 / (2))
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(36) ;float64.sin(x: float64): float64
	test/stdc.number.ci:38: (16 bytes): cosF64: float64 := float64.cos(pi64 / (2))
	<.main+?>:    dup.x2 sp(23)
	<.main+?>:    load.f64 2.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(37) ;float64.cos(x: float64): float64
	test/stdc.number.ci:39: (16 bytes): tanF64: float64 := float64.tan(pi64 / (4))
	<.main+?>:    dup.x2 sp(25)
	<.main+?>:    load.f64 4.000000
	<.main+?>:    div.f64
	<.main+?>:    nfc(38) ;float64.tan(x: float64): float64
	test/stdc.number.ci:40: (12 bytes): logF64: float64 := float64.log(e64 * e64 * e64)
	<.main+?>:    dup.x2 sp(25)
	<.main+?>:    dup.x2 sp(27)
	<.main+?>:    mul.f64
	<.main+?>:    dup.x2 sp(27)
	<.main+?>:    mul.f64
	<.main+?>:    nfc(39) ;float64.log(x: float64): float64
	test/stdc.number.ci:41: (13 bytes): expF64: float64 := float64.exp(1.000000)
	<.main+?>:    load.f64 1.000000
	<.main+?>:    nfc(40) ;float64.exp(x: float64): float64
	test/stdc.number.ci:42: (18 bytes): powF64: float64 := float64.pow(pi64 * pi64, 0.500000)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    mul.f64
	<.main+?>:    load.f64 0.500000
	<.main+?>:    nfc(41) ;float64.pow(x: float64, y: float64): float64
	test/stdc.number.ci:43: (9 bytes): sqrtF64: float64 := float64.sqrt(pi64 * pi64)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(35)
	<.main+?>:    mul.f64
	<.main+?>:    nfc(42) ;float64.sqrt(x: float64): float64
	test/stdc.number.ci:44: (15 bytes): atanF64: float64 := float64.atan2(pi64, 1.000000)
	<.main+?>:    dup.x2 sp(35)
	<.main+?>:    load.f64 1.000000
	<.main+?>:    nfc(43) ;float64.atan2(x: float64, y: float64): float64
	test/stdc.number.ci:46: (12 bytes): sinF32: float32 := float32.sin(pi32 / (2))
	<.main+?>:    dup.x1 sp(34)
	<.main+?>:    load.f32 2.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(28) ;float32.sin(x: float32): float32
	test/stdc.number.ci:47: (12 bytes): cosF32: float32 := float32.cos(pi32 / (2))
	<.main+?>:    dup.x1 sp(35)
	<.main+?>:    load.f32 2.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(29) ;float32.cos(x: float32): float32
	test/stdc.number.ci:48: (12 bytes): tanF32: float32 := float32.tan(pi32 / (4))
	<.main+?>:    dup.x1 sp(36)
	<.main+?>:    load.f32 4.000000
	<.main+?>:    div.f32
	<.main+?>:    nfc(30) ;float32.tan(x: float32): float32
	test/stdc.number.ci:49: (12 bytes): logF32: float32 := float32.log(e32 * e32 * e32)
	<.main+?>:    dup.x1 sp(36)
	<.main+?>:    dup.x1 sp(37)
	<.main+?>:    mul.f32
	<.main+?>:    dup.x1 sp(37)
	<.main+?>:    mul.f32
	<.main+?>:    nfc(31) ;float32.log(x: float32): float32
	test/stdc.number.ci:50: (9 bytes): expF32: float32 := float32.exp(1.000000)
	<.main+?>:    load.f32 1.000000
	<.main+?>:    nfc(32) ;float32.exp(x: float32): float32
	test/stdc.number.ci:51: (14 bytes): powF32: float32 := float32.pow(pi32 * pi32, 0.500000)
	<.main+?>:    dup.x1 sp(39)
	<.main+?>:    dup.x1 sp(40)
	<.main+?>:    mul.f32
	<.main+?>:    load.f32 0.500000
	<.main+?>:    nfc(33) ;float32.pow(x: float32, y: float32): float32
	test/stdc.number.ci:52: (9 bytes): sqrtF32: float32 := float32.sqrt(pi32 * pi32)
	<.main+?>:    dup.x1 sp(40)
	<.main+?>:    dup.x1 sp(41)
	<.main+?>:    mul.f32
	<.main+?>:    nfc(34) ;float32.sqrt(x: float32): float32
	test/stdc.number.ci:53: (11 bytes): atanF32: float32 := float32.atan2(pi32, 1.000000)
	<.main+?>:    dup.x1 sp(41)
	<.main+?>:    load.f32 1.000000
	<.main+?>:    nfc(35) ;float32.atan2(x: float32, y: float32): float32
	test/stdc.memory.ci:7: (14 bytes): p1: pointer := malloc(1024)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 1024
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:8: (14 bytes): p2: pointer := malloc(80)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 80
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:9: (14 bytes): p3: pointer := malloc(160)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 160
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:10: (14 bytes): p4: pointer := malloc(820)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.c32 820
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	test/stdc.memory.ci:13: (16 bytes): pointer.fill(p1, 0, 1024);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    load.c32 1024
	<.main+?>:    nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:14: (17 bytes): pointer.copy(p1, p3, 160);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.c32 160
	<.main+?>:    nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:17: (11 bytes): free(p1);
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:18: (11 bytes): free(p2);
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:19: (11 bytes): free(p3);
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:20: (11 bytes): free(p4);
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    nfc(7) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:23: (9 bytes): val1: int64 := 42
	<.main+?>:    load.c64 42
	test/stdc.memory.ci:24: (9 bytes): val2: int64 := 96
	<.main+?>:    load.c64 96
	test/stdc.memory.ci:26: (34 bytes): debug("val1", val1);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 26
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val1"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+32)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:27: (34 bytes): debug("val2", val2);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 27
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val2"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:29: (20 bytes): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.m32 .??????
	<.main+?>:    nfc(10) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:30: (17 bytes): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.z32
	<.main+?>:    load.m32 .??????
	<.main+?>:    nfc(8) ;pointer.fill(dst: pointer, value: int32, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/stdc.memory.ci:32: (34 bytes): debug("val1", val1);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 32
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val1"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+32)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.memory.ci:33: (34 bytes): debug("val2", val2);
	<.main+?>:    load.ref .?????? ;"test/stdc.memory.ci"
	<.main+?>:    load.c32 33
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"val2"
	<.main+?>:    load.ref .?????? ;int64
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/stdc.execute.ci:46: (14 bytes): tryExecErr0: int32 := tryExec(null, noError)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;noError(ptr: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:47: (14 bytes): tryExecErr1: int32 := tryExec(null, null)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:48: (14 bytes): tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;stackOverflow(ptr: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:49: (14 bytes): tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;divisionByZero(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:50: (14 bytes): tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;invalidInstruction(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:51: (14 bytes): tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;invalidMemoryAccess(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/stdc.execute.ci:52: (14 bytes): tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;abortExecution(args: pointer): void
	<.main+?>:    nfc(6) ;tryExec(args: pointer, action(args: pointer): void): int32
	test/lang.array.ci:49: (4 bytes): arrFixedNoInit: int64[7]
	<.main+?>:    inc.sp(+56)
	test/lang.array.ci:50: (4 bytes): arrArrayNoInit: int64[*]
	<.main+?>:    inc.sp(+4)
	test/lang.array.ci:51: (4 bytes): arrSliceNoInit: int64[]
	<.main+?>:    inc.sp(+8)
	test/lang.array.ci:54: (45 bytes): for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.array.ci:55: (20 bytes): arrFixedNoInit[i] := (42 + i);
	<.main+?>:    load.c32 42
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	<.main+?>:    i32.2i64
	<.main+?>:    load.sp(+24)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    mad.u32 8
	<.main+?>:    store.i64
	test/lang.array.ci:54: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.array.ci:54: (12 bytes): i < arrFixedNoInit.length
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.array.ci:59: (5 bytes): arrArrayInitNull: int64[*] := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.array.ci:60: (6 bytes): arrSliceInitNull: int64[] := null
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;null
	test/lang.array.ci:63: (4 bytes): arrArrayInitFixed: int64[*] := arrFixedNoInit
	<.main+?>:    load.sp(+24)
	test/lang.array.ci:64: (9 bytes): arrSliceInitFixed: int64[] := arrFixedNoInit
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+32)
	test/lang.array.ci:67: (2 bytes): arrArrayInitSlice: int64[*] := arrSliceInitFixed
	<.main+?>:    dup.x1 sp(0)
	test/lang.array.ci:68: (2 bytes): arrSliceInitSlice: int64[] := arrSliceInitFixed
	<.main+?>:    dup.x2 sp(1)
	test/lang.array.ci:71: (2 bytes): arrArrayInitPtr: int64[*] := arrArrayInitFixed
	<.main+?>:    dup.x1 sp(5)
	test/lang.array.ci:81: (4 bytes): strFixed: char[7]
	<.main+?>:    inc.sp(+8)
	test/lang.array.ci:82: (22 bytes): pointer.copy(strFixed, pointer("string"), 7);
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.ref .?????? ;"string"
	<.main+?>:    load.c32 7
	<.main+?>:    nfc(9) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>:    inc.sp(-4)
	test/lang.array.ci:83: (34 bytes): debug("string as variant", strFixed);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 83
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:84: (34 bytes): debug("string to variant", variant(strFixed));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 84
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:86: (5 bytes): strArray: char[*] := "string"
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.array.ci:87: (32 bytes): debug("string as variant", strArray);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 87
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:88: (32 bytes): debug("string to variant", variant(strArray));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 88
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:90: (10 bytes): strSlice: char[] := "string"
	<.main+?>:    load.c32 6
	<.main+?>:    load.ref .?????? ;"string"
	test/lang.array.ci:91: (32 bytes): debug("string as variant", strSlice);
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 91
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string as variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:92: (32 bytes): debug("string to variant", variant(strSlice));
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 92
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"string to variant"
	<.main+?>:    load.ref .??????
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:98: (51 bytes): assert(arrSliceNoInit.length >= (0));
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    load.z32
	<.main+?>:    clt.u32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 98
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:99: (51 bytes): assert(arrSliceInitNull.length == (0));
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 99
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:101: (59 bytes): assert(arrFixedNoInit[0] == (42));
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    load.c64 42
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 101
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:108: (25 bytes): assertEq(7, arrFixedNoInit.length);
	<.main+?>:    load.c32 7
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:109: (22 bytes): assertEq(arrFixedNoInit.length, arrSliceInitFixed.length);
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:110: (22 bytes): assertEq(arrFixedNoInit.length, arrSliceInitSlice.length);
	<.main+?>:    load.c32 7
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:112: (32 bytes): assertEq(0, lenSlice(null));
	<.main+?>:    load.z32
	<.main+?>:    load.z64
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:113: (29 bytes): assertEq(0, lenSlice(arrSliceInitNull));
	<.main+?>:    load.z32
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:114: (40 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrFixedNoInit));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+84)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:115: (33 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitFixed));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(11)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:116: (33 bytes): assertEq(arrFixedNoInit.length, lenSlice(arrSliceInitSlice));
	<.main+?>:    load.c32 7
	<.main+?>:    load.z32
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    load.ref .?????? ;lenSlice(values: int64[]): int32
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    load.ref .?????? ;assertEq(expected: int32, returned: int32, message: char[*]): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	test/lang.array.ci:118: (807 bytes): for (i: int32 := 0; i < arrFixedNoInit.length; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.array.ci:119: (9 bytes): expected: int64 := 42 + i
	<.main+?>:    load.c32 42
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    add.i32
	<.main+?>:    i32.2i64
	test/lang.array.ci:120: (61 bytes): assert(expected == arrFixedNoInit[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.sp(+92)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 120
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:121: (59 bytes): assert(expected == arrArrayInitFixed[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 121
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:122: (59 bytes): assert(expected == arrSliceInitFixed[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 122
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:124: (67 bytes): assert(expected == nthFixed(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.sp(+104)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 124
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:125: (65 bytes): assert(expected == nthFixed(i, arrArrayInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 125
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:126: (65 bytes): assert(expected == nthFixed(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    load.ref .?????? ;nthFixed(idx: int32, values: int64[7]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 126
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:128: (67 bytes): assert(expected == nthArray(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.sp(+104)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 128
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:129: (65 bytes): assert(expected == nthArray(i, arrArrayInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 129
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:130: (65 bytes): assert(expected == nthArray(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    load.ref .?????? ;nthArray(idx: int32, values: int64[*]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-8)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 130
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:132: (72 bytes): assert(expected == nthSlice(i, arrFixedNoInit));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    load.c32 7
	<.main+?>:    load.sp(+108)
	<.main+?>:    load.ref .?????? ;nthSlice(idx: int32, values: int64[]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 132
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:134: (65 bytes): assert(expected == nthSlice(i, arrSliceInitFixed));
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    load.z64
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    load.ref .?????? ;nthSlice(idx: int32, values: int64[]): int64
	<.main+?>:    call
	<.main+?>:    inc.sp(-12)
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 134
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.array.ci:136: (59 bytes): assert(expected == arrSliceInitSlice[i]);
	<.main+?>:    dup.x2 sp(0)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mad.u32 8
	<.main+?>:    load.i64
	<.main+?>:    ceq.i64
	<.main+?>:    jz <.main+?>
	<.main+?>:    jmp <.main+?>
	<.main+?>:    load.ref .?????? ;"test/lang.array.ci"
	<.main+?>:    load.c32 136
	<.main+?>:    load.c32 -2
	<.main+?>:    load.c32 128
	<.main+?>:    load.ref .?????? ;"assertion failed!"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    inc.sp(-8)
	test/lang.array.ci:118: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.array.ci:118: (12 bytes): i < arrFixedNoInit.length
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.member.ci:53: (60 bytes): recordMemberTest: RecordMemberTest := {...}
	<.main+?>:    inc.sp(+32)
	test/lang.member.ci:54: (7 bytes): recordMemberTest.member := 6;
	<.main+?>:    load.c32 6
	<.main+?>:    set.x1 sp(1)
	test/lang.member.ci:55: (7 bytes): recordMemberTest.constant := 7;
	<.main+?>:    load.c32 7
	<.main+?>:    set.x1 sp(2)
	test/lang.member.ci:56: (7 bytes): recordMemberTest.memberInit := 8;
	<.main+?>:    load.c32 8
	<.main+?>:    set.x1 sp(3)
	test/lang.member.ci:57: (7 bytes): recordMemberTest.constantInit := 9;
	<.main+?>:    load.c32 9
	<.main+?>:    set.x1 sp(4)
	test/lang.member.ci:60: (7 bytes): recordMemberTest.memberRec.member := 61;
	<.main+?>:    load.c32 61
	<.main+?>:    set.x1 sp(5)
	test/lang.member.ci:61: (7 bytes): recordMemberTest.memberRec.constant := 62;
	<.main+?>:    load.c32 62
	<.main+?>:    set.x1 sp(6)
	test/lang.member.ci:65: (7 bytes): recordMemberTest.constantRec.member := 71;
	<.main+?>:    load.c32 71
	<.main+?>:    set.x1 sp(7)
	test/lang.member.ci:66: (7 bytes): recordMemberTest.constantRec.constant := 72;
	<.main+?>:    load.c32 72
	<.main+?>:    set.x1 sp(8)
	test/lang.method.ci:53: (32 bytes): recordMethodTest: RecordMethodTest := {...}
	<.main+?>:    inc.sp(+16)
	test/lang.method.ci:54: (7 bytes): recordMethodTest.delegateMethod := globalFunction;
	<.main+?>:    load.ref .?????? ;globalFunction(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(2)
	test/lang.method.ci:55: (7 bytes): recordMethodTest.abstractMethod := RecordMethodTest.staticMethod;
	<.main+?>:    load.ref .?????? ;RecordMethodTest.staticMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(1)
	:: (7 bytes): recordMethodTest.virtualMethod := virtualMethod
	<.main+?>:    load.ref .?????? ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(3)
	:: (7 bytes): recordMethodTest.print := print
	<.main+?>:    load.ref .?????? ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+?>:    set.x1 sp(4)
	test/lang.method.ci:63: (31 bytes): recordMethodTestCustomPrint: RecordMethodTest := {...}
	<.main+?>:    inc.sp(+16)
	test/lang.method.ci:64: (7 bytes): recordMethodTestCustomPrint.abstractMethod := globalFunction;
	<.main+?>:    load.ref .?????? ;globalFunction(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(1)
	test/lang.method.ci:65: (7 bytes): recordMethodTestCustomPrint.print := customPrint;
	<.main+?>:    load.ref .?????? ;customPrint(this: RecordMethodTest): void
	<.main+?>:    set.x1 sp(4)
	:: (6 bytes): recordMethodTestCustomPrint.delegateMethod := forwardMethod
	<.main+?>:    load.m32 .?????? ;RecordMethodTest.forwardMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(2)
	:: (7 bytes): recordMethodTestCustomPrint.virtualMethod := virtualMethod
	<.main+?>:    load.ref .?????? ;RecordMethodTest.virtualMethod(x: int32, y: int32): int32
	<.main+?>:    set.x1 sp(3)
	test/lang.method.ci:69: (9 bytes): recordMethodTest.print(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:70: (9 bytes): recordMethodTestCustomPrint.print(recordMethodTestCustomPrint);
	<.main+?>:    dup.x4 sp(0)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:73: (12 bytes): recordMethodTest.printStatic(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    load.ref .?????? ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:84: (12 bytes): print(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    load.ref .?????? ;print(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:85: (12 bytes): printStatic(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    load.ref .?????? ;printStatic(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:86: (12 bytes): print(recordMethodTestCustomPrint);
	<.main+?>:    dup.x4 sp(0)
	<.main+?>:    load.ref .?????? ;print(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:89: (12 bytes): RecordMethodTest.print(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    load.ref .?????? ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:90: (12 bytes): RecordMethodTest.printStatic(recordMethodTest);
	<.main+?>:    dup.x4 sp(4)
	<.main+?>:    load.ref .?????? ;RecordMethodTest.printStatic(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.method.ci:91: (12 bytes): RecordMethodTest.print(recordMethodTestCustomPrint);
	<.main+?>:    dup.x4 sp(0)
	<.main+?>:    load.ref .?????? ;RecordMethodTest.print(this: RecordMethodTest): void
	<.main+?>:    call
	<.main+?>:    inc.sp(-16)
	test/lang.recUnion.ci:26: (22 bytes): black: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:26: (6 bytes): black.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:26: (6 bytes): black.g := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:26: (6 bytes): black.b := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (26 bytes): green: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:27: (6 bytes): green.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (10 bytes): green.g := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:27: (6 bytes): green.b := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (34 bytes): white: rgbU8 := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:28: (10 bytes): white.r := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (10 bytes): white.g := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:28: (10 bytes): white.b := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:30: (11 bytes): cyan: color := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:30: (7 bytes): cyan.col := (65535);
	<.main+?>:    load.c32 65535
	<.main+?>:    set.x1 sp(1)
	test/lang.recUnion.ci:31: (26 bytes): blue: color := {...}
	<.main+?>:    inc.sp(+4)
	test/lang.recUnion.ci:31: (6 bytes): blue.rgb.r := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+6)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:31: (6 bytes): blue.rgb.g := (0);
	<.main+?>:    load.z32
	<.main+?>:    load.sp(+5)
	<.main+?>:    store.i8
	test/lang.recUnion.ci:31: (10 bytes): blue.rgb.b := (255);
	<.main+?>:    load.c32 255
	<.main+?>:    load.sp(+4)
	<.main+?>:    store.i8
	test/lang.useOperator.ci:5: (5 bytes): shift: int32 := 2
	<.main+?>:    load.c32 2
	test/lang.useOperator.ci:7: (5 bytes): boolA: bool := true
	<.main+?>:    load.c32 1
	test/lang.useOperator.ci:8: (5 bytes): boolB: bool := !false
	<.main+?>:    load.c32 1
	test/lang.useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	<.main+?>:    load.sp(+12)
	<.main+?>:    load.i8
	<.main+?>:    not.b32
	test/lang.useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:30: (5 bytes): chrA: char := 'a'
	<.main+?>:    load.c32 97
	test/lang.useOperator.ci:31: (5 bytes): chrB: char := 'b'
	<.main+?>:    load.c32 98
	test/lang.useOperator.ci:32: (5 bytes): chrPls: char := +chrB
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.i32
	test/lang.useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:43: (8 bytes): chrShl: char := (chrA) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(26)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:44: (8 bytes): chrShr: char := (chrA) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(27)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:45: (7 bytes): chrNot: bool := !(chrB)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:53: (5 bytes): i8A: int8 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:54: (5 bytes): i8B: int8 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:55: (5 bytes): i8Pls: int8 := +i8B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.i32
	test/lang.useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:66: (8 bytes): i8Shl: int8 := (i8A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(48)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:67: (8 bytes): i8Shr: int8 := (i8A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(49)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:68: (7 bytes): i8Not: bool := !(i8B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:76: (5 bytes): u8A: uint8 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:77: (5 bytes): u8B: uint8 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:78: (5 bytes): u8Pls: uint8 := +u8B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i8
	test/lang.useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i8
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i8
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i8
	<.main+?>:    add.i32
	test/lang.useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i8
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i8
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i8
	<.main+?>:    div.u32
	test/lang.useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i8
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i8
	<.main+?>:    and.b32
	test/lang.useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i8
	<.main+?>:    or.b32
	test/lang.useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i8
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:89: (8 bytes): u8Shl: uint8 := (u8A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(70)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:90: (8 bytes): u8Shr: uint8 := (u8A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    dup.x1 sp(71)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:91: (7 bytes): u8Not: bool := !(u8B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i8
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i8
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i8
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i8
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i8
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i8
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:99: (5 bytes): i16A: int16 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:100: (5 bytes): i16B: int16 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:101: (5 bytes): i16Pls: int16 := +i16B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i16
	test/lang.useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i16
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i16
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    add.i32
	test/lang.useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    div.i32
	test/lang.useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    and.b32
	test/lang.useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    or.b32
	test/lang.useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:112: (8 bytes): i16Shl: int16 := (i16A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(92)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:113: (8 bytes): i16Shr: int16 := (i16A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(93)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:114: (7 bytes): i16Not: bool := !(i16B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:122: (5 bytes): u16A: uint16 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:123: (5 bytes): u16B: uint16 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:124: (5 bytes): u16Pls: uint16 := +u16B
	<.main+?>:    load.sp(+0)
	<.main+?>:    load.i16
	test/lang.useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	<.main+?>:    load.sp(+4)
	<.main+?>:    load.i16
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	<.main+?>:    load.sp(+8)
	<.main+?>:    load.i16
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+16)
	<.main+?>:    load.i16
	<.main+?>:    add.i32
	test/lang.useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+20)
	<.main+?>:    load.i16
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+24)
	<.main+?>:    load.i16
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+28)
	<.main+?>:    load.i16
	<.main+?>:    div.u32
	test/lang.useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+32)
	<.main+?>:    load.i16
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+36)
	<.main+?>:    load.i16
	<.main+?>:    and.b32
	test/lang.useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+40)
	<.main+?>:    load.i16
	<.main+?>:    or.b32
	test/lang.useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+44)
	<.main+?>:    load.i16
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:135: (8 bytes): u16Shl: uint16 := (u16A) << shift
	<.main+?>:    load.sp(+48)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(114)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:136: (8 bytes): u16Shr: uint16 := (u16A) >> shift
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    dup.x1 sp(115)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:137: (7 bytes): u16Not: bool := !(u16B)
	<.main+?>:    load.sp(+52)
	<.main+?>:    load.i16
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+60)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+64)
	<.main+?>:    load.i16
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+68)
	<.main+?>:    load.i16
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+72)
	<.main+?>:    load.i16
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+76)
	<.main+?>:    load.i16
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    load.sp(+80)
	<.main+?>:    load.i16
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:145: (5 bytes): i32A: int32 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:146: (5 bytes): i32B: int32 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:147: (2 bytes): i32Pls: int32 := +i32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:148: (3 bytes): i32Neg: int32 := -i32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:149: (3 bytes): i32Cmt: int32 := ~i32B
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:150: (5 bytes): i32Add: int32 := i32A + i32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    add.i32
	test/lang.useOperator.ci:151: (5 bytes): i32Sub: int32 := i32A - i32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:152: (5 bytes): i32Mul: int32 := i32A * i32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    mul.i32
	test/lang.useOperator.ci:153: (5 bytes): i32Div: int32 := i32A / i32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    div.i32
	test/lang.useOperator.ci:154: (5 bytes): i32Mod: int32 := i32A % i32B
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    mod.i32
	test/lang.useOperator.ci:155: (5 bytes): i32And: int32 := i32A & i32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    and.b32
	test/lang.useOperator.ci:156: (5 bytes): i32Ior: int32 := i32A | i32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    or.b32
	test/lang.useOperator.ci:157: (5 bytes): i32Xor: int32 := i32A ^ i32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:158: (5 bytes): i32Shl: int32 := i32A << shift
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(136)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:159: (5 bytes): i32Shr: int32 := i32A >> shift
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(137)
	<.main+?>:    sar.b32
	test/lang.useOperator.ci:160: (4 bytes): i32Not: bool := !(i32B)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:161: (5 bytes): i32Ceq: bool := i32A == i32B
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:162: (6 bytes): i32Cne: bool := i32A != i32B
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:163: (5 bytes): i32Clt: bool := i32A < i32B
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    clt.i32
	test/lang.useOperator.ci:164: (6 bytes): i32Cle: bool := i32A <= i32B
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    cgt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:165: (5 bytes): i32Cgt: bool := i32A > i32B
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    cgt.i32
	test/lang.useOperator.ci:166: (6 bytes): i32Cge: bool := i32A >= i32B
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    clt.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:168: (5 bytes): u32A: uint32 := a
	<.main+?>:    load.c32 96
	test/lang.useOperator.ci:169: (5 bytes): u32B: uint32 := b
	<.main+?>:    load.c32 42
	test/lang.useOperator.ci:170: (2 bytes): u32Pls: uint32 := +u32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:171: (3 bytes): u32Neg: uint32 := -u32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.i32
	test/lang.useOperator.ci:172: (3 bytes): u32Cmt: uint32 := ~u32B
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    cmt.b32
	test/lang.useOperator.ci:173: (5 bytes): u32Add: uint32 := u32A + u32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    add.i32
	test/lang.useOperator.ci:174: (5 bytes): u32Sub: uint32 := u32A - u32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    sub.i32
	test/lang.useOperator.ci:175: (5 bytes): u32Mul: uint32 := u32A * u32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    mul.u32
	test/lang.useOperator.ci:176: (5 bytes): u32Div: uint32 := u32A / u32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    div.u32
	test/lang.useOperator.ci:177: (5 bytes): u32Mod: uint32 := u32A % u32B
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    dup.x1 sp(8)
	<.main+?>:    mod.u32
	test/lang.useOperator.ci:178: (5 bytes): u32And: uint32 := u32A & u32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    and.b32
	test/lang.useOperator.ci:179: (5 bytes): u32Ior: uint32 := u32A | u32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    or.b32
	test/lang.useOperator.ci:180: (5 bytes): u32Xor: uint32 := u32A ^ u32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    xor.b32
	test/lang.useOperator.ci:181: (5 bytes): u32Shl: uint32 := u32A << shift
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(158)
	<.main+?>:    shl.b32
	test/lang.useOperator.ci:182: (5 bytes): u32Shr: uint32 := u32A >> shift
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(159)
	<.main+?>:    shr.b32
	test/lang.useOperator.ci:183: (4 bytes): u32Not: bool := !(u32B)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    i32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:184: (5 bytes): u32Ceq: bool := u32A == u32B
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    dup.x1 sp(15)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:185: (6 bytes): u32Cne: bool := u32A != u32B
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    dup.x1 sp(16)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:186: (5 bytes): u32Clt: bool := u32A < u32B
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    dup.x1 sp(17)
	<.main+?>:    clt.u32
	test/lang.useOperator.ci:187: (6 bytes): u32Cle: bool := u32A <= u32B
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    dup.x1 sp(18)
	<.main+?>:    cgt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:188: (5 bytes): u32Cgt: bool := u32A > u32B
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    dup.x1 sp(19)
	<.main+?>:    cgt.u32
	test/lang.useOperator.ci:189: (6 bytes): u32Cge: bool := u32A >= u32B
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    dup.x1 sp(20)
	<.main+?>:    clt.u32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:191: (9 bytes): i64A: int64 := a
	<.main+?>:    load.c64 96
	test/lang.useOperator.ci:192: (9 bytes): i64B: int64 := b
	<.main+?>:    load.c64 42
	test/lang.useOperator.ci:193: (2 bytes): i64Pls: int64 := +i64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:194: (3 bytes): i64Neg: int64 := -i64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.i64
	test/lang.useOperator.ci:195: (3 bytes): i64Cmt: int64 := ~i64B
	<.main+?>:    dup.x2 sp(4)
	<.main+?>:    cmt.b64
	test/lang.useOperator.ci:196: (5 bytes): i64Add: int64 := i64A + i64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    add.i64
	test/lang.useOperator.ci:197: (5 bytes): i64Sub: int64 := i64A - i64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    sub.i64
	test/lang.useOperator.ci:198: (5 bytes): i64Mul: int64 := i64A * i64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    mul.i64
	test/lang.useOperator.ci:199: (5 bytes): i64Div: int64 := i64A / i64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    div.i64
	test/lang.useOperator.ci:200: (5 bytes): i64Mod: int64 := i64A % i64B
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    mod.i64
	test/lang.useOperator.ci:201: (5 bytes): i64And: int64 := i64A & i64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    and.b64
	test/lang.useOperator.ci:202: (5 bytes): i64Ior: int64 := i64A | i64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    or.b64
	test/lang.useOperator.ci:203: (5 bytes): i64Xor: int64 := i64A ^ i64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    xor.b64
	test/lang.useOperator.ci:204: (5 bytes): i64Shl: int64 := i64A << shift
	<.main+?>:    dup.x2 sp(24)
	<.main+?>:    dup.x1 sp(194)
	<.main+?>:    shl.b64
	test/lang.useOperator.ci:205: (5 bytes): i64Shr: int64 := i64A >> shift
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    dup.x1 sp(196)
	<.main+?>:    sar.b64
	test/lang.useOperator.ci:206: (4 bytes): i64Not: bool := !(i64B)
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    i64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:207: (5 bytes): i64Ceq: bool := i64A == i64B
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    ceq.i64
	test/lang.useOperator.ci:208: (6 bytes): i64Cne: bool := i64A != i64B
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    ceq.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:209: (5 bytes): i64Clt: bool := i64A < i64B
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    clt.i64
	test/lang.useOperator.ci:210: (6 bytes): i64Cle: bool := i64A <= i64B
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    cgt.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:211: (5 bytes): i64Cgt: bool := i64A > i64B
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    cgt.i64
	test/lang.useOperator.ci:212: (6 bytes): i64Cge: bool := i64A >= i64B
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    clt.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:214: (9 bytes): u64A: uint64 := a
	<.main+?>:    load.c64 96
	test/lang.useOperator.ci:215: (9 bytes): u64B: uint64 := b
	<.main+?>:    load.c64 42
	test/lang.useOperator.ci:216: (2 bytes): u64Pls: uint64 := +u64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:217: (3 bytes): u64Neg: uint64 := -u64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.i64
	test/lang.useOperator.ci:218: (3 bytes): u64Cmt: uint64 := ~u64B
	<.main+?>:    dup.x2 sp(4)
	<.main+?>:    cmt.b64
	test/lang.useOperator.ci:219: (5 bytes): u64Add: uint64 := u64A + u64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    add.i64
	test/lang.useOperator.ci:220: (5 bytes): u64Sub: uint64 := u64A - u64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    sub.i64
	test/lang.useOperator.ci:221: (5 bytes): u64Mul: uint64 := u64A * u64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    mul.u64
	test/lang.useOperator.ci:222: (5 bytes): u64Div: uint64 := u64A / u64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    div.u64
	test/lang.useOperator.ci:223: (5 bytes): u64Mod: uint64 := u64A % u64B
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    dup.x2 sp(16)
	<.main+?>:    mod.u64
	test/lang.useOperator.ci:224: (5 bytes): u64And: uint64 := u64A & u64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    and.b64
	test/lang.useOperator.ci:225: (5 bytes): u64Ior: uint64 := u64A | u64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    or.b64
	test/lang.useOperator.ci:226: (5 bytes): u64Xor: uint64 := u64A ^ u64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    xor.b64
	test/lang.useOperator.ci:227: (5 bytes): u64Shl: uint64 := u64A << shift
	<.main+?>:    dup.x2 sp(24)
	<.main+?>:    dup.x1 sp(231)
	<.main+?>:    shl.b64
	test/lang.useOperator.ci:228: (5 bytes): u64Shr: uint64 := u64A >> shift
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    dup.x1 sp(233)
	<.main+?>:    shr.b64
	test/lang.useOperator.ci:229: (4 bytes): u64Not: bool := !(u64B)
	<.main+?>:    dup.x2 sp(26)
	<.main+?>:    i64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:230: (5 bytes): u64Ceq: bool := u64A == u64B
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    dup.x2 sp(29)
	<.main+?>:    ceq.i64
	test/lang.useOperator.ci:231: (6 bytes): u64Cne: bool := u64A != u64B
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    dup.x2 sp(30)
	<.main+?>:    ceq.i64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:232: (5 bytes): u64Clt: bool := u64A < u64B
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    dup.x2 sp(31)
	<.main+?>:    clt.u64
	test/lang.useOperator.ci:233: (6 bytes): u64Cle: bool := u64A <= u64B
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    dup.x2 sp(32)
	<.main+?>:    cgt.u64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:234: (5 bytes): u64Cgt: bool := u64A > u64B
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    dup.x2 sp(33)
	<.main+?>:    cgt.u64
	test/lang.useOperator.ci:235: (6 bytes): u64Cge: bool := u64A >= u64B
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    dup.x2 sp(34)
	<.main+?>:    clt.u64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:237: (5 bytes): f32A: float32 := a
	<.main+?>:    load.f32 96.300003
	test/lang.useOperator.ci:238: (5 bytes): f32B: float32 := b
	<.main+?>:    load.f32 42.139999
	test/lang.useOperator.ci:239: (2 bytes): f32Pls: float32 := +f32B
	<.main+?>:    dup.x1 sp(0)
	test/lang.useOperator.ci:240: (3 bytes): f32Neg: float32 := -f32B
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    neg.f32
	test/lang.useOperator.ci:242: (5 bytes): f32Add: float32 := f32A + f32B
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    dup.x1 sp(3)
	<.main+?>:    add.f32
	test/lang.useOperator.ci:243: (5 bytes): f32Sub: float32 := f32A - f32B
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    dup.x1 sp(4)
	<.main+?>:    sub.f32
	test/lang.useOperator.ci:244: (5 bytes): f32Mul: float32 := f32A * f32B
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    dup.x1 sp(5)
	<.main+?>:    mul.f32
	test/lang.useOperator.ci:245: (5 bytes): f32Div: float32 := f32A / f32B
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    dup.x1 sp(6)
	<.main+?>:    div.f32
	test/lang.useOperator.ci:246: (5 bytes): f32Mod: float32 := f32A % f32B
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    mod.f32
	test/lang.useOperator.ci:252: (4 bytes): f32Not: bool := !(f32B)
	<.main+?>:    dup.x1 sp(7)
	<.main+?>:    f32.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:253: (5 bytes): f32Ceq: bool := f32A == f32B
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    dup.x1 sp(9)
	<.main+?>:    ceq.f32
	test/lang.useOperator.ci:254: (6 bytes): f32Cne: bool := f32A != f32B
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    dup.x1 sp(10)
	<.main+?>:    ceq.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:255: (5 bytes): f32Clt: bool := f32A < f32B
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    dup.x1 sp(11)
	<.main+?>:    clt.f32
	test/lang.useOperator.ci:256: (6 bytes): f32Cle: bool := f32A <= f32B
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    dup.x1 sp(12)
	<.main+?>:    cgt.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:257: (5 bytes): f32Cgt: bool := f32A > f32B
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    dup.x1 sp(13)
	<.main+?>:    cgt.f32
	test/lang.useOperator.ci:258: (6 bytes): f32Cge: bool := f32A >= f32B
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    dup.x1 sp(14)
	<.main+?>:    clt.f32
	<.main+?>:    not.b32
	test/lang.useOperator.ci:260: (9 bytes): f64A: float64 := a
	<.main+?>:    load.f64 96.300000
	test/lang.useOperator.ci:261: (9 bytes): f64B: float64 := b
	<.main+?>:    load.f64 42.140000
	test/lang.useOperator.ci:262: (2 bytes): f64Pls: float64 := +f64B
	<.main+?>:    dup.x2 sp(0)
	test/lang.useOperator.ci:263: (3 bytes): f64Neg: float64 := -f64B
	<.main+?>:    dup.x2 sp(2)
	<.main+?>:    neg.f64
	test/lang.useOperator.ci:265: (5 bytes): f64Add: float64 := f64A + f64B
	<.main+?>:    dup.x2 sp(6)
	<.main+?>:    dup.x2 sp(6)
	<.main+?>:    add.f64
	test/lang.useOperator.ci:266: (5 bytes): f64Sub: float64 := f64A - f64B
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    dup.x2 sp(8)
	<.main+?>:    sub.f64
	test/lang.useOperator.ci:267: (5 bytes): f64Mul: float64 := f64A * f64B
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    dup.x2 sp(10)
	<.main+?>:    mul.f64
	test/lang.useOperator.ci:268: (5 bytes): f64Div: float64 := f64A / f64B
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    dup.x2 sp(12)
	<.main+?>:    div.f64
	test/lang.useOperator.ci:269: (5 bytes): f64Mod: float64 := f64A % f64B
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    mod.f64
	test/lang.useOperator.ci:275: (4 bytes): f64Not: bool := !(f64B)
	<.main+?>:    dup.x2 sp(14)
	<.main+?>:    f64.2bool
	<.main+?>:    not.b32
	test/lang.useOperator.ci:276: (5 bytes): f64Ceq: bool := f64A == f64B
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    dup.x2 sp(17)
	<.main+?>:    ceq.f64
	test/lang.useOperator.ci:277: (6 bytes): f64Cne: bool := f64A != f64B
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    dup.x2 sp(18)
	<.main+?>:    ceq.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:278: (5 bytes): f64Clt: bool := f64A < f64B
	<.main+?>:    dup.x2 sp(19)
	<.main+?>:    dup.x2 sp(19)
	<.main+?>:    clt.f64
	test/lang.useOperator.ci:279: (6 bytes): f64Cle: bool := f64A <= f64B
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    dup.x2 sp(20)
	<.main+?>:    cgt.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:280: (5 bytes): f64Cgt: bool := f64A > f64B
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    dup.x2 sp(21)
	<.main+?>:    cgt.f64
	test/lang.useOperator.ci:281: (6 bytes): f64Cge: bool := f64A >= f64B
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    dup.x2 sp(22)
	<.main+?>:    clt.f64
	<.main+?>:    not.b32
	test/lang.useOperator.ci:283: (5 bytes): ptrA: pointer := null
	<.main+?>:    load.ref .?????? ;null
	test/lang.useOperator.ci:284: (4 bytes): ptrB: pointer := pointer(shift)
	<.main+?>:    load.sp(+1128)
	test/lang.useOperator.ci:299: (5 bytes): ptrCeq: bool := ptrA == ptrB
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    dup.x1 sp(1)
	<.main+?>:    ceq.i32
	test/lang.useOperator.ci:300: (6 bytes): ptrCne: bool := ptrA != ptrB
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    dup.x1 sp(2)
	<.main+?>:    ceq.i32
	<.main+?>:    not.b32
	test/lang.statementIf.ci:4: (39 bytes): raise(raise.debug, 1, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 4
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 1
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:12: (39 bytes): raise(raise.debug, 3, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 12
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 3
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:22: (39 bytes): raise(raise.debug, 6, "0 == 0", null);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 22
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 6
	<.main+?>:    load.ref .?????? ;"0 == 0"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:26: (1 bytes): t: int32 := 0
	<.main+?>:    load.z32
	test/lang.statementIf.ci:28: (46 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:29: (38 bytes): raise(raise.debug, 7, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 29
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 7
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:32: (46 bytes): if (t != 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementIf.ci:33: (38 bytes): raise(raise.debug, 8, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 33
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 8
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:36: (88 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:37: (38 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 37
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 9
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:40: (38 bytes): raise(raise.debug, 10, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 40
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:43: (88 bytes): if (t != 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementIf.ci:44: (38 bytes): raise(raise.debug, 11, "t != 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 44
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 11
	<.main+?>:    load.ref .?????? ;"t != 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:47: (38 bytes): raise(raise.debug, 12, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 47
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 12
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementIf.ci:50: (358 bytes): if (t == 0)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.z32
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:51: (38 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 51
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 9
	<.main+?>:    load.ref .?????? ;"t == 0"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:53: (308 bytes): if (t == 1)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 1
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:54: (38 bytes): raise(raise.debug, 10, "t == 1", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 54
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 1"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:56: (254 bytes): if (t == 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:57: (38 bytes): raise(raise.debug, 10, "t == 2", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 57
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 2"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:59: (200 bytes): if (t == 3)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 3
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:60: (38 bytes): raise(raise.debug, 10, "t == 3", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 60
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 3"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:62: (146 bytes): if (t == 4)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 4
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:63: (38 bytes): raise(raise.debug, 10, "t == 4", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 63
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 4"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:65: (92 bytes): if (t == 5)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 5
	<.main+?>:    ceq.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementIf.ci:66: (38 bytes): raise(raise.debug, 10, "t == 5", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 66
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t == 5"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	<.main+?>:    jmp <.main+?>
	test/lang.statementIf.ci:69: (38 bytes): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+?>:    load.ref .?????? ;"test/lang.statementIf.ci"
	<.main+?>:    load.c32 69
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 10
	<.main+?>:    load.ref .?????? ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:3: (47 bytes): for ( ; ; )
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:4: (35 bytes): debug("for ( ; ; )");
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 4
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for ( ; ; )"
	<.main+?>:    load.ref .?????? ;pointer
	<.main+?>:    load.ref .?????? ;null
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:5: (4 bytes): break;
	<.main+?>:    jmp <.main+?>
	:: (4 bytes)
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:8: (59 bytes): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:9: (34 bytes): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 9
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for (int i = 0; i < 2; i += 1)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:8: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:8: (12 bytes): i < 2
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.statementFor.ci:12: (1 bytes): forIdx: int32
	<.main+?>:    load.z32
	test/lang.statementFor.ci:13: (57 bytes): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+?>:    load.z32
	<.main+?>:    set.x1 sp(1)
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:14: (34 bytes): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 14
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:13: (4 bytes): forIdx := forIdx + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:13: (12 bytes): forIdx < 2
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	test/lang.statementFor.ci:17: (75 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:18: (16 bytes): if (i < 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    clt.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementFor.ci:19: (4 bytes): continue;
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:21: (34 bytes): debug("for with continue", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 21
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for with continue"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:17: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:17: (12 bytes): i < 7
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	test/lang.statementFor.ci:24: (75 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>:    load.z32
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:25: (16 bytes): if (i > 2)
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 2
	<.main+?>:    cgt.i32
	<.main+?>:    jz <.main+?>
	test/lang.statementFor.ci:26: (4 bytes): break;
	<.main+?>:    jmp <.main+?>
	test/lang.statementFor.ci:28: (34 bytes): debug("for with break", i);
	<.main+?>:    load.ref .?????? ;"test/lang.statementFor.ci"
	<.main+?>:    load.c32 28
	<.main+?>:    load.c32 14
	<.main+?>:    load.z32
	<.main+?>:    load.ref .?????? ;"for with break"
	<.main+?>:    load.ref .?????? ;int32
	<.main+?>:    load.sp(+24)
	<.main+?>:    nfc(5) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
	test/lang.statementFor.ci:24: (4 bytes): i := i + 1
	<.main+?>:    inc.i32(+1)
	test/lang.statementFor.ci:24: (12 bytes): i < 7
	<.main+?>:    dup.x1 sp(0)
	<.main+?>:    load.c32 7
	<.main+?>:    clt.i32
	<.main+?>:    jnz <.main+?>
	<.main+?>:    inc.sp(-4)
	<.main+?>:    nfc(0) ;halt(): void
}

---------- Execute:
test/stdc.memory.ci:26: debug: val1: int64(42)
test/stdc.memory.ci:27: debug: val2: int64(96)
test/stdc.memory.ci:32: debug: val1: int64(0)
test/stdc.memory.ci:33: debug: val2: int64(42)
test/stdc.execute.ci:34: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	test/stdc.execute.ci:52: tryExec(args: null, action: <abortExecution @03b108>)
	native.code:: .main
test/lang.array.ci:83: debug: string as variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang.array.ci:84: debug: string to variant: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang.array.ci:87: debug: string as variant: char[*]("string")
test/lang.array.ci:88: debug: string to variant: char[*]("string")
test/lang.array.ci:91: debug: string as variant: char[]([0] {})
test/lang.array.ci:92: debug: string to variant: char[]([0] {})
test/lang.method.ci:41: debug: virtual
	test/lang.method.ci:69: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:60: debug: override
	test/lang.method.ci:70: customPrint(this: {
		abstractMethod: <globalFunction @03b240>,
		delegateMethod: <RecordMethodTest.forwardMethod @03b1e8>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <customPrint @03b248>
	})
	native.code:: .main
test/lang.method.ci:45: debug: static
	test/lang.method.ci:73: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:76: debug: extension
	test/lang.method.ci:84: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:80: debug: extension
	test/lang.method.ci:85: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:76: debug: extension
	test/lang.method.ci:86: print(this: {
		abstractMethod: <globalFunction @03b240>,
		delegateMethod: <RecordMethodTest.forwardMethod @03b1e8>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <customPrint @03b248>
	})
	native.code:: .main
test/lang.method.ci:41: debug: virtual
	test/lang.method.ci:89: print(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:45: debug: static
	test/lang.method.ci:90: printStatic(this: {
		abstractMethod: <RecordMethodTest.staticMethod @03b1d0>,
		delegateMethod: <globalFunction @03b240>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <RecordMethodTest.print @03b1f0>
	})
	native.code:: .main
test/lang.method.ci:41: debug: virtual
	test/lang.method.ci:91: print(this: {
		abstractMethod: <globalFunction @03b240>,
		delegateMethod: <RecordMethodTest.forwardMethod @03b1e8>,
		virtualMethod: <RecordMethodTest.virtualMethod @03b1e0>,
		print: <customPrint @03b248>
	})
	native.code:: .main
test/lang.statementIf.ci:4: debug: 0 == 0
	... 1 more
test/lang.statementIf.ci:12: debug: 0 == 0
	native.code:: .main
test/lang.statementIf.ci:22: debug: 0 == 0
	native.code:: .main
test/lang.statementIf.ci:29: debug: t == 0: int32(0)
	native.code:: .main
test/lang.statementIf.ci:37: debug: t == 0: int32(0)
	native.code:: .main
test/lang.statementIf.ci:47: debug: t == 0: int32(0)
	native.code:: .main
test/lang.statementIf.ci:51: debug: t == 0: int32(0)
	native.code:: .main
test/lang.statementFor.ci:4: debug: for ( ; ; )
test/lang.statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
test/lang.statementFor.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
test/lang.statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
test/lang.statementFor.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
test/lang.statementFor.ci:21: debug: for with continue: int32(2)
test/lang.statementFor.ci:21: debug: for with continue: int32(3)
test/lang.statementFor.ci:21: debug: for with continue: int32(4)
test/lang.statementFor.ci:21: debug: for with continue: int32(5)
test/lang.statementFor.ci:21: debug: for with continue: int32(6)
test/lang.statementFor.ci:28: debug: for with break: int32(0)
test/lang.statementFor.ci:28: debug: for with break: int32(1)
test/lang.statementFor.ci:28: debug: for with break: int32(2)

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit: typename(<emit>)
System: typename(<System>)
lib/stdlib.ci:31: NotEquals: typename(<NotEquals>)
lib/stdlib.ci:38: assertEq: function(<assertEq @03a148>)
lib/math.ci:22: Math.modf: function(<Math.modf @03a1a0>)
lib/math.ci:59: Math.floor: function(<Math.floor @03a208>)
lib/math.ci:71: Math.sign: function(<Math.sign @03a230>)
lib/math.ci:80: Math.sign: function(<Math.sign @03a258>)
lib/math.ci:90: Math.abs: function(<Math.abs @03a280>)
lib/math.ci:96: Math.abs: function(<Math.abs @03a298>)
lib/math.ci:103: Math.min: function(<Math.min @03a2b0>)
lib/math.ci:109: Math.min: function(<Math.min @03a2c8>)
lib/math.ci:116: Math.max: function(<Math.max @03a2e0>)
lib/math.ci:122: Math.max: function(<Math.max @03a2f8>)
lib/math.ci:129: Math.clamp: function(<Math.clamp @03a310>)
lib/math.ci:138: Math.clamp: function(<Math.clamp @03a338>)
lib/math.ci:148: Math.lerp: function(<Math.lerp @03a360>)
lib/math.ci:151: Math.lerp: function(<Math.lerp @03a370>)
lib/math.ci:155: Math.smooth: function(<Math.smooth @03a380>)
lib/math.ci:159: Math.smooth: function(<Math.smooth @03a3c0>)
lib/math.ci:239: Math.cmp: function(<Math.cmp @03a410>)
lib/math.ci:252: Math.cmp: function(<Math.cmp @03a450>)
lib/math.ci:266: Math.sinCos: function(<Math.sinCos @03a490>)
lib/math.ci:323: Math.tan: function(<Math.tan @03a5f0>)
lib/math.ci:380: Math.sinh: function(<Math.sinh @03a778>)
lib/math.ci:419: Math.cosh: function(<Math.cosh @03a870>)
lib/math.ci:435: Math.asin: function(<Math.asin @03a8c0>)
lib/math.ci:3: Math: typename(<Math>)
lib/math.Complex.ci:3: Complex: typename(<Complex>)
lib/math.Complex.ci:20: Complex: function(<Complex @03a978>)
lib/math.Complex.ci:25: Complex: function(<Complex @03a980>)
lib/math.Complex.ci:66: div: function(<div @03a990>)
lib/math.Complex.ci:93: inv: function(<inv @03aa10>)
lib/math.Complex.ci:107: pow: function(<pow @03aa38>)
lib/string.ci:3: length: function(<length @03aaa8>)
lib/string.ci:14: indexOf: function(<indexOf @03aae0>)
lib/string.ci:24: lastIndexOf: function(<lastIndexOf @03ab18>)
lib/string.ci:35: startsWith: function(<startsWith @03ab58>)
lib/string.ci:44: endsWith: function(<endsWith @03aba8>)
lib/string.ci:58: compare: function(<compare @03ac30>)
lib/string.ci:70: ignCaseCmp: function(<ignCaseCmp @03acc8>)
lib/string.ci:82: caseCmp: function(<caseCmp @03acf0>)
lib/string.ci:104: FormatFlags: typename(<FormatFlags>)
lib/string.ci:112: append: function(<append @03ad00>)
lib/string.ci:128: append: function(<append @03ad68>)
lib/string.ci:190: append: function(<append @03afe8>)
lib/string.ci:200: append: function(<append @03b008>)
test/lang.inlineEmit.ci:3: emitldz32: int32(0)
test/lang.inlineEmit.ci:4: emitldz64: int64(0)
test/lang.inlineEmit.ci:6: emitA: int32(42)
test/lang.inlineEmit.ci:7: emitB: int32(96)
test/lang.inlineEmit.ci:9: emitAddI32: int32(138)
test/lang.inlineEmit.ci:10: emitDivI32: int32(2)
test/lang.inlineEmit.ci:11: emitNfcF32: float32(1.000000)
test/lang.inlineEmit.ci:17: emitFloatAsInt1: int32(1140457472)
test/lang.inlineEmit.ci:18: emitFloatAsInt2: int64(1140457472)
test/lang.inlineEmit.ci:19: emitFloatAsInt3: int32(0)
test/lang.inlineEmit.ci:20: emitFloatAsInt4: int64(4647503709213818880)
test/lang.inlineEmit.ci:23: emitSlice: char[]([3] {'s', 't', 'r'})
test/lang.inlineMacros.ci:13: ma: int32(3)
test/lang.inlineMacros.ci:14: mb: int32(6)
test/lang.inlineMacros.ci:15: mc: int32(9)
test/lang.inlineMacros.ci:17: zeroVal: int32(0)
test/lang.inlineMacros.ci:18: zeroVar: int32(0)
test/lang.inlineMacros.ci:19: zeroXpr: int32(0)
test/lang.inlineMacros.ci:21: lastVal: int32(3)
test/lang.inlineMacros.ci:22: lastVar: int32(6)
test/lang.inlineMacros.ci:23: lastXpr: int32(15)
test/lang.inlineMacros.ci:25: sum2Val: int32(15)
test/lang.inlineMacros.ci:26: sum2Var: int32(9)
test/lang.inlineMacros.ci:27: sum2Xpr: int32(24)
test/lang.inlineMacros.ci:29: any2Val: int32(3)
test/lang.inlineMacros.ci:30: any2Var: int32(3)
test/lang.inlineMacros.ci:31: any2Xpr: int32(9)
test/lang.inlineMacros.ci:33: min2Val: int32(3)
test/lang.inlineMacros.ci:34: min2Var: int32(3)
test/lang.inlineMacros.ci:35: min2Xpr: int32(9)
test/lang.inlineMacros.ci:37: sum3Val: int32(11)
test/lang.inlineMacros.ci:38: sum3Var: int32(18)
test/lang.inlineMacros.ci:39: sum3Xpr: int32(36)
test/lang.inlineMacros.ci:41: any3Val: int32(3)
test/lang.inlineMacros.ci:42: any3Var: int32(3)
test/lang.inlineMacros.ci:43: any3Xpr: int32(9)
test/lang.inlineMacros.ci:45: min3Val: int32(2)
test/lang.inlineMacros.ci:46: min3Var: int32(3)
test/lang.inlineMacros.ci:47: min3Xpr: int32(9)
test/test.inlineOverload.ci:9: overload1: float32(1.000000)
test/test.inlineOverload.ci:10: overload2: float32(2.000000)
test/test.inlineOverload.ci:11: overload3: float32(3.000000)
test/test.inlineOverload.ci:12: overload4: float32(4.000000)
test/test.inlineOverload.ci:13: overload5: float32(5.000000)
test/test.inlineOverload.ci:15: Celsius: typename(<Celsius>)
test/test.inlineOverload.ci:16: Fahrenheit: typename(<Fahrenheit>)
test/test.inlineOverload.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
test/test.inlineOverload.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
test/lang.initByRef.ci:7: value: int64(42)
test/lang.initByRef.ci:8: valueRef: int64(42)
test/lang.initByRef.ci:9: valuePtr: pointer(<value @03b080>)
test/lang.initByRef.ci:10: valueVar: variant({int64: 42})
test/lang.initByRef.ci:12: fromRef: int64(42)
test/lang.initByRef.ci:13: fromPtr: int64(42)
test/lang.initByRef.ci:14: fromVar: int64(42)
test/lang.initByRef.ci:16: nullRef: int64(null)
test/lang.initByRef.ci:17: nullPtr: pointer(null)
test/lang.initByRef.ci:18: nullVar: variant(null)
test/lang.initByRef.ci:19: nullTyp: typename(null)
test/lang.initByRef.ci:20: nullFun: function(null)
test/lang.initByRef.ci:21: nullObj: object(null)
test/lang.initByRef.ci:23: typePtr: pointer(<int64 @000400>)
test/lang.initByRef.ci:24: typeVar: variant({typename: <int64>})
test/lang.initByRef.ci:25: typeTyp: typename(<int64>)
test/lang.initByRef.ci:27: local: int64(42)
test/lang.initByRef.ci:28: copyVal: int64(42)
test/lang.initByRef.ci:29: copyRef: int64(42)
test/lang.initByRef.ci:30: copyPtr: pointer(<value @03b080>)
test/lang.initByRef.ci:31: copyVar: variant({int64: 42})
test/lang.initByRef.ci:32: copyTyp: typename(<int64>)
test/lang.initByRef.ci:35: ptrVoid: pointer(<void @0000a0>)
test/lang.initByRef.ci:36: ptrBool: pointer(<bool @000130>)
test/lang.initByRef.ci:37: ptrChar: pointer(<char @0001c0>)
test/lang.initByRef.ci:38: ptrInt8: pointer(<int8 @000250>)
test/lang.initByRef.ci:39: ptrInt16: pointer(<int16 @0002e0>)
test/lang.initByRef.ci:40: ptrInt32: pointer(<int32 @000370>)
test/lang.initByRef.ci:41: ptrInt64: pointer(<int64 @000400>)
test/lang.initByRef.ci:42: ptrUint8: pointer(<uint8 @000490>)
test/lang.initByRef.ci:43: ptrUint16: pointer(<uint16 @000520>)
test/lang.initByRef.ci:44: ptrUint32: pointer(<uint32 @0005b0>)
test/lang.initByRef.ci:45: ptrUint64: pointer(<uint64 @000640>)
test/lang.initByRef.ci:46: ptrFloat32: pointer(<float32 @0006d0>)
test/lang.initByRef.ci:47: ptrFloat64: pointer(<float64 @000760>)
test/lang.initByRef.ci:48: ptrTypename: pointer(<typename @000008>)
test/lang.initByRef.ci:49: ptrFunction: pointer(<function @000910>)
test/lang.initByRef.ci:50: ptrPointer: pointer(<pointer @0007f0>)
test/lang.initByRef.ci:51: ptrVariant: pointer(<variant @000880>)
test/lang.initByRef.ci:52: ptrObject: pointer(<object @0009a8>)
test/lang.initByRef.ci:55: varVoid: variant({typename: <void>})
test/lang.initByRef.ci:56: varBool: variant({typename: <bool>})
test/lang.initByRef.ci:57: varChar: variant({typename: <char>})
test/lang.initByRef.ci:58: varInt8: variant({typename: <int8>})
test/lang.initByRef.ci:59: varInt16: variant({typename: <int16>})
test/lang.initByRef.ci:60: varInt32: variant({typename: <int32>})
test/lang.initByRef.ci:61: varInt64: variant({typename: <int64>})
test/lang.initByRef.ci:62: varUint8: variant({typename: <uint8>})
test/lang.initByRef.ci:63: varUint16: variant({typename: <uint16>})
test/lang.initByRef.ci:64: varUint32: variant({typename: <uint32>})
test/lang.initByRef.ci:65: varUint64: variant({typename: <uint64>})
test/lang.initByRef.ci:66: varFloat32: variant({typename: <float32>})
test/lang.initByRef.ci:67: varFloat64: variant({typename: <float64>})
test/lang.initByRef.ci:68: varTypename: variant({typename: <typename>})
test/lang.initByRef.ci:69: varFunction: variant({typename: <function>})
test/lang.initByRef.ci:70: varPointer: variant({typename: <pointer>})
test/lang.initByRef.ci:71: varVariant: variant({typename: <variant>})
test/lang.initByRef.ci:72: varObject: variant({typename: <object>})
test/lang.initByRef.ci:75: typVoid: typename(<void>)
test/lang.initByRef.ci:76: typBool: typename(<bool>)
test/lang.initByRef.ci:77: typChar: typename(<char>)
test/lang.initByRef.ci:78: typInt8: typename(<int8>)
test/lang.initByRef.ci:79: typInt16: typename(<int16>)
test/lang.initByRef.ci:80: typInt32: typename(<int32>)
test/lang.initByRef.ci:81: typInt64: typename(<int64>)
test/lang.initByRef.ci:82: typUint8: typename(<uint8>)
test/lang.initByRef.ci:83: typUint16: typename(<uint16>)
test/lang.initByRef.ci:84: typUint32: typename(<uint32>)
test/lang.initByRef.ci:85: typUint64: typename(<uint64>)
test/lang.initByRef.ci:86: typFloat32: typename(<float32>)
test/lang.initByRef.ci:87: typFloat64: typename(<float64>)
test/lang.initByRef.ci:88: typTypename: typename(<typename>)
test/lang.initByRef.ci:89: typFunction: typename(<function>)
test/lang.initByRef.ci:90: typPointer: typename(<pointer>)
test/lang.initByRef.ci:91: typVariant: typename(<variant>)
test/lang.initByRef.ci:92: typObject: typename(<object>)
test/lang.initByRef.ci:95: valueOfPtr: pointer(<value @03b080>)
test/lang.initByRef.ci:96: valueOfVar: variant({int64: 42})
test/lang.initByRef.ci:97: valueOfTyp: typename(<int64>)
test/lang.initByRef.ci:99: typeOfValue: typename(<int64>)
test/lang.initByRef.ci:105: copyPtrFloat64: variant({pointer: <float64 @000760>})
test/lang.initByRef.ci:108: copyVarFloat64: pointer(<float64 @000760>)
test/lang.function.ci:3: empty: function(<empty @03b088>)
test/lang.function.ci:6: funAdd: function(<funAdd @03b090>)
test/lang.function.ci:11: funAddResult: int32(9)
test/lang.function.ci:14: funAddRef: function(<funAdd @03b090>)
test/lang.function.ci:17: funAddRefResult: int32(10)
test/lang.function.ci:20: funMul: function(<funMul @03b098>)
test/lang.function.ci:23: funMulResult: int32(12)
test/lang.function.ci:26: funMulRef: function(<funMul @03b098>)
test/lang.function.ci:29: funMulRefResult: int32(14)
test/lang.function.ci:32: funMul: function(<funMul @03b098>)
test/lang.function.ci:37: fib: function(<fib @03b0a0>)
test/lang.function.ci:45: fibonacci_13: uint32(233)
test/lang.reflect.ci:3: sizeofVoid: int32(0)
test/lang.reflect.ci:4: sizeofBool: int32(1)
test/lang.reflect.ci:5: sizeofChar: int32(1)
test/lang.reflect.ci:6: sizeofInt8: int32(1)
test/lang.reflect.ci:7: sizeofInt16: int32(2)
test/lang.reflect.ci:8: sizeofInt32: int32(4)
test/lang.reflect.ci:9: sizeofInt64: int32(8)
test/lang.reflect.ci:10: sizeofUint8: int32(1)
test/lang.reflect.ci:11: sizeofUint16: int32(2)
test/lang.reflect.ci:12: sizeofUint32: int32(4)
test/lang.reflect.ci:13: sizeofUint64: int32(8)
test/lang.reflect.ci:14: sizeofFloat32: int32(4)
test/lang.reflect.ci:15: sizeofFloat64: int32(8)
test/lang.reflect.ci:16: sizeofPointer: int32(4)
test/lang.reflect.ci:17: sizeofVariant: int32(8)
test/lang.reflect.ci:18: sizeofTypename: int32(136)
test/lang.reflect.ci:19: sizeofFunction: int32(4)
test/lang.reflect.ci:20: sizeofObject: int32(4)
test/lang.reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
test/lang.reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
test/lang.reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
test/lang.reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
test/lang.reflect.ci:32: offsetOfRecord: int32(158520)
test/lang.reflect.ci:33: sizeOfRecord: int32(16)
test/lang.reflect.ci:34: fileOfRecord: char[*]("test/lang.reflect.ci")
test/lang.reflect.ci:35: lineOfRecord: int32(26)
test/lang.reflect.ci:37: typeofBase: typename(<RecordSizeof>)
test/lang.reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
test/lang.reflect.ci:39: offsetOfBase: int32(158248)
test/lang.reflect.ci:40: sizeOfBase: int32(12)
test/lang.reflect.ci:41: fileOfBase: char[*]("test/lang.reflect.ci")
test/lang.reflect.ci:42: lineOfBase: int32(22)
test/lang.reflect.ci:44: typeofBase1: typename(<object>)
test/lang.reflect.ci:45: offsetOfBase1: int32(2472)
test/lang.reflect.ci:46: sizeOfBase1: int32(4)
test/lang.reflect.ci:48: typeofBase2: typename(<typename>)
test/lang.reflect.ci:49: offsetOfBase2: int32(8)
test/lang.reflect.ci:50: sizeOfBase2: int32(136)
test/stdc.number.ci:3: pi64: float64(3.141593)
test/stdc.number.ci:4: e64: float64(2.718282)
test/stdc.number.ci:6: pi32: float32(3.141593)
test/stdc.number.ci:7: e32: float32(2.718282)
test/stdc.number.ci:14: r_comp: int32(112)
test/stdc.number.ci:15: g_comp: int32(252)
test/stdc.number.ci:16: b_comp: int32(248)
test/stdc.number.ci:18: r5g6b5: int32(30719)
test/stdc.number.ci:19: r8g8b8: int32(7404792)
test/stdc.number.ci:21: zxtR5: int32(14)
test/stdc.number.ci:22: zxtG6: int32(63)
test/stdc.number.ci:23: zxtB5: int32(31)
test/stdc.number.ci:25: sxtR5: int32(14)
test/stdc.number.ci:26: sxtG6: int32(-1)
test/stdc.number.ci:27: sxtB5: int32(-1)
test/stdc.number.ci:29: zxtR8: int32(112)
test/stdc.number.ci:30: zxtG8: int32(252)
test/stdc.number.ci:31: zxtB8: int32(248)
test/stdc.number.ci:33: sxtR8: int32(112)
test/stdc.number.ci:34: sxtG8: int32(-4)
test/stdc.number.ci:35: sxtB8: int32(-8)
test/stdc.number.ci:37: sinF64: float64(1.000000)
test/stdc.number.ci:38: cosF64: float64(0.000000)
test/stdc.number.ci:39: tanF64: float64(1.000000)
test/stdc.number.ci:40: logF64: float64(3.000000)
test/stdc.number.ci:41: expF64: float64(2.718282)
test/stdc.number.ci:42: powF64: float64(3.141593)
test/stdc.number.ci:43: sqrtF64: float64(3.141593)
test/stdc.number.ci:44: atanF64: float64(1.262627)
test/stdc.number.ci:46: sinF32: float32(1.000000)
test/stdc.number.ci:47: cosF32: float32(-0.000000)
test/stdc.number.ci:48: tanF32: float32(1.000000)
test/stdc.number.ci:49: logF32: float32(3.000000)
test/stdc.number.ci:50: expF32: float32(2.718282)
test/stdc.number.ci:51: powF32: float32(3.141593)
test/stdc.number.ci:52: sqrtF32: float32(3.141593)
test/stdc.number.ci:53: atanF32: float32(1.262627)
test/stdc.memory.ci:7: p1: pointer(<@03cf18>)
test/stdc.memory.ci:8: p2: pointer(<@03d328>)
test/stdc.memory.ci:9: p3: pointer(<@03d388>)
test/stdc.memory.ci:10: p4: pointer(<@03d438>)
test/stdc.memory.ci:23: val1: int64(0)
test/stdc.memory.ci:24: val2: int64(42)
test/stdc.execute.ci:11: noError: function(<noError @03b0d8>)
test/stdc.execute.ci:14: stackOverflow: function(<stackOverflow @03b0e0>)
test/stdc.execute.ci:19: divisionByZero: function(<divisionByZero @03b0f8>)
test/stdc.execute.ci:23: abortExecution: function(<abortExecution @03b108>)
test/stdc.execute.ci:37: invalidMemoryAccess: function(<invalidMemoryAccess @03b150>)
test/stdc.execute.ci:42: invalidInstruction: function(<invalidInstruction @03b160>)
test/stdc.execute.ci:46: tryExecErr0: int32(0)
test/stdc.execute.ci:47: tryExecErr1: int32(1)
test/stdc.execute.ci:48: tryExecErr2: int32(2)
test/stdc.execute.ci:49: tryExecErr3: int32(3)
test/stdc.execute.ci:50: tryExecErr4: int32(4)
test/stdc.execute.ci:51: tryExecErr5: int32(5)
test/stdc.execute.ci:52: tryExecErr6: int32(6)
test/lang.array.ci:49: arrFixedNoInit: int64[7]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:50: arrArrayNoInit: int64[*](BadRef)
test/lang.array.ci:51: arrSliceNoInit: int64[](BadRef)
test/lang.array.ci:59: arrArrayInitNull: int64[*](null)
test/lang.array.ci:60: arrSliceInitNull: int64[](null)
test/lang.array.ci:63: arrArrayInitFixed: int64[*]([0] {})
test/lang.array.ci:64: arrSliceInitFixed: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:67: arrArrayInitSlice: int64[*]([0] {})
test/lang.array.ci:68: arrSliceInitSlice: int64[]([7] {42, 43, 44, 45, 46, 47, 48})
test/lang.array.ci:71: arrArrayInitPtr: int64[*]([0] {})
test/lang.array.ci:81: strFixed: char[7]([7] {'s', 't', 'r', 'i', 'n', 'g', ''})
test/lang.array.ci:86: strArray: char[*]("string")
test/lang.array.ci:90: strSlice: char[]([6] {'s', 't', 'r', 'i', 'n', 'g'})
test/lang.array.ci:103: lenSlice: function(<lenSlice @03b168>)
test/lang.array.ci:104: nthFixed: function(<nthFixed @03b170>)
test/lang.array.ci:105: nthArray: function(<nthArray @03b180>)
test/lang.array.ci:106: nthSlice: function(<nthSlice @03b190>)
test/lang.member.ci:5: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
test/lang.member.ci:35: RecordMemberTest.global: int32(0)
test/lang.member.ci:38: RecordMemberTest.globalInit: int32(5)
test/lang.member.ci:41: RecordMemberTest.globalConstant: int32(6)
test/lang.member.ci:44: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(0)
})
test/lang.member.ci:47: RecordMemberTest.globalRecInit: Inner({
	member: int32(51),
	constant: int32(52)
})
test/lang.member.ci:50: RecordMemberTest.globalConstantRec: Inner({
	member: int32(61),
	constant: int32(62)
})
test/lang.member.ci:3: RecordMemberTest: typename(<RecordMemberTest>)
test/lang.member.ci:53: recordMemberTest: RecordMemberTest({
	member: int32(6),
	constant: int32(7),
	memberInit: int32(8),
	constantInit: int32(9),
	memberRec: Inner({
		member: int32(61),
		constant: int32(62)
	}),
	constantRec: Inner({
		member: int32(71),
		constant: int32(72)
	})
})
test/lang.method.ci:6: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod @03b1d0>)
test/lang.method.ci:12: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod @03b1e8>)
test/lang.method.ci:26: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod @03b1e0>)
test/lang.method.ci:31: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod @03b1e8>)
test/lang.method.ci:40: RecordMethodTest.print: function(<RecordMethodTest.print @03b1f0>)
test/lang.method.ci:44: RecordMethodTest.printStatic: function(<RecordMethodTest.printStatic @03b218>)
test/lang.method.ci:3: RecordMethodTest: typename(<RecordMethodTest>)
test/lang.method.ci:49: globalFunction: function(<globalFunction @03b240>)
test/lang.method.ci:53: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<RecordMethodTest.staticMethod @03b1d0>),
	delegateMethod: function(<globalFunction @03b240>),
	virtualMethod: function(<RecordMethodTest.virtualMethod @03b1e0>),
	print: function(<RecordMethodTest.print @03b1f0>)
})
test/lang.method.ci:59: customPrint: function(<customPrint @03b248>)
test/lang.method.ci:63: recordMethodTestCustomPrint: RecordMethodTest({
	abstractMethod: function(<globalFunction @03b240>),
	delegateMethod: function(<RecordMethodTest.forwardMethod @03b1e8>),
	virtualMethod: function(<RecordMethodTest.virtualMethod @03b1e0>),
	print: function(<customPrint @03b248>)
})
test/lang.method.ci:75: print: function(<print @03b270>)
test/lang.method.ci:79: printStatic: function(<printStatic @03b298>)
test/lang.recUnion.ci:2: rgbF32: typename(<rgbF32>)
test/lang.recUnion.ci:9: rgbU8: typename(<rgbU8>)
test/lang.recUnion.ci:16: color: typename(<color>)
test/lang.recUnion.ci:22: Color: typename(<Color>)
test/lang.recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
test/lang.recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
test/lang.recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
test/lang.recUnion.ci:30: cyan: color({
	col: uint32(65535),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(255),
		r: uint8(0)
	})
})
test/lang.recUnion.ci:31: blue: color({
	col: uint32(255),
	rgb: rgbU8({
		b: uint8(255),
		g: uint8(0),
		r: uint8(0)
	})
})
test/lang.recPacking.ci:2: record_pack0: typename(<record_pack0>)
test/lang.recPacking.ci:12: record_pack1: typename(<record_pack1>)
test/lang.recPacking.ci:22: record_pack2: typename(<record_pack2>)
test/lang.recPacking.ci:32: record_pack4: typename(<record_pack4>)
test/lang.recPacking.ci:42: record_pack8: typename(<record_pack8>)
test/lang.recPacking.ci:52: record_packDef: typename(<record_packDef>)
test/lang.useOperator.ci:5: shift: int32(2)
test/lang.useOperator.ci:7: boolA: bool(1)
test/lang.useOperator.ci:8: boolB: bool(1)
test/lang.useOperator.ci:17: boolAnd: bool(1)
test/lang.useOperator.ci:18: boolIor: bool(1)
test/lang.useOperator.ci:19: boolXor: bool(0)
test/lang.useOperator.ci:22: boolNot: bool(0)
test/lang.useOperator.ci:23: boolCeq: bool(1)
test/lang.useOperator.ci:24: boolCne: bool(0)
test/lang.useOperator.ci:25: boolClt: bool(0)
test/lang.useOperator.ci:26: boolCle: bool(1)
test/lang.useOperator.ci:27: boolCgt: bool(0)
test/lang.useOperator.ci:28: boolCge: bool(1)
test/lang.useOperator.ci:30: chrA: char('a')
test/lang.useOperator.ci:31: chrB: char('b')
test/lang.useOperator.ci:32: chrPls: char('b')
test/lang.useOperator.ci:33: chrNeg: char('')
test/lang.useOperator.ci:34: chrCmt: char('')
test/lang.useOperator.ci:35: chrAdd: char('')
test/lang.useOperator.ci:36: chrSub: char('')
test/lang.useOperator.ci:37: chrMul: char('\"')
test/lang.useOperator.ci:38: chrDiv: char('')
test/lang.useOperator.ci:39: chrMod: char('a')
test/lang.useOperator.ci:40: chrAnd: char('`')
test/lang.useOperator.ci:41: chrIor: char('c')
test/lang.useOperator.ci:42: chrXor: char('')
test/lang.useOperator.ci:43: chrShl: char('')
test/lang.useOperator.ci:44: chrShr: char('')
test/lang.useOperator.ci:45: chrNot: bool(0)
test/lang.useOperator.ci:46: chrCeq: bool(0)
test/lang.useOperator.ci:47: chrCne: bool(1)
test/lang.useOperator.ci:48: chrClt: bool(1)
test/lang.useOperator.ci:49: chrCle: bool(1)
test/lang.useOperator.ci:50: chrCgt: bool(0)
test/lang.useOperator.ci:51: chrCge: bool(0)
test/lang.useOperator.ci:53: i8A: int8(96)
test/lang.useOperator.ci:54: i8B: int8(42)
test/lang.useOperator.ci:55: i8Pls: int8(42)
test/lang.useOperator.ci:56: i8Neg: int8(-42)
test/lang.useOperator.ci:57: i8Cmt: int8(-43)
test/lang.useOperator.ci:58: i8Add: int8(-118)
test/lang.useOperator.ci:59: i8Sub: int8(54)
test/lang.useOperator.ci:60: i8Mul: int8(-64)
test/lang.useOperator.ci:61: i8Div: int8(2)
test/lang.useOperator.ci:62: i8Mod: int8(12)
test/lang.useOperator.ci:63: i8And: int8(32)
test/lang.useOperator.ci:64: i8Ior: int8(106)
test/lang.useOperator.ci:65: i8Xor: int8(74)
test/lang.useOperator.ci:66: i8Shl: int8(-128)
test/lang.useOperator.ci:67: i8Shr: int8(24)
test/lang.useOperator.ci:68: i8Not: bool(0)
test/lang.useOperator.ci:69: i8Ceq: bool(0)
test/lang.useOperator.ci:70: i8Cne: bool(1)
test/lang.useOperator.ci:71: i8Clt: bool(0)
test/lang.useOperator.ci:72: i8Cle: bool(0)
test/lang.useOperator.ci:73: i8Cgt: bool(1)
test/lang.useOperator.ci:74: i8Cge: bool(1)
test/lang.useOperator.ci:76: u8A: uint8(96)
test/lang.useOperator.ci:77: u8B: uint8(42)
test/lang.useOperator.ci:78: u8Pls: uint8(42)
test/lang.useOperator.ci:79: u8Neg: uint8(214)
test/lang.useOperator.ci:80: u8Cmt: uint8(213)
test/lang.useOperator.ci:81: u8Add: uint8(138)
test/lang.useOperator.ci:82: u8Sub: uint8(54)
test/lang.useOperator.ci:83: u8Mul: uint8(192)
test/lang.useOperator.ci:84: u8Div: uint8(2)
test/lang.useOperator.ci:85: u8Mod: uint8(12)
test/lang.useOperator.ci:86: u8And: uint8(32)
test/lang.useOperator.ci:87: u8Ior: uint8(106)
test/lang.useOperator.ci:88: u8Xor: uint8(74)
test/lang.useOperator.ci:89: u8Shl: uint8(128)
test/lang.useOperator.ci:90: u8Shr: uint8(24)
test/lang.useOperator.ci:91: u8Not: bool(0)
test/lang.useOperator.ci:92: u8Ceq: bool(0)
test/lang.useOperator.ci:93: u8Cne: bool(1)
test/lang.useOperator.ci:94: u8Clt: bool(0)
test/lang.useOperator.ci:95: u8Cle: bool(0)
test/lang.useOperator.ci:96: u8Cgt: bool(1)
test/lang.useOperator.ci:97: u8Cge: bool(1)
test/lang.useOperator.ci:99: i16A: int16(96)
test/lang.useOperator.ci:100: i16B: int16(42)
test/lang.useOperator.ci:101: i16Pls: int16(42)
test/lang.useOperator.ci:102: i16Neg: int16(-42)
test/lang.useOperator.ci:103: i16Cmt: int16(-43)
test/lang.useOperator.ci:104: i16Add: int16(138)
test/lang.useOperator.ci:105: i16Sub: int16(54)
test/lang.useOperator.ci:106: i16Mul: int16(4032)
test/lang.useOperator.ci:107: i16Div: int16(2)
test/lang.useOperator.ci:108: i16Mod: int16(12)
test/lang.useOperator.ci:109: i16And: int16(32)
test/lang.useOperator.ci:110: i16Ior: int16(106)
test/lang.useOperator.ci:111: i16Xor: int16(74)
test/lang.useOperator.ci:112: i16Shl: int16(384)
test/lang.useOperator.ci:113: i16Shr: int16(24)
test/lang.useOperator.ci:114: i16Not: bool(0)
test/lang.useOperator.ci:115: i16Ceq: bool(0)
test/lang.useOperator.ci:116: i16Cne: bool(1)
test/lang.useOperator.ci:117: i16Clt: bool(0)
test/lang.useOperator.ci:118: i16Cle: bool(0)
test/lang.useOperator.ci:119: i16Cgt: bool(1)
test/lang.useOperator.ci:120: i16Cge: bool(1)
test/lang.useOperator.ci:122: u16A: uint16(96)
test/lang.useOperator.ci:123: u16B: uint16(42)
test/lang.useOperator.ci:124: u16Pls: uint16(42)
test/lang.useOperator.ci:125: u16Neg: uint16(65494)
test/lang.useOperator.ci:126: u16Cmt: uint16(65493)
test/lang.useOperator.ci:127: u16Add: uint16(138)
test/lang.useOperator.ci:128: u16Sub: uint16(54)
test/lang.useOperator.ci:129: u16Mul: uint16(4032)
test/lang.useOperator.ci:130: u16Div: uint16(2)
test/lang.useOperator.ci:131: u16Mod: uint16(12)
test/lang.useOperator.ci:132: u16And: uint16(32)
test/lang.useOperator.ci:133: u16Ior: uint16(106)
test/lang.useOperator.ci:134: u16Xor: uint16(74)
test/lang.useOperator.ci:135: u16Shl: uint16(384)
test/lang.useOperator.ci:136: u16Shr: uint16(24)
test/lang.useOperator.ci:137: u16Not: bool(0)
test/lang.useOperator.ci:138: u16Ceq: bool(0)
test/lang.useOperator.ci:139: u16Cne: bool(1)
test/lang.useOperator.ci:140: u16Clt: bool(0)
test/lang.useOperator.ci:141: u16Cle: bool(0)
test/lang.useOperator.ci:142: u16Cgt: bool(1)
test/lang.useOperator.ci:143: u16Cge: bool(1)
test/lang.useOperator.ci:145: i32A: int32(96)
test/lang.useOperator.ci:146: i32B: int32(42)
test/lang.useOperator.ci:147: i32Pls: int32(42)
test/lang.useOperator.ci:148: i32Neg: int32(-42)
test/lang.useOperator.ci:149: i32Cmt: int32(-43)
test/lang.useOperator.ci:150: i32Add: int32(138)
test/lang.useOperator.ci:151: i32Sub: int32(54)
test/lang.useOperator.ci:152: i32Mul: int32(4032)
test/lang.useOperator.ci:153: i32Div: int32(2)
test/lang.useOperator.ci:154: i32Mod: int32(12)
test/lang.useOperator.ci:155: i32And: int32(32)
test/lang.useOperator.ci:156: i32Ior: int32(106)
test/lang.useOperator.ci:157: i32Xor: int32(74)
test/lang.useOperator.ci:158: i32Shl: int32(384)
test/lang.useOperator.ci:159: i32Shr: int32(24)
test/lang.useOperator.ci:160: i32Not: bool(0)
test/lang.useOperator.ci:161: i32Ceq: bool(0)
test/lang.useOperator.ci:162: i32Cne: bool(1)
test/lang.useOperator.ci:163: i32Clt: bool(0)
test/lang.useOperator.ci:164: i32Cle: bool(0)
test/lang.useOperator.ci:165: i32Cgt: bool(1)
test/lang.useOperator.ci:166: i32Cge: bool(1)
test/lang.useOperator.ci:168: u32A: uint32(96)
test/lang.useOperator.ci:169: u32B: uint32(42)
test/lang.useOperator.ci:170: u32Pls: uint32(42)
test/lang.useOperator.ci:171: u32Neg: uint32(4294967254)
test/lang.useOperator.ci:172: u32Cmt: uint32(4294967253)
test/lang.useOperator.ci:173: u32Add: uint32(138)
test/lang.useOperator.ci:174: u32Sub: uint32(54)
test/lang.useOperator.ci:175: u32Mul: uint32(4032)
test/lang.useOperator.ci:176: u32Div: uint32(2)
test/lang.useOperator.ci:177: u32Mod: uint32(12)
test/lang.useOperator.ci:178: u32And: uint32(32)
test/lang.useOperator.ci:179: u32Ior: uint32(106)
test/lang.useOperator.ci:180: u32Xor: uint32(74)
test/lang.useOperator.ci:181: u32Shl: uint32(384)
test/lang.useOperator.ci:182: u32Shr: uint32(24)
test/lang.useOperator.ci:183: u32Not: bool(0)
test/lang.useOperator.ci:184: u32Ceq: bool(0)
test/lang.useOperator.ci:185: u32Cne: bool(1)
test/lang.useOperator.ci:186: u32Clt: bool(0)
test/lang.useOperator.ci:187: u32Cle: bool(0)
test/lang.useOperator.ci:188: u32Cgt: bool(1)
test/lang.useOperator.ci:189: u32Cge: bool(1)
test/lang.useOperator.ci:191: i64A: int64(96)
test/lang.useOperator.ci:192: i64B: int64(42)
test/lang.useOperator.ci:193: i64Pls: int64(42)
test/lang.useOperator.ci:194: i64Neg: int64(-42)
test/lang.useOperator.ci:195: i64Cmt: int64(-43)
test/lang.useOperator.ci:196: i64Add: int64(138)
test/lang.useOperator.ci:197: i64Sub: int64(54)
test/lang.useOperator.ci:198: i64Mul: int64(4032)
test/lang.useOperator.ci:199: i64Div: int64(2)
test/lang.useOperator.ci:200: i64Mod: int64(12)
test/lang.useOperator.ci:201: i64And: int64(32)
test/lang.useOperator.ci:202: i64Ior: int64(106)
test/lang.useOperator.ci:203: i64Xor: int64(74)
test/lang.useOperator.ci:204: i64Shl: int64(384)
test/lang.useOperator.ci:205: i64Shr: int64(24)
test/lang.useOperator.ci:206: i64Not: bool(0)
test/lang.useOperator.ci:207: i64Ceq: bool(0)
test/lang.useOperator.ci:208: i64Cne: bool(1)
test/lang.useOperator.ci:209: i64Clt: bool(0)
test/lang.useOperator.ci:210: i64Cle: bool(0)
test/lang.useOperator.ci:211: i64Cgt: bool(1)
test/lang.useOperator.ci:212: i64Cge: bool(1)
test/lang.useOperator.ci:214: u64A: uint64(96)
test/lang.useOperator.ci:215: u64B: uint64(42)
test/lang.useOperator.ci:216: u64Pls: uint64(42)
test/lang.useOperator.ci:217: u64Neg: uint64(18446744073709551574)
test/lang.useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
test/lang.useOperator.ci:219: u64Add: uint64(138)
test/lang.useOperator.ci:220: u64Sub: uint64(54)
test/lang.useOperator.ci:221: u64Mul: uint64(4032)
test/lang.useOperator.ci:222: u64Div: uint64(2)
test/lang.useOperator.ci:223: u64Mod: uint64(12)
test/lang.useOperator.ci:224: u64And: uint64(32)
test/lang.useOperator.ci:225: u64Ior: uint64(106)
test/lang.useOperator.ci:226: u64Xor: uint64(74)
test/lang.useOperator.ci:227: u64Shl: uint64(384)
test/lang.useOperator.ci:228: u64Shr: uint64(24)
test/lang.useOperator.ci:229: u64Not: bool(0)
test/lang.useOperator.ci:230: u64Ceq: bool(0)
test/lang.useOperator.ci:231: u64Cne: bool(1)
test/lang.useOperator.ci:232: u64Clt: bool(0)
test/lang.useOperator.ci:233: u64Cle: bool(0)
test/lang.useOperator.ci:234: u64Cgt: bool(1)
test/lang.useOperator.ci:235: u64Cge: bool(1)
test/lang.useOperator.ci:237: f32A: float32(96.300003)
test/lang.useOperator.ci:238: f32B: float32(42.139999)
test/lang.useOperator.ci:239: f32Pls: float32(42.139999)
test/lang.useOperator.ci:240: f32Neg: float32(-42.139999)
test/lang.useOperator.ci:242: f32Add: float32(138.440002)
test/lang.useOperator.ci:243: f32Sub: float32(54.160004)
test/lang.useOperator.ci:244: f32Mul: float32(4058.082031)
test/lang.useOperator.ci:245: f32Div: float32(2.285240)
test/lang.useOperator.ci:246: f32Mod: float32(12.020004)
test/lang.useOperator.ci:252: f32Not: bool(0)
test/lang.useOperator.ci:253: f32Ceq: bool(0)
test/lang.useOperator.ci:254: f32Cne: bool(1)
test/lang.useOperator.ci:255: f32Clt: bool(0)
test/lang.useOperator.ci:256: f32Cle: bool(0)
test/lang.useOperator.ci:257: f32Cgt: bool(1)
test/lang.useOperator.ci:258: f32Cge: bool(1)
test/lang.useOperator.ci:260: f64A: float64(96.300000)
test/lang.useOperator.ci:261: f64B: float64(42.140000)
test/lang.useOperator.ci:262: f64Pls: float64(42.140000)
test/lang.useOperator.ci:263: f64Neg: float64(-42.140000)
test/lang.useOperator.ci:265: f64Add: float64(138.440000)
test/lang.useOperator.ci:266: f64Sub: float64(54.160000)
test/lang.useOperator.ci:267: f64Mul: float64(4058.082000)
test/lang.useOperator.ci:268: f64Div: float64(2.285240)
test/lang.useOperator.ci:269: f64Mod: float64(12.020000)
test/lang.useOperator.ci:275: f64Not: bool(0)
test/lang.useOperator.ci:276: f64Ceq: bool(0)
test/lang.useOperator.ci:277: f64Cne: bool(1)
test/lang.useOperator.ci:278: f64Clt: bool(0)
test/lang.useOperator.ci:279: f64Cle: bool(0)
test/lang.useOperator.ci:280: f64Cgt: bool(1)
test/lang.useOperator.ci:281: f64Cge: bool(1)
test/lang.useOperator.ci:283: ptrA: pointer(null)
test/lang.useOperator.ci:284: ptrB: pointer(<@1ff9b8>)
test/lang.useOperator.ci:299: ptrCeq: bool(0)
test/lang.useOperator.ci:300: ptrCne: bool(1)
test/lang.statementIf.ci:26: t: int32(0)
test/lang.statementFor.ci:12: forIdx: int32(2)

---------- Memory usage:
memory[all] @000000; size: 2096872(2.0 Mb)
memory[used] @000000; size: 249601(243.8 Kb)
memory[heap] @03cf01; size: 1323005(1.3 Mb)
memory[stack] @0fff44; size: 524218(511.9 Kb)

---------- used memory:
memory[meta] @000000; size: 237896(232.3 Kb)
memory[code] @000000; size: 11385(11.1 Kb)
memory[data] @000000; size: 80(80.0 bytes)

---------- heap memory:
memory[free] @03cf18; size: 1322960(1.3 Mb)
