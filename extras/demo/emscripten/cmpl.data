// graphics library extension
inline "gfx/color.ci";

/// Create a surface with the given with, height and depth
inline gxSurf(int width, int height, int depth) = gxSurf.create(width, height, depth);

/// Create a surface by opening an image file
gxSurf gxSurf(const char fileName[*], int depth) {
	if (fileName.endsWith(".jpeg", ignCaseCmp)) {
		return gxSurf.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".jpg", ignCaseCmp)) {
		return gxSurf.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".png", ignCaseCmp)) {
		return gxSurf.openPng(fileName, depth);
	}
	if (fileName.endsWith(".bmp", ignCaseCmp)) {
		return gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}

/// Create a surface by opening an image file
inline gxSurf(const char fileName[*]) = gxSurf(fileName, 32);

/// Create a surface by opening an image file with custom width and height
gxSurf gxSurf(const char fileName[*], int width, int height, int depth, int align, double maxScale) {
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: left + right;
		fitHorizontal: top + bottom;
		fill: 0x10;
		highRes: 0x20;
	}

	double scale = 1;
	gxSurf surf = gxSurf(fileName, depth);
	gxSurf result = gxSurf(width, height, depth);

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;

	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	if (fitWidth && fitHeight) {
		double widthScale = width / double(surf.width());
		double heightScale = height / double(surf.height());
		if (align & fill) {
			scale = Math.max(widthScale, heightScale);
		} else {
			scale = Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / double(surf.width());
	}
	else if (fitHeight) {
		scale = height / double(surf.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	double tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - surf.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - surf.width() * scale);
	}

	double ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - surf.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - surf.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	result.transform(null, surf, null, align & highRes ? 1 : 0, mat.data);
	surf.destroy();
	return result;
}

/// Create a surface by opening an image file with custom width and height
inline gxSurf(const char fileName[*], int width, int height, int depth, int align) = gxSurf(fileName, width, height, depth, align, Math.inf);

/// Create a surface by opening an image file with custom width and height
inline gxSurf(const char fileName[*], int width, int height, int depth) = gxSurf(fileName, width, height, depth, -1, Math.inf);

/// Create a mesh by opening a file
gxMesh gxMesh(const char fileName[*]) {
	if (fileName.endsWith(".obj", ignCaseCmp)) {
		return gxMesh.openObj(fileName);
	}
	if (fileName.endsWith(".3ds", ignCaseCmp)) {
		return gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}

/// Create a surface by cloning another one
gxSurf gxSurf(gxSurf copy) {
	gxSurf result = gxSurf.create(copy.width(), copy.height(), copy.depth());
	result.copy(0, 0, copy, null);
	return result;
}

/// Create a surface by cloning another one using a custom aspect ratio
gxSurf gxSurf(gxSurf copy, double aspect) {
	int width = copy.width();
	if (aspect > 0) {
		width = copy.height() * aspect;
	}
	gxSurf result = gxSurf.create(width, copy.height(), copy.depth());
	result.transform(null, copy, null, 1, null);
	return result;
}

/// Set the the color of a pixel at the given position
inline set(gxSurf dst, int32 x, int32 y, argb color) = gxSurf.set(dst, x, y, uint32(color));

///@public
inline resize(gxSurf surf, const gxRect rect&, const gxSurf src, const gxRect roi&, int interpolate) = gxSurf.transform(surf, rect, src, roi, interpolate, null);

///@public
bool clip(gxSurf src, gxRect roi&) {

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < 0) {
		roi.x = 0;
	}

	if (roi.y < 0) {
		roi.y = 0;
	}

	int width = src.width();
	if (roi.w > width) {
		roi.w = width;
	}

	int height = src.height();
	if (roi.h > height) {
		roi.h = height;
	}

	roi.w -= roi.x;
	roi.h -= roi.y;

	if (roi.w <= 0) {
		return false;
	}
	if (roi.h <= 0) {
		return false;
	}
	return true;
}

/// Fill the entire surface with the given color
inline fill(gxSurf dst, uint32 col) = dst.fillRect(0, 0, 65536, 65536, col);
/// Fill the given region with the given color
inline fill(gxSurf dst, const gxRect roi&, uint32 col) = dst.fillRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
/// Fill the given region and padding with the given color
inline fill(gxSurf dst, const gxRect roi&, int pad, uint32 col) = dst.fillRect(roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, col);

///@public
inline drawRect(gxSurf dst, const gxRect roi&, uint32 col) = dst.drawRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);

/// Fill the surface by evaluating the given function for each pixel
void eval(gxSurf dst, const gxRect roi&, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	gxRect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : dst.width();
		h: roi != null ? roi.h : dst.height();
	};

	if (!dst.clip(&rect)) {
		return;
	}

	vec4f in = {
		x: 0;
		y: 0;
		z: aspect;
		w: time;
	};
	float w = dst.width();
	float h = dst.height();
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		in.y = y / h;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			in.x = x / w;
			dst.set(x, y, argb(eval(in)));
		}
	}
}

///@public
void tile(gxSurf dst, int x, int y, gxSurf src, gxRect roi&) {
	gxRect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};

	if (!src.clip(&rect)) {
		return;
	}

	if (x < 0) {
		x = -(-x % rect.w);
	}
	if (y < 0) {
		y = -(-y % rect.h);
	}
	int width = dst.width();
	int height = dst.height();
	for (int j = y; j < height; j += rect.h) {
		for (int i = x; i < width; i += rect.w) {
			dst.copy(i, j, src, rect);
		}
	}
}

/// Show the mesh in a window
void show(gxMesh mesh, int w, int h, float32 fovy) {

	struct Closure {
		int mode;
		gxSurf offs;
		gxMesh mesh;
	}

	int next(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float speed = 1. / 100;
		if (action == Gui.FINGER_MOTION) {
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
			else if (button == 'l') {
				closure.mode ^= gxMesh.useLights;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				closure.mode ^= gxMesh.useTexture;
			}
			else if (button == '/') {
				closure.mode = next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
			}
			else if (button == '\t') {
				closure.mode = next(closure.mode, gxMesh.drawMode);
			}
			else if (button == '\r') {
				vec4f eye = {x: 0, y: 0, z: 2, w: 1};
				vec4f at = {x: 0, y: 0, z: 0, w: 1};
				vec4f up = {x: 0, y: 1, z: 0, w: 1};
				camera.lookAt(eye.data, at.data, up.data);
			}
		}
		else if (action == Gui.MOUSE_PRESS) {
			ox = ex;
			oy = ey;
			return 0;
		}
		else if (action == Gui.MOUSE_MOTION) {
			float32 dir[3];
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit
				float32 orig[3];
				orig[0] = 0;
				orig[1] = 0;
				orig[2] = 0;

				camera.readUp(&dir);
				camera.rotate(dir, orig, dx * speed);
				camera.readRight(&dir);
				camera.rotate(dir, orig, dy * speed);
			}
			else if (button == 2) {
				// rotate
				camera.readUp(&dir);
				camera.rotate(dir, null, -dx * speed);
				camera.readRight(&dir);
				camera.rotate(dir, null, -dy * speed);
			}
			else if (button == 3) {
				// move
				camera.readForward(&dir);
				camera.move(dir, dy * speed);
			}
			else if (button == 4) {
				// pan
				camera.readRight(&dir);
				camera.move(dir, -dx * speed);
				camera.readUp(&dir);
				camera.move(dir, dy * speed);
			}
			ox = ex;
			oy = ey;
		}

		int rendered = closure.offs.drawMesh(closure.mesh, closure.mode);

		char text[256];
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, closure.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, closure.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		Gui.setTitle(text);
		return 0;
	}

	Closure closure = {
		mode: gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill;
		offs: gxSurf.create3d(w, h);
		mesh: mesh;
	};
	camera.projection(fovy, w / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy();
}

/// Show the surface in a window
inline show(gxSurf surf) = Gui.showWindow(surf, null, null);

/// Show the surface in a window
void show(gxSurf surf, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Gui.showWindow(surf, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Gui.showWindow(surf, onEvent, delegate);
}

/// Show the surfaces in a window clicking on the window toggles the shown surface
void showDiff(gxSurf image1, gxSurf image2) {
	struct Closure {
		gxSurf offs;
		gxSurf image1;
		gxSurf image2;
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.MOUSE_PRESS) {
			closure.offs.copy(0, 0, closure.image2, null);
			return 0;
		}
		if (action == Gui.MOUSE_RELEASE) {
			closure.offs.copy(0, 0, closure.image1, null);
			return 0;
		}
		return 0;
	}

	Closure closure = {
		offs: gxSurf(image1);
		image1: image1;
		image2: image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Closure {
		bool lerp = true;
		const gxSurf offs;
		const gxSurf thumb;
		const float32 aspect;
		const vec4f eval(vec4f in);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return 0;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.KEY_RELEASE) {
			if (button == ' ') {
				float32 time = (System.millis() - start) / 1000f;
				closure.offs.eval(null, closure.aspect, time, closure.eval);
				return 0;
			}
			if (button == '\t') {
				closure.lerp = !closure.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				closure.offs.saveBmp("out/offs.bmp", 0);
				closure.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		closure.thumb.eval(null, closure.aspect, time, closure.eval);
		closure.offs.resize(null, closure.thumb, null, closure.lerp ? 1 : 0);

		// do not block for any input
		return 1;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		gxSurf surf = gxSurf(width, height, 32);
		surf.eval(null, aspect, 0f, eval);
		surf.show(null);
		surf.destroy();
		return;
	}

	Closure closure = {
		offs: gxSurf(width, height, 32);
		thumb: gxSurf(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy();
	closure.offs.destroy();
}
// micro ui

struct View: object {
	const char text[*];
	const int height = 0;
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onClick(View this) = null; /*TODO: {
		//trace("onClick", this);
		return true;
	}// */
}

struct Button: View {
	/* FIXME: do the override, use this method as default initializer
	// TODO: override or overload: bool onClick(Button this) { ??? }
	bool onClick(View this) {
		View.onClick(this);   // call super
		trace("onClick", this);
		// FIXME: enable lookup: value.value = 0;
		return this.enabled;
	}// */
}

struct Switch: View {
	const char on[*] = "on";
	const char off[*] = "off";

	bool checked = false;
}

struct Slider: View {
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 1;
}

struct ColorPicker: View {
	const float lum = 1f;
	argb value = argb(0);
	/*bool onClick(ColorPicker this) {
		trace("onClick", this);
		return true;
	}*/
}

struct Histogram: View {
	const gxSurf image;
	const bool lines = false;
	uint32 data[256] = null;   // FIXME: this should be not possible
}

struct MouseState {
	int32 clicks;   // click count
	int64 time;     // old clock
	int32 btn;      // old button
	int32 x;        // old x coord
	int32 y;        // old y coord
}

struct Layout {
	gxSurf offs;
	gxSurf font;
	int border = 3;
	int padding = 5;
	MouseState mouse;
	gxRect rect;

	int items = 0;
	View views[200] = null;
	gxRect rects[200] = null;
	int reset[200] = null;
	int selectedIndex = -1;
	int pressedIndex = -1;

	// Style
	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;
}

int val(Slider slider&) {
	if (slider.value < slider.minimum) {
		slider.value = slider.minimum;
	}
	if (slider.value > slider.maximum) {
		slider.value = slider.maximum;
	}
	return slider.value;
}

double valFlt(Slider slider&) {
	return slider.val() / double(slider.divisor);
}

void measure(Layout layout&) {
	int bottom = layout.rect.y;
	int fontHeight = layout.font.height() / 256;

	// measure
	for (int i = 0; i < layout.items; i += 1) {
		gxRect rect& = layout.rects[i];
		rect.x = layout.rect.x;
		rect.y = bottom;
		rect.w = layout.rect.w;
		View view = layout.views[i];
		if (view.height != 0) {
			rect.h = view.height;
		} else {
			rect.h = fontHeight;
		}
		if (ColorPicker item = view.as(ColorPicker)) {
			if (view.height == 0) {
				rect.h = 128;
			}
		}
		else if (Histogram item = view.as(Histogram)) {
			if (view.height == 0) {
				rect.h = 64;
			}
		}
		else if (Slider item = view.as(Slider)) {
			rect.h += 2 * layout.padding;
		}
		else if (Switch item = view.as(Switch)) {
			rect.h += 2 * layout.padding;
		}
		else if (Button item = view.as(Button)) {
			rect.h += 2 * layout.padding;
		}
		else {
			abort("item is not a known ui element", view);
		}
		bottom += rect.h;
	}
	layout.rect.h = bottom - layout.rect.y;
}
void draw(Layout layout&) {
	static const FormatFlags flagsInt = { padLen: 4 };
	static const FormatFlags flagsFlt = { padLen: 4, precision: 2 };

	// draw background
	if (layout.backgroundColor != -1) {
		int b = layout.border;
		const gxRect r& = layout.rect;
		layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.backgroundColor);
	}

	// draw items
	for (int i = 0; i < layout.items; i += 1) {
		int pos = 0;
		char value[256] = {};
		View view = layout.views[i];
		gxRect rect& = layout.rects[i];
		value[0] = 0;
		if (Slider item = view.as(Slider)) {
			if (item.divisor != 1) {
				pos = value.append(pos, item.valFlt(), flagsFlt);
			} else {
				pos = value.append(pos, item.val(), flagsInt);
			}
		}
		else if (Switch item = view.as(Switch)) {
			if (item.checked) {
				pos = value.append(pos, item.on);
			} else {
				pos = value.append(pos, item.off);
			}
		}
		else if (Button item = view.as(Button)) {
		}
		else {
			//abort("item is not a known ui element", view);
		}
		if (i == layout.selectedIndex) {
			layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.focusedColor);
		}

		if (ColorPicker item = view.as(ColorPicker)) {
			for (int y = 0; y < rect.h; y += 1) {
				for (int x = 0; x < rect.w; x += 1) {
					float px = float(x) / rect.w;
					float py = float(y) / rect.h;
					argb color = hsv2rgb(px, 1 - py, item.lum);
					layout.offs.set(x + rect.x, y + rect.y, color);
				}
			}
		}
		else if (Histogram item = view.as(Histogram)) {
			if (item.lines) {
				offs.drawLut(rect, null, item.data);
			} else {
				offs.drawLut(rect, item.data, null);
			}
		}

		int p = layout.padding;
		gxRect valueRect = rect;
		layout.font.clipText(&valueRect, value);
		if (valueRect.w > layout.rect.w - 2 * p) {
			valueRect.w = layout.rect.w - 2 * p;
		}
		if (view.text != null) {
			gxRect textRect = rect;
			textRect.x += p;
			textRect.y += p;
			textRect.w -= valueRect.w + 3 * p;
			layout.offs.drawText(textRect, layout.font, view.text, layout.textColor);
		}

		valueRect.x += rect.w - valueRect.w - p;
		valueRect.y += p;
		layout.offs.drawText(valueRect, layout.font, value, layout.valueColor);
	}
}

Layout Layout(gxSurf offs, int x, int y, gxSurf font, View items...) {
	Layout layout = {
		offs: offs;
		font: font;
		mouse: {};
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
	};

	for (int i = 0; i < layout.views.length; i += 1) {
		layout.views[i] = null;
	}

	for (int i = 0; i < items.length; i += 1) {
		if (Slider slider = items[i].as(Slider)) {
			layout.reset[i] = slider.value;
		}
		layout.views[i] = items[i];
	}
	layout.items = items.length;

	if (y < 0) {
		layout.measure();
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline selected(const Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.views[layout.selectedIndex]);
inline selected(const Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.views[layout.selectedIndex].as(type);
inline isActiveSelected(const Layout layout&) = layout.pressedIndex < 0 ? true : layout.pressedIndex == layout.selectedIndex;
bool isSelected(const Layout layout&, View items...) {
	View selected = layout.selected();
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == selected) {
			return true;
		}
	}
	return false;
}

// FIXME: dispatch click event using inheritance and override
bool onClick(View this) {
	if (this.onClick == null) {
		return true;
	}
	if (ColorPicker item = this.as(ColorPicker)) {
		return item.onClick(item);
	}
	if (Histogram item = this.as(Histogram)) {
		return item.onClick(item);
	}
	if (Slider item = this.as(Slider)) {
		return item.onClick(item);
	}
	if (Switch item = this.as(Switch)) {
		return item.onClick(item);
	}
	if (Button item = this.as(Button)) {
		return item.onClick(item);
	}
	abort("invalid view detected", this);
	return this.onClick();
}

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
static int click(MouseState old&, int btn, int x, int y) {
	if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
		// reset values
		old.time = System.millis();
		old.btn = btn;
		old.clicks = 1;
		old.x = x;
		old.y = y;
		return 0;
	}
	if (btn == 0) {
		// release button
		// old.time = keep value?;
		// old.btn = keep value?;
		// old.cnt = keep value?;
		return old.clicks;
	}

	int64 now = System.millis();
	if ((now - old.time) / 1000. > .5) {
		// reset counter
		old.clicks = 0;
	}
	old.time = now;
	old.btn = btn;
	old.clicks += 1;
	return old.clicks;
}

bool test(const gxRect rect&, int x, int y) {
	if (x < rect.x || x >= rect.x + rect.w) {
		return false;
	}
	if (y < rect.y || y >= rect.y + rect.h) {
		return false;
	}
	return true;
}

bool select(Layout layout&, int index) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");
	View view = layout.views[index];
	assert(view != null, "selecting null");
	if (!view.enabled) {
		return false;
	}
	if (!view.selectable) {
		return false;
	}
	layout.selectedIndex = index;
	return true;
}
bool select(Layout layout&, bool prev) {
	layout.pressedIndex = -1;
	int selectedIndex = layout.selectedIndex;
	for (int i = 1; i < layout.items; i += 1) {
		int index = selectedIndex + (prev ? -i : i);
		if (index >= layout.items) {
			index -= layout.items;
		}
		else if (index < 0) {
			index += layout.items;
		}
		if (layout.select(index)) {
			return true;
		}
	}
	return false;
}

inline reset = 1 << 31;
inline activeIndex(const Layout layout&) = layout.pressedIndex != -1 ? layout.pressedIndex : layout.selectedIndex;
bool update(Layout layout&, int index, int value) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");
	View view = layout.views[index];
	assert(view != null, "selecting null");

	if (ColorPicker picker = selectedItem.as(ColorPicker)) {
		gxRect rect& = layout.rects[index];
		int x = layout.mouse.x;
		int y = layout.mouse.y;
		if (rect.test(x, y)) {
			float px = float(x - rect.x) / rect.w;
			float py = float(y - rect.y) / rect.h;
			picker.value = hsv2rgb(px, 1 - py, picker.lum);
			layout.focusedColor = uint32(picker.value);
		}
		return true;
	}
	if (Slider item = view.as(Slider)) {
		if (value == reset) {
			item.value = layout.reset[index];
		} else {
			item.value += value;
		}
		return true;
	}
	if (Switch item = view.as(Switch)) {
		debug("update Switch");
		if (value != reset) {
			item.checked = !item.checked;
		}
		return true;
	}
	return true;
}

bool click(Layout layout&, int x, int y) {
	if (!layout.rect.test(x, y)) {
		return false;
	}
	for (int i = 0; i < layout.items; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}
		layout.pressedIndex = i;
		if (layout.mouse.clicks > 1) {
			layout.update(i, reset);
		} else {
			layout.update(i, 0);
		}
		if (!layout.select(i)) {
			return !false;
		}
	}
	// click is outside any control
	return !false;
}

	bool isCtrl = (y & Gui.KEY_MASK_CONTROL) != 0;
	bool isShift = (y & Gui.KEY_MASK_SHIFT) != 0;

	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.select(false);
		layout.measure();
		return true;
	}

	if (action == Gui.FINGER_MOTION) {
		action = Gui.MOUSE_MOTION;
	}
	if (action == Gui.KEY_PRESS) {
		if (button == ' ' || button == 8) {
			if (isShift) {
				for (int i = 0; i < layout.items; i += 1) {
					layout.update(i, reset);
				}
				return true;
			}
			return layout.update(layout.activeIndex(), reset);
		}
		if (button == '-' || button == '_') {	// down
			int delta = isShift ? 1 : 10;
			return layout.update(layout.activeIndex(), -delta);
		}
		if (button == '+' || button == '=') {	// up
			int delta = isShift ? 1 : 10;
			return layout.update(layout.activeIndex(), +delta);
		}
		if (button == '\t') {
			return layout.select(isShift);
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		layout.mouse.click(button, x, y);
		if (button == 1) {
			if (layout.click(x, y)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_RELEASE) {
		layout.mouse.click(0, x, y);
//		int index = layout.pressedIndex;
//		layout.pressedIndex = -1;
//		if (index == -1) {
//			index = layout.selectedIndex;
//		}
//		if (index < 0) {
//			return false;
//		}
//		View selectedItem = layout.views[index];
//		if (!selectedItem.enabled) {
//			return false;
//		}
//		if (ColorPicker picker = selectedItem.as(ColorPicker)) {
//			gxRect rect& = layout.rects[index];
//			if (rect.test(x, y)) {
//				float px = float(x - rect.x) / rect.w;
//				float py = float(y - rect.y) / rect.h;
//				picker.value = hsv2rgb(px, 1 - py, picker.lum);
//			}
//			return true;
//		}
	}
	else if (action == Gui.MOUSE_MOTION) {
		int ox = layout.mouse.x;
		int oy = layout.mouse.y;
		layout.mouse.click(-1, x, y);
		if (button == 1) {
			if (layout.update(layout.activeIndex(), oy - y)) {
				return true;
			}
			/*int index = layout.activeIndex();
			if (index < 0) {
				return false;
			}
			View selectedItem = layout.views[index];
			if (!selectedItem.enabled) {
				return false;
			}
			if (ColorPicker picker = selectedItem.as(ColorPicker)) {
				gxRect rect& = layout.rects[index];
				if (rect.test(x, y)) {
					float px = float(x - rect.x) / rect.w;
					float py = float(y - rect.y) / rect.h;
					picker.value = hsv2rgb(px, 1 - py, picker.lum);
					layout.focusedColor = uint32(picker.value);
				}
				return true;
			}
			if (Histogram item = selectedItem.as(Histogram)) {
				gxRect rect& = layout.rects[index];
				int min = ox < x ? ox : x;
				int max = ox > x ? ox : x;
				for (int i = min; i < max; i += 1) {
					int idx = i - rect.x;
					if (idx >= 0 && idx < 256) {
						int32 val = 255 * (rect.h - (y - rect.y)) / rect.h;
						item.data[idx] = uint32(argb(idx, val, val, val));
					}
				}
				return true;
			}
			if (Slider slider = selectedItem.as(Slider)) {
				slider.value += oy - y;
				return true;
			}*/
		}
	}
	return false;
}
// micro ui

struct View: object {
	const char text[*];
	const int height = 0;
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onClick(View this) = null; /*TODO: {
		//trace("onClick", this);
		return true;
	}// */
}

struct Button: View {
	/* FIXME: do the override, use this method as default initializer
	// TODO: override or overload: bool onClick(Button this) { ??? }
	bool onClick(View this) {
		View.onClick(this);   // call super
		trace("onClick", this);
		// FIXME: enable lookup: value.value = 0;
		return this.enabled;
	}// */
}

struct Switch: View {
	const char on[*] = "on";
	const char off[*] = "off";

	bool checked = false;
}

struct Slider: View {
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 1;
}

struct ColorPicker: View {
	const float lum = 1f;
	argb value = argb(0);
	void onUpdate(ColorPicker this) = null;/* {
		trace("onClick", this);
	}// */
}

struct Histogram: View {
	const gxSurf image;
	const bool lines = false;
	uint32 data[256] = null;   // FIXME: this should be not possible
}

struct MouseState {
	int32 clicks;   // click count
	int64 time;     // old clock
	int32 btn;      // old button
	int32 x;        // old x coord
	int32 y;        // old y coord
}

struct Layout {
	gxSurf offs;
	gxSurf font;
	int border = 3;
	int padding = 5;
	MouseState mouse;
	gxRect rect;
	bool visible = true;

	int items = 0;
	View views[200] = null;
	gxRect rects[200] = null;
	int reset[200] = null;
	int selectedIndex = -1;
	int pressedIndex = -1;

	// Style
	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;
}

int val(Slider slider&) {
	if (slider.value < slider.minimum) {
		slider.value = slider.minimum;
	}
	if (slider.value > slider.maximum) {
		slider.value = slider.maximum;
	}
	return slider.value;
}

double valFlt(Slider slider&) {
	return slider.val() / double(slider.divisor);
}

void measure(Layout layout&) {
	int bottom = layout.rect.y;
	int fontHeight = layout.font.height() / 256;

	// measure
	for (int i = 0; i < layout.items; i += 1) {
		gxRect rect& = layout.rects[i];
		rect.x = layout.rect.x;
		rect.y = bottom;
		rect.w = layout.rect.w;
		View view = layout.views[i];
		if (view.height != 0) {
			rect.h = view.height;
		} else {
			rect.h = fontHeight;
		}
		if (ColorPicker item = view.as(ColorPicker)) {
			if (view.height == 0) {
				rect.h = 128;
			}
		}
		else if (Histogram item = view.as(Histogram)) {
			if (view.height == 0) {
				rect.h = 64;
			}
		}
		else if (Slider item = view.as(Slider)) {
			rect.h += 2 * layout.padding;
		}
		else if (Switch item = view.as(Switch)) {
			rect.h += 2 * layout.padding;
		}
		else if (Button item = view.as(Button)) {
			rect.h += 2 * layout.padding;
		}
		else {
			abort("item is not a known ui element", view);
		}
		bottom += rect.h;
	}
	layout.rect.h = bottom - layout.rect.y;
}
void draw(Layout layout&) {
	static const FormatFlags flagsInt = { padLen: 4 };
	static const FormatFlags flagsFlt = { padLen: 4, precision: 2 };

	if (!layout.visible) {
		return;
	}
	// draw background
	if (layout.backgroundColor != -1) {
		int b = layout.border;
		const gxRect r& = layout.rect;
		layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.backgroundColor);
	}

	// draw items
	for (int i = 0; i < layout.items; i += 1) {
		int pos = 0;
		char value[256] = {};
		View view = layout.views[i];
		gxRect rect& = layout.rects[i];
		value[0] = 0;
		if (Slider item = view.as(Slider)) {
			if (item.divisor != 1) {
				pos = value.append(pos, item.valFlt(), flagsFlt);
			} else {
				pos = value.append(pos, item.val(), flagsInt);
			}
		}
		else if (Switch item = view.as(Switch)) {
			if (item.checked) {
				pos = value.append(pos, item.on);
			} else {
				pos = value.append(pos, item.off);
			}
		}
		else if (Button item = view.as(Button)) {
		}
		else {
			//abort("item is not a known ui element", view);
		}
		if (i == layout.selectedIndex) {
			layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.focusedColor);
		}

		if (ColorPicker item = view.as(ColorPicker)) {
			for (int y = 0; y < rect.h; y += 1) {
				for (int x = 0; x < rect.w; x += 1) {
					float px = float(x) / rect.w;
					float py = float(y) / rect.h;
					argb color = hsv2rgb(px, 1 - py, item.lum);
					layout.offs.set(x + rect.x, y + rect.y, color);
				}
			}
		}
		else if (Histogram item = view.as(Histogram)) {
			if (item.lines) {
				offs.drawLut(rect, null, item.data);
			} else {
				offs.drawLut(rect, item.data, null);
			}
		}

		int p = layout.padding;
		gxRect valueRect = rect;
		layout.font.clipText(&valueRect, value);
		if (valueRect.w > layout.rect.w - 2 * p) {
			valueRect.w = layout.rect.w - 2 * p;
		}
		if (view.text != null) {
			gxRect textRect = rect;
			textRect.x += p;
			textRect.y += p;
			textRect.w -= valueRect.w + 3 * p;
			layout.offs.drawText(textRect, layout.font, view.text, layout.textColor);
		}

		valueRect.x += rect.w - valueRect.w - p;
		valueRect.y += p;
		layout.offs.drawText(valueRect, layout.font, value, layout.valueColor);
	}
}

Layout Layout(gxSurf offs, int x, int y, gxSurf font, View items...) {
	Layout layout = {
		offs: offs;
		font: font;
		mouse: {};
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
	};

	for (int i = 0; i < layout.views.length; i += 1) {
		layout.views[i] = null;
	}

	for (int i = 0; i < items.length; i += 1) {
		if (Slider slider = items[i].as(Slider)) {
			layout.reset[i] = slider.value;
		}
		layout.views[i] = items[i];
	}
	layout.items = items.length;

	if (y < 0) {
		layout.measure();
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline selected(const Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.views[layout.selectedIndex]);
inline selected(const Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.views[layout.selectedIndex].as(type);

inline activeIndex(const Layout layout&) = layout.pressedIndex != -1 ? layout.pressedIndex : layout.selectedIndex;

bool isSelected(const Layout layout&, View items...) {
	View selected = layout.selected();
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == selected) {
			return true;
		}
	}
	return false;
}
bool isActive(const Layout layout&, View views...) {
	int activeIndex = layout.pressedIndex != -1 ? layout.pressedIndex : layout.selectedIndex;
	if (activeIndex < 0) {
		return false;
	}
	View view = layout.views[activeIndex];
	for (int i = 0; i < views.length; i += 1) {
		if (views[i] == view) {
			return true;
		}
	}
	return false;

}

bool setSelected(Layout layout&, View view) {
	for (int i = 0; i < layout.items; i += 1) {
		if (layout.views[i] == view) {
			layout.selectedIndex = i;
			return true;
		}
	}
	return false;
}

// FIXME: dispatch click event using inheritance and override
bool onClick(View this) {
	if (this.onClick == null) {
		return true;
	}
	if (ColorPicker item = this.as(ColorPicker)) {
		return item.onClick(item);
	}
	if (Histogram item = this.as(Histogram)) {
		return item.onClick(item);
	}
	if (Slider item = this.as(Slider)) {
		return item.onClick(item);
	}
	if (Switch item = this.as(Switch)) {
		return item.onClick(item);
	}
	if (Button item = this.as(Button)) {
		return item.onClick(item);
	}
	abort("invalid view detected", this);
	return this.onClick();
}

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
static int click(MouseState old&, int btn, int x, int y) {
	if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
		// reset values
		old.time = System.millis();
		old.btn = btn;
		old.clicks = 1;
		old.x = x;
		old.y = y;
		return 0;
	}
	if (btn == 0) {
		// release button
		// old.time = keep value?;
		// old.btn = keep value?;
		// old.cnt = keep value?;
		return old.clicks;
	}

	int64 now = System.millis();
	if ((now - old.time) / 1000. > .5) {
		// reset counter
		old.clicks = 0;
	}
	old.time = now;
	old.btn = btn;
	old.clicks += 1;
	return old.clicks;
}

bool test(const gxRect rect&, int x, int y) {
	if (x < rect.x || x >= rect.x + rect.w) {
		return false;
	}
	if (y < rect.y || y >= rect.y + rect.h) {
		return false;
	}
	return true;
}

bool select(Layout layout&, int index) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");

	View view = layout.views[index];
	if (!view.enabled) {
		return false;
	}
	if (!view.selectable) {
		return false;
	}
	layout.selectedIndex = index;
	return true;
}
bool select(Layout layout&, bool prev) {
	layout.pressedIndex = -1;
	int selectedIndex = layout.selectedIndex;
	for (int i = 1; i < layout.items; i += 1) {
		int index = selectedIndex + (prev ? -i : i);
		if (index >= layout.items) {
			index -= layout.items;
		}
		else if (index < 0) {
			index += layout.items;
		}
		if (layout.select(index)) {
			return true;
		}
	}
	return false;
}

static void reset(Layout layout&, int index) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");

	View view = layout.views[index];
	if (!view.enabled) {
		return;
	}
	if (Slider item = view.as(Slider)) {
		item.value = layout.reset[index];
	}
}
static bool update(Layout layout&, int index, int dx, int dy) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");

	// FIXME: who is y??? debug("y", y);

	View view = layout.views[index];
	if (!view.enabled) {
		return false;
	}
	if (ColorPicker item = view.as(ColorPicker)) {
		gxRect rect& = layout.rects[index];
		int x = layout.mouse.x;
		int y = layout.mouse.y;
		if (!rect.test(x, y)) {
			return false;
		}
		float px = float(x - rect.x) / rect.w;
		float py = float(y - rect.y) / rect.h;
		item.value = hsv2rgb(px, 1 - py, item.lum);
		if (item.onUpdate != null) {
			item.onUpdate();
		}
		return true;
	}
	if (Histogram item = view.as(Histogram)) {
		gxRect rect& = layout.rects[index];
		int min = layout.mouse.x;
		int max = layout.mouse.x;
		int y = layout.mouse.y;
		if (dx < 0) {
			min += dx;
		} else {
			max += dx;
		}
		for (int i = min; i < max; i += 1) {
			int idx = i - rect.x;
			if (idx >= 0 && idx < 256) {
				int32 val = 255 * (rect.h - (y - rect.y)) / rect.h;
				item.data[idx] = uint32(argb(idx, val, val, val));
			}
		}
		return true;
	}
	if (Slider item = view.as(Slider)) {
		if (dx == 0 && dy == 0) {
			return false;
		}
		item.value += dy;
		return true;
	}
	if (Switch item = view.as(Switch)) {
		if (dx != 0 || dy != 0) {
			// disable change using drag
			return false;
		}
		if (layout.selectedIndex != index) {
			// disable first click update
			if (item.selectable) {
				return false;
			}
		}
		item.checked = !item.checked;
		return true;
	}
	if (Button item = view.as(Button)) {
		if (dx != 0 || dy != 0) {
			// disable clicks using drag
			return false;
		}
		item.onClick();
		return true;
	}

	// unknown view type
	return false;
}

bool click(Layout layout&, int x, int y) {
	layout.pressedIndex = -1;
	if (!layout.rect.test(x, y)) {
		return false;
	}
	for (int i = 0; i < layout.items; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}

		View view = layout.views[i];
		if (!view.enabled) {
			return false;
		}

		bool result = false;
		layout.pressedIndex = i;
		if (layout.mouse.clicks > 1) {
			layout.reset(i);
			result = true;
		}
		if (layout.update(i, 0, 0)) {
			result = true;
		}
		if (layout.select(i)) {
			result = true;
		}
		return result;
	}
	return false;
}

	bool isCtrl = (y & Gui.KEY_MASK_CONTROL) != 0;
	bool isShift = (y & Gui.KEY_MASK_SHIFT) != 0;

	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.select(false);
		layout.measure();
		return true;
	}

	if (action == Gui.FINGER_MOTION) {
		action = Gui.MOUSE_MOTION;
	}
	if (action == Gui.KEY_PRESS) {
		if (button == ' ' || button == 8) {
			if (isShift) {
				for (int i = 0; i < layout.items; i += 1) {
					layout.reset(i);
				}
				return true;
			}
			layout.reset(layout.activeIndex());
			layout.update(layout.activeIndex(), 0, 0);
			return true;
		}
		if (button == '-' || button == '_') {	// down
			int delta = isShift ? 1 : 10;
			return layout.update(layout.activeIndex(), -delta, -delta);
		}
		if (button == '+' || button == '=') {	// up
			int delta = isShift ? 1 : 10;
			return layout.update(layout.activeIndex(), +delta, +delta);
		}
		if (button == '[' || button == ']') {	// position
			layout.visible = !layout.visible;
			return true;
		}
		if (button == '\t') {
			return layout.select(isShift);
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		layout.mouse.click(button, x, y);
		if (button != 1) {
			return false;
		}
		return layout.click(x, y);
	}
	else if (action == Gui.MOUSE_RELEASE) {
		layout.mouse.click(0, x, y);
		layout.pressedIndex = -1;
		return false;
	}
	else if (action == Gui.MOUSE_MOTION) {
		int ox = layout.mouse.x;
		int oy = layout.mouse.y;
		layout.mouse.click(-1, x, y);
		if (button != 1) {
			return false;
		}
		if (ox == x && oy == y) {
			return false;
		}
		return layout.update(layout.activeIndex(), ox - x, oy - y);
	}
	return false;
}
/// an 32 bit argb color
struct argb: 0 {
	/// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;

		/// green component
		uint8 g;

		/// red component
		uint8 r;

		/// alpha component
		uint8 a;
	}
	/*enum {
		Black             : 0x00000000;
		White             : 0x00ffffff;
		Aquamarine        : 0x007fffd4;
		Azure             : 0x00007fff;
		Blue              : 0x000000ff;
		BlueViolet        : 0x008a2be2;
		Brown             : 0x00a52a2a;
		CadetBlue         : 0x005f9ea0;
		Coral             : 0x00ff7f50;
		CornflowerBlue    : 0x006495ed;
		Cyan              : 0x0000ffff;
		DarkGray          : 0x00a9a9a9;
		DarkGrey          : 0x00a9a9a9;
		DarkGreen         : 0x00006400;
		DarkOliveGreen    : 0x00556b2f;
		DarkOrchid        : 0x009932cc;
		DarkSlateBlue     : 0x00483d8b;
		DarkSlateGray     : 0x002f4f4f;
		DarkSlateGrey     : 0x002f4f4f;
		DarkTurquoise     : 0x0000ced1;
		DarkWood          : 0x000d0301;
		DeepPink          : 0x00ff1493;
		DimGray           : 0x00696969;
		DimGrey           : 0x00696969;
		FireBrick         : 0x00b22222;
		ForestGreen       : 0x00228b22;
		Gold              : 0x00ffd700;
		Goldenrod         : 0x00daa520;
		Gray              : 0x00808080;
		Grey              : 0x00808080;
		Green             : 0x00008000;
		GreenYellow       : 0x00adff2f;
		IndianRed         : 0x00cd5c5c;
		Khaki             : 0x00f0e68c;
		LightBlue         : 0x00add8e6;
		LightGray         : 0x00d3d3d3;
		LightGrey         : 0x00d3d3d3;
		LightSteelBlue    : 0x00b0c4de;
		LightWood         : 0x00993d1a;
		Lime              : 0x0000ff00;
		LimeGreen         : 0x0032cd32;
		Magenta           : 0x00ff00ff;
		Maroon            : 0x00800000;
		MedianWood        : 0x004d1f09;
		MediumAquamarine  : 0x0066cdaa;
		MediumBlue        : 0x000000cd;
		MediumForestGreen : 0x006b8e23;
		MediumGoldenrod   : 0x00eaeaad;
		MediumOrchid      : 0x00ba55d3;
		MediumSeaGreen    : 0x003cb371;
		MediumSlateBlue   : 0x007b68ee;
		MediumSpringGreen : 0x0000fa9a;
		MediumTurquoise   : 0x0048d1cc;
		MediumVioletRed   : 0x00c71585;
		MidnightBlue      : 0x00191970;
		Navy              : 0x00000080;
		NavyBlue          : 0x0023238e;
		Orange            : 0x00ffa500;
		OrangeRed         : 0x00ff4500;
		Orchid            : 0x00da70d6;
		PaleGreen         : 0x0098fb98;
		Pink              : 0x00ffc0cb;
		Plum              : 0x00dda0dd;
		Red               : 0x00ff0000;
		Salmon            : 0x00fa8072;
		SeaGreen          : 0x002e8b57;
		Sienna            : 0x00a0522d;
		SkyBlue           : 0x0087ceeb;
		SlateBlue         : 0x006a5acd;
		SpringGreen       : 0x0000ff7f;
		SteelBlue         : 0x004682b4;
		Tan               : 0x00d2b48c;
		Thistle           : 0x00d8bfd8;
		Turquoise         : 0x0040e0d0;
		Violet            : 0x00ee82ee;
		VioletRed         : 0x00cc3299;
		Wheat             : 0x00f5deb3;
		Yellow            : 0x00ffff00;
		YellowGreen       : 0x009acd32;
		//Transparent     : 0xff000000;
	}*/
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = argb(emit(uint32(argb)));
/// cast argb value to unsigned integer
inline uint32(argb value) = uint32(emit(struct(value)));


/// clamp signed gray or color component to fit in 8 bits (0 ... 255)
uint32 clamp_s8(int32 c) {
	if (c < 0) {
		return 0;
	}
	if (c > 255) {
		return 255;
	}
	return c;
}
/// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
uint32 clamp_u8(uint32 c) {
	if (c > 255) {
		return 255;
	}
	return c;
}

// construct a rgb8 gray color from the given value
inline _gray(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = _gray(clamp_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = _gray(clamp_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct an argb color from the given components
inline _argb(uint32 r, uint32 g, uint32 b) = argb(uint32((((r << 8) | g) << 8) | b));
/// construct an argb color from the given components
inline _argb(uint32 a, uint32 r, uint32 g, uint32 b) = argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));

/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = _argb(clamp_s8(r), clamp_s8(g), clamp_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = _argb(clamp_u8(r), clamp_u8(g), clamp_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 a, int32 r, int32 g, int32 b) = _argb(clamp_s8(a), clamp_s8(r), clamp_s8(g), clamp_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 a, uint32 r, uint32 g, uint32 b) = _argb(clamp_u8(a), clamp_u8(r), clamp_u8(g), clamp_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 a, float32 r, float32 g, float32 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 a, float64 r, float64 g, float64 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb col) = uint32((uint32(col) >> 24) & 0xff);
/// get the Red channel of the color
inline rch(argb col) = uint32((uint32(col) >> 16) & 0xff);
/// get the Green channel of the color
inline gch(argb col) = uint32((uint32(col) >> 8) & 0xff);
/// get the Blue channel of the color
inline bch(argb col) = uint32(uint32(col) & 0xff);
/// get the luminosity of the color
inline lum(argb c) = uint32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);


/// linear interpolate a lookup-table with the given colors
void lerpLut(uint32 lut[], int alpha, bool invert, argb colors...) {
	inline lrp(int32 t, uint32 x, uint32 y) = x + (t * (y - x) >> 16);

	int mid = alpha < 0 ? 0 : 254;
	int div = 256 - clamp_u8(alpha > 0 ? alpha : -alpha);
	int dt = (colors.length - 1 << 16) / (lut.length - 1);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * dt;
		argb c1 = colors[t >> 16];
		argb c2 = colors[(t >> 16) + 1];
		int32 a = lrp(t & 0xffff, ach(c1), ach(c2));
		int32 r = lrp(t & 0xffff, rch(c1), rch(c2));
		int32 g = lrp(t & 0xffff, gch(c1), gch(c2));
		int32 b = lrp(t & 0xffff, bch(c1), bch(c2));
		a = clamp_s8((a - mid) * 256 / div + mid);
		r = clamp_s8((r - mid) * 256 / div + mid);
		g = clamp_s8((g - mid) * 256 / div + mid);
		b = clamp_s8((b - mid) * 256 / div + mid);
		if (invert) {
			a = ~a;
			r = ~r;
			g = ~g;
			b = ~b;
		}
		lut[i] = a << 24 | r << 16 | g << 8 | b;
	}
}

static if (typename(vec4f) != null) {

/// convert a floating point vector to rgb
inline argb(const vec4f vec&) = argb(vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(const vec4f vec&) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;

/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
}

argb hsv2rgb(float h, float s, float v) {
	if (s == 0) {
		return argb(0, 0, 0);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return argb(u, t, p);
	}
	if (i == 1) {
		return argb(q, u, p);
	}
	if (i == 2) {
		return argb(p, u, t);
	}
	if (i == 3) {
		return argb(p, q, u);
	}
	if (i == 4) {
		return argb(t, p, u);
	}
	return argb(u, p, q);
}

/// draw the given lookup table to the image
void drawLut(gxSurf image, const gxRect roi&, const uint32 bars[256], const uint32 lines[256]) {
	enum {
		margin: 20;
		colB: 0x4371c6;
		colG: 0x72d874;
		colR: 0xfc6165;
		colL: 0xdadada;
	}

	gxRect rect = {
		w: roi != null ? roi.w : 256;
		h: roi != null ? roi.h : 128;
		y: roi != null ? roi.y : margin;
		x: roi != null ? roi.x : image.width() - rect.w - margin;
	};

	int px = (rect.w - 256) / 2;

	if (bars != null) {
		for (int x = 0; x < bars.length; x += 1) {
			int bv = bch(argb(bars[x])) * rect.h / 256;
			int gv = gch(argb(bars[x])) * rect.h / 256;
			int rv = rch(argb(bars[x])) * rect.h / 256;
			int lv = ach(argb(bars[x])) * rect.h / 256;
			for (int y = 0; y < rect.h; y += 1) {
				uint32 b = colB * uint32(y < bv);
				uint32 g = colG * uint32(y < gv);
				uint32 r = colR * uint32(y < rv);
				uint32 l = colL * uint32(y < lv);
				image.set(x + rect.x + px, rect.h - y + rect.y - 1, r | g | b | l);
			}
		}
	}
	if (lines != null) {
		int y = rect.y + rect.h - 1;
		int pb = bch(argb(lines[0])) * rect.h / 256;
		int pg = gch(argb(lines[0])) * rect.h / 256;
		int pr = rch(argb(lines[0])) * rect.h / 256;
		int pl = ach(argb(lines[0])) * rect.h / 256;

		for (int i = 1; i < lines.length; i += 1) {
			int x = rect.x + i + px;
			int bv = bch(argb(lines[i])) * rect.h / 256;
			int gv = gch(argb(lines[i])) * rect.h / 256;
			int rv = rch(argb(lines[i])) * rect.h / 256;
			int lv = ach(argb(lines[i])) * rect.h / 256;

			image.drawLine(x, y - pl, x, y - lv, colL);
			image.drawLine(x, y - pb, x, y - bv, colB);
			image.drawLine(x, y - pg, x, y - gv, colG);
			image.drawLine(x, y - pr, x, y - rv, colR);

			pl = lv;
			pb = bv;
			pg = gv;
			pr = rv;
		}
	}
}
// emulated implementation
void transform(gxSurf surf, const gxRect rect&, gxSurf src, const gxRect roi&, int32 interpolate, float32 mat[16]) {
	assert(roi == null);
	assert(rect != null);

	gxRect dRec = {
		x: rect != null ? rect.x : 0;
		y: rect != null ? rect.y : 0;
		w: rect != null ? rect.w : surf.width();
		h: rect != null ? rect.h : surf.height();
	};

	gxRect sRec = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};

	float32 xx = mat != null ? mat[0] : float32(sRec.w) / dRec.w;
	float32 xy = mat != null ? mat[1] : 0;
	float32 xt = mat != null ? mat[3] : sRec.x;
	float32 yy = mat != null ? mat[5] : float32(sRec.h) / dRec.h;
	float32 yx = mat != null ? mat[4] : 0;
	float32 yt = mat != null ? mat[7] : sRec.y;

	if (!surf.clip(dRec)) {
		// nothing to set
		return;
	}

	if (!src.clip(sRec)) {
		// nothing to get
		return;
	}

	for (int y = 0; y < dRec.h; y += 1) {
		int dy = dRec.y + y;
		float32 sy = sRec.y + y;
		for (int x = 0; x < dRec.w; x += 1) {
			int dx = dRec.x + x;
			float32 sx = sRec.x + x;
			float32 tx = (xx * sx + xy * sy + xt) / src.width();
			float32 ty = (yx * sx + yy * sy + yt) / src.height();
			surf.set(dx, dy, argb(src.tex(tx, ty)));
		}
	}
}
// emulated implementation
void blend(gxSurf surf, int32 x0, int32 y0, const gxSurf src, const gxRect roi&, int32 alpha, bool dstAlpha, vec4f blend(vec4f base, vec4f with)) {
	int width = surf.width();
	int height = surf.height();

	assert(!dstAlpha, "not implemented");
	assert(roi == null, "not implemented");
	assert(blend == null, "not implemented");

	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			inline lerp(int32 l, int32 r) = int32(l + alpha * (r - l) / 256);
			argb col = argb(src.get(x,y));
			int r = rch(col);
			int g = gch(col);
			int b = bch(col);

			col = argb(surf.get(x,y));
			r = lerp(rch(col), r);
			g = lerp(gch(col), g);
			b = lerp(bch(col), b);

			surf.set(x + x0, y + y0, argb(r, g, b));
		}
	}
}
// emulated implementation
void blur(gxSurf img, int radius, double sigma) {
	static double gauss(double x, double sigma) {
		inline SQRT_2_PI_INV = 0.398942280401432677939946059935;
		double t = x / sigma;
		/*switch (dx) {
			default:
				break;
			case -1:
				return 1;
			case 0:
				return SQRT_2_PI_INV * exp(-0.5*t*t) / sigma;
			case 1:
				return -x * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma);
			case 2:
				return (x * x - sigma * sigma) * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma * sigma * sigma);
		}*/
		return SQRT_2_PI_INV * double.exp(-0.5 * t * t) / sigma;
	}

	uint32 kernel[1024];
	int size = radius * 2 + 1;
	assert(size < kernel.length);

	float64 kernelSum = 0;
	float64 kernelFlt[kernel.length];
	for (int i = 0; i < size; i += 1) {
		kernelFlt[i] = gauss(radius - i, sigma);
		kernelSum += kernelFlt[i];
	}

	for (int i = 0; i < size; i += 1) {
		kernel[i] = 65536 * (kernelFlt[i] / kernelSum);
	}

	int width = img.width();
	int height = img.height();

	gxSurf tmp = gxSurf(width, height, img.depth());

	// x direction: inout -> temp
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			uint32 r = 0;
			uint32 g = 0;
			uint32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _x = x + i - radius;
				if (_x >= 0 && _x < width) {
					argb col = argb(img.get(_x, y));
					uint32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			tmp.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	// y direction: temp -> inout
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			uint32 r = 0;
			uint32 g = 0;
			uint32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _y = y + i - radius;
				if (_y >= 0 && _y < height) {
					argb col = argb(tmp.get(x, _y));
					uint32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			img.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	tmp.destroy();
}
// debugging related functions

/// report message at `verbose` logging level
inline verbose(const char message[*], const variant inspect) = raise(raise.verbose, raise.noTrace, message, inspect);
/// report message at `verbose` logging level
inline verbose(const char message[*]) = raise(raise.verbose, raise.noTrace, message, null);

/// report message at `debug` logging level
inline debug(const char message[*], const variant inspect) = raise(raise.debug, raise.noTrace, message, inspect);
/// report message at `debug` logging level
inline debug(const char message[*]) = raise(raise.debug, raise.noTrace, message, null);

/// report message with stacktrace at `debug` logging level
inline trace(const char message[*], const variant inspect) = raise(raise.debug, raise.defTrace, message, inspect);
/// report message with stacktrace at `debug` logging level
inline trace(const char message[*]) = raise(raise.debug, raise.defTrace, message, null);

/// report message at `info` logging level
inline info(const char message[*], const variant inspect) = raise(raise.info, raise.noTrace, message, inspect);
/// report message at `info` logging level
inline info(const char message[*]) = raise(raise.info, raise.noTrace, message, null);

/// report message at `warn` logging level
inline warn(const char message[*], const variant inspect) = raise(raise.warn, raise.noTrace, message, inspect);
/// report message at `warn` logging level
inline warn(const char message[*]) = raise(raise.warn, raise.noTrace, message, null);

/// report message with stacktrace at `error` logging level
inline error(const char message[*], const variant inspect) = raise(raise.error, raise.defTrace, message, inspect);
/// report message with stacktrace at `error` logging level
inline error(const char message[*]) = raise(raise.error, raise.defTrace, message, null);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(const char message[*], const variant inspect) = raise(raise.abort, raise.defTrace, message, inspect);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort(const char message[*]) = raise(raise.abort, raise.defTrace, message, null);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!", null);

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*], const variant inspect) = void(condition ? void(0) : abort(message, inspect));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*]) = void(condition ? void(0) : abort(message));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

///@public
struct NotEquals {
	/// Value of the expected result
	const variant expected;

	/// Value of the actual result
	const variant returned;

	/// Extra argument to identify what happened
	const variant argument = null;

	/// Extra message to identify what happened
	const char message[*] = null;
}

/// abort execution if the returned value is not equal to the expected value
// TODO: make inline
static void assertEq(int expected, int returned, const char message[*]) {
	if (returned == expected) {
		return;
	}
	NotEquals details = {
		expected: expected;
		returned: returned;
		message: message;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
/// abort execution if the returned value is not equal to the expected value
inline assertEq(int expected, int returned) = assertEq(expected, returned, null);
// string related functions

/// Computes the length of the string
int length(const char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(const char str[*], char chr) {
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the index of the last occurrence of a character in string
int lastIndexOf(const char str[*], char chr) {
	int result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
	return result;
}

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	for (int i = 0; with[i] != 0; i += 1) {
		if (cmp(str[i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int withLen = length(with);
	int strLen = length(str);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if the two strings are equal, using a custom comparator
int compare(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int result = 0;
	for (int i = 0; result == 0; i += 1) {
		result = cmp(str[i], with[i]);
		if (str[i] == 0) {
			break;
		}
	}
	return result;
}

/// ignore case character comparator
int ignCaseCmp(char chr, char with) {
	static char ignCase(char chr) {
		if (chr < 'A') {
			return chr;
		}
		if (chr > 'Z') {
			return chr;
		}
		return chr - 'A' + 'a';
	}

	return ignCase(chr) - ignCase(with);
}

/// default character comparator
int caseCmp(char chr, char with) {
	return chr - with;
}

inline startsWith(const char str[*], const char with[*]) = startsWith(str, with, caseCmp);
inline endsWith(const char str[*], const char with[*]) = endsWith(str, with, caseCmp);
inline compare(const char str[*], const char with[*]) = compare(str, with, caseCmp);

/// Check if a string contains the given character
inline contains(const char str[*], char chr) = indexOf(str, chr) >= 0;

/* TODO: implement operator overloading

inline ==(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) < 0;
inline >(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) > 0;

// */

/// Flags to convert numbers to string
struct FormatFlags {
	/// forced show sign
	const bool showSign = false;

	/// precision or radix
	const int precision = 0;

	/// padding character
	const char padChr = 0;

	/// padding length
	const int padLen = 0;
}

/// Append a string to the output at the given position
int append(char output[], int pos, const char value[*]) {
	for (int i = 0; value[i]; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = value[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

// Append a number to the output at the given position
int append(char output[], int pos, char sign, uint64 value, const FormatFlags format&) {
	static const char whiteSpace[] = " \t\n\r";
	static const char radixDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

	int len = 0;
	char digits[80];

	if (format.showSign) {
		if (sign == 0) {
			sign = '+';
		}
	}

	int radix = format.precision;
	if (radix == 0) {
		radix = 10;
	}
	assert(radix > 1, "radix is too small", radix);
	assert(radix < radixDigits.length, "radix is too big", radix);

	// print digits in reverse order
	for ( ; value > 0; value /= radix) {
		digits[len += 1] = radixDigits[value % radix];
	}
	if (len == 0) {
		digits[len += 1] = '0';
	}

	int maxLen = format.padLen - len;

	char padChr = format.padChr;
	if (padChr == '\0') {
		padChr = ' ';
	}

	// print sign value
	if (sign != 0) {
		maxLen -= 1;
		if (whiteSpace.contains(padChr)) {
			// if padding character is whitespace padd before sign
			for ( ; maxLen > 0; maxLen -= 1) {
				assert(pos < output.length);
				output[pos] = padChr;
				pos += 1;
			}
		}
		assert(pos < output.length);
		output[pos] = sign;
		pos += 1;
	}

	// print padding
	for ( ; maxLen > 0; maxLen -= 1) {
		assert(pos < output.length);
		output[pos] = padChr;
		pos += 1;
	}

	// print digits
	for (int i = 0; i < len; i += 1) {
		assert(i < output.length);
		output[pos] = digits[len - i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, uint64 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint32 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint16 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint8 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int64 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int32 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int16 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int8 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, float64 value, const FormatFlags format&) {
	FormatFlags formatInt = {
		showSign: format.showSign;
		precision : 0;
		padChr: format.padChr;
		padLen: format.padLen - format.precision;
	};
	FormatFlags formatDec = {
		showSign: false;
		precision : 0;
		padChr: '0';
		padLen: format.precision;
	};

	char sign = value < 0 ? '-' : 0;
	float64 fract = Math.modf(Math.abs(value), &value);
	pos = output.append(pos, sign, uint64(value), formatInt);

	pos = output.append(pos, ".");
	fract *= float64.pow(10, format.precision);
	pos = output.append(pos, 0, uint64(fract), formatDec);
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, float32 value, const FormatFlags format&) = append(output, pos, float64(value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, int value) {
	static const FormatFlags format = {};
	return append(output, pos, value, format);
}

//inline append(char output[], uint32 value, const FormatFlags format) = output.append(length(output), value, format);
//inline append(char output[], uint32 value) = output.append(length(output), value);
//inline append(char output[], char value[*]) = output.append(length(output), value);
/// Mathematical utility functions and constants
static struct Math {

	// constants
	enum: float64 {
		pi: 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e: 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2: 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E: 1. / ln2;
		ln10: 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E: 1. / ln10;
		phi: 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2: 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE: 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi: 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi: 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan: 0 / 0.;
		inf: 1 / 0.;
	}

	/// Decompose a value into integer and fractional parts
	float64 modf(float64 x, float64 intPart&) {
		if (x < 1) {
			if (x < 0) {
				float64 result = -modf(-x, &intPart);
				intPart = -intPart;
				return result;
			}
			intPart = 0;
			return x;
		}
		float64 result = x % 1;
		intPart = x - result;
		return result;
	}

	// inline isNan(float64 x) = x != x;
	// inline isNan(float32 x) = x != x;

	// inline isInf(float64 x) = x != 0 && x == 2 * x;
	// inline isInf(float32 x) = x != 0 && x == 2 * x;

	// inline isFinite(float64 x) = x - x == 0;
	// inline isFinite(float32 x) = x - x == 0;

	/// Computes the largest integer value not greater than the input
	float64 floor(float64 x) {
		float64 result;
		modf(x, &result);
		return result;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float64 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float64 x) = floor(x + .5);

	// inline floor(float32 x) = float32(floor(float64(x)));
	// inline ceil(float32 x) = -floor(-x);
	// inline round(float32 x) = floor(x + .5f);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float64 x) = int(x > 0) - int(x < 0);

	// inline sign(int32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(int64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(uint32 x) = x > 0 ? 1 : 0;
	// inline sign(uint64 x) = x > 0 ? 1 : 0;
	// inline sign(float32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(float64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;

	/// Returns the absolute value of the input
	float32 abs(float32 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the absolute value of the input
	float64 abs(float64 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the positive modulus of the input
	float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the positive modulus of the input
	float64 absMod(float64 val, float64 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	// inline abs(int32 x) = x < 0 ? -x : x;
	// inline abs(int64 x) = x < 0 ? -x : x;
	// inline abs(uint32 x) = x;
	// inline abs(float32 x) = x < 0 ? -x : x;
	// inline abs(float64 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	float32 min(float32 a, float32 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	/// Returns the smaller value from the input values
	float64 min(float64 a, float64 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	// inline min(int32 a, int32 b) = a < b ? a : b;
	// inline min(int64 a, int64 b) = a < b ? a : b;
	// inline min(uint32 a, uint32 b) = a < b ? a : b;
	// inline min(float32 a, float32 b) = a < b ? a : b;
	// inline min(float64 a, float64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	float32 max(float32 a, float32 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	/// Returns the greater value from the input values
	float64 max(float64 a, float64 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	// inline max(int32 a, int32 b) = a > b ? a : b;
	// inline max(int64 a, int64 b) = a > b ? a : b;
	// inline max(uint32 a, uint32 b) = a > b ? a : b;
	// inline max(float32 a, float32 b) = a > b ? a : b;
	// inline max(float64 a, float64 b) = a > b ? a : b;

	/// Returns the value of `t` clamped between `a` and `b`
	float32 clamp(float32 t, float32 a, float32 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	/// Returns the value of `t` clamped between `a` and `b`
	float64 clamp(float64 t, float64 a, float64 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	// inline clamp(int32 t, int32 a, int32 b) = min(max(t, a), b);
	// inline clamp(int32 t, int32 a, int32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float32 t, float32 a, float32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float64 t, float64 a, float64 b) = t < a ? a : t > b ? b : t;

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float32 t, float32 a, float32 b) = a + t * (b - a);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float64 t, float64 a, float64 b) = a + t * (b - a);

	inline smooth(float32 t) = t * t * (3 - 2 * t);
	inline smooth(float64 t) = t * t * (3 - 2 * t);

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float32 t, float32 a, float32 b) = smooth(clamp((t - a) / (b - a), float32(0), float32(1)));

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float64 t, float64 a, float64 b) = smooth(clamp((t - a) / (b - a), float64(0), float64(1)));

	/// Returns the smaller value from the input values
	float64 min(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result > data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	float64 max(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result < data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the sum of the input values
	float64 sum(float64 data...) {
		float64 result = 0;
		for (int i = 0; i < data.length; i += 1) {
			result += data[i];
		}
		return result;
	}

	/*TODO: implement spread operator
	/// Returns the mean of the input values
	float64 mean(float64 data...) {
		return sum(...data) / data.length;
	}*/

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0) = (a0);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1) = (a0 + x * a1);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2) = (a0 + x * eval(x, a1, a2));

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = (a0 + x * eval(x, a1, a2, a3));

	/// Return the polynomial evaluated at x using Horner's algorithm
	float64 eval(float64 x, float64 polynomial...) {
		float64 result = 0;
		for (int i = polynomial.length - 1; i >= 0; i -= 1) {
			result = result * x + polynomial[i];
		}
		return result;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float32 a, float32 b, float32 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float64 a, float64 b, float64 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	// calculate sin or cos
	float64 sinCos(float64 arg, int quad) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: .1357884097877375669092680e8;
			p1: -.4942908100902844161158627e7;
			p2: .4401030535375266501944918e6;
			p3: -.1384727249982452873054457e5;
			p4: .1459688406665768722226959e3;
			q0: .8644558652922534429915149e7;
			q1: .4081792252343299749395779e6;
			q2: .9463096101538208180571257e4;
			q3: .1326534908786136358911494e3;
		}

		float64 x = arg;
		if (x < 0) {
			x = -x;
			quad += 2;
		}

		float64 y;
		x *= 1 / PIO2;	/* underflow? */
		if (x > 32764) {
			float64 e;
			y = modf(x, &e);
			e += quad;

			float64 f;
			modf(0.25 * e, &f);
			quad = e - 4 * f;
		}
		else {
			int k = x;
			y = x - k;
			quad += k;
			quad &= 3;
		}
		if (quad & 1) {
			y = 1-y;
		}
		if (quad > 1) {
			y = -y;
		}

		float64 ysq = y * y;
		float64 temp1 = ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
		float64 temp2 = ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
		return temp1 / temp2;
	}

	/// Returns the sine of the input
	inline sin(float64 arg) = sinCos(arg, 0);

	/// Returns the cosine of the input
	inline cos(float64 arg) = sinCos(abs(arg), 1);

	/// Returns the tangent of the input
	float64 tan(float64 arg) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: -0.1306820264754825668269611177e+5;
			p1:  0.1055970901714953193602353981e+4;
			p2: -0.1550685653483266376941705728e+2;
			p3:  0.3422554387241003435328470489e-1;
			p4:  0.3386638642677172096076369e-4;
			q0: -0.1663895238947119001851464661e+5;
			q1:  0.4765751362916483698926655581e+4;
			q2: -0.1555033164031709966900124574e+3;
		}

		bool complement = false;
		bool negate = false;

		if (arg < 0) {
			arg = -arg;
			negate = true;
		}
		arg = 2 * arg / PIO2;   /* overflow? */

		double e;
		double x = modf(arg, &e);
		int i = int(e) % 4;

		if (i == 0) {}
		else if (i == 1) {
			x = 1 - x;
			complement = true;
		}
		else if (i == 2) {
			negate = !negate;
			complement = true;
		}
		else if (i == 3) {
			x = 1 - x;
			negate = !negate;
		}

		double xsq = x * x;
		float64 result = ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
		result /= ((xsq + q2) * xsq + q1) * xsq + q0;

		if (complement) {
			if (result == 0) {
				return nan;
			}
			result = 1 / result;
		}
		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic sine of the input
	float64 sinh(float64 x) {
		// The coefficients are #2029 from Hart & Cheney. (20.36D)
		enum: float64 {
			P0: -0.6307673640497716991184787251e+6;
			P1: -0.8991272022039509355398013511e+5;
			P2: -0.2894211355989563807284660366e+4;
			P3: -0.2630563213397497062819489e+2;
			Q0: -0.6307673640497716991212077277e+6;
			Q1: 0.1521517378790019070696485176e+5;
			Q2: -0.173678953558233699533450911e+3;
		}

		bool negate = false;
		if (x < 0) {
			x = -x;
			negate = true;
		}

		if (x > 21) {
			return float64.exp(x) / 2;
		}

		float64 result;
		if (x > 0.5) {
			result = (float64.exp(x) - float64.exp(-x)) / 2;
		}
		else {
			float64 sq = x * x;
			result = (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
			result /= ((sq + Q2) * sq + Q1) * sq + Q0;
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic cosine of the input
	float64 cosh(float64 x) {
		if (x < 0) {
			x = -x;
		}
		if (x > 21) {
			return float64.exp(x) / 2;
		}
		return (float64.exp(x) + float64.exp(-x)) / 2;
	}

	/** Returns the arc sine of the input
	 *  Special cases are:
	 *    Asin(±0) = ±0
	 *    Asin(x) = NaN if x < -1 or x > 1
	 */
	float64 asin(float64 x) {
		if (x == 0) {
			// special case
			return x;
		}

		bool negate = false;
		if (x < 0) {
			negate = true;
			x = -x;
		}

		if (x > 1) {
			// special case
			return nan;
		}

		float64 result = float64.sqrt(1 - x * x);
		if (x > 0.7) {
			result = pi / 2 - float64.atan2(result, x);
		}
		else {
			result = float64.atan2(x, result);
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/** Returns the arc cosine of the input
	 *  Special case is:
	 *    Acos(x) = NaN if x < -1 or x > 1
	 */
	inline acos(float64 x) = (pi / 2 - asin(x));

	/* arc cosine of x
		Absolute error <= 6.7e-5.
		http://http.developer.nvidia.com/Cg/acos.html
	float64 acos(float64 x) {
		float64 negate = 0;
		if (x < 0) {
			negate = 1;
			x = -x;
		}
		result = -0.0187293;
		result = result * x;
		result = result + 0.0742610;
		result = result * x;
		result = result - 0.2121144;
		result = result * x;
		result = result + 1.5707288;
		result = result * sqrt(1. - x);
		result = result - 2 * negate * result;
		result = negate * 3.14159265358979 + result;
	}*/

	/// Converts the input to radians from degrees.
	inline radians(float64 degrees) = float64(degrees * pi / 180);

	/// Converts the input to degrees from radians.
	inline degrees(float64 radians) = float64(radians * 180 / pi);

	// inline rand(int min, int max) = System.rand() % (max - min) + min;
	// inline rand(double min, double max) = (System.rand() / float64(RAND_MAX)) * (max - min) + min;
}
/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		///@public
		vec4f x;
		///@public
		vec4f y;
		///@public
		vec4f z;
		///@public
		vec4f w;
	}
	struct {
		///@public
		float32 xx;
		///@public
		float32 xy;
		///@public
		float32 xz;
		///@public
		float32 xw;

		///@public
		float32 yx;
		///@public
		float32 yy;
		///@public
		float32 yz;
		///@public
		float32 yw;

		///@public
		float32 zx;
		///@public
		float32 zy;
		///@public
		float32 zz;
		///@public
		float32 zw;

		///@public
		float32 wx;
		///@public
		float32 wy;
		///@public
		float32 wz;
		///@public
		float32 ww;
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		x: { x: xx, y: xy, z: xz, w: xw };
		y: { x: yx, y: yy, z: yz, w: yw };
		z: { x: zx, y: zy, z: zz, w: zw };
		w: { x: wx, y: wy, z: wz, w: ww };
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(const vec4f x&, const vec4f y&, const vec4f z&, const vec4f w&) {
	return { x: x, y: y, z: z, w: w };
}

/// Multiply with vector: dot product of the first 3 elements
inline dp3(const mat4f mat&, const vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
/// Multiply with vector: homogeneous dot product
inline dph(const mat4f mat&, const vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
/// Multiply with vector: dot product
inline dp4(const mat4f mat&, const vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

/// Multiply two matrices (rows * cols)
mat4f mul(const mat4f lhs&, const mat4f rhs&) {
	mat4f transposed = {
		x: { x: rhs.x.x, y: rhs.y.x, z: rhs.z.x, w: rhs.w.x };
		y: { x: rhs.x.y, y: rhs.y.y, z: rhs.z.y, w: rhs.w.y };
		z: { x: rhs.x.z, y: rhs.y.z, z: rhs.z.z, w: rhs.w.z };
		w: { x: rhs.x.w, y: rhs.y.w, z: rhs.z.w, w: rhs.w.w };
	};
	return {
		x: dp4(transposed, lhs.x);
		y: dp4(transposed, lhs.y);
		z: dp4(transposed, lhs.z);
		w: dp4(transposed, lhs.w);
	};
}

/**
 * Build a rotation matrix
 * adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
 */
mat4f rotation(const vec4f center&, const vec4f direction&, float angle) {
	float len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float x = direction.x / len;
	float y = direction.y / len;
	float z = direction.z / len;
	float cx = center.x;
	float cy = center.y;
	float cz = center.z;
	float xx = x * x;
	float xy = x * y;
	float xz = x * z;
	float yy = y * y;
	float yz = y * z;
	float zz = z * z;

	float s = float.sin(angle);
	float c = float.cos(angle);
	float k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
inline rotation(const vec4f direction&, float angle) = rotation(vec4f(0), direction, angle);

/// Build a translation matrix
mat4f translation(const vec4f direction&, float amount) {
	return {
		x: {x: 1, y: 0, z: 0, w: direction.x * amount};
		y: {x: 0, y: 1, z: 0, w: direction.y * amount};
		z: {x: 0, y: 0, z: 1, w: direction.z * amount};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}

/// Build a scaling matrix
mat4f scale(const vec4f direction&, float amount) {
	inline rcp(float val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		x: {x: rcp(direction.x * amount), y: 0, z: 0, w: 0};
		y: {x: 0, y: rcp(direction.y * amount), z: 0, w: 0};
		z: {x: 0, y: 0, z: rcp(direction.z * amount), w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}
/// Complex number
struct Complex {

	/// The real component of a complex number.
	const float64 re;

	/// The imaginary component of a complex number.
	const float64 im = 0;

	/* TODO: implement enumerations
	enum: Complex {
		zero: { re: 0 };	// 0 + 0i
		unit: { re: 1 };	// 1 + 0i
	}*/
}

/* TODO: implement inline initializer
// constructing a complex number
inline Complex(float64 re) = { re: re };
inline Complex(float64 re, float64 im) = { re: re, im: im };
*/

///@public
Complex Complex(float64 re) {
	return {
		re: re;
	};
}

///@public
Complex Complex(float64 re, float64 im) {
	return {
		re: re;
		im: im;
	};
}

/* TODO: implement operator overloading
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
inline /(float64 a, Complex b) = div(Complex(a), b);
*/

///@public
inline neg(Complex a) = Complex(-a.re, -a.im);

///@public
inline add(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
///@public
inline add(Complex a, float64 b) = Complex(a.re + b, a.im);
///@public
inline add(float64 a, Complex b) = Complex(a + b.re, b.im);

///@public
inline sub(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
///@public
inline sub(Complex a, float64 b) = Complex(a.re - b, a.im);
///@public
inline sub(float64 a, Complex b) = Complex(a - b.re, b.im);

///@public
inline mul(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
///@public
inline mul(Complex a, float64 b) = Complex(a.re * b, a.im * b);
///@public
inline mul(float64 a, Complex b) = Complex(a * b.re, a * b.im);

///@public
Complex div(Complex a, Complex b) {
	// Adapted from Numerical Recipes in C - The Art of Scientific Computing
	// ISBN 0-521-43108-5

	if (Math.abs(b.re) >= Math.abs(b.im)) {
		float64 r = b.im / b.re;
		float64 den = b.re + r * b.im;
		return {
			re: (a.re + r * a.im) / den;
			im: (a.im - r * a.re) / den;
		};
	}
	float64 r = b.re / b.im;
	float64 den = b.im + r * b.re;
	return {
		re: (a.re * r + a.im) / den;
		im: (a.im * r - a.re) / den;
	};
}

///@public
inline div(Complex a, float64 b) = div(a, Complex(b));
///@public
inline div(float64 a, Complex b) = div(Complex(a), b);

///@public
inline abs(Complex a) = float64.sqrt(a.re * a.re + a.im * a.im);
///@public
inline arg(Complex a) = float64.atan2(a.re, a.im);

/// Reciprocal of a complex number (1 / a)
Complex inv(Complex a) {
	float64 d = (a.re * a.re + a.im * a.im);
	return {
		re: +a.re / d;
		im: -a.im / d;
	};
}

///@public
inline conj(Complex a) = Complex(a.re, -a.im);

///@public
inline exp(Complex a) = Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));

///@public
inline log(Complex a) = Complex(float64.log(abs(a)), arg(a));

///@public
Complex pow(Complex a, Complex b) {
	float64 r = abs(a);
	float64 t = arg(a);
	float64 u = b.re * t + b.im * float64.log(r);
	float64 v = float64.pow(r, b.re) * float64.exp(-b.im * t);
	return {
		re: v * float64.cos(u);
		im: v * float64.sin(u);
	};
}
///@public
inline pow(Complex a, float64 b) = pow(a, Complex(b));

///@public
inline sin(Complex a) = Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
///@public
inline cos(Complex a) = Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));

/* TODO: implement operator overloading
inline tan(Complex a) = sin(a) / cos(a);
inline cot(Complex a) = cos(a) / sin(a);

inline sinh(Complex a) = (exp(a) - exp(-a)) / 2;
inline cosh(Complex a) = (exp(a) + exp(-a)) / 2;
inline tanh(Complex a) = (exp(2 * a) - 1) / (exp(2 * a) + 1);
inline coth(Complex a) = (exp(2 * a) + 1) / (exp(2 * a) - 1);
*/

///@public
inline tan(Complex a) = div(sin(a), cos(a));
///@public
inline cot(Complex a) = div(cos(a), sin(a));

///@public
inline sinh(Complex a) = div(sub(exp(a), exp(neg(a))), 2);
///@public
inline cosh(Complex a) = div(add(exp(a), exp(neg(a))), 2);
///@public
inline tanh(Complex a) = div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
///@public
inline coth(Complex a) = div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));

///@public
inline sec(Complex a) = inv(cos(a));
///@public
inline csc(Complex a) = inv(sin(a));
///@public
inline sech(Complex a) = inv(cosh(a));
///@public
inline csch(Complex a) = inv(sinh(a));

///@public
inline toCartesian(Complex x) = Complex(x.re * double.cos(x.im), x.re * double.sin(x.im));
///@public
inline toPolar(Complex x) = Complex(abs(x), arg(x));
/// A 4d vector (4x float32)
struct vec4f: 0 {
	/// Access the components as an array
	float32 data[4];
	struct {
		/// X component of the vector
		float32 x;
		/// Y component of the vector
		float32 y;
		/// Z component of the vector
		float32 z;
		/// W component of the vector
		float32 w;
	}
}

/* TODO: implement inline initializer
// constructing a vector
inline vec4f(float32 x, float32 y, float32 z, float32 w) = { x: x, y: y, z: z, w: w };
inline vec4f(float32 x, float32 y, float32 z) = { x: x, y: y, z: z, w: 0 };
inline vec4f(const vec4f v&, float32 w) = { x: v.x, y: v.y, z: v.z, w: w };
inline vec4f(const float32 val&) = { x: val, y: val, z: val, w: val };
*/

/// Initialize with given x, y, z, w components
vec4f vec4f(float32 x, float32 y, float32 z, float32 w) {
	return { x: x, y: y, z: z, w: w };
}

/// Initialize with  (x: x, y: y, z: z, w: 1)
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 1f);

/// Initialize with (x: x, y: y, z: 0, w: 1)
inline vec4f(float32 x, float32 y) = vec4f(x, y, 0f, 1f);

/// Initialize x, y, z components using the components form the given vector, and w with the given value
inline vec4f(vec4f xyz, float32 w) = vec4f(xyz.x, xyz.y, xyz.z, w);

/// Initialize x, y, z, w components with the given scalar value
inline vec4f(float32 val) = vec4f(val, val, val, val);

/* TODO: implement operator overloading
//~ -a => vec4f(-a.x, -a.y, -a.z, -a.w);
inline -(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));

//~ a + b => vec4f(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
inline +(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));

//~ a - b => vec4f(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
inline -(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));

//~ a * b => vec4f(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
inline *(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));

//~ a / b => vec4f(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
inline /(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

inline +(vec4f a, float32 b) = a + vec4f(b);
inline +(float32 a, vec4f b) = vec4f(a) + b;
inline -(vec4f a, float32 b) = a - vec4f(b);
inline -(float32 a, vec4f b) = vec4f(a) - b;
inline *(vec4f a, float32 b) = a * vec4f(b);
inline *(float32 a, vec4f b) = vec4f(a) * b;
inline /(vec4f a, float32 b) = a / vec4f(b);
inline /(float32 a, vec4f b) = vec4f(a) / b;

inline normalize(vec4f v) = v / len(v);
*/

/// Returns a negated copy of the vector.
inline neg(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));
/// Component wise add the two vectors.
inline add(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));
/// Component wise subtract the two vectors.
inline sub(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
/// Component wise multiply the two vectors.
inline mul(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
/// Component wise divide the two vectors.
inline div(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

/// Component wise minimum of the two vectors.
inline min(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), min.p4f));
/// Component wise maximum of the two vectors.
inline max(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), max.p4f));

/// Dot product of the first 3 elements
// inline dp3(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z;
inline dp3(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp3));

/// Homogeneous dot product
// inline dph(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w;
inline dph(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dph));

/// Dot product
// inline dp4(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
inline dp4(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp4));

/// Cross product of the first 3 elements
inline cross(const vec4f a&, const vec4f b&) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

/// Length of the vector(xyz)
inline length(vec4f v) = float32.sqrt(dp3(v, v));
/// Normalize the vector(xyz)
inline normalize(const vec4f v&) = div(v, vec4f(length(v)));

/// Evaluate as a polynomial in point x
inline eval(const vec4f v&, float32 x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
/// A 2d vector (2x float64)
struct vec2d: 0 {
	/// Access the components as an array
	float64 data[2];
	struct {
		/// X component of the vector
		float64 x;
		/// Y component of the vector
		float64 y;
	}
}

/// Initialize with given x, y components
vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}

/// Component wise subtract the two vectors.
inline sub(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), sub.p2d));

/// Dot product
inline dot(const vec2d a&, const vec2d b&) = a.x * b.x + a.y * b.y;
// standard library extension

enum: bool {
	true: 0 == 0;
	false: 0 != 0;
}

inline byte = uint8;
inline float = float32;
inline double = float64;

static if (typename(raise) == function) {
inline "std/debug.ci";
}

/// Returns the size of the given type
inline sizeof(typename type) = int(type.size);

inline "std/math.ci";
inline "std/math/Complex.ci"?;      // -> Complex<float64>
//inline "std/math/Rational.ci"?;     // -> Rational<int64>
inline "std/math/Vector4f.ci"?;
inline "std/math/Matrix4f.ci"?;
inline "std/math/Vector2d.ci"?;
//inline "std/math/BigInteger.ci?"   // TODO: inline Rational -> BigInteger.Rational<BigInteger>
//inline "std/math/BigDecimal.ci?"   // TODO: inline Complex -> BigDecimal.Complex<BigDecimal>
//inline "std/math/Perlin.ci"?;

inline "std/string.ci";
