// standard library extension

enum: bool {
	true: 0 == 0;
	false: 0 != 0;
}

inline byte = uint8;
inline float = float32;
inline double = float64;

/// convert unsigned to signed integer
inline signed(uint8 value) = int8(value);

/// convert unsigned to signed integer
inline signed(uint16 value) = int16(value);

/// convert unsigned to signed integer
inline signed(uint32 value) = int32(value);

/// convert unsigned to signed integer
inline signed(uint64 value) = int64(value);

/// convert signed to unsigned integer
inline unsigned(int8 value) = uint8(value);

/// convert signed to unsigned integer
inline unsigned(int16 value) = uint16(value);

/// convert signed to unsigned integer
inline unsigned(int32 value) = uint32(value);

/// convert signed to unsigned integer
inline unsigned(int64 value) = uint64(value);

/// Returns the size of the given type
inline sizeof(typename type) = int(type.size);

static if (typename(raise) == function) {
inline "lib/debug.ci";
}

inline "lib/math.ci";
//inline "lib/math/Decimal.ci"?;      // -> Decimal TODO: implement http://dec64.com/
//inline "lib/math/Rational.ci"?;     // -> Rational<int64>
inline "lib/math/Complex.ci"?;      // -> Complex<float64>
inline "lib/math/Vector4f.ci"?;
inline "lib/math/Matrix4f.ci"?;
inline "lib/math/Vector2d.ci"?;
//inline "lib/math/BigInteger.ci?"   // TODO: inline Rational -> BigInteger.Rational<BigInteger>
//inline "lib/math/BigDecimal.ci?"   // TODO: inline Complex -> BigDecimal.Complex<BigDecimal>
//inline "lib/math/Perlin.ci"?;

inline "lib/string.ci";
// graphics library extension
inline "lib/color.ci";
inline "lib/image.ci";
inline "lib/mesh.ci";
inline "lib/camera.ci";

static if (typename(Image.blur) == null) {
raise(raise.debug, raise.noTrace, "emulated/blur.ci", null);
inline "lib/emulated/blur.ci";
}

static if (typename(Image.blend) == null) {
raise(raise.debug, raise.noTrace, "emulated/blend.ci", null);
inline "lib/emulated/blend.ci";
}

static if (typename(Image.transform) == null) {
raise(raise.debug, raise.noTrace, "emulated/transform.ci", null);
inline "lib/emulated/transform.ci";
}

/// Show the surface in a window
inline show(Image surf) = Gui.showWindow(surf, null, null);

/// Show the surface in a window
void show(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Gui.showWindow(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Gui.showWindow(image, onEvent, delegate);
}

/// Show the surfaces in a window clicking on the window toggles the shown surface
void showDiff(Image image1, Image image2) {
	struct Closure {
		Image offs;
		Image image1;
		Image image2;
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.MOUSE_PRESS) {
			closure.offs.copy(0, 0, closure.image2, null);
			return 0;
		}
		if (action == Gui.MOUSE_RELEASE) {
			closure.offs.copy(0, 0, closure.image1, null);
			return 0;
		}
		return 0;
	}

	Closure closure = {
		offs: Image(image1);
		image1: image1;
		image2: image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Closure {
		bool lerp = true;
		const Image offs;
		const Image thumb;
		const float32 aspect;
		int32 fpsCount = 0;	// frames drawn
		float32 fpsTime = 0;	// frame per sec shot time
		const vec4f eval(vec4f in);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return 0;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.KEY_RELEASE) {
			if (button == ' ') {
				char text[256] = {};
				int64 now = System.millis();
				float32 time = (now - start) / 1000f;
				closure.offs.eval(null, closure.aspect, time, closure.eval);
				text.append(text.append(0, "Millis: "), System.millis() - now);
				Gui.setTitle(text);
				return 0;
			}
			if (button == '\t') {
				closure.lerp = !closure.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				closure.offs.saveBmp("out/offs.bmp", 0);
				closure.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		closure.thumb.eval(null, closure.aspect, time, closure.eval);
		closure.offs.resize(null, closure.thumb, null, closure.lerp ? 1 : 0);
		if (time > closure.fpsTime) {
			char text[256] = {};
			text.append(text.append(0, "Fps: "), closure.fpsCount);
			Gui.setTitle(text);
			closure.fpsTime = time + 1;
			closure.fpsCount = 0;
		}
		closure.fpsCount += 1;

		// do not block for any input
		return 1;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		Image image = Image(width, height, 32);
		image.eval(null, aspect, 0f, eval);
		image.show(null);
		image.destroy();
		return;
	}

	Closure closure = {
		offs: Image(width, height, 32);
		thumb: Image(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy();
	closure.offs.destroy();
}

/// Show the mesh in a window
void show(Mesh mesh, int w, int h, float32 fovy) {

	struct Closure {
		int32 fpsCount = 0;	// frames drawn
		int32 fpsShow = 0;	// frames drawn
		int64 fpsTime = 0;	// frame per sec shot time
		int mode;
		Image offs;
		mat4f proj;
		Camera cam;
		Mesh mesh;

		static void updateCamera(const Closure this&) {
			Camera camera& = this.cam;
			camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		}
	}

	int next(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float32 speed = 1 / 100f;
		if (action == Gui.FINGER_MOTION) {
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
			else if (button == 'l') {
				closure.mode ^= Mesh.useLights;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				closure.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				closure.mode = next(closure.mode, Mesh.cullBack | Mesh.cullFront);
			}
			else if (button == '\t') {
				closure.mode = next(closure.mode, Mesh.drawMode);
			}
			else if (button == '\r') {
				vec4f eye = {x: 0, y: 0, z: 2, w: 1};
				vec4f at = {x: 0, y: 0, z: 0, w: 1};
				vec4f up = {x: 0, y: 1, z: 0, w: 1};
				closure.cam = Camera.lookAt(eye, at, up);
				closure.updateCamera();
			}
		}
		else if (action == Gui.MOUSE_PRESS) {
			ox = ex;
			oy = ey;
			return 0;
		}
		else if (action == Gui.MOUSE_MOTION) {
			Camera camera& = closure.cam;
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit around the origin: (x: 0, y: 0, z: 0)
				camera.rotate(vec4f(0), camera.up, dx * speed);
				camera.rotate(vec4f(0), camera.right, dy * speed);
				closure.updateCamera();
			}
			else if (button == 2) {
				// rotate
				camera.rotate(camera.up, -dx * speed);
				camera.rotate(camera.right, -dy * speed);
				closure.updateCamera();
			}
			else if (button == 3) {
				// move the camera back and forward
				camera.move(camera.forward, dy * speed);
				closure.updateCamera();
			}
			else if (button == 4) {
				// pan the camera
				camera.move(camera.right, -dx * speed);
				camera.move(camera.up, dy * speed);
				closure.updateCamera();
			}
			ox = ex;
			oy = ey;
		}

		int rendered = closure.offs.drawMesh(closure.mesh, closure.mode);

		char text[256] = {};
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, closure.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, closure.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		pos = text.append(pos, ", Fps: ");
		pos = text.append(pos, closure.fpsShow);
		Gui.setTitle(text);

		int64 time = System.millis();
		if (time > closure.fpsTime) {
			closure.fpsTime = time + 1000;
			closure.fpsShow = closure.fpsCount;
			closure.fpsCount = 0;
		}
		closure.fpsCount += 1;
		return 0;
	}

	Closure closure = {
		mode: Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		proj: Camera.projection(fovy, w / float32(h), 1, 100);
		cam: Camera.lookAt(vec4f(0,0,2), vec4f(0), vec4f(0,1,0));
		mesh: mesh;
	};
	closure.updateCamera();
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy();
}
/// Mathematical utility functions and constants
static struct Math {

	// constants
	enum: float64 {
		pi: 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e: 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2: 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E: 1. / ln2;
		ln10: 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E: 1. / ln10;
		phi: 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2: 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE: 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi: 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi: 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan: 0 / 0.;
		inf: 1 / 0.;
	}

	/// Decompose a value into integer and fractional parts
	float64 modf(float64 x, float64 intPart&) {
		if (x < 1) {
			if (x < 0) {
				float64 result = -modf(-x, &intPart);
				intPart = -intPart;
				return result;
			}
			intPart = 0;
			return x;
		}
		float64 result = x % 1;
		intPart = x - result;
		return result;
	}

	// inline isNan(float64 x) = x != x;
	// inline isNan(float32 x) = x != x;

	// inline isInf(float64 x) = x != 0 && x == 2 * x;
	// inline isInf(float32 x) = x != 0 && x == 2 * x;

	// inline isFinite(float64 x) = x - x == 0;
	// inline isFinite(float32 x) = x - x == 0;

	/// Computes the largest integer value not greater than the input
	float64 floor(float64 x) {
		float64 result;
		modf(x, &result);
		return result;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float64 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float64 x) = floor(x + .5);

	// inline floor(float32 x) = float32(floor(float64(x)));
	// inline ceil(float32 x) = -floor(-x);
	// inline round(float32 x) = floor(x + .5f);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float64 x) = int(x > 0) - int(x < 0);

	// inline sign(int32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(int64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(uint32 x) = x > 0 ? 1 : 0;
	// inline sign(uint64 x) = x > 0 ? 1 : 0;
	// inline sign(float32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(float64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;

	/// Returns the absolute value of the input
	float32 abs(float32 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the absolute value of the input
	float64 abs(float64 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the positive modulus of the input
	float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the positive modulus of the input
	float64 absMod(float64 val, float64 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	// inline abs(int32 x) = x < 0 ? -x : x;
	// inline abs(int64 x) = x < 0 ? -x : x;
	// inline abs(uint32 x) = x;
	// inline abs(float32 x) = x < 0 ? -x : x;
	// inline abs(float64 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	float32 min(float32 a, float32 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	/// Returns the smaller value from the input values
	float64 min(float64 a, float64 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	// inline min(int32 a, int32 b) = a < b ? a : b;
	// inline min(int64 a, int64 b) = a < b ? a : b;
	// inline min(uint32 a, uint32 b) = a < b ? a : b;
	// inline min(float32 a, float32 b) = a < b ? a : b;
	// inline min(float64 a, float64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	float32 max(float32 a, float32 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	/// Returns the greater value from the input values
	float64 max(float64 a, float64 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	// inline max(int32 a, int32 b) = a > b ? a : b;
	// inline max(int64 a, int64 b) = a > b ? a : b;
	// inline max(uint32 a, uint32 b) = a > b ? a : b;
	// inline max(float32 a, float32 b) = a > b ? a : b;
	// inline max(float64 a, float64 b) = a > b ? a : b;

	/// Returns the value of `t` clamped between `a` and `b`
	float32 clamp(float32 t, float32 a, float32 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	/// Returns the value of `t` clamped between `a` and `b`
	float64 clamp(float64 t, float64 a, float64 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	// inline clamp(int32 t, int32 a, int32 b) = min(max(t, a), b);
	// inline clamp(int32 t, int32 a, int32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float32 t, float32 a, float32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float64 t, float64 a, float64 b) = t < a ? a : t > b ? b : t;

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float32 t, float32 a, float32 b) = a + t * (b - a);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float64 t, float64 a, float64 b) = a + t * (b - a);

	inline smooth(float32 t) = t * t * (3 - 2 * t);
	inline smooth(float64 t) = t * t * (3 - 2 * t);

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float32 t, float32 a, float32 b) = smooth(clamp((t - a) / (b - a), float32(0), float32(1)));

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float64 t, float64 a, float64 b) = smooth(clamp((t - a) / (b - a), float64(0), float64(1)));

	/// Returns the smaller value from the input values
	float64 min(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result > data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	float64 max(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result < data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the sum of the input values
	float64 sum(float64 data...) {
		float64 result = 0;
		for (int i = 0; i < data.length; i += 1) {
			result += data[i];
		}
		return result;
	}

	/// Returns the mean of the input values
	float64 mean(float64 data...) {
		return sum(...data) / signed(data.length);
	}

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0) = (a0);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1) = (a0 + x * a1);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2) = (a0 + x * eval(x, a1, a2));

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = (a0 + x * eval(x, a1, a2, a3));

	/// Return the polynomial evaluated at x using Horner's algorithm
	float64 eval(float64 x, float64 polynomial...) {
		float64 result = 0;
		for (int i = polynomial.length - 1; i >= 0; i -= 1) {
			result = result * x + polynomial[i];
		}
		return result;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float32 a, float32 b, float32 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float64 a, float64 b, float64 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	// calculate sin or cos
	float64 sinCos(float64 arg, int quad) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: .1357884097877375669092680e8;
			p1: -.4942908100902844161158627e7;
			p2: .4401030535375266501944918e6;
			p3: -.1384727249982452873054457e5;
			p4: .1459688406665768722226959e3;
			q0: .8644558652922534429915149e7;
			q1: .4081792252343299749395779e6;
			q2: .9463096101538208180571257e4;
			q3: .1326534908786136358911494e3;
		}

		float64 x = arg;
		if (x < 0) {
			x = -x;
			quad += 2;
		}

		float64 y;
		x *= 1 / PIO2;	/* underflow? */
		if (x > 32764) {
			float64 e;
			y = modf(x, &e);
			e += quad;

			float64 f;
			modf(0.25 * e, &f);
			quad = e - 4 * f;
		}
		else {
			int k = x;
			y = x - k;
			quad += k;
			quad &= 3;
		}
		if (quad & 1) {
			y = 1-y;
		}
		if (quad > 1) {
			y = -y;
		}

		float64 ysq = y * y;
		float64 temp1 = ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
		float64 temp2 = ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
		return temp1 / temp2;
	}

	/// Returns the sine of the input
	inline sin(float64 arg) = sinCos(arg, 0);

	/// Returns the cosine of the input
	inline cos(float64 arg) = sinCos(abs(arg), 1);

	/// Returns the tangent of the input
	float64 tan(float64 arg) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: -0.1306820264754825668269611177e+5;
			p1:  0.1055970901714953193602353981e+4;
			p2: -0.1550685653483266376941705728e+2;
			p3:  0.3422554387241003435328470489e-1;
			p4:  0.3386638642677172096076369e-4;
			q0: -0.1663895238947119001851464661e+5;
			q1:  0.4765751362916483698926655581e+4;
			q2: -0.1555033164031709966900124574e+3;
		}

		bool complement = false;
		bool negate = false;

		if (arg < 0) {
			arg = -arg;
			negate = true;
		}
		arg = 2 * arg / PIO2;   /* overflow? */

		float64 e;
		float64 x = modf(arg, &e);
		int i = int(e) % 4;

		if (i == 0) {}
		else if (i == 1) {
			x = 1 - x;
			complement = true;
		}
		else if (i == 2) {
			negate = !negate;
			complement = true;
		}
		else if (i == 3) {
			x = 1 - x;
			negate = !negate;
		}

		float64 xsq = x * x;
		float64 result = ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
		result /= ((xsq + q2) * xsq + q1) * xsq + q0;

		if (complement) {
			if (result == 0) {
				return nan;
			}
			result = 1 / result;
		}
		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic sine of the input
	float64 sinh(float64 x) {
		// The coefficients are #2029 from Hart & Cheney. (20.36D)
		enum: float64 {
			P0: -0.6307673640497716991184787251e+6;
			P1: -0.8991272022039509355398013511e+5;
			P2: -0.2894211355989563807284660366e+4;
			P3: -0.2630563213397497062819489e+2;
			Q0: -0.6307673640497716991212077277e+6;
			Q1: 0.1521517378790019070696485176e+5;
			Q2: -0.173678953558233699533450911e+3;
		}

		bool negate = false;
		if (x < 0) {
			x = -x;
			negate = true;
		}

		if (x > 21) {
			return float64.exp(x) / 2;
		}

		float64 result;
		if (x > 0.5) {
			result = (float64.exp(x) - float64.exp(-x)) / 2;
		}
		else {
			float64 sq = x * x;
			result = (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
			result /= ((sq + Q2) * sq + Q1) * sq + Q0;
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic cosine of the input
	float64 cosh(float64 x) {
		if (x < 0) {
			x = -x;
		}
		if (x > 21) {
			return float64.exp(x) / 2;
		}
		return (float64.exp(x) + float64.exp(-x)) / 2;
	}

	/** Returns the arc sine of the input
	 *  Special cases are:
	 *    Asin(±0) = ±0
	 *    Asin(x) = NaN if x < -1 or x > 1
	 */
	float64 asin(float64 x) {
		if (x == 0) {
			// special case
			return x;
		}

		bool negate = false;
		if (x < 0) {
			negate = true;
			x = -x;
		}

		if (x > 1) {
			// special case
			return nan;
		}

		float64 result = float64.sqrt(1 - x * x);
		if (x > 0.7) {
			result = pi / 2 - float64.atan2(result, x);
		}
		else {
			result = float64.atan2(x, result);
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/** Returns the arc cosine of the input
	 *  Special case is:
	 *    Acos(x) = NaN if x < -1 or x > 1
	 */
	inline acos(float64 x) = (pi / 2 - asin(x));

	/* arc cosine of x
		Absolute error <= 6.7e-5.
		http://http.developer.nvidia.com/Cg/acos.html
	float64 acos(float64 x) {
		float64 negate = 0;
		if (x < 0) {
			negate = 1;
			x = -x;
		}
		result = -0.0187293;
		result = result * x;
		result = result + 0.0742610;
		result = result * x;
		result = result - 0.2121144;
		result = result * x;
		result = result + 1.5707288;
		result = result * sqrt(1. - x);
		result = result - 2 * negate * result;
		result = negate * 3.14159265358979 + result;
	}*/

	/// Converts the input to radians from degrees.
	inline radians(float64 degrees) = float64(degrees * pi / 180);

	/// Converts the input to degrees from radians.
	inline degrees(float64 radians) = float64(radians * 180 / pi);

	// inline rand(int min, int max) = System.rand() % (max - min) + min;
	// inline rand(double min, double max) = (System.rand() / float64(RAND_MAX)) * (max - min) + min;
}

/* TODO: leftovers
//~ float64 abs(float64 x);
//~ float64 sin(float64 x);
//~ float64 cos(float64 x);
//~ float64 tan(float64 x);
//~ float64 log(float64 x);
//~ float64 exp(float64 x);
//~ float64 pow(float64 x, float64 y);
//~ float64 sqrt(float64 x);
//~ float64 atan2(float64 x, float64 y);

//~ Number.prototype.abs = function(){return Math.abs(this);};
//~ Number.prototype.sign = function(){return this == 0 ? 0 : (this > 0 ? 1 : -1);};
//~ Number.prototype.ceil = function(){return Math.ceil(this);};
//~ Number.prototype.floor = function(){return Math.floor(this);};
//~ Number.prototype.round = function(){return Math.round(this);};
//~ Number.prototype.degToRad = function(){return this * Math.PI / 180;};
//~ Number.prototype.radToDeg = function(){return this * 180 / Math.PI;};

//~ Number.prototype.sin = function(){return Math.sin(this);};
//~ Number.prototype.sinh = function(){return (Math.exp(this) - Math.exp(-this)) / 2;};
//~ Number.prototype.asin = function(){return Math.asin(this);};
Number.prototype.asinh = function(){return Math.log(this + Math.sqrt(this * this + 1));};

Number.prototype.sec = function(){return 1 / Math.cos(this);};
Number.prototype.sech = function(){return 2 / (Math.exp(this) + Math.exp(-this));};
Number.prototype.asec = function(){return Math.PI / 2 - Math.asin(1 / this);};
Number.prototype.asech = function(){return Math.log((1 + Math.sqrt(1 - this * this)) / this);};

//~ Number.prototype.cos = function(){return Math.cos(this);};
//~ Number.prototype.cosh = function(){return (Math.exp(this) + Math.exp(-this)) / 2;};
//~ Number.prototype.acos = function(){return Math.acos(this);};
Number.prototype.acosh = function(){return Math.log(this + Math.sqrt(this * this - 1));};

Number.prototype.cot = function(){return 1 / Math.tan(this);};
Number.prototype.coth = function(){return (Math.exp(this) + Math.exp(-this)) / (Math.exp(this) - Math.exp(-this));};
Number.prototype.acot = function(){return Math.PI / 2 - Math.atan(this);};
Number.prototype.acoth = function(){return Math.log((this + 1) / (this - 1)) / 2;};

Number.prototype.cosec = function(){return 1 / Math.sin(this);};
Number.prototype.cosech = function(){return 2 / (Math.exp(this) - Math.exp(-this));};
Number.prototype.acosec = function(){return Math.asin(1 / this);};
Number.prototype.acosech = function(){
	return this < 0
		? Math.log((1 - Math.sqrt(1 + this * this)) / this)
		: Math.log((1 + Math.sqrt(1 + this * this)) / this);
};

//~ Number.prototype.tan = function(){return Math.tan(this);};
Number.prototype.tanh = function(){return (Math.exp(this) - Math.exp(-this)) / (Math.exp(this) + Math.exp(-this));};
Number.prototype.atan = function(){return Math.atan(this);};
Number.prototype.atanh = function(){return Math.log((1 + this) / (1 - this)) / 2;};

Number.prototype.ln = function(){return Math.log(this);};
//~ Number.prototype.log = function(base){return Math.log(this) / Math.log(base);};
Number.prototype.log2 = function(){return Math.log(this) / Math.LN2;};
Number.prototype.log10 = function(){return Math.log(this) / Math.LN10;};
//~ Number.prototype.exp = function(){return Math.exp(this);};

//~ Number.prototype.sqrt = function(){return Math.sqrt(this);};
//~ Number.prototype.pow = function(exponent){return Math.pow(this,exponent);};
//- Number.prototype.mod = function(modulus){return this >= 0 ? this % modulus : (this % modulus + Math.abs(modulus)) % modulus;};
//- Number.prototype.wrap = function(low, high){return low + (this - low).mod(high - low);};

	/// Returns the smaller value from the input values
	int32 min(int32 values...) {
		assert(values.length > 0);
		int32 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result > values[i]) {
				result = values[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	int32 max(int32 values...) {
		assert(values.length > 0);
		int32 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result < values[i]) {
				result = values[i];
			}
		}
		return result;
	}
// */
// string related functions

/// Computes the length of the string
int length(const char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(const char str[*], char chr) {
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the index of the last occurrence of a character in string
int lastIndexOf(const char str[*], char chr) {
	int result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
	return result;
}

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	for (int i = 0; with[i] != 0; i += 1) {
		if (cmp(str[i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int withLen = length(with);
	int strLen = length(str);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if the two strings are equal, using a custom comparator
int compare(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int result = 0;
	for (int i = 0; result == 0; i += 1) {
		result = cmp(str[i], with[i]);
		if (str[i] == 0) {
			break;
		}
	}
	return result;
}

/// ignore case character comparator
int ignCaseCmp(char chr, char with) {
	static char ignCase(char chr) {
		if (chr < 'A') {
			return chr;
		}
		if (chr > 'Z') {
			return chr;
		}
		return chr - 'A' + 'a';
	}

	return ignCase(chr) - ignCase(with);
}

/// default character comparator
int caseCmp(char chr, char with) {
	return chr - with;
}

inline startsWith(const char str[*], const char with[*]) = startsWith(str, with, caseCmp);
inline endsWith(const char str[*], const char with[*]) = endsWith(str, with, caseCmp);
inline compare(const char str[*], const char with[*]) = compare(str, with, caseCmp);
inline equals(const char str[*], const char with[*]) = compare(str, with, caseCmp) == 0;

/// Check if a string contains the given character
inline contains(const char str[*], char chr) = indexOf(str, chr) >= 0;

/* TODO: implement operator overloading

inline ==(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) < 0;
inline >(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) > 0;

// */

/// Flags to convert numbers to string
struct FormatFlags {
	/// forced show sign
	const bool showSign = false;

	/// precision or radix
	const int precision = 0;

	/// padding character
	const char padChr = 0;

	/// padding length
	const int padLen = 0;
}

/// Append a string to the output at the given position
int append(char output[], int pos, const char value[*]) {
	for (int i = 0; value[i]; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = value[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

// Append a number to the output at the given position
int append(char output[], int pos, char sign, uint64 value, const FormatFlags format&) {
	static const char whiteSpace[] = " \t\n\r";
	static const char radixDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

	int len = 0;
	char digits[80] = {};

	if (format.showSign) {
		if (sign == 0) {
			sign = '+';
		}
	}

	int radix = format.precision;
	if (radix == 0) {
		radix = 10;
	}
	assert(radix > 1, "radix is too small", radix);
	assert(radix < radixDigits.length, "radix is too big", radix);

	// print digits in reverse order
	for ( ; value > 0; value /= radix) {
		digits[len += 1] = radixDigits[value % radix];
	}
	if (len == 0) {
		digits[len += 1] = '0';
	}

	int maxLen = format.padLen - len;

	char padChr = format.padChr;
	if (padChr == '\0') {
		padChr = ' ';
	}

	// print sign value
	if (sign != 0) {
		maxLen -= 1;
		if (whiteSpace.contains(padChr)) {
			// if padding character is whitespace padd before sign
			for ( ; maxLen > 0; maxLen -= 1) {
				assert(pos < output.length);
				output[pos] = padChr;
				pos += 1;
			}
		}
		assert(pos < output.length);
		output[pos] = sign;
		pos += 1;
	}

	// print padding
	for ( ; maxLen > 0; maxLen -= 1) {
		assert(pos < output.length);
		output[pos] = padChr;
		pos += 1;
	}

	// print digits
	for (int i = 0; i < len; i += 1) {
		assert(i < output.length);
		output[pos] = digits[len - i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, uint64 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint32 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint16 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint8 value, const FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int64 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int32 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int16 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int8 value, const FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, float64 value, const FormatFlags format&) {
	FormatFlags formatInt = {
		showSign: format.showSign;
		precision : 0;
		padChr: format.padChr;
		padLen: format.padLen - format.precision;
	};
	FormatFlags formatDec = {
		showSign: false;
		precision : 0;
		padChr: '0';
		padLen: format.precision;
	};

	char sign = value < 0 ? '-' : 0;
	float64 fract = Math.modf(Math.abs(value), &value);
	pos = output.append(pos, sign, uint64(int64(value)), formatInt);

	pos = output.append(pos, ".");
	fract *= float64.pow(10, format.precision);
	pos = output.append(pos, 0, uint64(int64(fract)), formatDec);
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, float32 value, const FormatFlags format&) = append(output, pos, float64(value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, int value) {
	static const FormatFlags format = {};
	return append(output, pos, value, format);
}

//inline append(char output[], uint32 value, const FormatFlags format) = output.append(length(output), value, format);
//inline append(char output[], uint32 value) = output.append(length(output), value);
//inline append(char output[], char value[*]) = output.append(length(output), value);

/* TODO: leftovers
 * Format integer to text
 * @param output write output to this buffer
 * @param format format string
 *  	%b format as binary
 *  	%o format as octal
 *  	%d format as decimal
 *  	%x format as hexadecimal
 *  	%i format as custom radix
 *  	null defaults to: "%d"
 * @param value date to format
int format(char output[], string format, int value) {
	int pos = 0;
	if (format == null) {
		format = "%d";
	}
	int spos = 0;
	for (int chr; chr = format[spos]; spos += 1) {
		if (chr == '%') {
			chr = format[spos += 1];
			if (chr == '%') {
				if (pos < output.length) {
					output[pos] = chr;
					pos += 1;
				}
				continue;
			}

			int sgnChr = 0;
			if (chr == '-' || chr == '+') {
				sgnChr = chr;
				chr = format[spos += 1];
			}

			int padChr = ' ';
			if (chr == '0') {
				padChr = chr;
				chr = format[spos += 1];
			}

			int padLen = 0;
			for (;chr >= '0' && chr <= '9';) {
				padLen = padLen * 10 + chr - '0';
				chr = format[spos += 1];
			}

			int precision = 0;
			if (chr == '.') {
				chr = format[spos += 1];
				for ( ;chr >= '0' && chr <= '9'; ) {
					precision = precision * 10 + chr - '0';
					chr = format[spos += 1];
				}
			}


			int rad = 10;
			if (chr == 'b') {
				rad = 2;
			}
			else if (chr == 'o') {
				rad = 8;
			}
			else if (chr == 'd') {
				rad = 10;
			}
			else if (chr == 'x') {
				rad = 16;
			}
			else if (chr == 'i') {
				rad = precision;
			}

			int val = value;
			if (val < 0) {
				val = -val;
				sgnChr = '-';
			}
			else {
				if (val == 0) {
					padChr = '0';
					if (!padLen) {
						padLen = 1;
					}
				}
			}

			FormatFlags flags = FormatFlags(rad, sgnChr, padChr, padLen, precision);
			pos = format(output, pos, &flags, val);
		}
		else if (pos < output.length) {
			output[pos] = chr;
			pos += 1;
		}
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}
// */
// debugging related functions

/// report message at `verbose` logging level
inline verbose(const char message[*], const variant inspect) = raise(raise.verbose, raise.noTrace, message, inspect);
/// report message at `verbose` logging level
inline verbose(const char message[*]) = raise(raise.verbose, raise.noTrace, message, null);

/// report message at `debug` logging level
inline debug(const char message[*], const variant inspect) = raise(raise.debug, raise.noTrace, message, inspect);
/// report message at `debug` logging level
inline debug(const char message[*]) = raise(raise.debug, raise.noTrace, message, null);

/// report message with stacktrace at `debug` logging level
inline trace(const char message[*], const variant inspect) = raise(raise.debug, raise.defTrace, message, inspect);
/// report message with stacktrace at `debug` logging level
inline trace(const char message[*]) = raise(raise.debug, raise.defTrace, message, null);

/// report message at `info` logging level
inline info(const char message[*], const variant inspect) = raise(raise.info, raise.noTrace, message, inspect);
/// report message at `info` logging level
inline info(const char message[*]) = raise(raise.info, raise.noTrace, message, null);

/// report message at `warn` logging level
inline warn(const char message[*], const variant inspect) = raise(raise.warn, raise.noTrace, message, inspect);
/// report message at `warn` logging level
inline warn(const char message[*]) = raise(raise.warn, raise.noTrace, message, null);

/// report message with stacktrace at `error` logging level
inline error(const char message[*], const variant inspect) = raise(raise.error, raise.defTrace, message, inspect);
/// report message with stacktrace at `error` logging level
inline error(const char message[*]) = raise(raise.error, raise.defTrace, message, null);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(const char message[*], const variant inspect) = raise(raise.abort, raise.defTrace, message, inspect);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort(const char message[*]) = raise(raise.abort, raise.defTrace, message, null);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!", null);

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*], const variant inspect) = void(condition ? void(0) : abort(message, inspect));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*]) = void(condition ? void(0) : abort(message));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

///@public
struct NotEquals {
	/// Value of the expected result
	const variant expected;

	/// Value of the actual result
	const variant returned;

	/// Extra argument to identify what happened
	const variant extras[] = null;
}

/// abort execution if the returned value is not equal to the expected value
// TODO: make inline
static void assertEq(int expected, int returned, const char message[*]) {
	if (returned == expected) {
		return;
	}
	variant extras[1] = { message };
	NotEquals details = {
		expected: expected;
		returned: returned;
		extras: extras;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
/// abort execution if the returned value is not equal to the expected value
inline assertEq(int expected, int returned) = assertEq(expected, returned, null);
/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		///@public
		vec4f x;
		///@public
		vec4f y;
		///@public
		vec4f z;
		///@public
		vec4f w;
	}
	struct {
		///@public
		float32 xx;
		///@public
		float32 xy;
		///@public
		float32 xz;
		///@public
		float32 xw;

		///@public
		float32 yx;
		///@public
		float32 yy;
		///@public
		float32 yz;
		///@public
		float32 yw;

		///@public
		float32 zx;
		///@public
		float32 zy;
		///@public
		float32 zz;
		///@public
		float32 zw;

		///@public
		float32 wx;
		///@public
		float32 wy;
		///@public
		float32 wz;
		///@public
		float32 ww;
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		xx: xx; xy: xy; xz: xz; xw: xw;
		yx: yx; yy: yy; yz: yz; yw: yw;
		zx: zx; zy: zy; zz: zz; zw: zw;
		wx: wx; wy: wy; wz: wz; ww: ww;
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(const vec4f x&, const vec4f y&, const vec4f z&, const vec4f w&) {
	return { x: x, y: y, z: z, w: w };
}

/// Multiply with vector: dot product of the first 3 elements
inline dp3(const mat4f mat&, const vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
/// Multiply with vector: homogeneous dot product
inline dph(const mat4f mat&, const vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
/// Multiply with vector: dot product
inline dp4(const mat4f mat&, const vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

/// Transpose the matrix
mat4f transpose(const mat4f mat) {
	return {
		xx: mat.xx; xy: mat.yx; xz: mat.zx; xw: mat.wx;
		yx: mat.xy; yy: mat.yy; yz: mat.zy; yw: mat.wy;
		zx: mat.xz; zy: mat.yz; zz: mat.zz; zw: mat.wz;
		wx: mat.xw; wy: mat.yw; wz: mat.zw; ww: mat.ww;
	};
}

/// Multiply two matrices (rows * cols)
mat4f mul(const mat4f lhs&, const mat4f rhs&) {
	mat4f transposed = transpose(rhs);
	return {
		x: dp4(transposed, lhs.x);
		y: dp4(transposed, lhs.y);
		z: dp4(transposed, lhs.z);
		w: dp4(transposed, lhs.w);
	};
}

/**
 * Build a rotation matrix
 * adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
 */
mat4f rotation(const vec4f center&, const vec4f direction&, float32 angle) {
	float32 len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float32 x = direction.x / len;
	float32 y = direction.y / len;
	float32 z = direction.z / len;
	float32 cx = center.x;
	float32 cy = center.y;
	float32 cz = center.z;
	float32 xx = x * x;
	float32 xy = x * y;
	float32 xz = x * z;
	float32 yy = y * y;
	float32 yz = y * z;
	float32 zz = z * z;

	float32 s = float32.sin(angle);
	float32 c = float32.cos(angle);
	float32 k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
inline rotation(const vec4f direction&, float32 angle) = rotation(vec4f(0), direction, angle);

/// Build a translation matrix
mat4f translation(const vec4f direction&, float32 amount) {
	return {
		xx: 1; xy: 0; xz: 0; xw: direction.x * amount;
		yx: 0; yy: 1; yz: 0; yw: direction.y * amount;
		zx: 0; zy: 0; zz: 1; zw: direction.z * amount;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}

/// Build a scaling matrix
mat4f scale(const vec4f direction&, float32 amount) {
	inline rcp(float32 val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		xx: rcp(direction.x * amount); xy: 0; xz: 0; xw: 0;
		yx: 0; yy: rcp(direction.y * amount); yz: 0; yw: 0;
		zx: 0; zy: 0; zz: rcp(direction.z * amount); zw: 0;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}
/// convert a 64 bit value between Little endian and Big endian
uint64 swapBytes(uint64 x) {
	x = (x & 0x00000000ffffffff) << 32 | (x & 0xffffffff00000000) >> 32;
	x = (x & 0x0000ffff0000ffff) << 16 | (x & 0xffff0000ffff0000) >> 16;
	x = (x & 0x00ff00ff00ff00ff) << 8  | (x & 0xff00ff00ff00ff00) >> 8;
	return x;
}

/// convert a 32 bit value between Little endian and Big endian
uint32 swapBytes(uint32 x) {
	x = (x & 0x0000ffff) << 16 | (x & 0xffff0000) >> 16;
	x = (x & 0x00ff00ff) << 8  | (x & 0xff00ff00) >> 8;
	return x;
}

/// convert a 16 bit value between Little endian and Big endian
uint16 swapBytes(uint16 x) {
	return (x & 0x00ff) << 8 | (x & 0xff00) >> 8;
}


/// find the index of the most significant(highest) bit
int scanMsb(uint64 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if (x & 0xffffffff00000000) {
		result += 32;
		x >>= 32;
	}
	if (x & 0xffff0000) {
		result += 16;
		x >>= 16;
	}
	if (x & 0xff00) {
		result += 8;
		x >>= 8;
	}
	if (x & 0xf0) {
		result += 4;
		x >>= 4;
	}
	if (x & 0xc) {
		result += 2;
		x >>= 2;
	}
	if (x & 0x2) {
		result += 1;
	}
	return result;
}

/// find the index of the most significant(highest) bit
int scanMsb(uint32 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if (x & 0xffff0000) {
		result += 16;
		x >>= 16;
	}
	if (x & 0xff00) {
		result += 8;
		x >>= 8;
	}
	if (x & 0xf0) {
		result += 4;
		x >>= 4;
	}
	if (x & 0xc) {
		result += 2;
		x >>= 2;
	}
	if (x & 0x2) {
		result += 1;
	}
	return result;
}

/// find the index of the most significant(highest) bit
int scanMsb(uint16 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if (x & 0xff00) {
		result += 8;
		x >>= 8;
	}
	if (x & 0xf0) {
		result += 4;
		x >>= 4;
	}
	if (x & 0xc) {
		result += 2;
		x >>= 2;
	}
	if (x & 0x2) {
		result += 1;
	}
	return result;
}

/// find the index of the most significant(highest) bit
int scanMsb(uint8 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if (x & 0xf0) {
		result += 4;
		x >>= 4;
	}
	if (x & 0xc) {
		result += 2;
		x >>= 2;
	}
	if (x & 0x2) {
		result += 1;
	}
	return result;
}

/// find the index of the least significant(lowest) bit
int scanLsb(uint64 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if ((x & 0xffffffff) == 0) {
		result += 32;
		x >>= 32;
	}
	if ((x & 0xffff) == 0) {
		result += 16;
		x >>= 16;
	}
	if ((x & 0xff) == 0) {
		result += 8;
		x >>= 8;
	}
	if ((x & 0xf) == 0) {
		result += 4;
		x >>= 4;
	}
	if ((x & 0x3) == 0) {
		result += 2;
		x >>= 2;
	}
	if ((x & 0x1) == 0) {
		result += 1;
	}
	return result;
}

/// find the index of the least significant(lowest) bit
int scanLsb(uint32 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if ((x & 0xffff) == 0) {
		result += 16;
		x >>= 16;
	}
	if ((x & 0xff) == 0) {
		result += 8;
		x >>= 8;
	}
	if ((x & 0xf) == 0) {
		result += 4;
		x >>= 4;
	}
	if ((x & 0x3) == 0) {
		result += 2;
		x >>= 2;
	}
	if ((x & 0x1) == 0) {
		result += 1;
	}
	return result;
}

/// find the index of the least significant(lowest) bit
int scanLsb(uint16 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if ((x & 0xff) == 0) {
		result += 8;
		x >>= 8;
	}
	if ((x & 0xf) == 0) {
		result += 4;
		x >>= 4;
	}
	if ((x & 0x3) == 0) {
		result += 2;
		x >>= 2;
	}
	if ((x & 0x1) == 0) {
		result += 1;
	}
	return result;
}

/// find the index of the least significant(lowest) bit
int scanLsb(uint8 x) {
	if (x == 0) {
		return -1;
	}

	int result = 0;
	if ((x & 0xf) == 0) {
		result += 4;
		x >>= 4;
	}
	if ((x & 0x3) == 0) {
		result += 2;
		x >>= 2;
	}
	if ((x & 0x1) == 0) {
		result += 1;
	}
	return result;
}

// TODO: uint16 keepMsb(uint16 x)
// TODO: uint8 keepMsb(uint8 x)
/// keep the highest bit set
uint64 keepMsb(uint64 x) {
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;
	x |= x >> 32;
	return x - (x >> 1);
}
/// keep the highest bit set
uint32 keepMsb(uint32 x) {
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;
	return x - (x >> 1);
}

/// keep the lowest bit set
inline keepLsb(uint64 x) = uint64(x & -x);
/// keep the lowest bit set
inline keepLsb(uint32 x) = uint32(x & -x);
/// keep the lowest bit set
inline keepLsb(uint16 x) = uint16(x & -x);
/// keep the lowest bit set
inline keepLsb(uint8 x) = uint8(x & -x);

// TODO: int countBits(uint64 x)
// TODO: int countBits(uint16 x)
// TODO: int countBits(uint8 x)
/// count bits set to one
int countBits(uint64 x) {
	x -= (x >> 1) & 0x5555555555555555;
	x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
	x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
	x += x >> 8;
	x += x >> 16;
	x += x >> 32;
	return x & 0x3f;
}
int countBits(uint32 x) {
	x -= (x >> 1) & 0x55555555;
	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	x = (x + (x >> 4)) & 0x0f0f0f0f;
	x += x >> 8;
	x += x >> 16;
	return x & 0x3f;
}
// reverse all the bits
uint64 swapBits(uint64 x) {
	x = ((x >> 1) & 0x5555555555555555) | ((x & 0x5555555555555555) << 1);
	x = ((x >> 2) & 0x3333333333333333) | ((x & 0x3333333333333333) << 2);
	x = ((x >> 4) & 0x0f0f0f0f0f0f0f0f) | ((x & 0x0f0f0f0f0f0f0f0f) << 4);
	x = ((x >> 8) & 0x00ff00ff00ff00ff) | ((x & 0x00ff00ff00ff00ff) << 8);
	x = ((x >> 16) & 0x0000ffff0000ffff) | ((x & 0x0000ffff0000ffff) << 16);
	return (x >> 32) | (x << 32);
}

// reverse all the bits
uint32 swapBits(uint32 x) {
	x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
	x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
	return (x >> 16) | (x << 16);
}

// reverse all the bits
uint16 swapBits(uint16 x) {
	x = ((x >> 1) & 0x5555) | ((x & 0x5555) << 1);
	x = ((x >> 2) & 0x3333) | ((x & 0x3333) << 2);
	x = ((x >> 4) & 0x0f0f) | ((x & 0x0f0f) << 4);
	return (x >> 8) | (x << 8);
}

// reverse all the bits
uint8 swapBits(uint8 x) {
	x = ((x >> 1) & 0x55) | ((x & 0x55) << 1);
	x = ((x >> 2) & 0x33) | ((x & 0x33) << 2);
	return (x >> 4) | (x << 4);
}

inline swapBytes(int64 x) = int64(swapBytes(uint64(x)));
inline swapBytes(int32 x) = int32(swapBytes(uint32(x)));
inline swapBytes(int16 x) = int16(swapBytes(uint16(x)));

/* TODO: leftovers
define Lo32(int64 a) = int32(a);					// Lo32 part
define Hi32(int64 a) = Lo32(int64.Shr(a, 32));		// Hi32 part
define Lo16(int32 a) = int32(a & 0xffff);			// Lo16 part
define Hi16(int32 a) = Lo16(a >> 16);				// Hi16 part
define Lo8(int32 a) = int32(a & 0xff);				// Lo16 part
define Hi8(int32 a) = Lo8(a >> 8);					// Hi16 part
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
*//// Complex number
struct Complex {

	/// The real component of a complex number.
	const float64 re;

	/// The imaginary component of a complex number.
	const float64 im = 0;

	/* TODO: implement enumerations
	enum: Complex {
		zero: { re: 0 };	// 0 + 0i
		unit: { re: 1 };	// 1 + 0i
	}*/
}

/* TODO: implement inline initializer
// constructing a complex number
inline Complex(float64 re) = { re: re };
inline Complex(float64 re, float64 im) = { re: re, im: im };
*/

///@public
Complex Complex(float64 re) {
	return {
		re: re;
	};
}

///@public
Complex Complex(float64 re, float64 im) {
	return {
		re: re;
		im: im;
	};
}

/* TODO: implement operator overloading
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
inline /(float64 a, Complex b) = div(Complex(a), b);
*/

///@public: Complex(-a.re, -a.im);
inline neg(Complex a) = Complex(emit(struct(a), neg.p2d));

///@public: Complex(a.re + b.re, a.im + b.im);
inline add(Complex a, Complex b) = Complex(emit(struct(a), struct(b), add.p2d));
///@public
inline add(Complex a, float64 b) = Complex(a.re + b, a.im);
///@public
inline add(float64 a, Complex b) = Complex(a + b.re, b.im);

///@public: Complex(a.re - b.re, a.im - b.im);
inline sub(Complex a, Complex b) = Complex(emit(struct(a), struct(b), sub.p2d));
///@public
inline sub(Complex a, float64 b) = Complex(a.re - b, a.im);
///@public
inline sub(float64 a, Complex b) = Complex(a - b.re, b.im);

///@public: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline mul(Complex a, Complex b) = Complex(emit(
	struct(a), struct(b), swz.x2, mul.p2d, add.f64,
	struct(a), struct(b), mul.p2d, swz.x2, sub.f64
));
///@public
inline mul(Complex a, float64 b) = Complex(a.re * b, a.im * b);
///@public
inline mul(float64 a, Complex b) = Complex(a * b.re, a * b.im);

///@public
Complex div(Complex a, Complex b) {
	// Adapted from Numerical Recipes in C - The Art of Scientific Computing
	// ISBN 0-521-43108-5

	if (Math.abs(b.re) >= Math.abs(b.im)) {
		float64 r = b.im / b.re;
		float64 den = b.re + r * b.im;
		return {
			re: (a.re + r * a.im) / den;
			im: (a.im - r * a.re) / den;
		};
	}
	float64 r = b.re / b.im;
	float64 den = b.im + r * b.re;
	return {
		re: (a.re * r + a.im) / den;
		im: (a.im * r - a.re) / den;
	};
}

///@public
inline div(Complex a, float64 b) = div(a, Complex(b));
///@public
inline div(float64 a, Complex b) = div(Complex(a), b);

///@public
inline abs(Complex a) = float64.sqrt(a.re * a.re + a.im * a.im);
///@public
inline arg(Complex a) = float64.atan2(a.re, a.im);

/// Reciprocal of a complex number (1 / a)
Complex inv(Complex a) {
	float64 d = a.re * a.re + a.im * a.im;
	return {
		re: +a.re / d;
		im: -a.im / d;
	};
}

///@public
inline conj(Complex a) = Complex(a.re, -a.im);

///@public
inline exp(Complex a) = Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));

///@public
inline log(Complex a) = Complex(float64.log(abs(a)), arg(a));

///@public
Complex pow(Complex a, Complex b) {
	float64 r = abs(a);
	float64 t = arg(a);
	float64 u = b.re * t + b.im * float64.log(r);
	float64 v = float64.pow(r, b.re) * float64.exp(-b.im * t);
	return {
		re: v * float64.cos(u);
		im: v * float64.sin(u);
	};
}
///@public
inline pow(Complex a, float64 b) = pow(a, Complex(b));

///@public
inline sin(Complex a) = Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
///@public
inline cos(Complex a) = Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));

/* TODO: implement operator overloading
inline tan(Complex a) = sin(a) / cos(a);
inline cot(Complex a) = cos(a) / sin(a);

inline sinh(Complex a) = (exp(a) - exp(-a)) / 2;
inline cosh(Complex a) = (exp(a) + exp(-a)) / 2;
inline tanh(Complex a) = (exp(2 * a) - 1) / (exp(2 * a) + 1);
inline coth(Complex a) = (exp(2 * a) + 1) / (exp(2 * a) - 1);
*/

///@public
inline tan(Complex a) = div(sin(a), cos(a));
///@public
inline cot(Complex a) = div(cos(a), sin(a));

///@public
inline sinh(Complex a) = div(sub(exp(a), exp(neg(a))), 2);
///@public
inline cosh(Complex a) = div(add(exp(a), exp(neg(a))), 2);
///@public
inline tanh(Complex a) = div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
///@public
inline coth(Complex a) = div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));

///@public
inline sec(Complex a) = inv(cos(a));
///@public
inline csc(Complex a) = inv(sin(a));
///@public
inline sech(Complex a) = inv(cosh(a));
///@public
inline csch(Complex a) = inv(sinh(a));

///@public
inline toCartesian(Complex x) = Complex(x.re * float64.cos(x.im), x.re * float64.sin(x.im));
///@public
inline toPolar(Complex x) = Complex(abs(x), arg(x));
/// A 4d vector (4x float32)
struct vec4f: 0 {
	struct {
		/// X component of the vector
		float32 x;
		/// Y component of the vector
		float32 y;
		/// Z component of the vector
		float32 z;
		/// W component of the vector
		float32 w;
	}
	/// Access the components as an array
	float32 data[4];
}

/* TODO: implement inline initializer
// constructing a vector
inline vec4f(float32 x, float32 y, float32 z, float32 w) = { x: x, y: y, z: z, w: w };
inline vec4f(float32 x, float32 y, float32 z) = { x: x, y: y, z: z, w: 0 };
inline vec4f(const vec4f v&, float32 w) = { x: v.x, y: v.y, z: v.z, w: w };
inline vec4f(const float32 val&) = { x: val, y: val, z: val, w: val };
*/

/// Initialize with given x, y, z, w components
inline vec4f(float32 x, float32 y, float32 z, float32 w) = vec4f(emit(struct(w), struct(z), struct(y), struct(x)));

/// Initialize with  (x: x, y: y, z: z, w: 1)
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 1f);

/// Initialize with (x: x, y: y, z: 0, w: 1)
inline vec4f(float32 x, float32 y) = vec4f(x, y, 0f, 1f);

/// Initialize x, y, z components using the components form the given vector, and w with the given value
inline vec4f(vec4f xyz, float32 w) = vec4f(xyz.x, xyz.y, xyz.z, w);

/// Initialize x, y, z, w components with the given scalar value
inline vec4f(float32 val) = vec4f(val, val, val, val);

/* TODO: implement operator overloading
//~ -a => vec4f(-a.x, -a.y, -a.z, -a.w);
inline -(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));

//~ a + b => vec4f(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
inline +(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));

//~ a - b => vec4f(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
inline -(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));

//~ a * b => vec4f(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
inline *(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));

//~ a / b => vec4f(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
inline /(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

inline +(vec4f a, float32 b) = a + vec4f(b);
inline +(float32 a, vec4f b) = vec4f(a) + b;
inline -(vec4f a, float32 b) = a - vec4f(b);
inline -(float32 a, vec4f b) = vec4f(a) - b;
inline *(vec4f a, float32 b) = a * vec4f(b);
inline *(float32 a, vec4f b) = vec4f(a) * b;
inline /(vec4f a, float32 b) = a / vec4f(b);
inline /(float32 a, vec4f b) = vec4f(a) / b;

inline normalize(vec4f v) = v / len(v);
*/

/// Returns a negated copy of the vector.
inline neg(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));
/// Component wise add the two vectors.
inline add(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));
/// Component wise subtract the two vectors.
inline sub(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
/// Component wise multiply the two vectors.
inline mul(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
/// Component wise divide the two vectors.
inline div(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

/// Component wise add vector and scalar.
inline add(float32 a, vec4f b) = add(vec4f(a), b);
/// Component wise add vector and scalar.
inline add(vec4f a, float32 b) = add(a, vec4f(b));

/// Component wise subtract vector and scalar.
inline sub(float32 a, vec4f b) = sub(vec4f(a), b);
/// Component wise subtract vector and scalar.
inline sub(vec4f a, float32 b) = sub(a, vec4f(b));

/// Component wise multiply vector and scalar.
inline mul(float32 a, vec4f b) = mul(vec4f(a), b);
/// Component wise multiply vector and scalar.
inline mul(vec4f a, float32 b) = mul(a, vec4f(b));

/// Component wise divide vector and scalar.
inline div(float32 a, vec4f b) = div(vec4f(a), b);
/// Component wise divide vector and scalar.
inline div(vec4f a, float32 b) = div(a, vec4f(b));

/// Component wise minimum of the two vectors.
inline min(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), min.p4f));
/// Component wise maximum of the two vectors.
inline max(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), max.p4f));

/// Clamp the vector component wise to the range [min ... max]
inline clamp(vec4f vec, vec4f min, vec4f max) = min(max(vec, min), max);

/// Clamp each component of the vector to the range [min ... max]
inline clamp(vec4f vec, float32 min, float32 max) = clamp(vec, vec4f(min), vec4f(max));

/// Dot product of the first 3 elements
// inline dp3(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z;
inline dp3(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp3));

/// Homogeneous dot product
// inline dph(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w;
inline dph(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dph));

/// Dot product
// inline dp4(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
inline dp4(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp4));

/// Cross product of the first 3 elements
inline cross(const vec4f a&, const vec4f b&) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

/// Length of the vector(xyz)
inline length(vec4f v) = float32.sqrt(dp3(v, v));
/// Normalize the vector(xyz)
inline normalize(const vec4f v&) = div(v, vec4f(length(v)));

/// Evaluate as a polynomial in point x
inline eval(const vec4f v&, float32 x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);

/* TODO: leftovers
inline ceq(vec4f x, vec4f y) = emit(ceq.p4f, vec4f(y), vec4f(x));
inline mad(vec4f a, vec4f b, vec4f c) = emit(vec4f, add.p4f, mul.p4f, vec4f(a), vec4f(b), vec4f(c));	// a * b + c

inline lerp(float32 t, vec4f lhs, vec4f rhs) = vec4f(Math.lerp(t, lhs.x, rhs.x), Math.lerp(t, lhs.y, rhs.y), Math.lerp(t, lhs.z, rhs.z), Math.lerp(t, lhs.w, rhs.w));

inline float32(vec4f &vec) = float32(vec.w);
inline bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);
*/// TODO: enum Easing: double(double t) { ... }
static struct Easing {
	float64 Linear(float64 t) {
		return t;
	}

	float64 Quad(float64 t) {
		return t * t;
	}

	float64 Cubic(float64 t) {
		return t * t * t;
	}

	float64 Quart(float64 t) {
		return t * t * t * t;
	}

	float64 Quint(float64 t) {
		return t * t * t * t * t;
	}

	float64 Expo(float64 t) {
		return t == 0 ? 0 : float64.pow(2, 10 * (t - 1));
	}

	float64 Sine(float64 t) {
		return -float64.cos(t * Math.pi / 2) + 1;
	}

	float64 Circle(float64 t) {
		return -(float64.sqrt(1 - t * t) - 1);
	}

	float64 Elastic(float64 t) {
		if (t == 0.0 || t == 1.0) return t;
		t = t - 1.0;
		return - float64.pow(2.0, 10.0 * t) * float64.sin((t - 0.3 / 4.0) * (2.0 * Math.pi) / 0.3) ;
	}

	float64 Back(float64 t) {
		inline s = 1.70158;
		return t * t * ((s + 1) * t - s);
	}

	float64 Bounce(float64 t) {
		static float64 Helper(float64 t, float64 c, float64 a) {
			if (t == 1) {
				return c;
			}
			if (t < (4 / 11.)) {
				return c * (7.5625 * t * t);
			}
			if (t < (8 / 11.)) {
				t -= (6 / 11.);
				return -a * (1 - (7.5625 * t * t + 0.75)) + c;
			}
			if (t < (10 / 11.)) {
				t -= (9 / 11.0f);
				return -a * (1 - (7.5625 * t * t + 0.9375)) + c;
			}
			t -= (21 / 22.);
			return -a * (1 - (7.5625 * t * t + 0.984375)) + c;
		}
		inline a = 1.70158;
		return 1 - Helper(1 - t, 1, a);
	}
}

float64 easeOut(float64 easeIn(float64 ratio), float64 ratio) {
	if (easeIn == null) {
		return ratio;
	}
	return 1. - easeIn(1. - ratio);
}

float64 easeInOut(float64 easeIn(float64 ratio), float64 ratio) {
	if (easeIn == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * easeIn(ratio) : .5 * easeOut(easeIn, ratio - 1) + .5;
}

float64 easeOutIn(float64 easeIn(float64 ratio), float64 ratio) {
	if (easeIn == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * easeOut(easeIn, ratio) : .5 * easeIn(ratio - 1) + .5;
}
/// Perlin noise generator
static struct Perlin {
	inline B = 0x100;
	inline BM = 0xff;
	inline N = 0x1000;
	inline NP = 12;   // 2^N
	inline NM = 0xfff;

	int p[B + B + 2];
	float g3[B + B + 2][3];
	float g2[B + B + 2][2];
	float g1[B + B + 2];

	bool start = true;

	inline sqr(float x) = float(x * x);

	void init() {
		int i;
		System.srand(System.time());
		for (i = 0; i < B ; i += 1) {
			p[i] = i;

			g1[i] = float((System.rand() % (B + B)) - B) / B;

			for (int j = 0 ; j < 2 ; j += 1) {
				g2[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize2(g2[i]);
			float n2 = float64.sqrt(sqr(g2[i][0]) + sqr(g2[i][1]));
			if (n2 != 0) {
				g2[i][0] /= n2;
				g2[i][1] /= n2;
			}

			for (int j = 0 ; j < 3 ; j += 1) {
				g3[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize3(g3[i]);
			float n3 = float64.sqrt(sqr(g3[i][0]) + sqr(g3[i][1]) + sqr(g3[i][1]));
			if (n3 != 0) {
				g3[i][0] /= n3;
				g3[i][1] /= n3;
				g3[i][2] /= n3;
			}
		}

		for ( ; i -= 1; ) {
			int k = p[i];
			int j = System.rand() % B;
			p[i] = p[j];
			p[j] = k;
		}

		for (i = 0 ; i < B + 2 ; i += 1) {
			p[B + i] = p[i];
			g1[B + i] = g1[i];
			for (int j = 0 ; j < 2 ; j += 1) {
				g2[B + i][j] = g2[i][j];
			}
			for (int j = 0 ; j < 3 ; j += 1) {
				g3[B + i][j] = g3[i][j];
			}
		}
	}

	void setup(float vec_i, int b0&, int b1&, float r0&,float r1&) {
		float t = vec_i + N;
		b0 = int(t) & BM;
		b1 = (b0 + 1) & BM;
		r0 = t - int(t);
		r1 = r0 - 1.;
	}

	inline smooth(float32 t) = Math.smooth(t);
	inline lerp(float32 t, float32 a, float32 b) = Math.lerp(t, a, b);

	inline at2(float rx, float ry, int i) = float(rx * g2[i][0] + ry * g2[i][1]);
	inline at3(float rx, float ry, float rz, int i) = float(rx * g3[i][0] + ry * g3[i][1] + rz * g3[i][2]);

	float noise1f(float x) {
		int bx0;
		int bx1;
		float rx0;
		float rx1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);

		float sx = smooth(rx0);
		float u = rx0 * g1[p[bx0]];
		float v = rx1 * g1[p[bx1]];

		return lerp(sx, u, v);
	}
	float noise2f(float x, float y) {
		int bx0;
		int bx1;
		int by0;
		int by1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);

		float a = lerp(sx, at2(rx0, ry0, b00), at2(rx1, ry0, b10));
		float b = lerp(sx, at2(rx0, ry1, b01), at2(rx1, ry1, b11));

		return lerp(sy, a, b);
	}
	float noise3f(float x, float y, float z) {

		int bx0;
		int bx1;
		int by0;
		int by1;
		int bz0;
		int bz1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;
		float rz0;
		float rz1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);
		setup(z, &bz0, &bz1, &rz0, &rz1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);
		float sz = smooth(rz0);

		float a;
		float b;
		float c;
		float d;
		float u;
		float v;

		u = at3(rx0, ry0, rz0, b00 + bz0);
		v = at3(rx1, ry0, rz0, b10 + bz0);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz0, b01 + bz0);
		v = at3(rx1, ry1, rz0, b11 + bz0);
		b = lerp(sx, u, v);

		c = lerp(sy, a, b);

		u = at3(rx0, ry0, rz1, b00 + bz1);
		v = at3(rx1, ry0, rz1, b10 + bz1);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz1, b01 + bz1);
		v = at3(rx1, ry1, rz1, b11 + bz1);
		b = lerp(sx, u, v);

		d = lerp(sy, a, b);

		return lerp(sz, c, d);
	}

	inline noise(float x) = noise1f(x);
	inline noise(float x, float y) = noise2f(x, y);
	inline noise(float x, float y, float z) = noise3f(x, y, z);
}
/// A 2d vector (2x float64)
struct vec2d: 0 {
	struct {
		/// X component of the vector
		float64 x;
		/// Y component of the vector
		float64 y;
	}
	/// Access the components as an array
	float64 data[2];
}

/// Initialize with given x, y components
vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}

/// Component wise add the two vectors.
inline add(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), add.p2d));

/// Component wise subtract the two vectors.
inline sub(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), sub.p2d));

/// Component wise multiply the two vectors.
inline mul(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), mul.p2d));

/// Component wise divide the two vectors.
inline div(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), div.p2d));

/// Component wise select the minimum from the two vectors.
inline min(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), min.p2d));

/// Component wise select the maximum from the two vectors.
inline max(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), max.p2d));

/// Compare the two vectors for equality.
inline ceq(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), ceq.p2d));

/// Dot product of thw two vectors
inline dot(const vec2d a&, const vec2d b&) = a.x * b.x + a.y * b.y;
/// emulated implementation of transform function
void transform(Image surf, const Rect rect&, Image src, const Rect roi&, int32 interpolate, float32 mat[16]) {
	Rect dRec = {
		x: rect != null ? rect.x : 0;
		y: rect != null ? rect.y : 0;
		w: rect != null ? rect.w : surf.width();
		h: rect != null ? rect.h : surf.height();
	};
	Rect sRec = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};

	float32 xx = mat != null ? mat[0] : float32(sRec.w) / dRec.w;
	float32 xy = mat != null ? mat[1] : 0;
	float32 xt = mat != null ? mat[3] : sRec.x;
	float32 yy = mat != null ? mat[5] : float32(sRec.h) / dRec.h;
	float32 yx = mat != null ? mat[4] : 0;
	float32 yt = mat != null ? mat[7] : sRec.y;

	if (!surf.clip(&dRec)) {
		// nothing to set
		return;
	}

	if (!src.clip(&sRec)) {
		// nothing to get
		return;
	}

	for (int y = 0; y < dRec.h; y += 1) {
		int dy = dRec.y + y;
		float32 sy = sRec.y + y;
		for (int x = 0; x < dRec.w; x += 1) {
			int dx = dRec.x + x;
			float32 sx = sRec.x + x;
			float32 tx = (xx * sx + xy * sy + xt) / src.width();
			float32 ty = (yx * sx + yy * sy + yt) / src.height();
			surf.set(dx, dy, argb(src.tex(tx, ty)));
		}
	}
}
/// emulated implementation of blur function
void blur(Image img, int radius, double sigma) {
	static double gauss(double x, double sigma) {
		inline SQRT_2_PI_INV = 0.398942280401432677939946059935;
		double t = x / sigma;
		/*switch (dx) {
			default:
				break;
			case -1:
				return 1;
			case 0:
				return SQRT_2_PI_INV * exp(-0.5*t*t) / sigma;
			case 1:
				return -x * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma);
			case 2:
				return (x * x - sigma * sigma) * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma * sigma * sigma);
		}*/
		return SQRT_2_PI_INV * double.exp(-0.5 * t * t) / sigma;
	}

	int32 kernel[1024] = {};
	int size = radius * 2 + 1;
	assert(size < kernel.length);

	float64 kernelSum = 0;
	float64 kernelFlt[kernel.length] = {};
	for (int i = 0; i < size; i += 1) {
		kernelFlt[i] = gauss(radius - i, sigma);
		kernelSum += kernelFlt[i];
	}

	for (int i = 0; i < size; i += 1) {
		kernel[i] = 65536 * (kernelFlt[i] / kernelSum);
	}

	int width = img.width();
	int height = img.height();

	Image tmp = Image(width, height, img.depth());

	// x direction: inout -> temp
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _x = x + i - radius;
				if (_x >= 0 && _x < width) {
					argb col = argb(img.get(_x, y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			tmp.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	// y direction: temp -> inout
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _y = y + i - radius;
				if (_y >= 0 && _y < height) {
					argb col = argb(tmp.get(x, _y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			img.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	tmp.destroy();
}
/// emulated implementation of blend function
void blend(Image surf, int32 x0, int32 y0, const Image src, const Rect roi&, int32 alpha, bool dstAlpha, vec4f blend(vec4f base, vec4f with)) {
	int width = surf.width();
	int height = surf.height();

	assert(!dstAlpha, "not implemented");
	assert(roi == null, "not implemented");

	inline lrp(int32 l, int32 r) = int32(l + alpha * (r - l) / 255);
	if (blend == null) {
		for (int y = 0; y < height; y += 1) {
			for (int x = 0; x < width; x += 1) {
				argb col = argb(surf.get(x,y));
				int r = rch(col);
				int g = gch(col);
				int b = bch(col);

				col = argb(src.get(x,y));
				r = lrp(r, rch(col));
				g = lrp(g, gch(col));
				b = lrp(b, bch(col));

				surf.set(x + x0, y + y0, argb(r, g, b));
			}
		}
		return;
	}

	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			argb col = argb(surf.get(x,y));
			int r = rch(col);
			int g = gch(col);
			int b = bch(col);

			col = argb(blend(vec4f(col), vec4f(argb(src.get(x,y)))));
			r = lrp(r, rch(col));
			g = lrp(g, gch(col));
			b = lrp(b, bch(col));

			surf.set(x + x0, y + y0, argb(r, g, b));
		}
	}
}
/// Create an image with the given with, height and depth
inline Image(int width, int height, int depth) = Image.create(width, height, depth);

/// Create an image by copying another one
Image Image(Image copy) {
	Image result = Image.create(copy.width(), copy.height(), copy.depth());
	result.copy(0, 0, copy, null);
	return result;
}

/// Create an image by copying another one using a custom aspect ratio
Image Image(Image copy, float64 aspect) {
	int width = copy.width();
	if (aspect > 0) {
		width = copy.height() * aspect;
	}
	Image result = Image.create(width, copy.height(), copy.depth());
	result.transform(null, copy, null, 1, null);
	return result;
}

/// Create an image by opening an image file
Image Image(const char fileName[*], int depth) {
	if (fileName.endsWith(".jpeg", ignCaseCmp)) {
		return Image.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".jpg", ignCaseCmp)) {
		return Image.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".png", ignCaseCmp)) {
		return Image.openPng(fileName, depth);
	}
	if (fileName.endsWith(".bmp", ignCaseCmp)) {
		return Image.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}

/// Create an image by opening an image file
inline Image(const char fileName[*]) = Image(fileName, 32);

/// Create an image by opening an image file with custom width and height
Image Image(const char fileName[*], int width, int height, int depth, int align, float64 maxScale) {
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: left + right;
		fitHorizontal: top + bottom;
		fill: 0x10;
		highRes: 0x20;
	}

	float64 scale = 1;
	Image image = Image(fileName, depth);
	Image result = Image(width, height, depth);

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;

	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	if (fitWidth && fitHeight) {
		float64 widthScale = width / float64(image.width());
		float64 heightScale = height / float64(image.height());
		if (align & fill) {
			scale = Math.max(widthScale, heightScale);
		} else {
			scale = Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / float64(image.width());
	}
	else if (fitHeight) {
		scale = height / float64(image.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	float64 tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - image.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - image.width() * scale);
	}

	float64 ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - image.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - image.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	result.transform(null, image, null, align & highRes ? 1 : 0, mat.data);
	image.destroy();
	return result;
}

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth, int align) = Image(fileName, width, height, depth, align, Math.inf);

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth) = Image(fileName, width, height, depth, -1, Math.inf);

/// Set the the color of a pixel at the given position
inline set(Image image, int32 x, int32 y, argb color) = Image.set(image, x, y, uint32(color));

/// apply the 2d lookup table to the image
inline colorMap(Image image, const Rect roi&, const argb lut[256]) = Image.colorMap(image, roi, pointer(lut));

///@public
inline resize(Image image, const Rect rect&, const Image src, const Rect roi&, int interpolate) = Image.transform(image, rect, src, roi, interpolate, null);

///@public
inline slice(Image image, const Rect rect&) = Image.slice(Image(0, 0, image.depth()), image, rect);

///@public
bool clip(Image src, Rect roi&) {

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < 0) {
		roi.x = 0;
	}

	if (roi.y < 0) {
		roi.y = 0;
	}

	int width = src.width();
	if (roi.w > width) {
		roi.w = width;
	}

	int height = src.height();
	if (roi.h > height) {
		roi.h = height;
	}

	roi.w -= roi.x;
	roi.h -= roi.y;

	if (roi.w <= 0) {
		return false;
	}
	if (roi.h <= 0) {
		return false;
	}
	return true;
}

/// Fill the entire image with the given color
inline fill(Image image, uint32 color) = image.fillRect(0, 0, 65536, 65536, color);
/// Fill the given region of the image with the given color
inline fill(Image image, const Rect roi&, uint32 color) = image.fillRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
/// Fill the given region and padding of the image with the given color
inline fill(Image image, const Rect roi&, int pad, uint32 color) = image.fillRect(roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, color);

///@public
inline drawRect(Image image, const Rect roi&, uint32 color) = image.drawRect(roi.x, roi.y, roi.x + roi.w - 1, roi.y + roi.h - 1, color);

/// Fill the surface by evaluating the given function for each pixel
void eval(Image image, const Rect roi&, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	Rect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : image.width();
		h: roi != null ? roi.h : image.height();
	};

	if (!image.clip(&rect)) {
		return;
	}

	float32 w = image.width();
	float32 h = image.height();
	if (aspect == 0) {
		aspect = w / h;
	}
	h *= aspect;
	vec4f in = {
		x: 0;
		y: 0;
		z: 0;
		w: time;
	};
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		in.y = y / h;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			in.x = x / w;
			image.set(x, y, argb(eval(in)));
		}
	}
}

///@public
void tile(Image image, int x, int y, Image src, Rect roi&) {
	Rect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};

	if (!src.clip(&rect)) {
		return;
	}

	if (x < 0) {
		x = -(-x % rect.w);
	}
	if (y < 0) {
		y = -(-y % rect.h);
	}
	int width = image.width();
	int height = image.height();
	for (int j = y; j < height; j += rect.h) {
		for (int i = x; i < width; i += rect.w) {
			image.copy(i, j, src, rect);
		}
	}
}
struct Camera {
	vec4f position = vec4f(0, 0, 0, 1);
	vec4f forward = vec4f(0, 0, 0, 1);
	vec4f right = vec4f(0, 0, 0, 1);
	vec4f up = vec4f(0, 1, 0, 1);

	/// create an orthographic or perspective projection matrix
	static mat4f projection(float32 fov, float32 asp, float32 n, float32 f) {
		float32 bot = 1;
		float32 nf = n - f;

		if (fov == 0) {
			// orthographic
			return {
				x: vec4f(1 / asp, 0,       0,      0);
				y: vec4f(0,       1 / bot, 0,      0);
				z: vec4f(0,       0,       2 / nf, -(f+n) / nf);
				w: vec4f(0,       0,       0,      1);
			};
		}

		// perspective
		bot = float32.tan(Math.radians(fov));
		asp *= bot;

		return {
			x: vec4f(n / asp, 0,       0,          0);
			y: vec4f(0,       n / bot, 0,          0);
			z: vec4f(0,       0,       (n+f) / nf, -2 * n * f / nf);
			w: vec4f(0,       0,       1,          0);
		};
	}

	// create a rotation matrix
	static mat4f rotation(vec4f dir, float ang) {
		float sin_t = float64.sin(ang);
		float cos_t = float64.cos(ang);
		float one_c = 1. - cos_t;
		vec4f tmp = mul(dir, sin_t);

		float xx = dir.x * dir.x;
		float yy = dir.y * dir.y;
		float zz = dir.z * dir.z;
		float xy = dir.x * dir.y;
		float xz = dir.x * dir.z;
		float yz = dir.y * dir.z;

		return {
			xx: one_c * xx + cos_t;
			xy: one_c * xy - tmp.z;
			xz: one_c * xz + tmp.y;
			xw: 0;

			yx: one_c * xy + tmp.z;
			yy: one_c * yy + cos_t;
			yz: one_c * yz - tmp.x;
			yw: 0;

			z: {
				x: one_c * xz - tmp.y;
				y: one_c * yz + tmp.x;
				z: one_c * zz + cos_t;
				w: 0;
			};

			w: vec4f(0., 0., 0., 1.);
		};
	}

	// create a translation matrix
	static mat4f translation(vec4f dir, float cnt) {
		vec4f tmp = mul(dir, vec4f(cnt));
		return {
			x: vec4f(1, 0, 0, tmp.x);
			y: vec4f(0, 1, 0, tmp.y);
			z: vec4f(0, 0, 1, tmp.z);
			w: vec4f(0, 0, 0, tmp.w);
		};
	}

	/// Create a camera at the given `position` looking at the given `target`
	static Camera lookAt(vec4f position, vec4f target, vec4f up) {
		vec4f forward = normalize(sub(target, position));
		vec4f right = normalize(cross(up, forward));
		return {
			position: position;
			forward: forward;
			right: right;
			up: cross(forward, right);
		};
	}

	/// get the matrix of the camera, which can be multiplied with the projection matrix
	static mat4f matrix(const Camera camera&) {
		return {
			x: camera.forward;
			y: camera.right;
			z: camera.up;
			w: vec4f(0, 0, 0, 1);
		};
	}

	/// get the matrix of the camera multiplied with the projection matrix
	static mat4f matrix(const mat4f projection&, const Camera camera&) {
		return projection.mul(camera.matrix());
	}

	/// Move the camera in the given `direction` with the given `amount`
	static void move(Camera camera&, vec4f direction, float32 amount) {
		camera.position = add(camera.position, mul(direction, amount));
	}

	/// Rotate the camera in the given `direction` with the given `amount`
	static void rotate(Camera camera&, vec4f direction, float32 amount) {
		if (amount == 0) {
			return;
		}

		// rotate the camera
		mat4f matrix = rotation(direction, amount);
		camera.forward = normalize(dp3(matrix, camera.forward));
		camera.right = normalize(dp3(matrix, camera.right));
		camera.up = cross(camera.forward, camera.right);
	}

	/// Rotate the camera around the `orbit` in the given `direction` with the given `amount`
	static void rotate(Camera camera&, vec4f orbit, vec4f direction, float32 amount) {
		if (amount == 0) {
			return;
		}

		rotate(&camera, direction, amount);
		// orbit the camera around the given position
		// it is usually the camera position, or the target position
		float dist = length(sub(orbit, camera.position));
		mat4f matrix = translation(camera.forward, -dist);
		camera.position = dph(matrix, orbit);
	}
}
/// Create a mesh by opening a file
Mesh Mesh(const char fileName[*]) {
	if (fileName.endsWith(".obj", ignCaseCmp)) {
		return Mesh.openObj(fileName);
	}
	if (fileName.endsWith(".3ds", ignCaseCmp)) {
		return Mesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
// micro ui, TODO: add comments

struct Style {
	const Image font;

	const FormatFlags flagsInt;
	const FormatFlags flagsFlt;

	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;

	int border = 3;
	int padding = 8;

	enum: int32 {
		left: 1;
		right: 2;

		top: 4;
		bottom: 8;

		center: 0;

		fitVertical: left + right;
		fitHorizontal: top + bottom;
	}

	/// Align one rect containing text relative to its container
	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*], int align) {
		rect.x += this.padding;
		rect.y += this.padding;
		rect.w -= 2 * this.padding;
		rect.h -= 2 * this.padding;
		this.font.clipText(&valueRect, value);

		if (valueRect.w > rect.w) {
			valueRect.w = rect.w;
		}

		int vertical = align & fitVertical;
		if (vertical == center) {
			valueRect.x = rect.x + (rect.w - valueRect.w) / 2;
		}
		else if (vertical == right) {
			valueRect.x = rect.x + (rect.w - valueRect.w);
		}
		else if (vertical == left) {
			valueRect.x = rect.x;
		}
		else { // fit
			valueRect.x = rect.x;
			valueRect.w = rect.w;
		}

		int horizontal = align & fitHorizontal;
		if (horizontal == center) {
			valueRect.y = rect.y + (rect.h - valueRect.h) / 2;
		}
		else if (horizontal == bottom) {
			valueRect.y = rect.y + (rect.h - valueRect.h);
		}
		else if (horizontal == top) {
			valueRect.y = rect.y;
		}
		else { // fit
			valueRect.y = rect.y;
			valueRect.h = rect.h;
		}
	}

	//- private debug function
	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*], int align, Image offs) {
		enum: uint32 {
			// chromium inspector colors
			margin: 0xf9cc9d; //dark: 0xae8152;
			border: 0xffeebc; //dark: 0xe3c381;
			padding: 0xc3d799; //dark: 0xb6c373;
			content: 0x8cb7c5; //dark: 0x87b1bc;
		}
		align(&this, rect, &valueRect, value, align);
		offs.fill(valueRect, this.padding, padding);
		offs.fill(valueRect, content);
	}// */
}
struct KeyEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int key;
}
struct MouseEvent {
	const Rect clientRect&;
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int button;
	const int dx = 0;
	const int dy = 0;
	const int x;
	const int y;
}

struct View: object {
	const int height = 0;
	const int group = 0;
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onMouseEvent(View this, const MouseEvent event&) = null;
	bool onClick(View this) {
		return true;
	}
	bool onReset(View this) = null;
}

struct Button: View {
	const char text[*];
	/* FIXME: do the override, use this method as default initializer
	// TODO: override or overload: bool onClick(Button this) { ... }
	bool onClick(Button this) {
		View.onClick(this);   // call super
		trace("onClick", this);
		return this.enabled;
	}// */

	void onDraw(Button this, Image offs, Rect rect, const Style style&) {
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Switch: View {
	const char text[*];
	/* TODO: allow selecting one out of multiple choices
	const char choices[*][] = {
		"off",
		"on"
	};
	int selected = 0;*/

	const char on[*] = "on";
	const char off[*] = "off";

	bool checked = false;
	const bool resetValue = false;

	bool onUpdate(Switch this, bool checked) {
		this.checked = checked;
		return true;
	}

	void onDraw(Switch this, Image offs, Rect rect, const Style style&) {
		Rect valueRoi = rect;
		char value[*] = this.checked ? this.on : this.off;

		Style.align(style, valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Slider: View {
	const char text[*];
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 0;
	const int resetValue = 0;

	bool onUpdate(Slider this, int value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		if (this.value == value) {
			return false;
		}
		this.value = value;
		return true;
	}

	void onDraw(Slider this, Image offs, Rect rect, const Style style&) {
		Rect valueRoi = rect;
		char value[64] = {0};
		if (this.divisor != 0) {
			float32 valueF64 = float64(this.value) / this.divisor;
			value.append(0, valueF64, style.flagsFlt);
		} else {
			value.append(0, this.value, style.flagsInt);
		}

		Style.align(style, valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}

	static float64 valFlt(Slider slider&) {
		float64 value = slider.value;
		if (slider.divisor != 0) {
			return value / slider.divisor;
		}
		return value / (slider.maximum - slider.minimum);
	}
}

struct Histogram: View {
	const bool lines = false;
	// histogram data is in alpha channel, display it with color rgb
	bool color = false;
	argb data[256] = null;   // FIXME: this should be not possible

	void update(Histogram this, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = argb(idx, value, value, value);
		return true;
	}

	void onDraw(Histogram this, Image offs, const Rect rect, const Style style&) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		int px = (rect.w - 256) / 2;
		if (this.lines) {
			int y = rect.y + rect.h - 1;
			int pb = bch(this.data[0]) * rect.h / 256;
			int pg = gch(this.data[0]) * rect.h / 256;
			int pr = rch(this.data[0]) * rect.h / 256;
			int pl = ach(this.data[0]) * rect.h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				int bv = bch(data) * rect.h / 256;
				int gv = gch(data) * rect.h / 256;
				int rv = rch(data) * rect.h / 256;
				int lv = ach(data) * rect.h / 256;

				if (this.color) {
					offs.drawLine(x, y - pl, x, y - lv, uint32(data));
				} else {
					offs.drawLine(x, y - pb, x, y - bv, colB);
					offs.drawLine(x, y - pg, x, y - gv, colG);
					offs.drawLine(x, y - pr, x, y - rv, colR);
					offs.drawLine(x, y - pl, x, y - lv, colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		} else {
			for (int i = 0; i < this.data.length; i += 1) {
				argb data = this.data[i];
				if (this.color) {
					int x = rect.x + i + px;
					int y1 = rect.y + rect.h;
					int y0 = y1 - ach(data) * rect.h / 256;
					offs.fillRect(x, y0 - 1, x + 1, y1, uint32(data));
				} else {
					int x = rect.x + px + i;
					int bv = bch(data) * rect.h / 256;
					int gv = gch(data) * rect.h / 256;
					int rv = rch(data) * rect.h / 256;
					int lv = ach(data) * rect.h / 256;
					for (int y = 0; y < rect.h; y += 1) {
						uint32 b = colB * uint32(y < bv);
						uint32 g = colG * uint32(y < gv);
						uint32 r = colR * uint32(y < rv);
						uint32 l = colL * uint32(y < lv);
						offs.set(x, rect.h - y + rect.y - 1, r | g | b | l);
					}
				}
			}
		}
	}
}

void onInit(View this) {
	// FIXME: dispatch using inheritance and override
	if (Histogram item = this.as(Histogram)) {
		for (int i = 0; i < 256; i += 1) {
			item.data[i] = argb(i, i, i, i);
		}
		return;
	}
	if (Slider item = this.as(Slider)) {
		Slider.onUpdate(item, item.value);// clamp initial value
		int resetValue& = pointer(item.resetValue);
		resetValue = item.value;
		return;
	}
	if (Switch item = this.as(Switch)) {
		bool resetValue& = pointer(item.resetValue);
		resetValue = item.checked;
		return;
	}
	if (Button item = this.as(Button)) {
		return;
	}
	abort("invalid view", this);
}
bool onReset(View this) {
	if (this.onReset != null) {
		return this.onReset(this);
	}
	// FIXME: dispatch using inheritance and override
	if (Histogram item = this.as(Histogram)) {
		if (item.onUpdate == null) {
			return false;
		}
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= item.onUpdate(i, i);
		}
		return result;
	}
	if (Slider item = this.as(Slider)) {
		if (item.onUpdate == null) {
			return false;
		}
		return item.onUpdate(item.resetValue);
	}
	if (Switch item = this.as(Switch)) {
		if (item.onUpdate == null) {
			return false;
		}
		return item.onUpdate(item.resetValue);
	}
	if (Button item = this.as(Button)) {
		return false;
	}
	abort("invalid view", this);
	return false;
}
bool onEvent(View this, const KeyEvent event&) {
	// FIXME: dispatch using inheritance and override
	if (!event.release) {
		return false;
	}
	if (Histogram item = this.as(Histogram)) {
		if (event.key == ' ' || event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Slider item = this.as(Slider)) {
		if (event.key == '+' || event.key == '=') {
			if (item.onUpdate == null) {
				return false;
			}
			return item.onUpdate(item.value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			if (item.onUpdate == null) {
				return false;
			}
			return item.onUpdate(item.value - (event.isShift ? 1 : 10));
		}
		if (event.key == ' ' || event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Switch item = this.as(Switch)) {
		if (event.key == ' ') {
			if (item.onUpdate != null) {
				item.onUpdate(!item.checked);
			}
			return item.onClick();
		}
		if (event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Button item = this.as(Button)) {
		if (event.key == ' ') {
			return item.onClick();
		}
		return false;
	}
	abort("invalid view", this);
	return false;
}
bool onEvent(View this, const MouseEvent event&) {
	if (this.onMouseEvent != null) {
		return this.onMouseEvent(event);
	}

	// FIXME: dispatch using inheritance and override
	if (Histogram item = this.as(Histogram)) {
		if (event.release) {
			if (event.repeat > 1) {
				// double click to reset
				return item.onReset();
			}
			return item.onClick();
		}
		if (item.onUpdate == null) {
			return false;
		}

		const Rect rect& = event.clientRect;
		int x0 = event.x - rect.x;
		int x1 = x0 + event.dx;
		int y0 = event.y - rect.y;
		int y1 = y0 + event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.h;
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			item.onUpdate(x, val);
			y += dy;
		}
		return true;
	}
	if (Slider item = this.as(Slider)) {
		if (event.release) {
			if (event.repeat > 1) {
				// double click to reset
				return item.onReset();
			}
			return item.onClick();
		}
		if (item.onUpdate == null) {
			return false;
		}
		if (event.dy == 0) {
			// do not update to the same value
			return false;
		}
		return item.onUpdate(item.value + event.dy);
	}
	if (Switch item = this.as(Switch)) {
		if (event.release) {
			if (item.onUpdate != null) {
				item.onUpdate(!item.checked);
			}
			return item.onClick();
		}
		return false;
	}
	if (Button item = this.as(Button)) {
		if (event.release) {
			if (event.repeat > 1) {
				// double click to reset
				return item.onReset();
			}
			return item.onClick();
		}
		return false;
	}
	abort("invalid view", this);
	return false;
}
void onMeasure(View this, Rect rect&, const Style style&) {
	// FIXME: dispatch using inheritance and override
	if (Histogram item = this.as(Histogram)) {
		if (item.height == 0) {
			rect.h = 128;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Slider item = this.as(Slider)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Switch item = this.as(Switch)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Button item = this.as(Button)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		}
		else if (item.text == null) {
			// TODO: remove hack: empty button used for separator
			rect.h = item.height + style.padding;
		}
		else {
			rect.h = item.height;
		}
		return;
	}
	if (typename(item) == View) {
		rect.h = this.height;
		return;
	}
	abort("invalid view", this);
}
bool onDraw(View view, Image offs, const Rect rect&, const Style style&) {
	// FIXME: dispatch using inheritance and override
	if (Histogram item = view.as(Histogram)) {
		return item.onDraw(item, offs, rect, style);
	}
	if (Slider item = view.as(Slider)) {
		return item.onDraw(item, offs, rect, style);
	}
	if (Switch item = view.as(Switch)) {
		return item.onDraw(item, offs, rect, style);
	}
	if (Button item = view.as(Button)) {
		return item.onDraw(item, offs, rect, style);
	}
	abort("invalid view", view);
}

struct Layout: object {
	Style style;
	Image offs;
	Rect rect;

	bool visible = true;
	bool measure = true;
	int selectedIndex = -1;
	int activeIndex = -1;
	bool colorPick = false;
	View views[64] = null;
	Rect rects[64] = null;
	int items = 0;
	int group = 0;

	static bool isActive(const Layout layout&, View views...) {
		View active = layout.activeIndex < 0 ? null : layout.views[layout.activeIndex];
		for (int i = 0; i < views.length; i += 1) {
			if (views[i] == active) {
				return true;
			}
		}
		return false;
	}
	static bool isSelected(const Layout layout&, View items...) {
		View selected = layout.selectedIndex < 0 ? null : layout.views[layout.selectedIndex];
		for (int i = 0; i < items.length; i += 1) {
			if (items[i] == selected) {
				return true;
			}
		}
		return false;
	}

	static View getSelected(const Layout layout&) {
		if (layout.selectedIndex < 0) {
			return null;
		}
		return layout.views[layout.selectedIndex];
	}
	static bool setSelected(Layout layout&, View view) {
		if (view == null) {
			layout.selectedIndex = -1;
			return true;
		}
		for (int i = 0; i < layout.items; i += 1) {
			if (layout.views[i] == view) {
				layout.selectedIndex = i;
				return true;
			}
		}
		return false;
	}
	static bool setGroup(Layout layout&, int group) {
		if (layout.group != group) {
			layout.group = group;
			layout.measure = true;
			return true;
		}
		return false;
	}

	static bool onEvent(Layout layout&, int action, int button, int x, int y) {
	struct Mouse {
		int32 clicks;   // click count
		int64 time;     // old clock
		int32 btn;      // old button
		int32 x;        // old x coord
		int32 y;        // old y coord

		static int click(Mouse old&, int btn, int x, int y) {
			if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
				// reset values
				old.clicks = 1;
				old.time = System.millis();
				old.btn = btn;
				old.x = x;
				old.y = y;
				return 0;
			}
			if (btn == 0) {
				// release button
				// old.time = keep value?;
				// old.btn = keep value?;
				// old.cnt = keep value?;
				return old.clicks;
			}

			int64 now = System.millis();
			if ((now - old.time) / 1000. > .5) {
				// reset counter
				old.clicks = 0;
			}
			old.time = now;
			old.btn = btn;
			old.clicks += 1;
			return old.clicks;
		}
	}

	static int click(Layout layout&, int x, int y) {
		static bool test(const Rect rect&, int x, int y) {
			if (x < rect.x || x >= rect.x + rect.w) {
				return false;
			}
			if (y < rect.y || y >= rect.y + rect.h) {
				return false;
			}
			return true;
		}

		if (!layout.visible) {
			return -1;
		}
		if (!layout.rect.test(x, y)) {
			return -1;
		}
		for (int i = 0; i < layout.items; i += 1) {
			if (!layout.rects[i].test(x, y)) {
				continue;
			}

			View view = layout.views[i];
			if (!view.enabled) {
				return -1;
			}
			return i;
		}
		return -1;
	}
	static bool select(Layout layout&, int index) {
		assert(index >= 0, "invalid selection");
		assert(index < layout.items, "invalid selection");

		View view = layout.views[index];
		if (!view.enabled) {
			return false;
		}
		if (!view.selectable) {
			return false;
		}
		if (layout.group != view.group) {
			if (layout.group != 0) {
				if (view.group != 0) {
					return false;
				}
			}
		}
		layout.selectedIndex = index;
		return true;
	}
	static bool select(Layout layout&, bool prev) {
		layout.activeIndex = -1;
		int selectedIndex = layout.selectedIndex;
		for (int i = 1; i < layout.items; i += 1) {
			int index = selectedIndex + (prev ? -i : i);
			if (index >= layout.items) {
				index -= layout.items;
			}
			else if (index < 0) {
				index += layout.items;
			}
			if (layout.select(index)) {
				return true;
			}
		}
		return false;
	}
	static View active(const Layout layout&) {
		int idx = layout.activeIndex;
		if (idx < 0) {
			idx = layout.selectedIndex;
		}
		if (idx < 0) {
			return null;
		}
		return layout.views[idx];
	}
	static void measure(Layout layout&) {
		int bottom = layout.rect.y;
		for (int i = 0; i < layout.items; i += 1) {
			Rect rect& = layout.rects[i];
			View view = layout.views[i];

			rect.x = layout.rect.x;
			rect.y = bottom;
			rect.w = layout.rect.w;
			rect.h = view.height;

			view.onMeasure(&rect, layout.style);
			if (layout.group != view.group) {
				if (layout.group != 0) {
					if (view.group != 0) {
						rect.h = 0;
					}
				}
			}
			if (rect.h > 0) {
				bottom += rect.h;
			}
		}
		layout.rect.h = bottom - layout.rect.y;
	}
	static void draw(Layout layout&) {
		if (!layout.visible) {
			return;
		}

		// draw background
		if (layout.style.backgroundColor != -1) {
			int b = layout.style.border;
			const Rect r& = layout.rect;
			layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.style.backgroundColor);
		}

		// draw items
		Image offs = layout.offs.slice(null);
		for (int i = 0; i < layout.items; i += 1) {
			View view = layout.views[i];
			const Rect rect& = layout.rects[i];

			if (i == layout.selectedIndex) {
				layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.style.focusedColor);
			}

			if (rect.w > 0 && rect.h > 0) {
				offs.slice(layout.offs, rect);
				Rect rect = {
					x: 0; y: 0;
					w: offs.width();
					h: offs.height();
				};
				view.onDraw(offs, rect, layout.style);
			}

			if (i == layout.activeIndex) {
				layout.offs.drawRect(rect.x, rect.y, rect.x + rect.w - 1, rect.y + rect.h - 1, layout.style.valueColor);
			}
		}
		offs.destroy();
	}

		static Mouse mouse = {};
		static bool isShift;
		static bool isCtrl;
		static bool isAlt;

		layout.colorPick = false;
		if (action == Gui.WINDOW_INIT) {
			layout.selectedIndex = -1;
			layout.measure = true;
			layout.select(false);
			return true;
		}
		if (action == Gui.WINDOW_DRAW) {
			if (layout.measure) {
				layout.measure = false;
				measure(layout);
			}
			layout.draw();
			return true;
		}
		if (action == Gui.WINDOW_ENTER) {
			// do not process event
			return false;
		}
		if (action == Gui.WINDOW_LEAVE) {
			// do not process event
			return false;
		}

		if (action == Gui.FINGER_PRESS) {
			// finger press results also a mouse event
			// skip the finger event
			return false;
		}
		if (action == Gui.FINGER_MOTION) {
			// translate to mouse event
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.FINGER_RELEASE) {
			// finger release results also a mouse event
			// skip the finger event
			return false;
		}

		if (action == Gui.MOUSE_PRESS) {
			Mouse.click(&mouse, button, x, y);
			if (button != 1) {
				return false;
			}
			bool result = false;
			int activeIndex = layout.click(x, y);
			if (layout.activeIndex != activeIndex) {
				// active index changed, most probably from -1
				layout.activeIndex = activeIndex;
				result = true;
			}
			if (activeIndex < 0) {
				// allow update of selected control
				activeIndex = layout.selectedIndex;
				layout.colorPick = true;
				if (activeIndex < 0) {
					return result;
				}
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					x: x;
					y: y;
				};
				if (view.onEvent(event)) {
					return true;
				}
			}
			return result;
		}
		if (action == Gui.MOUSE_MOTION) {
			int ox = mouse.x;
			int oy = mouse.y;
			Mouse.click(&mouse, -1, x, y);
			if (button != 1) {
				return false;
			}
			if (ox == x && oy == y) {
				return false;
			}
			int activeIndex = layout.activeIndex;
			if (activeIndex < 0) {
				// allow update of selected control
				activeIndex = layout.selectedIndex;
				layout.colorPick = true;
				if (activeIndex < 0) {
					return true;
				}
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					dx: ox - x;
					dy: oy - y;
					x: x;
					y: y;
				};
				if (view.onEvent(event)) {
					return true;
				}
			}
			return false;
		}
		if (action == Gui.MOUSE_RELEASE) {
			int btn = mouse.btn;
			Mouse.click(&mouse, 0, x, y);
			if (button != 1) {
				return false;
			}

			bool result = false;
			int activeIndex = layout.activeIndex;
			if (activeIndex >= 0) {
				layout.activeIndex = -1;
				result = true;
			}
			if (activeIndex != layout.click(x, y)) {
				// release on a different view
				return result;
			}
			if (activeIndex < 0) {
				// might be a disabled view
				layout.colorPick = true;
				return result;
			}
			// select / focus the view
			if (layout.select(activeIndex)) {
				result = true;
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: true;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					x: x;
					y: y;
				};
				if (view.onEvent(event)) {
					result = true;
				}
			}
			return result;
		}

		if (action == Gui.KEY_PRESS) {
			isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			if (View view = layout.active()) {
				KeyEvent event = {
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: 0;
					key: button;
				};
				if (view.onEvent(event)) {
					return true;
				}
			}
			if (button == '\t' || button == '\r') {
				// Tab, Enter: select prev or next control.
				return layout.select(isShift);
			}
			if (button == '[' || button == ']') {
				// hide, show controls
				layout.visible = !layout.visible;
				return true;
			}
			if (button == 8 && isShift) {
				for (int i = 0; i < layout.items; i += 1) {
					layout.views[i].onReset();
				}
				return true;
			}
			return false;
		}
		if (action == Gui.KEY_RELEASE) {
			isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			if (View view = layout.active()) {
				KeyEvent event = {
					release: true;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: 0;
					key: button;
				};
				if (view.onEvent(event)) {
					return true;
				}
			}
			return false;
		}

		debug("event not processed", action);
		return false;
	}

	static void draw(Layout layout&) {
		layout.onEvent(Gui.WINDOW_DRAW, 0, 0, 0);
	}
}

Layout Layout(Image offs, int x, int y, Image font, View items...) {
	Layout layout = {
		offs: offs;
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
		style: {
			font: font;
			flagsInt: { padLen: 4 };
			flagsFlt: { padLen: 4, precision: 2 };
		};
	};

	for (int i = 0; i < layout.views.length; i += 1) {
		layout.views[i] = null;
	}

	for (int i = 0; i < items.length; i += 1) {
		assert(i < layout.views.length);
		layout.views[i] = items[i];
		items[i].onInit();
	}
	layout.items = items.length;

	if (y < 0) {
		layout.onEvent(Gui.WINDOW_INIT, 0, 0, 0);
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline getSelected(const Layout layout&, typename type) = layout.getSelected().as(type);
/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
/// an 32 bit argb color
struct argb: 0 {
	/// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;

		/// green component
		uint8 g;

		/// red component
		uint8 r;

		/// alpha component
		uint8 a;
	}
	/*enum {
		Black             : 0x00000000;
		White             : 0x00ffffff;
		Aquamarine        : 0x007fffd4;
		Azure             : 0x00007fff;
		Blue              : 0x000000ff;
		BlueViolet        : 0x008a2be2;
		Brown             : 0x00a52a2a;
		CadetBlue         : 0x005f9ea0;
		Coral             : 0x00ff7f50;
		CornflowerBlue    : 0x006495ed;
		Cyan              : 0x0000ffff;
		DarkGray          : 0x00a9a9a9;
		DarkGrey          : 0x00a9a9a9;
		DarkGreen         : 0x00006400;
		DarkOliveGreen    : 0x00556b2f;
		DarkOrchid        : 0x009932cc;
		DarkSlateBlue     : 0x00483d8b;
		DarkSlateGray     : 0x002f4f4f;
		DarkSlateGrey     : 0x002f4f4f;
		DarkTurquoise     : 0x0000ced1;
		DarkWood          : 0x000d0301;
		DeepPink          : 0x00ff1493;
		DimGray           : 0x00696969;
		DimGrey           : 0x00696969;
		FireBrick         : 0x00b22222;
		ForestGreen       : 0x00228b22;
		Gold              : 0x00ffd700;
		Goldenrod         : 0x00daa520;
		Gray              : 0x00808080;
		Grey              : 0x00808080;
		Green             : 0x00008000;
		GreenYellow       : 0x00adff2f;
		IndianRed         : 0x00cd5c5c;
		Khaki             : 0x00f0e68c;
		LightBlue         : 0x00add8e6;
		LightGray         : 0x00d3d3d3;
		LightGrey         : 0x00d3d3d3;
		LightSteelBlue    : 0x00b0c4de;
		LightWood         : 0x00993d1a;
		Lime              : 0x0000ff00;
		LimeGreen         : 0x0032cd32;
		Magenta           : 0x00ff00ff;
		Maroon            : 0x00800000;
		MedianWood        : 0x004d1f09;
		MediumAquamarine  : 0x0066cdaa;
		MediumBlue        : 0x000000cd;
		MediumForestGreen : 0x006b8e23;
		MediumGoldenrod   : 0x00eaeaad;
		MediumOrchid      : 0x00ba55d3;
		MediumSeaGreen    : 0x003cb371;
		MediumSlateBlue   : 0x007b68ee;
		MediumSpringGreen : 0x0000fa9a;
		MediumTurquoise   : 0x0048d1cc;
		MediumVioletRed   : 0x00c71585;
		MidnightBlue      : 0x00191970;
		Navy              : 0x00000080;
		NavyBlue          : 0x0023238e;
		Orange            : 0x00ffa500;
		OrangeRed         : 0x00ff4500;
		Orchid            : 0x00da70d6;
		PaleGreen         : 0x0098fb98;
		Pink              : 0x00ffc0cb;
		Plum              : 0x00dda0dd;
		Red               : 0x00ff0000;
		Salmon            : 0x00fa8072;
		SeaGreen          : 0x002e8b57;
		Sienna            : 0x00a0522d;
		SkyBlue           : 0x0087ceeb;
		SlateBlue         : 0x006a5acd;
		SpringGreen       : 0x0000ff7f;
		SteelBlue         : 0x004682b4;
		Tan               : 0x00d2b48c;
		Thistle           : 0x00d8bfd8;
		Turquoise         : 0x0040e0d0;
		Violet            : 0x00ee82ee;
		VioletRed         : 0x00cc3299;
		Wheat             : 0x00f5deb3;
		Yellow            : 0x00ffff00;
		YellowGreen       : 0x009acd32;
		//Transparent     : 0xff000000;
	}*/
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = argb(emit(uint32(argb)));
/// cast argb value to unsigned integer
inline uint32(argb value) = uint32(emit(struct(value)));


/// clamp signed gray or color component to fit in 8 bits (0 ... 255)
uint32 clamp_s8(int32 c) {
	if (c < 0) {
		return 0;
	}
	if (c > 255) {
		return 255;
	}
	return c;
}
/// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
uint32 clamp_u8(uint32 c) {
	if (c > 255) {
		return 255;
	}
	return c;
}

// construct a rgb8 gray color from the given value
inline _gray(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = _gray(clamp_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = _gray(clamp_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct an argb color from the given components
inline _argb(uint32 r, uint32 g, uint32 b) = argb(uint32((((r << 8) | g) << 8) | b));
/// construct an argb color from the given components
inline _argb(uint32 a, uint32 r, uint32 g, uint32 b) = argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));

/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = _argb(clamp_s8(r), clamp_s8(g), clamp_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = _argb(clamp_u8(r), clamp_u8(g), clamp_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 a, int32 r, int32 g, int32 b) = _argb(clamp_s8(a), clamp_s8(r), clamp_s8(g), clamp_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 a, uint32 r, uint32 g, uint32 b) = _argb(clamp_u8(a), clamp_u8(r), clamp_u8(g), clamp_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 a, float32 r, float32 g, float32 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 a, float64 r, float64 g, float64 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb color) = int32((uint32(color) >> 24) & 0xff);
/// get the Red channel of the color
inline rch(argb color) = int32((uint32(color) >> 16) & 0xff);
/// get the Green channel of the color
inline gch(argb color) = int32((uint32(color) >> 8) & 0xff);
/// get the Blue channel of the color
inline bch(argb color) = int32(uint32(color) & 0xff);

/// get the luminosity of the color (0.299 * color.r + 0.587 * color.g + 0.114 * color.b)
inline lum(argb color) = int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16);

/// get the hue of the color
uint32 hue(argb rgb) {
	// adapted from: https://gist.github.com/mity/6034000
	int r = rch(rgb);
	int g = gch(rgb);
	int b = bch(rgb);
	int min = r;
	int max = r;

	if (min > g) {
		min = g;
	}
	if (min > b) {
		min = b;
	}
	if (max < g) {
		max = g;
	}
	if (max < b) {
		max = b;
	}

	if (max == min) {
		return 0;
	}

	int hue = 0;
	if (max == r) {
		hue = ((g - b) * 60) / (max - min);
	}
	else if (max == g) {
		hue = ((b - r) * 60) / (max - min) + 120;
	}
	else if (max == b) {
		hue = ((r - g) * 60) / (max - min) + 240;
	}
	if (hue < 0) {
		hue += 360;
	}
	return hue;
}

/// linear interpolate a lookup-table with the given colors
void lerpLut(uint32 lut[], argb colors...) {
	inline lrp(int32 t, uint32 x, uint32 y) = x + (t * (y - x + 1) >> 16);

	int dt = (colors.length - 1 << 16) / (lut.length - 1);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * dt;
		argb c1 = colors[t >> 16];
		argb c2 = colors[(t >> 16) + 1];
		int32 a = lrp(t & 0xffff, ach(c1), ach(c2));
		int32 r = lrp(t & 0xffff, rch(c1), rch(c2));
		int32 g = lrp(t & 0xffff, gch(c1), gch(c2));
		int32 b = lrp(t & 0xffff, bch(c1), bch(c2));
		lut[i] = a << 24 | r << 16 | g << 8 | b;
	}
}

/// linear interpolate a alpha lookup-table with the given colors
void alphaLut(uint32 lut[], int hardness, int alpha, bool reflect) {
	int mid = hardness <= 0 ? -1 : 255;
	int div = 256 - clamp_u8(hardness < 0 ? -hardness : hardness);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * 255 / (lut.length - 1);
		lut[i] = clamp_s8((t - mid) * 255 / div + mid);
		if (alpha < 0) {
			lut[i] = 255 - (255 - lut[i]) * -alpha / 255;
		} else {
			lut[i] = 255 - lut[i] * alpha / 255;
		}
	}
	if (reflect) {
		int end = lut.length - 1;
		int mid = lut.length / 2;
		for (int i = end; i >= mid; i -= 1) {
			lut[i] = lut[end];
			end -= 2;
		}
		for (int i = 0; i < mid; i += 1) {
			lut[i] = lut[lut.length - i - 1];
		}
	}
}

static if (typename(vec4f) != null) {

/// convert an argb color to a floating point vector
inline vec4f(argb rgb) = vec4f(rch(rgb) / 255f, gch(rgb) / 255f, bch(rgb) / 255f, ach(rgb) / 255f);

/// convert a floating point vector to an argb color
inline argb(const vec4f vec&) = argb(vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(const vec4f vec&) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;
}

inline "color.hsv.ci";
inline "color.hsl.ci";
// adapted from: https://gitlab.bestminr.com/bestminr/FrontShaders/-/blob/master/shaders/hsl.glsl
/// Convert color from Rgb color space to Hsl color space
vec4f rgb2hsl(vec4f rgb) {
	inline min(float32 x, float32 y) = x < y ? x : y;
	inline max(float32 x, float32 y) = x > y ? x : y;
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);
	float fmin = min(min(rgb.x, rgb.y), rgb.z);    //Min. value of RGB
	float fmax = max(max(rgb.x, rgb.y), rgb.z);    //Max. value of RGB
	float delta = fmax - fmin;             //Delta RGB value

	// Luminance
	float lum = (fmax + fmin) / 2;

	if (delta == 0) {
		//This is a gray, no chroma...
		return {
			x: 0;   // Hue
			y: 0;   // Saturation
			z: lum; // Luminance
		};
	}

	// Chromatic data...
	float sat;
	if (lum < 0.5f) {
		sat = delta / (fmax + fmin);
	} else {
		sat = delta / (2 - fmax - fmin);
	}

	float deltaR = (((fmax - rgb.x) / 6) + (delta / 2)) / delta;
	float deltaG = (((fmax - rgb.y) / 6) + (delta / 2)) / delta;
	float deltaB = (((fmax - rgb.z) / 6) + (delta / 2)) / delta;

	float hue;
	if (rgb.x == fmax) {
		hue = deltaB - deltaG;
	}
	else if (rgb.y == fmax) {
		hue = (1 / 3f) + deltaR - deltaB;
	}
	else if (rgb.z == fmax) {
		hue = (2 / 3f) + deltaG - deltaR;
	}

	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}

	return {
		x: clamp(hue, 0, 1); // Hue
		y: clamp(sat, 0, 1); // Saturation
		z: clamp(lum, 0, 1); // Luminance
	};
}

/// Convert color from Hsl color space to Rgb color space
vec4f hsl2rgb(vec4f hsl) {
float hue2rgb(float f1, float f2, float hue) {
	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}
	float res;
	if ((6 * hue) < 1) {
		res = f1 + (f2 - f1) * 6 * hue;
	}
	else if ((2 * hue) < 1) {
		res = f2;
	}
	else if ((3 * hue) < 2) {
		res = f1 + (f2 - f1) * ((2 / 3f) - hue) * 6;
	}
	else {
		res = f1;
	}
	return res;
}

	if (hsl.y == 0) {
		return vec4f(hsl.z); // Luminance
	}

	float f2;
	if (hsl.z < .5f) {
		f2 = hsl.z * (1 + hsl.y);
	}
	else {
		f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
	}

	float f1 = 2 * hsl.z - f2;
	return {
		x: hue2rgb(f1, f2, hsl.x + (1 / 3f));
		y: hue2rgb(f1, f2, hsl.x);
		z: hue2rgb(f1, f2, hsl.x - (1 / 3f));
	};
}

/* TODO: integer based hsl and hsv calculation
/// hue saturation lightness color model
struct hsl {
	/// hue: 0 ... 359
	uint16 hue;
	/// sat: 0 ... 255
	uint8 sat;
	/// lum: 0 ... 255
	uint8 lum;
}

///@public
hsl hsl(argb rgb) {
	// adapted from: https://gist.github.com/mity/6034000
	int r = rch(rgb);
	int g = gch(rgb);
	int b = bch(rgb);

	int min = r;
	if (min > g) min = g;
	if (min > b) min = b;

	int max = r;
	if (max < g) max = g;
	if (max < b) max = b;

	int lum = lum(rgb);
	if (max == min) {
		return {
			hue: 0;
			sat: 0;
			lum: lum;
		};
	}

	int hue = 0;
	int sat = max - min;
	//int lum = (min + max) / 2;
	if (max == r) {
		hue = ((g - b) * 60) / sat;
	}
	else if (max == g) {
		hue = ((b - r) * 60) / sat + 120;
	}
	else /+if(max == b)+/ {
		hue = ((r - g) * 60) / sat + 240;
	}
	if (hue < 0) {
		hue += 360;
	}
	return {
		hue: hue;
		sat: sat;
		lum: lum;
	};
}
*/
