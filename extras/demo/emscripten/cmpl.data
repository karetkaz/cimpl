// standard library extension

enum: bool {
	true: 0 == 0;
	false: 0 != 0;
}

inline byte = uint8;
inline float = float32;
inline double = float64;

static if (typename(raise) == function) {
inline "std/debug.ci";
}

/// Returns the size of the given type
inline sizeof(typename type) = int(type.size);

inline "std/math.ci";
inline "std/string.ci";
// graphics library extension
inline "gfx/color.ci";

/// Create a surface with the given with, height and depth
inline gxSurf(int width, int height, int depth) = gxSurf.create(width, height, depth);

/// Create a surface by opening an image file
gxSurf gxSurf(char fileName[*], int depth) {
	if (fileName.endsWith(".jpeg", ignCaseCmp)) {
		return gxSurf.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".jpg", ignCaseCmp)) {
		return gxSurf.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".png", ignCaseCmp)) {
		return gxSurf.openPng(fileName, depth);
	}
	if (fileName.endsWith(".bmp", ignCaseCmp)) {
		return gxSurf.openBmp(fileName, depth);
	}
	abort("unknown file extension", fileName);
}

/// Create a surface by opening an image file
inline gxSurf(char fileName[*]) = gxSurf(fileName, 32);

/// Create a surface by opening an image file with custom width and height
gxSurf gxSurf(char fileName[*], int width, int height, int depth, int align, double maxScale) {
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: 3;
		fitHorizontal: 12;
		fill: 0x10;
		highRes: 0x20;
	}

	double scale = 1;
	gxSurf surf = gxSurf(fileName, depth);
	gxSurf result = gxSurf(width, height, depth);

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;

	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	if (fitWidth && fitHeight) {
		double widthScale = width / double(surf.width());
		double heightScale = height / double(surf.height());
		if (align & fill) {
			scale = Math.max(widthScale, heightScale);
		} else {
			scale = Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / double(surf.width());
	}
	else if (fitHeight) {
		scale = height / double(surf.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	double tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - surf.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - surf.width() * scale);
	}

	double ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - surf.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - surf.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	result.transform(null, surf, null, align & highRes ? 1 : 0, mat.data);
	surf.destroy();
	return result;
}

/// Create a surface by opening an image file with custom width and height
inline gxSurf(char fileName[*], int width, int height, int depth, int align) = gxSurf(fileName, width, height, depth, align, Math.inf);

/// Create a surface by opening an image file with custom width and height
inline gxSurf(char fileName[*], int width, int height, int depth) = gxSurf(fileName, width, height, depth, -1, Math.inf);

/// Create a mesh by opening a file
gxMesh gxMesh(char fileName[*]) {
	if (fileName.endsWith(".obj", ignCaseCmp)) {
		return gxMesh.openObj(fileName);
	}
	if (fileName.endsWith(".3ds", ignCaseCmp)) {
		return gxMesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}

/// Create a surface by cloning another one
gxSurf gxSurf(gxSurf copy) {
	gxSurf result = gxSurf.create(copy.width(), copy.height(), copy.depth());
	result.copy(0, 0, copy, null);
	return result;
}

/// Create a surface by cloning another one using a custom aspect ratio
gxSurf gxSurf(gxSurf copy, double aspect) {
	int width = copy.width();
	if (aspect > 0) {
		width = copy.height() * aspect;
	}
	gxSurf result = gxSurf.create(width, copy.height(), copy.depth());
	result.transform(null, copy, null, 1, null);
	return result;
}

/// Set the the color of a pixel at the given position
inline set(gxSurf dst, int32 x, int32 y, argb color) = gxSurf.set(dst, x, y, uint32(color));

///@public
inline resize(gxSurf surf, const gxRect rect&, const gxSurf src, const gxRect roi&, int interpolate) = gxSurf.transform(surf, rect, src, roi, interpolate, null);

///@public
bool clip(gxSurf src, gxRect roi&) {

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < 0) {
		roi.x = 0;
	}

	if (roi.y < 0) {
		roi.y = 0;
	}

	int width = src.width();
	if (roi.w > width) {
		roi.w = width;
	}

	int height = src.height();
	if (roi.h > height) {
		roi.h = height;
	}

	roi.w -= roi.x;
	roi.h -= roi.y;

	if (roi.w <= 0) {
		return false;
	}
	if (roi.h <= 0) {
		return false;
	}
	return true;
}

/// Fill the entire surface with the given color
inline fill(gxSurf dst, uint32 col) = dst.fillRect(0, 0, 65536, 65536, col);
/// Fill the given region with the given color
inline fill(gxSurf dst, const gxRect roi&, uint32 col) = dst.fillRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
/// Fill the given region and padding with the given color
inline fill(gxSurf dst, const gxRect roi&, int pad, uint32 col) = dst.fillRect(roi.x - pad, roi.y - pad, roi.x + roi.w + pad, roi.y + roi.h + pad, col);

///@public
inline drawRect(gxSurf dst, const gxRect roi&, uint32 col) = dst.drawRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);

/// Fill the surface by evaluating the given function for each pixel
void eval(gxSurf dst, const gxRect roi&, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	gxRect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : dst.width();
		h: roi != null ? roi.h : dst.height();
	};

	if (!dst.clip(rect)) {
		return;
	}

	vec4f in = {
		x: 0;
		y: 0;
		z: aspect;
		w: time;
	};
	float w = dst.width();
	float h = dst.height();
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		in.y = y / h;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			in.x = x / w;
			dst.set(x, y, argb(eval(in)));
		}
	}
}

///@public
void tile(gxSurf dst, int x, int y, gxSurf src, gxRect roi&) {
	gxRect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};

	if (!src.clip(rect)) {
		return;
	}

	if (x < 0) {
		x = -(-x % rect.w);
	}
	if (y < 0) {
		y = -(-y % rect.h);
	}
	int width = dst.width();
	int height = dst.height();
	for (int j = y; j < height; j += rect.h) {
		for (int i = x; i < width; i += rect.w) {
			dst.copy(i, j, src, rect);
		}
	}
}

/// Show the mesh in a window
void show(gxMesh mesh, int w, int h, float32 fovy) {

	struct Closure {
		int mode;
		gxSurf offs;
		gxMesh mesh;
	}

	int next(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float speed = 1. / 100;
		if (action == Gui.FINGER_MOTION) {
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
			else if (button == 'l') {
				closure.mode ^= gxMesh.useLights;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				closure.mode ^= gxMesh.useTexture;
			}
			else if (button == '/') {
				closure.mode = next(closure.mode, gxMesh.cullBack | gxMesh.cullFront);
			}
			else if (button == '\t') {
				closure.mode = next(closure.mode, gxMesh.drawMode);
			}
			else if (button == '\r') {
				vec4f eye = {x: 0, y: 0, z: 2, w: 1};
				vec4f at = {x: 0, y: 0, z: 0, w: 1};
				vec4f up = {x: 0, y: 1, z: 0, w: 1};
				camera.lookAt(eye.data, at.data, up.data);
			}
		}
		else if (action == Gui.MOUSE_PRESS) {
			ox = ex;
			oy = ey;
			return 0;
		}
		else if (action == Gui.MOUSE_MOTION) {
			float32 dir[3];
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit
				float32 orig[3];
				orig[0] = 0;
				orig[1] = 0;
				orig[2] = 0;

				camera.readUp(dir);
				camera.rotate(dir, orig, dx * speed);
				camera.readRight(dir);
				camera.rotate(dir, orig, dy * speed);
			}
			else if (button == 2) {
				// rotate
				camera.readUp(dir);
				camera.rotate(dir, null, -dx * speed);
				camera.readRight(dir);
				camera.rotate(dir, null, -dy * speed);
			}
			else if (button == 3) {
				// move
				camera.readForward(dir);
				camera.move(dir, dy * speed);
			}
			else if (button == 4) {
				// pan
				camera.readRight(dir);
				camera.move(dir, -dx * speed);
				camera.readUp(dir);
				camera.move(dir, dy * speed);
			}
			ox = ex;
			oy = ey;
		}

		int rendered = closure.offs.drawMesh(closure.mesh, closure.mode);

		char text[256];
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, closure.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, closure.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		Gui.setTitle(text);
		return 0;
	}

	Closure closure = {
		mode: gxMesh.clearDepth | gxMesh.clearColor | gxMesh.useLights | gxMesh.cullBack | gxMesh.drawFill;
		offs: gxSurf.create3d(w, h);
		mesh: mesh;
	};
	camera.projection(fovy, w / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy();
}

/// Show the surface in a window
inline show(gxSurf surf) = Gui.showWindow(surf, null, null);

/// Show the surface in a window
void show(gxSurf surf, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Gui.showWindow(surf, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Gui.showWindow(surf, onEvent, delegate);
}

/// Show the surfaces in a window clicking on the window toggles the shown surface
void showDiff(gxSurf image1, gxSurf image2) {
	struct Closure {
		gxSurf offs;
		gxSurf image1;
		gxSurf image2;
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.MOUSE_PRESS) {
			closure.offs.copy(0, 0, closure.image2, null);
			return 0;
		}
		if (action == Gui.MOUSE_RELEASE) {
			closure.offs.copy(0, 0, closure.image1, null);
			return 0;
		}
		return 0;
	}

	Closure closure = {
		offs: gxSurf(image1);
		image1: image1;
		image2: image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Closure {
		bool lerp = true;
		const gxSurf offs;
		const gxSurf thumb;
		const float32 aspect;
		const vec4f eval(vec4f in);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return 0;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.KEY_RELEASE) {
			if (button == ' ') {
				float32 time = (System.millis() - start) / 1000f;
				closure.offs.eval(null, closure.aspect, time, closure.eval);
				return 0;
			}
			if (button == '\t') {
				closure.lerp = !closure.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				closure.offs.saveBmp("out/offs.bmp", 0);
				closure.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		closure.thumb.eval(null, closure.aspect, time, closure.eval);
		closure.offs.resize(null, closure.thumb, null, closure.lerp ? 1 : 0);

		// do not block for any input
		return 1;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		gxSurf surf = gxSurf(width, height, 32);
		surf.eval(null, aspect, 0f, eval);
		surf.show(null);
		surf.destroy();
		return;
	}

	Closure closure = {
		offs: gxSurf(width, height, 32);
		thumb: gxSurf(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy();
	closure.offs.destroy();
}
/// an 32 bit argb color
struct argb: 0 {
	/// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;

		/// green component
		uint8 g;

		/// red component
		uint8 r;

		/// alpha component
		uint8 a;
	}
	/*enum {
		Black             : 0x00000000;
		White             : 0x00ffffff;
		Aquamarine        : 0x007fffd4;
		Azure             : 0x00007fff;
		Blue              : 0x000000ff;
		BlueViolet        : 0x008a2be2;
		Brown             : 0x00a52a2a;
		CadetBlue         : 0x005f9ea0;
		Coral             : 0x00ff7f50;
		CornflowerBlue    : 0x006495ed;
		Cyan              : 0x0000ffff;
		DarkGray          : 0x00a9a9a9;
		DarkGrey          : 0x00a9a9a9;
		DarkGreen         : 0x00006400;
		DarkOliveGreen    : 0x00556b2f;
		DarkOrchid        : 0x009932cc;
		DarkSlateBlue     : 0x00483d8b;
		DarkSlateGray     : 0x002f4f4f;
		DarkSlateGrey     : 0x002f4f4f;
		DarkTurquoise     : 0x0000ced1;
		DarkWood          : 0x000d0301;
		DeepPink          : 0x00ff1493;
		DimGray           : 0x00696969;
		DimGrey           : 0x00696969;
		FireBrick         : 0x00b22222;
		ForestGreen       : 0x00228b22;
		Gold              : 0x00ffd700;
		Goldenrod         : 0x00daa520;
		Gray              : 0x00808080;
		Grey              : 0x00808080;
		Green             : 0x00008000;
		GreenYellow       : 0x00adff2f;
		IndianRed         : 0x00cd5c5c;
		Khaki             : 0x00f0e68c;
		LightBlue         : 0x00add8e6;
		LightGray         : 0x00d3d3d3;
		LightGrey         : 0x00d3d3d3;
		LightSteelBlue    : 0x00b0c4de;
		LightWood         : 0x00993d1a;
		Lime              : 0x0000ff00;
		LimeGreen         : 0x0032cd32;
		Magenta           : 0x00ff00ff;
		Maroon            : 0x00800000;
		MedianWood        : 0x004d1f09;
		MediumAquamarine  : 0x0066cdaa;
		MediumBlue        : 0x000000cd;
		MediumForestGreen : 0x006b8e23;
		MediumGoldenrod   : 0x00eaeaad;
		MediumOrchid      : 0x00ba55d3;
		MediumSeaGreen    : 0x003cb371;
		MediumSlateBlue   : 0x007b68ee;
		MediumSpringGreen : 0x0000fa9a;
		MediumTurquoise   : 0x0048d1cc;
		MediumVioletRed   : 0x00c71585;
		MidnightBlue      : 0x00191970;
		Navy              : 0x00000080;
		NavyBlue          : 0x0023238e;
		Orange            : 0x00ffa500;
		OrangeRed         : 0x00ff4500;
		Orchid            : 0x00da70d6;
		PaleGreen         : 0x0098fb98;
		Pink              : 0x00ffc0cb;
		Plum              : 0x00dda0dd;
		Red               : 0x00ff0000;
		Salmon            : 0x00fa8072;
		SeaGreen          : 0x002e8b57;
		Sienna            : 0x00a0522d;
		SkyBlue           : 0x0087ceeb;
		SlateBlue         : 0x006a5acd;
		SpringGreen       : 0x0000ff7f;
		SteelBlue         : 0x004682b4;
		Tan               : 0x00d2b48c;
		Thistle           : 0x00d8bfd8;
		Turquoise         : 0x0040e0d0;
		Violet            : 0x00ee82ee;
		VioletRed         : 0x00cc3299;
		Wheat             : 0x00f5deb3;
		Yellow            : 0x00ffff00;
		YellowGreen       : 0x009acd32;
		//Transparent     : 0xff000000;
	}*/
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = argb(emit(uint32(argb)));
/// cast argb value to unsigned integer
inline uint32(argb value) = uint32(emit(struct(value)));


/// clamp signed gray or color component to fit in 8 bits (0 ... 255)
uint32 grayClamp(int32 c) {
	if (c < 0) {
		return 0;
	}
	if (c > 255) {
		return 255;
	}
	return c;
}
/// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
uint32 grayClamp(uint32 c) {
	if (c > 255) {
		return 255;
	}
	return c;
}


// construct a rgb8 gray color from the given value
inline _gray(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = _gray(grayClamp(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = _gray(grayClamp(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct an argb color from the given components
inline _argb(uint32 r, uint32 g, uint32 b) = argb(uint32((((r << 8) | g) << 8) | b));
/// construct an argb color from the given components
inline _argb(uint32 a, uint32 r, uint32 g, uint32 b) = argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));

/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = _argb(grayClamp(r), grayClamp(g), grayClamp(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = _argb(grayClamp(r), grayClamp(g), grayClamp(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb col) = uint32((uint32(col) >> 24) & 0xff);
/// get the Red channel of the color
inline rch(argb col) = uint32((uint32(col) >> 16) & 0xff);
/// get the Green channel of the color
inline gch(argb col) = uint32((uint32(col) >> 8) & 0xff);
/// get the Blue channel of the color
inline bch(argb col) = uint32(uint32(col) & 0xff);
/// get the luminosity of the color
inline lum(argb c) = uint32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);

/// linear interpolation between `c1` and `c2` by `t`, where t is a 16 bit fixed point
argb rgbLerp16(argb c1, argb c2, uint32 t) {
	inline lerp(uint32 x, uint32 y) = uint32(x + (t * (y - x) >> 16));
	uint32 r = lerp(rch(c1), rch(c2));
	uint32 g = lerp(gch(c1), gch(c2));
	uint32 b = lerp(bch(c1), bch(c2));
	return argb(r, g, b);
}

/// linear interpolation between `c1` and `c2` by `t`, where t is between 0. and 1.
inline rgbLerp(argb c1, argb c2, double t) = rgbLerp16(c1, c2, uint32(t * (1 << 16)));

/// linear interpolate a lookup-table with the given colors
void lerpLut(uint32 lut[], argb colors...) {
	int dt = (colors.length - 1 << 16) / (lut.length - 1);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * dt;
		argb c1 = colors[t >> 16];
		argb c2 = colors[(t >> 16) + 1];
		lut[i] = uint32(rgbLerp16(c1, c2, t & 0xffff));
	}
}

static if (typename(vec4f) != null) {

/// convert a floating point vector to rgb
inline argb(const vec4f vec&) = argb(vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(const vec4f vec&) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;

/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
}

/// draw the given lookup table to the image
void drawLut(gxSurf image, gxRect roi&, uint32 bars[256], uint32 lines[256]) {
	enum {
		margin: 20;
		padding: 7;
		colB: 0x4371c6;
		colG: 0x72d874;
		colR: 0xfc6165;
		colL: 0xdadada;
	}

	gxRect rect = {
		w: roi != null ? roi.w : 256;
		h: roi != null ? roi.h : 128;
		y: roi != null ? roi.y : margin;
		x: roi != null ? roi.x : image.width() - rect.w - margin;
	};

	image.fillRect(
		rect.x - padding,
		rect.y - padding,
		rect.x + rect.w + padding,
		rect.y + rect.h + padding,
		0
	);

	if (bars != null) {
		for (int x = 0; x < rect.w; x += 1) {
			int bv = bch(argb(bars[x])) * rect.h / 256;
			int gv = gch(argb(bars[x])) * rect.h / 256;
			int rv = rch(argb(bars[x])) * rect.h / 256;
			int lv = ach(argb(bars[x])) * rect.h / 256;
			for (int y = 0; y < rect.h; y += 1) {
				uint32 b = colB * uint32(y < bv);
				uint32 g = colG * uint32(y < gv);
				uint32 r = colR * uint32(y < rv);
				uint32 l = colL * uint32(y < lv);
				image.set(x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
			}
		}
	}
	if (lines != null) {
		int y = rect.y + rect.h - 1;
		int pb = bch(argb(lines[0])) * rect.h / 256;
		int pg = gch(argb(lines[0])) * rect.h / 256;
		int pr = rch(argb(lines[0])) * rect.h / 256;
		int pl = ach(argb(lines[0])) * rect.h / 256;

		for (int i = 1; i < rect.w; i += 1) {
			int x = rect.x + i;
			int bv = bch(argb(lines[i])) * rect.h / 256;
			int gv = gch(argb(lines[i])) * rect.h / 256;
			int rv = rch(argb(lines[i])) * rect.h / 256;
			int lv = ach(argb(lines[i])) * rect.h / 256;

			image.drawLine(x - 1, y - pl, x, y - lv, colL);
			image.drawLine(x - 1, y - pb, x, y - bv, colB);
			image.drawLine(x - 1, y - pg, x, y - gv, colG);
			image.drawLine(x - 1, y - pr, x, y - rv, colR);
			
			pl = lv;
			pb = bv;
			pg = gv;
			pr = rv;
		}
	}
}

/// calculate and draw the histogram of the image
void drawHist(gxSurf image, gxRect roi&, uint32 hist, uint32 lut2[256]) {
	uint32 lut[256];
	image.calcHist(roi, hist, lut);
	image.drawLut(roi, lut, lut2);
}

/// calculate and draw the histogram of the image
inline drawHist(gxSurf image, gxRect roi&, uint32 hist) = drawHist(image, roi, hist, null);// micro ui

struct Button {
	const char text[*];
	bool enabled = true;
	bool selectable = false;

	const variant data = null;
	bool onClick(Button item&) = null;
}

struct Checker {
	const char text[*];
	const char on[*] = "on";
	const char off[*] = "off";
	bool enabled = true;
	bool selectable = false;

	bool checked = false;
	const variant data = null;
	bool onClick(Checker item&) = null;
}

struct Slider {
	const char text[*];
	bool enabled = true;
	bool selectable = true;

	const int divValue = 1;
	const int minValue = 0;
	const int maxValue = -1u >> 1;

	int value = 0;
	const variant data = null;
	bool onClick(Slider item&) = null;
}

struct Layout {
	gxSurf offs;
	gxSurf font;
	variant items[200] = {};
	gxRect rects[200] = {};
	int reset[200] = {};
	int selectedIndex = -1;
	int count = 0;
}

int val(Slider slider&) {
	if (slider.value < slider.minValue) {
		slider.value = slider.minValue;
	}
	if (slider.value > slider.maxValue) {
		slider.value = slider.maxValue;
	}
	return slider.value;
}

double valFlt(Slider slider&) {
	return slider.val() / double(slider.divValue);
}

Layout Layout(gxSurf offs, gxSurf font, variant items...) {
	Layout layout;/* FIXME:BUG: = {
		selectedIndex: -1;
		// rect: {x: 0, y: 0, w: 0, h: 0};
	};*/
	layout.offs = offs;
	layout.font = font;
	layout.selectedIndex = -1;
	for (int i = 0; i < items.length; i += 1) {
		if (Slider slider& = items[i].as(Slider)) {
			layout.reset[i] = slider.value;
		}
		layout.items[i] = items[i];
	}
	layout.count = items.length;
	return layout;
}

void draw(Layout layout&, int x, int y) {
	int posAll = 0;
	char textAll[1024];
	FormatFlags flagsInt = { padLen: 4 };
	FormatFlags flagsFlt = { padLen: 4, precision: 2 };
	gxRect rectAll = { x:x, y:y, w:0, h:0 };

	for (int i = 0; i < layout.count; i += 1) {
		int pos = 0;
		char text[256];
		gxRect rect& = layout.rects[i];
		if (i == layout.selectedIndex) {
			pos = text.append(pos, "* ");
		} else {
			pos = text.append(pos, " ");
		}
		if (Slider item& = layout.items[i].as(Slider)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			if (item.divValue != 1) {
				pos = append(text, pos, item.valFlt(), flagsFlt);
			} else {
				pos = text.append(pos, item.val(), flagsInt);
			}
		}
		else if (Checker item& = layout.items[i].as(Checker)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			if (item.checked) {
				pos = text.append(pos, item.on);
			} else {
				pos = text.append(pos, item.off);
			}
		}
		else if (Button item& = layout.items[i].as(Button)) {
			pos = text.append(pos, item.text);
		}
		else {
			abort("item is not a known ui element", layout.items[i]);
		}
		posAll = textAll.append(posAll, text);
		posAll = textAll.append(posAll, "\n");
		layout.font.clipText(rect, text);
		rect.x = x;
		rect.y = y;
		y += rect.h;
	}
	layout.font.clipText(rectAll, textAll);
	layout.offs.fill(rectAll, 5, 0x000000);
	layout.offs.drawText(rectAll.x, rectAll.y, layout.font, textAll, 0xffffff);
}

inline selected(Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.items[layout.selectedIndex]);
inline selected(Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.items[layout.selectedIndex].as(type);
inline isSelected(Layout layout&, pointer item) = item == layout.selected();

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
// TODO: void measure(Layout layout&) { }
// TODO: void layout(Layout layout&) { }

bool click(Layout layout&, int index) {
	if (index < 0) {
		return false;
	}
	if (Slider item& = layout.items[index].as(Slider)) {
		if (!item.enabled) {
			return false;
		}
		if (item.selectable) {
			layout.selectedIndex = index;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	if (Checker item& = layout.items[index].as(Checker)) {
		if (!item.enabled) {
			return false;
		}
		int previousIndex = index;
		if (item.selectable) {
			previousIndex = layout.selectedIndex;
			layout.selectedIndex = index;
		}
		if (previousIndex == index) {
			// change only if already selected
			item.checked = !item.checked;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	if (Button item& = layout.items[index].as(Button)) {
		if (!item.enabled) {
			return false;
		}
		if (item.selectable) {
			layout.selectedIndex = index;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}

	abort("item is not a known ui element", layout.items[index]);
	return false;
}
bool click(Layout layout&, int x, int y) {
	bool test(const gxRect rect&, int x, int y) {
		if (x < rect.x || x >= rect.x + rect.w) {
			return false;
		}
		if (y < rect.y || y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}

	for (int i = 0; i < layout.count; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}
		return click(layout, i);
	}
	// click is outside any control
	return false;
}

bool update(Layout layout&, int delta) {
	if (layout.selectedIndex < 0) {
		return false;
	}
	variant selectedItem = layout.items[layout.selectedIndex];
	if (Slider slider& = selectedItem.as(Slider)) {
		slider.value += delta;
		return true;
	}
	if (Checker checker& = selectedItem.as(Checker)) {
		checker.checked = delta < 0;
		return true;
	}
	return false;
}

bool reset(Layout layout&, int index) {
	if (index < 0) {
		for (int i = 0; i < layout.count; i += 1) {
			layout.reset(i);
		}
		return true;
	}
	if (Slider item& = layout.items[index].as(Slider)) {
		item.value = layout.reset[index];
		return true;
	}
	return false;
}

bool select(Layout layout&, bool prev) {
	for (int i = 1; i < layout.count; i += 1) {
		int index = layout.selectedIndex + (prev ? -i : i);
		if (index >= layout.count) {
			index -= layout.count;
		}
		else if (index < 0) {
			index += layout.count;
		}
		if (Button item& = layout.items[index].as(Button)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Checker item& = layout.items[index].as(Checker)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Slider item& = layout.items[index].as(Slider)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
	}
	return false;
}

	static int ox = 0;
	static int px = 0;
	static int oy = 0;
	static int py = 0;

	bool isCtrl = (y & Gui.KEY_MASK_CONTROL) != 0;
	bool isShift = (y & Gui.KEY_MASK_SHIFT) != 0;

	if (action == Gui.FINGER_MOTION) {
		action = Gui.MOUSE_MOTION;
	}
	
	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.select(false);
		return true;
	}
	else if (action == Gui.KEY_PRESS) {
		if (button == 8) {	// backspace
			if (layout.reset(isShift ? -1 : layout.selectedIndex)) {
				return true;
			}
		}
		if (button == ' ') {
			if (layout.click(layout.selectedIndex)) {
				return true;
			}
		}
		if (button == '-' || button == '_') {	// down
			int delta = isShift ? 10 : 1;
			if (layout.update(-delta)) {
				return true;
			}
		}
		if (button == '+' || button == '=') {	// up
			int delta = isShift ? 10 : 1;
			if (layout.update(+delta)) {
				return true;
			}
		}
		if (button == '\t') {
			if (layout.select(isShift)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		px = ox = x;
		py = oy = y;
	}
	else if (action == Gui.MOUSE_RELEASE) {
		if (button == 1 && x == px && y == py) {
			if (layout.click(x, y)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_MOTION) {
		if (button == 1) {
			if (layout.update(oy - y)) {
				ox = x;
				oy = y;
				return true;
			}
		}
	}
	return false;
}
// debugging related functions

/// report message at `verbose` logging level
inline verbose(char message[*], variant inspect) = raise(raise.verbose, raise.noTrace, message, inspect);
/// report message at `verbose` logging level
inline verbose(char message[*]) = raise(raise.verbose, raise.noTrace, message, null);

/// report message at `debug` logging level
inline debug(char message[*], variant inspect) = raise(raise.debug, raise.noTrace, message, inspect);
/// report message at `debug` logging level
inline debug(char message[*]) = raise(raise.debug, raise.noTrace, message, null);

/// report message with stacktrace at `debug` logging level
inline trace(char message[*], variant inspect) = raise(raise.debug, raise.defTrace, message, inspect);
/// report message with stacktrace at `debug` logging level
inline trace(char message[*]) = raise(raise.debug, raise.defTrace, message, null);

/// report message at `info` logging level
inline info(char message[*], variant inspect) = raise(raise.info, raise.noTrace, message, inspect);
/// report message at `info` logging level
inline info(char message[*]) = raise(raise.info, raise.noTrace, message, null);

/// report message at `warn` logging level
inline warn(char message[*], variant inspect) = raise(raise.warn, raise.noTrace, message, inspect);
/// report message at `warn` logging level
inline warn(char message[*]) = raise(raise.warn, raise.noTrace, message, null);

/// report message with stacktrace at `error` logging level
inline error(char message[*], variant inspect) = raise(raise.error, raise.defTrace, message, inspect);
/// report message with stacktrace at `error` logging level
inline error(char message[*]) = raise(raise.error, raise.defTrace, message, null);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(char message[*], variant inspect) = raise(raise.abort, raise.defTrace, message, inspect);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort(char message[*]) = raise(raise.abort, raise.defTrace, message, null);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!", null);

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, char message[*], variant inspect) = void(condition ? void(0) : abort(message, inspect));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, char message[*]) = void(condition ? void(0) : abort(message));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

///@public
struct NotEquals {
	/// Value of the expected result
	const variant expected;

	/// Value of the actual result
	const variant returned;

	/// Extra argument to identify what happened
	const variant argument = null;

	/// Extra message to identify what happened
	const char message[*] = null;
}

/// abort execution if the returned value is not equal to the expected value
// TODO: make inline
static void assertEq(int expected, int returned, char message[*]) {
	if (returned == expected) {
		return;
	}
	NotEquals details = {
		expected: expected;
		returned: returned;
		message: message;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
/// abort execution if the returned value is not equal to the expected value
inline assertEq(int expected, int returned) = assertEq(expected, returned, null);
/// A 2d vector (2x float64)
struct vec2d: 0 {
	/// Access the components as an array
	float64 data[2];
	struct {
		/// X component of the vector
		float64 x;
		/// Y component of the vector
		float64 y;
	}
}

/// Initialize with given x, y components
vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}

/// Component wise subtract the two vectors.
inline sub(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), sub.p2d));

/// Dot product
inline dot(const vec2d a&, const vec2d b&) = a.x * b.x + a.y * b.y;
/// A 4d vector (4x float32)
struct vec4f: 0 {
	/// Access the components as an array
	float32 data[4];
	struct {
		/// X component of the vector
		float32 x;
		/// Y component of the vector
		float32 y;
		/// Z component of the vector
		float32 z;
		/// W component of the vector
		float32 w;
	}
}

/* TODO: implement inline initializer
// constructing a vector
inline vec4f(float32 x, float32 y, float32 z, float32 w) = { x: x, y: y, z: z, w: w };
inline vec4f(float32 x, float32 y, float32 z) = { x: x, y: y, z: z, w: 0 };
inline vec4f(const vec4f v&, float32 w) = { x: v.x, y: v.y, z: v.z, w: w };
inline vec4f(const float32 val&) = { x: val, y: val, z: val, w: val };
*/

/// Initialize with given x, y, z, w components
vec4f vec4f(float32 x, float32 y, float32 z, float32 w) {
	return { x: x, y: y, z: z, w: w };
}

/// Initialize with  (x: x, y: y, z: z, w: 1)
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 1f);

/// Initialize with (x: x, y: y, z: 0, w: 1)
inline vec4f(float32 x, float32 y) = vec4f(x, y, 0f, 1f);

/// Initialize x, y, z components using the components form the given vector, and w with the given value
inline vec4f(vec4f xyz, float32 w) = vec4f(xyz.x, xyz.y, xyz.z, w);

/// Initialize x, y, z, w components with the given scalar value
inline vec4f(float32 val) = vec4f(val, val, val, val);

/* TODO: implement operator overloading
//~ -a => vec4f(-a.x, -a.y, -a.z, -a.w);
inline -(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));

//~ a + b => vec4f(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
inline +(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));

//~ a - b => vec4f(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
inline -(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));

//~ a * b => vec4f(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
inline *(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));

//~ a / b => vec4f(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
inline /(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

inline +(vec4f a, float32 b) = a + vec4f(b);
inline +(float32 a, vec4f b) = vec4f(a) + b;
inline -(vec4f a, float32 b) = a - vec4f(b);
inline -(float32 a, vec4f b) = vec4f(a) - b;
inline *(vec4f a, float32 b) = a * vec4f(b);
inline *(float32 a, vec4f b) = vec4f(a) * b;
inline /(vec4f a, float32 b) = a / vec4f(b);
inline /(float32 a, vec4f b) = vec4f(a) / b;

inline normalize(vec4f v) = v / len(v);
*/

/// Returns a negated copy of the vector.
inline neg(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));
/// Component wise add the two vectors.
inline add(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));
/// Component wise subtract the two vectors.
inline sub(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
/// Component wise multiply the two vectors.
inline mul(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
/// Component wise divide the two vectors.
inline div(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

/// Component wise minimum of the two vectors.
inline min(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), min.p4f));
/// Component wise maximum of the two vectors.
inline max(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), max.p4f));

/// Dot product of the first 3 elements
// inline dp3(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z;
inline dp3(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp3));

/// Homogeneous dot product
// inline dph(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w;
inline dph(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dph));

/// Dot product
// inline dp4(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
inline dp4(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp4));

/// Cross product of the first 3 elements
inline cross(const vec4f a&, const vec4f b&) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

/// Length of the vector(xyz)
inline length(vec4f v) = float32.sqrt(dp3(v, v));
/// Normalize the vector(xyz)
inline normalize(const vec4f v&) = div(v, vec4f(length(v)));

/// Evaluate as a polynomial in point x
inline eval(const vec4f v&, float32 x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		///@public
		vec4f x;
		///@public
		vec4f y;
		///@public
		vec4f z;
		///@public
		vec4f w;
	}
	struct {
		///@public
		float32 xx;
		///@public
		float32 xy;
		///@public
		float32 xz;
		///@public
		float32 xw;

		///@public
		float32 yx;
		///@public
		float32 yy;
		///@public
		float32 yz;
		///@public
		float32 yw;

		///@public
		float32 zx;
		///@public
		float32 zy;
		///@public
		float32 zz;
		///@public
		float32 zw;

		///@public
		float32 wx;
		///@public
		float32 wy;
		///@public
		float32 wz;
		///@public
		float32 ww;
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		x: { x: xx, y: xy, z: xz, w: xw };
		y: { x: yx, y: yy, z: yz, w: yw };
		z: { x: zx, y: zy, z: zz, w: zw };
		w: { x: wx, y: wy, z: wz, w: ww };
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(const vec4f x&, const vec4f y&, const vec4f z&, const vec4f w&) {
	return { x: x, y: y, z: z, w: w };
}

/// Multiply with vector: dot product of the first 3 elements
inline dp3(const mat4f mat&, const vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
/// Multiply with vector: homogeneous dot product
inline dph(const mat4f mat&, const vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
/// Multiply with vector: dot product
inline dp4(const mat4f mat&, const vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

/// Multiply two matrices (rows * cols)
mat4f mul(const mat4f lhs&, const mat4f rhs&) {
	mat4f transposed = {
		x: { x: rhs.x.x, y: rhs.y.x, z: rhs.z.x, w: rhs.w.x };
		y: { x: rhs.x.y, y: rhs.y.y, z: rhs.z.y, w: rhs.w.y };
		z: { x: rhs.x.z, y: rhs.y.z, z: rhs.z.z, w: rhs.w.z };
		w: { x: rhs.x.w, y: rhs.y.w, z: rhs.z.w, w: rhs.w.w };
	};
	return {
		x: dp4(transposed, lhs.x);
		y: dp4(transposed, lhs.y);
		z: dp4(transposed, lhs.z);
		w: dp4(transposed, lhs.w);
	};
}

/**
 * Build a rotation matrix
 * adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
 */
mat4f rotation(const vec4f center&, const vec4f direction&, float angle) {
	float len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float x = direction.x / len;
	float y = direction.y / len;
	float z = direction.z / len;
	float cx = center.x;
	float cy = center.y;
	float cz = center.z;
	float xx = x * x;
	float xy = x * y;
	float xz = x * z;
	float yy = y * y;
	float yz = y * z;
	float zz = z * z;

	float s = float.sin(angle);
	float c = float.cos(angle);
	float k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
inline rotation(const vec4f direction&, float angle) = rotation(vec4f(0), direction, angle);

/// Build a translation matrix
mat4f translation(const vec4f direction&, float amount) {
	return {
		x: {x: 1, y: 0, z: 0, w: direction.x * amount};
		y: {x: 0, y: 1, z: 0, w: direction.y * amount};
		z: {x: 0, y: 0, z: 1, w: direction.z * amount};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}

/// Build a scaling matrix
mat4f scale(const vec4f direction&, float amount) {
	inline rcp(float val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		x: {x: rcp(direction.x * amount), y: 0, z: 0, w: 0};
		y: {x: 0, y: rcp(direction.y * amount), z: 0, w: 0};
		z: {x: 0, y: 0, z: rcp(direction.z * amount), w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}
/// Complex number
struct Complex {

	/// The real component of a complex number.
	const float64 re;

	/// The imaginary component of a complex number.
	const float64 im = 0;

	/* TODO: implement enumerations
	enum: Complex {
		zero: { re: 0 };	// 0 + 0i
		unit: { re: 1 };	// 1 + 0i
	}*/
}

/* TODO: implement inline initializer
// constructing a complex number
inline Complex(float64 re) = { re: re };
inline Complex(float64 re, float64 im) = { re: re, im: im };
*/

///@public
Complex Complex(float64 re) {
	return {
		re: re;
	};
}

///@public
Complex Complex(float64 re, float64 im) {
	return {
		re: re;
		im: im;
	};
}

/* TODO: implement operator overloading
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
inline /(float64 a, Complex b) = div(Complex(a), b);
*/

///@public
inline neg(Complex a) = Complex(-a.re, -a.im);

///@public
inline add(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
///@public
inline add(Complex a, float64 b) = Complex(a.re + b, a.im);
///@public
inline add(float64 a, Complex b) = Complex(a + b.re, b.im);

///@public
inline sub(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
///@public
inline sub(Complex a, float64 b) = Complex(a.re - b, a.im);
///@public
inline sub(float64 a, Complex b) = Complex(a - b.re, b.im);

///@public
inline mul(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
///@public
inline mul(Complex a, float64 b) = Complex(a.re * b, a.im * b);
///@public
inline mul(float64 a, Complex b) = Complex(a * b.re, a * b.im);

///@public
Complex div(Complex a, Complex b) {
	// Adapted from Numerical Recipes in C - The Art of Scientific Computing
	// ISBN 0-521-43108-5

	if (Math.abs(b.re) >= Math.abs(b.im)) {
		float64 r = b.im / b.re;
		float64 den = b.re + r * b.im;
		return {
			re: (a.re + r * a.im) / den;
			im: (a.im - r * a.re) / den;
		};
	}
	float64 r = b.re / b.im;
	float64 den = b.im + r * b.re;
	return {
		re: (a.re * r + a.im) / den;
		im: (a.im * r - a.re) / den;
	};
}

///@public
inline div(Complex a, float64 b) = div(a, Complex(b));
///@public
inline div(float64 a, Complex b) = div(Complex(a), b);

///@public
inline abs(Complex a) = float64.sqrt(a.re * a.re + a.im * a.im);
///@public
inline arg(Complex a) = float64.atan2(a.re, a.im);

/// Reciprocal of a complex number (1 / a)
Complex inv(Complex a) {
	float64 d = (a.re * a.re + a.im * a.im);
	return {
		re: +a.re / d;
		im: -a.im / d;
	};
}

///@public
inline conj(Complex a) = Complex(a.re, -a.im);

///@public
inline exp(Complex a) = Complex(float64.exp(a.re) * float64.cos(a.im), float64.exp(a.re) * float64.sin(a.im));

///@public
inline log(Complex a) = Complex(float64.log(abs(a)), arg(a));

///@public
Complex pow(Complex a, Complex b) {
	float64 r = abs(a);
	float64 t = arg(a);
	float64 u = b.re * t + b.im * float64.log(r);
	float64 v = float64.pow(r, b.re) * float64.exp(-b.im * t);
	return {
		re: v * float64.cos(u);
		im: v * float64.sin(u);
	};
}
///@public
inline pow(Complex a, float64 b) = pow(a, Complex(b));

///@public
inline sin(Complex a) = Complex(float64.sin(a.re) * Math.cosh(a.im), +float64.cos(a.re) * Math.sinh(a.im));
///@public
inline cos(Complex a) = Complex(float64.cos(a.re) * Math.cosh(a.im), -float64.sin(a.re) * Math.sinh(a.im));

/* TODO: implement operator overloading
inline tan(Complex a) = sin(a) / cos(a);
inline cot(Complex a) = cos(a) / sin(a);

inline sinh(Complex a) = (exp(a) - exp(-a)) / 2;
inline cosh(Complex a) = (exp(a) + exp(-a)) / 2;
inline tanh(Complex a) = (exp(2 * a) - 1) / (exp(2 * a) + 1);
inline coth(Complex a) = (exp(2 * a) + 1) / (exp(2 * a) - 1);
*/

///@public
inline tan(Complex a) = div(sin(a), cos(a));
///@public
inline cot(Complex a) = div(cos(a), sin(a));

///@public
inline sinh(Complex a) = div(sub(exp(a), exp(neg(a))), 2);
///@public
inline cosh(Complex a) = div(add(exp(a), exp(neg(a))), 2);
///@public
inline tanh(Complex a) = div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
///@public
inline coth(Complex a) = div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));

///@public
inline sec(Complex a) = inv(cos(a));
///@public
inline csc(Complex a) = inv(sin(a));
///@public
inline sech(Complex a) = inv(cosh(a));
///@public
inline csch(Complex a) = inv(sinh(a));

///@public
inline toCartesian(Complex x) = Complex(x.re * double.cos(x.im), x.re * double.sin(x.im));
///@public
inline toPolar(Complex x) = Complex(abs(x), arg(x));
/// Mathematical utility functions and constants
static struct Math {

	// constants
	enum: float64 {
		pi: 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e: 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2: 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E: 1. / ln2;
		ln10: 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E: 1. / ln10;
		phi: 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2: 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE: 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi: 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi: 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan: 0 / 0.;
		inf: 1 / 0.;
	}

	/// Decompose a value into integer and fractional parts
	float64 modf(float64 x, float64 intPart&) {
		if (x < 1) {
			if (x < 0) {
				float64 result = -modf(-x, intPart);
				intPart = -intPart;
				return result;
			}
			intPart = 0;
			return x;
		}
		float64 result = x % 1;
		intPart = x - result;
		return result;
	}

	// inline isNan(float64 x) = x != x;
	// inline isNan(float32 x) = x != x;

	// inline isInf(float64 x) = x != 0 && x == 2 * x;
	// inline isInf(float32 x) = x != 0 && x == 2 * x;

	// inline isFinite(float64 x) = x - x == 0;
	// inline isFinite(float32 x) = x - x == 0;

	/// Computes the largest integer value not greater than the input
	float64 floor(float64 x) {
		float64 result;
		modf(x, result);
		return result;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float64 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float64 x) = floor(x + .5);

	// inline floor(float32 x) = float32(floor(float64(x)));
	// inline ceil(float32 x) = -floor(-x);
	// inline round(float32 x) = floor(x + .5f);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float64 x) = int(x > 0) - int(x < 0);

	// inline sign(int32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(int64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(uint32 x) = x > 0 ? 1 : 0;
	// inline sign(uint64 x) = x > 0 ? 1 : 0;
	// inline sign(float32 x) = x != 0 ? x < 0 ? -1 : 1 : 0;
	// inline sign(float64 x) = x != 0 ? x < 0 ? -1 : 1 : 0;

	/// Returns the absolute value of the input
	float32 abs(float32 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the absolute value of the input
	float64 abs(float64 x) {
		if (x < 0) {
			return -x;
		}
		return x;
	}

	/// Returns the positive modulus of the input
	float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the positive modulus of the input
	float64 absMod(float64 val, float64 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	// inline abs(int32 x) = x < 0 ? -x : x;
	// inline abs(int64 x) = x < 0 ? -x : x;
	// inline abs(uint32 x) = x;
	// inline abs(float32 x) = x < 0 ? -x : x;
	// inline abs(float64 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	float32 min(float32 a, float32 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	/// Returns the smaller value from the input values
	float64 min(float64 a, float64 b) {
		if (a < b) {
			return a;
		}
		return b;
	}

	// inline min(int32 a, int32 b) = a < b ? a : b;
	// inline min(int64 a, int64 b) = a < b ? a : b;
	// inline min(uint32 a, uint32 b) = a < b ? a : b;
	// inline min(float32 a, float32 b) = a < b ? a : b;
	// inline min(float64 a, float64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	float32 max(float32 a, float32 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	/// Returns the greater value from the input values
	float64 max(float64 a, float64 b) {
		if (a > b) {
			return a;
		}
		return b;
	}

	// inline max(int32 a, int32 b) = a > b ? a : b;
	// inline max(int64 a, int64 b) = a > b ? a : b;
	// inline max(uint32 a, uint32 b) = a > b ? a : b;
	// inline max(float32 a, float32 b) = a > b ? a : b;
	// inline max(float64 a, float64 b) = a > b ? a : b;

	/// Returns the value of `t` clamped between `a` and `b`
	float32 clamp(float32 t, float32 a, float32 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	/// Returns the value of `t` clamped between `a` and `b`
	float64 clamp(float64 t, float64 a, float64 b) {
		if (t < a) {
			return a;
		}
		if (t > b) {
			return b;
		}
		return t;
	}

	// inline clamp(int32 t, int32 a, int32 b) = min(max(t, a), b);
	// inline clamp(int32 t, int32 a, int32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float32 t, float32 a, float32 b) = t < a ? a : t > b ? b : t;
	// inline clamp(float64 t, float64 a, float64 b) = t < a ? a : t > b ? b : t;

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float32 t, float32 a, float32 b) = a + t * (b - a);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline lerp(float64 t, float64 a, float64 b) = a + t * (b - a);

	inline smooth(float32 t) = t * t * (3 - 2 * t);
	inline smooth(float64 t) = t * t * (3 - 2 * t);

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float32 t, float32 a, float32 b) = smooth(clamp((t - a) / (b - a), float32(0), float32(1)));

	/// Returns smooth interpolation between `a` and `b` by `t`
	inline smooth(float64 t, float64 a, float64 b) = smooth(clamp((t - a) / (b - a), float64(0), float64(1)));

	/// Returns the smaller value from the input values
	float64 min(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result > data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	float64 max(float64 data...) {
		if (data.length == 0) {
			return nan;
		}
		float64 result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result < data[i]) {
				result = data[i];
			}
		}
		return result;
	}

	/// Returns the sum of the input values
	float64 sum(float64 data...) {
		float64 result = 0;
		for (int i = 0; i < data.length; i += 1) {
			result += data[i];
		}
		return result;
	}

	/*TODO: implement spread operator
	/// Returns the mean of the input values
	float64 mean(float64 data...) {
		return sum(...data) / data.length;
	}*/

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0) = (a0);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1) = (a0 + x * a1);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2) = (a0 + x * eval(x, a1, a2));

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = (a0 + x * eval(x, a1, a2, a3));

	/// Return the polynomial evaluated at x using Horner's algorithm
	float64 eval(float64 x, float64 polynomial...) {
		float64 result = 0;
		for (int i = polynomial.length - 1; i >= 0; i -= 1) {
			result = result * x + polynomial[i];
		}
		return result;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float32 a, float32 b, float32 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	/// Compare `a` and `b` floating point with `eps` tolerance
	int cmp(float64 a, float64 b, float64 eps) {
		if (a < b) {
			if (eps < (b - a)) {
				return -1;
			}
		}
		else {
			if (eps < (a - b)) {
				return +1;
			}
		}
		return 0;
	}

	// calculate sin or cos
	float64 sinCos(float64 arg, int quad) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: .1357884097877375669092680e8;
			p1: -.4942908100902844161158627e7;
			p2: .4401030535375266501944918e6;
			p3: -.1384727249982452873054457e5;
			p4: .1459688406665768722226959e3;
			q0: .8644558652922534429915149e7;
			q1: .4081792252343299749395779e6;
			q2: .9463096101538208180571257e4;
			q3: .1326534908786136358911494e3;
		}

		float64 x = arg;
		if (x < 0) {
			x = -x;
			quad += 2;
		}

		float64 y;
		x *= 1 / PIO2;	/* underflow? */
		if (x > 32764) {
			float64 e;
			y = modf(x, e);
			e += quad;

			float64 f;
			modf(0.25 * e, f);
			quad = e - 4 * f;
		}
		else {
			int k = x;
			y = x - k;
			quad += k;
			quad &= 3;
		}
		if (quad & 1) {
			y = 1-y;
		}
		if (quad > 1) {
			y = -y;
		}

		float64 ysq = y * y;
		float64 temp1 = ((((p4 * ysq + p3) * ysq + p2) * ysq + p1) * ysq + p0) * y;
		float64 temp2 = ((((ysq + q3) * ysq + q2) * ysq + q1) * ysq + q0);
		return temp1 / temp2;
	}

	/// Returns the sine of the input
	inline sin(float64 arg) = sinCos(arg, 0);

	/// Returns the cosine of the input
	inline cos(float64 arg) = sinCos(abs(arg), 1);

	/// Returns the tangent of the input
	float64 tan(float64 arg) {
		enum: float64 {
			PIO2: 1.570796326794896619231e0;
			p0: -0.1306820264754825668269611177e+5;
			p1:  0.1055970901714953193602353981e+4;
			p2: -0.1550685653483266376941705728e+2;
			p3:  0.3422554387241003435328470489e-1;
			p4:  0.3386638642677172096076369e-4;
			q0: -0.1663895238947119001851464661e+5;
			q1:  0.4765751362916483698926655581e+4;
			q2: -0.1555033164031709966900124574e+3;
		}

		bool complement = false;
		bool negate = false;

		if (arg < 0) {
			arg = -arg;
			negate = true;
		}
		arg = 2 * arg / PIO2;   /* overflow? */

		double e;
		double x = modf(arg, e);
		int i = int(e) % 4;

		if (i == 0) {}
		else if (i == 1) {
			x = 1 - x;
			complement = true;
		}
		else if (i == 2) {
			negate = !negate;
			complement = true;
		}
		else if (i == 3) {
			x = 1 - x;
			negate = !negate;
		}

		double xsq = x * x;
		float64 result = ((((p4 * xsq + p3) * xsq + p2) * xsq + p1) * xsq + p0) * x;
		result /= ((xsq + q2) * xsq + q1) * xsq + q0;

		if (complement) {
			if (result == 0) {
				return nan;
			}
			result = 1 / result;
		}
		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic sine of the input
	float64 sinh(float64 x) {
		// The coefficients are #2029 from Hart & Cheney. (20.36D)
		enum: float64 {
			P0: -0.6307673640497716991184787251e+6;
			P1: -0.8991272022039509355398013511e+5;
			P2: -0.2894211355989563807284660366e+4;
			P3: -0.2630563213397497062819489e+2;
			Q0: -0.6307673640497716991212077277e+6;
			Q1: 0.1521517378790019070696485176e+5;
			Q2: -0.173678953558233699533450911e+3;
		}

		bool negate = false;
		if (x < 0) {
			x = -x;
			negate = true;
		}

		if (x > 21) {
			return float64.exp(x) / 2;
		}

		float64 result;
		if (x > 0.5) {
			result = (float64.exp(x) - float64.exp(-x)) / 2;
		}
		else {
			float64 sq = x * x;
			result = (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
			result /= ((sq + Q2) * sq + Q1) * sq + Q0;
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/// Returns the hyperbolic cosine of the input
	float64 cosh(float64 x) {
		if (x < 0) {
			x = -x;
		}
		if (x > 21) {
			return float64.exp(x) / 2;
		}
		return (float64.exp(x) + float64.exp(-x)) / 2;
	}

	/** Returns the arc sine of the input
	 *  Special cases are:
	 *    Asin(±0) = ±0
	 *    Asin(x) = NaN if x < -1 or x > 1
	 */
	float64 asin(float64 x) {
		if (x == 0) {
			// special case
			return x;
		}

		bool negate = false;
		if (x < 0) {
			negate = true;
			x = -x;
		}

		if (x > 1) {
			// special case
			return nan;
		}

		float64 result = float64.sqrt(1 - x * x);
		if (x > 0.7) {
			result = pi / 2 - float64.atan2(result, x);
		}
		else {
			result = float64.atan2(x, result);
		}

		if (negate) {
			return -result;
		}
		return result;
	}

	/** Returns the arc cosine of the input
	 *  Special case is:
	 *    Acos(x) = NaN if x < -1 or x > 1
	 */
	inline acos(float64 x) = (pi / 2 - asin(x));

	/* arc cosine of x
		Absolute error <= 6.7e-5.
		http://http.developer.nvidia.com/Cg/acos.html
	float64 acos(float64 x) {
		float64 negate = 0;
		if (x < 0) {
			negate = 1;
			x = -x;
		}
		result = -0.0187293;
		result = result * x;
		result = result + 0.0742610;
		result = result * x;
		result = result - 0.2121144;
		result = result * x;
		result = result + 1.5707288;
		result = result * sqrt(1. - x);
		result = result - 2 * negate * result;
		result = negate * 3.14159265358979 + result;
	}*/

	/// Converts the input to radians from degrees.
	inline radians(float64 degrees) = float64(degrees * pi / 180);

	/// Converts the input to degrees from radians.
	inline degrees(float64 radians) = float64(radians * 180 / pi);

	// inline rand(int min, int max) = System.rand() % (max - min) + min;
	// inline rand(double min, double max) = (System.rand() / float64(RAND_MAX)) * (max - min) + min;
}

inline "math/Complex.ci";     // -> Complex<float64>
//inline "math/Rational.ci";    // -> Rational<int64>
inline "math/Vector4f.ci";
inline "math/Matrix4f.ci";
inline "math/Vector2d.ci";

//inline "math/BigInteger.ci"   // TODO: inline Rational -> BigInteger.Rational<BigInteger>
//inline "math/BigDecimal.ci"   // TODO: inline Complex -> BigDecimal.Complex<BigDecimal>

//inline "math/Perlin.ci";
// string related functions

/// Computes the length of the string
int length(char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(char str[*], char chr) {
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the index of the last occurrence of a character in string
int lastIndexOf(char str[*], char chr) {
	int result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
	return result;
}

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(char str[*], char with[*], int cmp(char chr, char with)) {
	for (int i = 0; with[i] != 0; i += 1) {
		if (cmp(str[i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(char str[*], char with[*], int cmp(char chr, char with)) {
	int withLen = length(with);
	int strLen = length(str);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if the two strings are equal, using a custom comparator
int compare(char str[*], char with[*], int cmp(char chr, char with)) {
	int result = 0;
	for (int i = 0; result == 0; i += 1) {
		result = cmp(str[i], with[i]);
		if (str[i] == 0) {
			break;
		}
	}
	return result;
}

/// ignore case character comparator
int ignCaseCmp(char chr, char with) {
	static char ignCase(char chr) {
		if (chr < 'A') {
			return chr;
		}
		if (chr > 'Z') {
			return chr;
		}
		return chr - 'A' + 'a';
	}

	return ignCase(chr) - ignCase(with);
}

/// default character comparator
int caseCmp(char chr, char with) {
	return chr - with;
}

inline startsWith(char str[*], char with[*]) = startsWith(str, with, caseCmp);
inline endsWith(char str[*], char with[*]) = endsWith(str, with, caseCmp);
inline compare(char str[*], char with[*]) = compare(str, with, caseCmp);

/// Check if a string contains the given character
inline contains(char str[*], char chr) = indexOf(str, chr) >= 0;

/* TODO: implement operator overloading

inline ==(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) < 0;
inline >(char lhs[*], char rhs[*]) = compare(lhs, rhs, caseCmp) > 0;

// */

/// Flags to convert numbers to string
struct FormatFlags {
	/// forced show sign
	const bool showSign = false;

	/// precision or radix
	const int precision = 0;

	/// padding character
	const char padChr = 0;

	/// padding length
	const int padLen = 0;
}

/// Append a string to the output at the given position
int append(char output[], int pos, char value[*]) {
	for (int i = 0; value[i]; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = value[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

// Append a number to the output at the given position
int append(char output[], int pos, char sign, uint64 value, FormatFlags format&) {
	static const char whiteSpace[] = " \t\n\r";
	static const char radixDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

	int len = 0;
	char digits[80];

	if (format.showSign) {
		if (sign == 0) {
			sign = '+';
		}
	}

	int radix = format.precision;
	if (radix == 0) {
		radix = 10;
	}
	assert(radix > 1, "radix is too small", radix);
	assert(radix < radixDigits.length, "radix is too big", radix);

	// print digits in reverse order
	for ( ; value > 0; value /= radix) {
		digits[len += 1] = radixDigits[value % radix];
	}
	if (len == 0) {
		digits[len += 1] = '0';
	}

	int maxLen = format.padLen - len;

	char padChr = format.padChr;
	if (padChr == '\0') {
		padChr = ' ';
	}

	// print sign value
	if (sign != 0) {
		maxLen -= 1;
		if (whiteSpace.contains(padChr)) {
			// if padding character is whitespace padd before sign
			for ( ; maxLen > 0; maxLen -= 1) {
				assert(pos < output.length);
				output[pos] = padChr;
				pos += 1;
			}
		}
		assert(pos < output.length);
		output[pos] = sign;
		pos += 1;
	}

	// print padding
	for ( ; maxLen > 0; maxLen -= 1) {
		assert(pos < output.length);
		output[pos] = padChr;
		pos += 1;
	}

	// print digits
	for (int i = 0; i < len; i += 1) {
		assert(i < output.length);
		output[pos] = digits[len - i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, uint64 value, FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint32 value, FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint16 value, FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, uint8 value, FormatFlags format&) = append(output, pos, 0, uint64(value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int64 value, FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int32 value, FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int16 value, FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);
/// Append a number to the output at the given position
inline append(char output[], int pos, int8 value, FormatFlags format&) = append(output, pos, value < 0 ? '-' : 0, uint64(value < 0 ? -value : value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, float64 value, FormatFlags format&) {
	FormatFlags formatInt = {
		showSign: format.showSign;
		precision : 0;
		padChr: format.padChr;
		padLen: format.padLen - format.precision;
	};
	FormatFlags formatDec = {
		showSign: false;
		precision : 0;
		padChr: '0';
		padLen: format.precision;
	};

	char sign = value < 0 ? '-' : 0;
	float64 fract = Math.modf(Math.abs(value), value);
	pos = output.append(pos, sign, uint64(value), formatInt);

	pos = output.append(pos, ".");
	fract *= float64.pow(10, format.precision);
	pos = output.append(pos, 0, uint64(fract), formatDec);
	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, float32 value, FormatFlags format&) = append(output, pos, float64(value), format);

/// Append a number to the output at the given position
int append(char output[], int pos, int value) {
	static const FormatFlags format = {};
	return append(output, pos, value, format);
}

//inline append(char output[], uint32 value, FormatFlags format) = output.append(length(output), value, format);
//inline append(char output[], uint32 value) = output.append(length(output), value);
//inline append(char output[], char value[*]) = output.append(length(output), value);
