typename
typename.size
typename.offset
typename.base(type: typename): typename
typename.file(type: typename): .cstr
typename.line(type: typename): int32
typename.name(type: typename): .cstr
void
bool
char
int8
int16
int32
int64
uint8
uint16
uint32
uint32.zxt(value: int32, offs: int32, count: int32): int32
uint32.sxt(value: int32, offs: int32, count: int32): int32
uint32.pop(value: int32): int32
uint32.swap(value: int32): int32
uint32.bsr(value: int32): int32
uint32.bsf(value: int32): int32
uint32.hib(value: int32): int32
uint32.lob(value: int32): int32
uint64
uint64.zxt(value: int64, offs: int32, count: int32): int64
uint64.sxt(value: int64, offs: int32, count: int32): int64
float32
float32.sin(x: float32): float32
float32.cos(x: float32): float32
float32.tan(x: float32): float32
float32.log(x: float32): float32
float32.exp(x: float32): float32
float32.pow(x: float32, y: float32): float32
float32.sqrt(x: float32): float32
float32.atan2(x: float32, y: float32): float32
float64
float64.sin(x: float64): float64
float64.cos(x: float64): float64
float64.tan(x: float64): float64
float64.log(x: float64): float64
float64.exp(x: float64): float64
float64.pow(x: float64, y: float64): float64
float64.sqrt(x: float64): float64
float64.atan2(x: float64, y: float64): float64
pointer
pointer.alloc(ptr: pointer, size: int32): pointer
pointer.fill(dst: pointer, value: int32, size: int32): pointer
pointer.copy(dst: pointer, src: pointer, size: int32): pointer
pointer.move(dst: pointer, src: pointer, size: int32): pointer
variant
function
object
null
true
false
int
byte
float
double
emit
emit.nop
emit.not
emit.set
emit.ret
emit.call
emit.p4x
emit.p4x.dp3
emit.p4x.dp4
emit.p4x.dph
emit.dup
emit.dup.x1
emit.dup.x2
emit.dup.x4
emit.load
emit.load.z32
emit.load.z64
emit.load.z128
emit.load.i8
emit.load.i16
emit.load.i32
emit.load.i64
emit.load.i128
emit.store
emit.store.i8
emit.store.i16
emit.store.i32
emit.store.i64
emit.store.i128
emit.cmt
emit.cmt.u32
emit.cmt.u64
emit.and
emit.and.u32
emit.and.u64
emit.or
emit.or.u32
emit.or.u64
emit.xor
emit.xor.u32
emit.xor.u64
emit.shl
emit.shl.u32
emit.shl.u64
emit.shr
emit.shr.i32
emit.shr.i64
emit.shr.u32
emit.shr.u64
emit.neg
emit.neg.i32
emit.neg.i64
emit.neg.f32
emit.neg.f64
emit.neg.p4f
emit.neg.p2d
emit.add
emit.add.i32
emit.add.i64
emit.add.f32
emit.add.f64
emit.add.p4f
emit.add.p2d
emit.sub
emit.sub.i32
emit.sub.i64
emit.sub.f32
emit.sub.f64
emit.sub.p4f
emit.sub.p2d
emit.mul
emit.mul.i32
emit.mul.i64
emit.mul.u32
emit.mul.u64
emit.mul.f32
emit.mul.f64
emit.mul.p4f
emit.mul.p2d
emit.div
emit.div.i32
emit.div.i64
emit.div.u32
emit.div.u64
emit.div.f32
emit.div.f64
emit.div.p4f
emit.div.p2d
emit.mod
emit.mod.i32
emit.mod.i64
emit.mod.u32
emit.mod.u64
emit.mod.f32
emit.mod.f64
emit.ceq
emit.ceq.i32
emit.ceq.i64
emit.ceq.f32
emit.ceq.f64
emit.ceq.p4f
emit.ceq.p2d
emit.clt
emit.clt.i32
emit.clt.i64
emit.clt.u32
emit.clt.u64
emit.clt.f32
emit.clt.f64
emit.cgt
emit.cgt.i32
emit.cgt.i64
emit.cgt.u32
emit.cgt.u64
emit.cgt.f32
emit.cgt.f64
emit.min
emit.min.p4f
emit.min.p2d
emit.max
emit.max.p4f
emit.max.p2d
halt(): void
CLOCKS_PER_SEC
RAND_MAX
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
raise.abort
raise.error
raise.warn
raise.info
raise.debug
raise.verbose
raise.noTrace
raise.defTrace
tryExec(args: pointer, action(args: pointer): void): int32
System
System.exit(code: int32): void
System.srand(seed: int32): void
System.rand(): int32
System.time(): int32
System.clock(): int32
System.millis(): int64
System.sleep(millis: int64): void
verbose(message: char[*], inspect: variant): void
verbose(message: char[*]): void
trace(message: char[*], inspect: variant): void
trace(message: char[*]): void
debug(message: char[*], inspect: variant): void
debug(message: char[*]): void
info(message: char[*], inspect: variant): void
info(message: char[*]): void
warn(message: char[*], inspect: variant): void
warn(message: char[*]): void
error(message: char[*], inspect: variant): void
error(message: char[*]): void
abort(message: char[*], inspect: variant): void
abort(message: char[*]): void
abort(): void
assert(condition: bool, message: char[*], inspect: variant): void
assert(condition: bool, message: char[*]): void
assert(condition: bool): void
NotEquals
NotEquals.expected
NotEquals.returned
NotEquals.message
assertEq(expected: int32, returned: int32, message: char[*]): void
assertEq(expected: int32, returned: int32): void
sizeof(type: typename): int32
Math
Math.pi
Math.e
Math.ln2
Math.log2E
Math.ln10
Math.log10E
Math.phi
Math.sqrt2
Math.sqrtE
Math.sqrtPi
Math.sqrtPhi
Math.nan
Math.inf
Math.modf(x: float64, intPart: float64): float64
Math.floor(x: float64): float64
Math.ceil(x: float64): float64
Math.round(x: float64): float64
Math.sign(x: float32): int32
Math.sign(x: float64): int32
Math.abs(x: float32): float32
Math.abs(x: float64): float64
Math.min(a: float32, b: float32): float32
Math.min(a: float64, b: float64): float64
Math.max(a: float32, b: float32): float32
Math.max(a: float64, b: float64): float64
Math.clamp(t: float32, a: float32, b: float32): float32
Math.clamp(t: float64, a: float64, b: float64): float64
Math.lerp(t: float32, a: float32, b: float32): float32
Math.lerp(t: float64, a: float64, b: float64): float64
Math.smooth(t: float32, a: float32, b: float32): float32
Math.smooth(t: float64, a: float64, b: float64): float64
Math.smooth(t: float32): float32
Math.smooth(t: float64): float64
Math.cmp(a: float32, b: float32, eps: float32): int32
Math.cmp(a: float64, b: float64, eps: float64): int32
Math.sinCos(arg: float64, quad: int32): float64
Math.sin(arg: float64): float64
Math.cos(arg: float64): float64
Math.tan(arg: float64): float64
Math.sinh(x: float64): float64
Math.cosh(x: float64): float64
Math.asin(x: float64): float64
Math.acos(x: float64): float64
Math.deg2rad(x: float64): float64
Math.rad2deg(x: float64): float64
Complex
Complex.re
Complex.im
Complex(re: float64): Complex
Complex(re: float64, im: float64): Complex
neg(a: Complex): Complex
add(a: Complex, b: Complex): Complex
add(a: Complex, b: float64): Complex
add(a: float64, b: Complex): Complex
sub(a: Complex, b: Complex): Complex
sub(a: Complex, b: float64): Complex
sub(a: float64, b: Complex): Complex
mul(a: Complex, b: Complex): Complex
mul(a: Complex, b: float64): Complex
mul(a: float64, b: Complex): Complex
div(a: Complex, b: Complex): Complex
div(a: Complex, b: float64): Complex
div(a: float64, b: Complex): Complex
abs(a: Complex): float64
arg(a: Complex): float64
inv(a: Complex): Complex
conj(a: Complex): Complex
exp(a: Complex): Complex
log(a: Complex): Complex
pow(a: Complex, b: Complex): Complex
pow(a: Complex, b: float64): Complex
sin(a: Complex): Complex
cos(a: Complex): Complex
tan(a: Complex): Complex
cot(a: Complex): Complex
sinh(a: Complex): Complex
cosh(a: Complex): Complex
tanh(a: Complex): Complex
coth(a: Complex): Complex
sec(a: Complex): Complex
csc(a: Complex): Complex
sech(a: Complex): Complex
csch(a: Complex): Complex
toCartesian(x: Complex): Complex
toPolar(x: Complex): Complex
length(str: char[*]): int32
indexOf(str: char[*], chr: char): int32
lastIndexOf(str: char[*], chr: char): int32
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
ignCaseCmp(chr: char, with: char): int32
caseCmp(chr: char, with: char): int32
startsWith(str: char[*], with: char[*]): bool
endsWith(str: char[*], with: char[*]): bool
compare(str: char[*], with: char[*]): int32
contains(str: char[*], chr: char): bool
FormatFlags
FormatFlags.radix
FormatFlags.padChr
FormatFlags.padLen
FormatFlags.precision
append(output: char[], pos: int32, value: char[*]): int32
append(output: char[], pos: int32, sign: char, value: uint32, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint32): int32
gxRect
gxRect.x
gxRect.y
gxRect.w
gxRect.h
gxSurf
gxSurf.create(width: int32, height: int32, depth: int32): gxSurf
gxSurf.create3d(width: int32, height: int32): gxSurf
gxSurf.recycle(recycle: gxSurf, width: int32, height: int32, depth: int32, flags: int32): gxSurf
gxSurf.destroy(surf: gxSurf): void
gxSurf.openBmp(path: char[*], depth: int32): gxSurf
gxSurf.openPng(path: char[*], depth: int32): gxSurf
gxSurf.openJpg(path: char[*], depth: int32): gxSurf
gxSurf.openFnt(path: char[*]): gxSurf
gxSurf.saveBmp(surf: gxSurf, path: char[*], flags: int32): void
gxSurf.width(surf: gxSurf): int32
gxSurf.height(surf: gxSurf): int32
gxSurf.depth(surf: gxSurf): int32
gxSurf.get(surf: gxSurf, x: int32, y: int32): int32
gxSurf.set(surf: gxSurf, x: int32, y: int32, color: uint32): void
gxSurf.drawRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
gxSurf.fillRect(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
gxSurf.drawOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
gxSurf.fillOval(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
gxSurf.drawLine(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void
gxSurf.drawBezier(surf: gxSurf, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void
gxSurf.clipText(font: gxSurf, rect: gxRect, text: char[*]): void
gxSurf.drawText(surf: gxSurf, x: int32, y: int32, font: gxSurf, text: char[*], color: int32): void
gxSurf.copy(surf: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
gxSurf.resize(surf: gxSurf, rect: gxRect, src: gxSurf, roi: gxRect, interpolate: int32): void
gxSurf.colorMap(surf: gxSurf, roi: gxRect, lut: uint32[256]): void
gxSurf.colorMat(surf: gxSurf, roi: gxRect, mat: float32[16]): void
gxSurf.calcHist(surf: gxSurf, roi: gxRect, rgb: uint32, lut: uint32[256]): void
gxSurf.drawMesh(surf: gxSurf, mesh: gxMesh, mode: int32): int32
gxMesh
gxMesh.create(size: int32): gxMesh
gxMesh.recycle(recycle: gxMesh, size: int32): gxMesh
gxMesh.destroy(mesh: gxMesh): void
gxMesh.openObj(path: char[*]): gxMesh
gxMesh.open3ds(path: char[*]): gxMesh
gxMesh.saveObj(mesh: gxMesh, path: char[*]): void
gxMesh.normalize(mesh: gxMesh, tolerance: float32, center: float32[3], resize: float32[3]): void
gxMesh.addVertex(mesh: gxMesh, x: float32, y: float32, z: float32): void
gxMesh.ambient(mesh: gxMesh, r: float32, g: float32, b: float32): void
gxMesh.diffuse(mesh: gxMesh, r: float32, g: float32, b: float32): void
gxMesh.specular(mesh: gxMesh, r: float32, g: float32, b: float32): void
gxMesh.shine(mesh: gxMesh, value: float32): void
gxMesh.texture(mesh: gxMesh, surf: gxSurf): void
gxMesh.clearDepth
gxMesh.clearColor
gxMesh.cullBack
gxMesh.cullFront
gxMesh.drawPlot
gxMesh.drawWire
gxMesh.drawFill
gxMesh.drawMode
gxMesh.useTexture
gxMesh.useLights
gxMesh.vertices
gxMesh.triangles
gxMesh.segments
camera
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void
camera.readUp(result: float32[3]): void
camera.readRight(result: float32[3]): void
camera.readForward(result: float32[3]): void
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void
camera.move(direction: float32[3], amount: float32): void
lights
lights.enabled(light: int32): bool
lights.enable(light: int32, on: bool): void
lights.position(light: int32, x: float32, y: float32, z: float32): void
lights.ambient(light: int32, r: float32, g: float32, b: float32): void
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void
lights.specular(light: int32, r: float32, g: float32, b: float32): void
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void
Gui
Gui.KEY_PRESS
Gui.KEY_RELEASE
Gui.MOUSE_PRESS
Gui.MOUSE_MOTION
Gui.MOUSE_RELEASE
Gui.EVENT_TIMEOUT
Gui.WINDOW_CREATE
Gui.WINDOW_CLOSE
Gui.WINDOW_ENTER
Gui.WINDOW_LEAVE
Gui.KEY_MASK_SHIFT
Gui.KEY_MASK_CONTROL
Gui.showWindow(surf: gxSurf, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
Gui.setTitle(title: char[*]): void
vec2d
vec2d.x
vec2d.y
vec2d(x: float64, y: float64): vec2d
sub(a: vec2d, b: vec2d): vec2d
dot(a: vec2d, b: vec2d): float64
vec4f
vec4f.data
vec4f..anonymous.x
vec4f..anonymous.y
vec4f..anonymous.z
vec4f..anonymous.w
vec4f.x
vec4f.y
vec4f.z
vec4f.w
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
vec4f(x: float32, y: float32, z: float32): vec4f
vec4f(xyz: vec4f, w: float32): vec4f
vec4f(val: float32): vec4f
neg(rhs: vec4f): vec4f
add(lhs: vec4f, rhs: vec4f): vec4f
sub(lhs: vec4f, rhs: vec4f): vec4f
mul(lhs: vec4f, rhs: vec4f): vec4f
div(lhs: vec4f, rhs: vec4f): vec4f
min(lhs: vec4f, rhs: vec4f): float32
max(lhs: vec4f, rhs: vec4f): float32
dp3(lhs: vec4f, rhs: vec4f): float32
dph(lhs: vec4f, rhs: vec4f): float32
dp4(lhs: vec4f, rhs: vec4f): float32
cross(a: vec4f, b: vec4f): vec4f
len(v: vec4f): float32
normalize(v: vec4f): vec4f
eval(v: vec4f, x: float32): float32
mat4f
mat4f.data
mat4f..anonymous.x
mat4f..anonymous.y
mat4f..anonymous.z
mat4f..anonymous.w
mat4f.x
mat4f.y
mat4f.z
mat4f.w
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
dp3(mat: mat4f, vec: vec4f): vec4f
dp4(mat: mat4f, vec: vec4f): vec4f
dph(mat: mat4f, vec: vec4f): vec4f
mul(lhs: mat4f, rhs: mat4f): mat4f
grayClamp(c: uint32): uint32
grayClamp(c: int32): uint32
grayAnd(c: uint32): uint32
rgb(r: int32, g: int32, b: int32): uint32
rgb(r: uint32, g: uint32, b: uint32): uint32
rgbClamp(r: uint32, g: uint32, b: uint32): uint32
rgbClamp(r: int32, g: int32, b: int32): uint32
rgbAnd(r: uint32, g: uint32, b: uint32): uint32
rgb(r: float64, g: float64, b: float64): uint32
rgb(r: float32, g: float32, b: float32): uint32
gray(c: float64): uint32
gray(c: float32): uint32
ach(col: uint32): uint32
rch(col: uint32): uint32
gch(col: uint32): uint32
bch(col: uint32): uint32
lum(c: uint32): uint32
argb
argb.b
argb.g
argb.r
argb.a
uint32(value: argb): uint32
argb(argb: uint32): argb
argb(r: uint32, g: uint32, b: uint32): argb
argb(a: uint32, r: uint32, g: uint32, b: uint32): argb
rgbOr(c1: uint32, c2: uint32): uint32
rgbXor(c1: uint32, c2: uint32): uint32
rgbAnd(c1: uint32, c2: uint32): uint32
rgbAdd(c1: uint32, c2: uint32): uint32
rgbAvg(c1: uint32, c2: uint32): uint32
rgbSub(c1: uint32, c2: uint32): uint32
rgbMul(c1: uint32, c2: uint32): uint32
rgbDiv(c1: uint32, c2: uint32): uint32
rgbLerp16(c1: uint32, c2: uint32, t: uint32): uint32
rgbLerp(c1: uint32, c2: uint32, t: float64): uint32
drawHist(image: gxSurf, roi: gxRect, hist: uint32): void
rgb(vec: vec4f): uint32
hsv2rgb(hsv: vec4f): vec4f
gxSurf(width: int32, height: int32, depth: int32): gxSurf
gxSurf(fileName: char[*], depth: int32): gxSurf
gxSurf(fileName: char[*]): gxSurf
gxMesh(fileName: char[*]): gxMesh
gxSurf(copy: gxSurf): gxSurf
clip(src: gxSurf, roi: gxRect): bool
eval(out: gxSurf, roi: gxRect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
tile(dst: gxSurf, x: int32, y: int32, src: gxSurf, roi: gxRect): void
show(mesh: gxMesh, w: int32, h: int32, fovy: float32): void
show(surf: gxSurf): void
show(surf: gxSurf, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void
showDiff(image1: gxSurf, image2: gxSurf): void
showWindow(w: int32, h: int32, t: int32, eval(in: vec4f): vec4f): void
