typename
typename.size
typename.offset
typename.base(type: typename): typename
typename.file(type: typename): .cstr
typename.line(type: typename): int32
typename.name(type: typename): .cstr
void
bool
char
int8
int16
int32
int64
uint8
uint16
uint32
uint32.zxt(value: int32, offs: int32, count: int32): int32
uint32.sxt(value: int32, offs: int32, count: int32): int32
uint32.pop(value: int32): int32
uint32.swap(value: int32): int32
uint32.bsr(value: int32): int32
uint32.bsf(value: int32): int32
uint32.hib(value: int32): int32
uint32.lob(value: int32): int32
uint64
uint64.zxt(value: int64, offs: int32, count: int32): int64
uint64.sxt(value: int64, offs: int32, count: int32): int64
float32
float32.sin(x: float32): float32
float32.cos(x: float32): float32
float32.tan(x: float32): float32
float32.log(x: float32): float32
float32.exp(x: float32): float32
float32.pow(x: float32, y: float32): float32
float32.sqrt(x: float32): float32
float32.atan2(x: float32, y: float32): float32
float64
float64.sin(x: float64): float64
float64.cos(x: float64): float64
float64.tan(x: float64): float64
float64.log(x: float64): float64
float64.exp(x: float64): float64
float64.pow(x: float64, y: float64): float64
float64.sqrt(x: float64): float64
float64.atan2(x: float64, y: float64): float64
pointer
pointer.alloc(ptr: pointer, size: int32): pointer
pointer.fill(dst: pointer, value: int32, size: int32): pointer
pointer.copy(dst: pointer, src: pointer, size: int32): pointer
pointer.move(dst: pointer, src: pointer, size: int32): pointer
variant
variant.is(var: variant, type: typename): bool
variant.as(var: variant, type: typename): pointer
function
object
object.create(type: typename): pointer
object.as(obj: object, type: typename): pointer
null
int
emit
emit.nop
emit.not
emit.set
emit.ret
emit.call
emit.p4x
emit.p4x.dp3
emit.p4x.dp4
emit.p4x.dph
emit.dup
emit.dup.x1
emit.dup.x2
emit.dup.x4
emit.load
emit.load.z32
emit.load.z64
emit.load.z128
emit.load.i8
emit.load.i16
emit.load.i32
emit.load.i64
emit.load.i128
emit.store
emit.store.i8
emit.store.i16
emit.store.i32
emit.store.i64
emit.store.i128
emit.cmt
emit.cmt.u32
emit.cmt.u64
emit.and
emit.and.u32
emit.and.u64
emit.or
emit.or.u32
emit.or.u64
emit.xor
emit.xor.u32
emit.xor.u64
emit.shl
emit.shl.u32
emit.shl.u64
emit.shr
emit.shr.i32
emit.shr.i64
emit.shr.u32
emit.shr.u64
emit.neg
emit.neg.i32
emit.neg.i64
emit.neg.f32
emit.neg.f64
emit.neg.p4f
emit.neg.p2d
emit.add
emit.add.i32
emit.add.i64
emit.add.f32
emit.add.f64
emit.add.p4f
emit.add.p2d
emit.sub
emit.sub.i32
emit.sub.i64
emit.sub.f32
emit.sub.f64
emit.sub.p4f
emit.sub.p2d
emit.mul
emit.mul.i32
emit.mul.i64
emit.mul.u32
emit.mul.u64
emit.mul.f32
emit.mul.f64
emit.mul.p4f
emit.mul.p2d
emit.div
emit.div.i32
emit.div.i64
emit.div.u32
emit.div.u64
emit.div.f32
emit.div.f64
emit.div.p4f
emit.div.p2d
emit.mod
emit.mod.i32
emit.mod.i64
emit.mod.u32
emit.mod.u64
emit.mod.f32
emit.mod.f64
emit.ceq
emit.ceq.i32
emit.ceq.i64
emit.ceq.f32
emit.ceq.f64
emit.ceq.p4f
emit.ceq.p2d
emit.clt
emit.clt.i32
emit.clt.i64
emit.clt.u32
emit.clt.u64
emit.clt.f32
emit.clt.f64
emit.cgt
emit.cgt.i32
emit.cgt.i64
emit.cgt.u32
emit.cgt.u64
emit.cgt.f32
emit.cgt.f64
emit.min
emit.min.p4f
emit.min.p2d
emit.max
emit.max.p4f
emit.max.p2d
emit.swz
emit.swz.x2
halt(): void
CLOCKS_PER_SEC
RAND_MAX
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], inspect: variant): void
raise.abort
raise.error
raise.warn
raise.info
raise.debug
raise.verbose
raise.noTrace
raise.defTrace
tryExec(args: pointer, action(args: pointer): void): int32
System
System.exit(code: int32): void
System.srand(seed: int32): void
System.rand(): int32
System.time(): int32
System.clock(): int32
System.millis(): int64
System.sleep(millis: int64): void
true
false
byte
float
double
verbose(message: char[*], inspect: variant): void
verbose(message: char[*]): void
debug(message: char[*], inspect: variant): void
debug(message: char[*]): void
trace(message: char[*], inspect: variant): void
trace(message: char[*]): void
info(message: char[*], inspect: variant): void
info(message: char[*]): void
warn(message: char[*], inspect: variant): void
warn(message: char[*]): void
error(message: char[*], inspect: variant): void
error(message: char[*]): void
abort(message: char[*], inspect: variant): void
abort(message: char[*]): void
abort(): void
assert(condition: bool, message: char[*], inspect: variant): void
assert(condition: bool, message: char[*]): void
assert(condition: bool): void
NotEquals
NotEquals.expected
NotEquals.returned
NotEquals.argument
NotEquals.message
assertEq(expected: int32, returned: int32, message: char[*]): void
assertEq(expected: int32, returned: int32): void
sizeof(type: typename): int32
Math
Math.pi
Math.e
Math.ln2
Math.log2E
Math.ln10
Math.log10E
Math.phi
Math.sqrt2
Math.sqrtE
Math.sqrtPi
Math.sqrtPhi
Math.nan
Math.inf
Math.modf(x: float64, intPart: float64): float64
Math.floor(x: float64): float64
Math.ceil(x: float64): float64
Math.round(x: float64): float64
Math.sign(x: float32): int32
Math.sign(x: float64): int32
Math.abs(x: float32): float32
Math.abs(x: float64): float64
Math.absMod(val: float32, mod: float32): float32
Math.absMod(val: float64, mod: float64): float64
Math.min(a: float32, b: float32): float32
Math.min(a: float64, b: float64): float64
Math.max(a: float32, b: float32): float32
Math.max(a: float64, b: float64): float64
Math.clamp(t: float32, a: float32, b: float32): float32
Math.clamp(t: float64, a: float64, b: float64): float64
Math.lerp(t: float32, a: float32, b: float32): float32
Math.lerp(t: float64, a: float64, b: float64): float64
Math.smooth(t: float32): float32
Math.smooth(t: float64): float64
Math.smooth(t: float32, a: float32, b: float32): float32
Math.smooth(t: float64, a: float64, b: float64): float64
Math.min(data: float64[]): float64
Math.max(data: float64[]): float64
Math.sum(data: float64[]): float64
Math.mean(data: float64[]): float64
Math.eval(x: float64, a0: float64): float64
Math.eval(x: float64, a0: float64, a1: float64): float64
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64
Math.eval(x: float64, polynomial: float64[]): float64
Math.cmp(a: float32, b: float32, eps: float32): int32
Math.cmp(a: float64, b: float64, eps: float64): int32
Math.sinCos(arg: float64, quad: int32): float64
Math.sin(arg: float64): float64
Math.cos(arg: float64): float64
Math.tan(arg: float64): float64
Math.sinh(x: float64): float64
Math.cosh(x: float64): float64
Math.asin(x: float64): float64
Math.acos(x: float64): float64
Math.radians(degrees: float64): float64
Math.degrees(radians: float64): float64
Complex
Complex.re
Complex.im
Complex(re: float64): Complex
Complex(re: float64, im: float64): Complex
neg(a: Complex): Complex
add(a: Complex, b: Complex): Complex
add(a: Complex, b: float64): Complex
add(a: float64, b: Complex): Complex
sub(a: Complex, b: Complex): Complex
sub(a: Complex, b: float64): Complex
sub(a: float64, b: Complex): Complex
mul(a: Complex, b: Complex): Complex
mul(a: Complex, b: float64): Complex
mul(a: float64, b: Complex): Complex
div(a: Complex, b: Complex): Complex
div(a: Complex, b: float64): Complex
div(a: float64, b: Complex): Complex
abs(a: Complex): float64
arg(a: Complex): float64
inv(a: Complex): Complex
conj(a: Complex): Complex
exp(a: Complex): Complex
log(a: Complex): Complex
pow(a: Complex, b: Complex): Complex
pow(a: Complex, b: float64): Complex
sin(a: Complex): Complex
cos(a: Complex): Complex
tan(a: Complex): Complex
cot(a: Complex): Complex
sinh(a: Complex): Complex
cosh(a: Complex): Complex
tanh(a: Complex): Complex
coth(a: Complex): Complex
sec(a: Complex): Complex
csc(a: Complex): Complex
sech(a: Complex): Complex
csch(a: Complex): Complex
toCartesian(x: Complex): Complex
toPolar(x: Complex): Complex
vec4f
vec4f.data
vec4f.<?>
vec4f.<?>.x
vec4f.<?>.y
vec4f.<?>.z
vec4f.<?>.w
vec4f.x
vec4f.y
vec4f.z
vec4f.w
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f
vec4f(x: float32, y: float32, z: float32): vec4f
vec4f(x: float32, y: float32): vec4f
vec4f(xyz: vec4f, w: float32): vec4f
vec4f(val: float32): vec4f
neg(rhs: vec4f): vec4f
add(lhs: vec4f, rhs: vec4f): vec4f
sub(lhs: vec4f, rhs: vec4f): vec4f
mul(lhs: vec4f, rhs: vec4f): vec4f
div(lhs: vec4f, rhs: vec4f): vec4f
min(lhs: vec4f, rhs: vec4f): float32
max(lhs: vec4f, rhs: vec4f): float32
dp3(lhs: vec4f, rhs: vec4f): float32
dph(lhs: vec4f, rhs: vec4f): float32
dp4(lhs: vec4f, rhs: vec4f): float32
cross(a: vec4f, b: vec4f): vec4f
length(v: vec4f): float32
normalize(v: vec4f): vec4f
eval(v: vec4f, x: float32): float32
mat4f
mat4f.data
mat4f.m
mat4f.v
mat4f.<?>
mat4f.<?>.x
mat4f.<?>.y
mat4f.<?>.z
mat4f.<?>.w
mat4f.x
mat4f.y
mat4f.z
mat4f.w
mat4f.<?>
mat4f.<?>.xx
mat4f.<?>.xy
mat4f.<?>.xz
mat4f.<?>.xw
mat4f.<?>.yx
mat4f.<?>.yy
mat4f.<?>.yz
mat4f.<?>.yw
mat4f.<?>.zx
mat4f.<?>.zy
mat4f.<?>.zz
mat4f.<?>.zw
mat4f.<?>.wx
mat4f.<?>.wy
mat4f.<?>.wz
mat4f.<?>.ww
mat4f.xx
mat4f.xy
mat4f.xz
mat4f.xw
mat4f.yx
mat4f.yy
mat4f.yz
mat4f.yw
mat4f.zx
mat4f.zy
mat4f.zz
mat4f.zw
mat4f.wx
mat4f.wy
mat4f.wz
mat4f.ww
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f
dp3(mat: mat4f, vec: vec4f): vec4f
dph(mat: mat4f, vec: vec4f): vec4f
dp4(mat: mat4f, vec: vec4f): vec4f
transpose(mat: mat4f): mat4f
mul(lhs: mat4f, rhs: mat4f): mat4f
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
rotation(direction: vec4f, angle: float32): mat4f
translation(direction: vec4f, amount: float32): mat4f
scale(direction: vec4f, amount: float32): mat4f
vec2d
vec2d.data
vec2d.<?>
vec2d.<?>.x
vec2d.<?>.y
vec2d.x
vec2d.y
vec2d(x: float64, y: float64): vec2d
add(a: vec2d, b: vec2d): vec2d
sub(a: vec2d, b: vec2d): vec2d
mul(a: vec2d, b: vec2d): vec2d
div(a: vec2d, b: vec2d): vec2d
min(a: vec2d, b: vec2d): vec2d
max(a: vec2d, b: vec2d): vec2d
ceq(a: vec2d, b: vec2d): vec2d
dot(a: vec2d, b: vec2d): float64
length(str: char[*]): int32
indexOf(str: char[*], chr: char): int32
lastIndexOf(str: char[*], chr: char): int32
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32
ignCaseCmp(chr: char, with: char): int32
caseCmp(chr: char, with: char): int32
startsWith(str: char[*], with: char[*]): bool
endsWith(str: char[*], with: char[*]): bool
compare(str: char[*], with: char[*]): int32
equals(str: char[*], with: char[*]): bool
contains(str: char[*], chr: char): bool
FormatFlags
FormatFlags.showSign
FormatFlags.precision
FormatFlags.padChr
FormatFlags.padLen
append(output: char[], pos: int32, value: char[*]): int32
append(output: char[], pos: int32, sign: char, value: uint64, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32
append(output: char[], pos: int32, value: int32): int32
Rect
Rect.x
Rect.y
Rect.w
Rect.h
Image
Image.create(width: int32, height: int32, depth: int32): Image
Image.create3d(width: int32, height: int32): Image
Image.recycle(recycle: Image, width: int32, height: int32, depth: int32, flags: int32): Image
Image.destroy(image: Image): void
Image.openBmp(path: char[*], depth: int32): Image
Image.openPng(path: char[*], depth: int32): Image
Image.openJpg(path: char[*], depth: int32): Image
Image.openFnt(path: char[*]): Image
Image.saveBmp(image: Image, path: char[*], flags: int32): void
Image.width(image: Image): int32
Image.height(image: Image): int32
Image.depth(image: Image): int32
Image.get(image: Image, x: int32, y: int32): int32
Image.set(image: Image, x: int32, y: int32, color: uint32): void
Image.tex(image: Image, x: float32, y: float32): vec4f
Image.drawRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
Image.fillRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
Image.drawOval(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
Image.fillOval(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
Image.drawLine(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, color: int32): void
Image.drawBezier(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: int32): void
Image.drawBezier(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, x4: int32, y4: int32, color: int32): void
Image.clipText(font: Image, rect: Rect, text: char[*]): void
Image.drawText(image: Image, x: int32, y: int32, font: Image, text: char[*], color: int32): void
Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
Image.copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, alpha: int32, dstAlpha: bool, blend(base: vec4f, with: vec4f): vec4f): void
Image.transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: float32[16]): void
Image.blur(image: Image, radius: int32, sigma: float64): void
Image.colorMap(image: Image, roi: Rect, lut: uint32[256]): void
Image.colorMat(image: Image, roi: Rect, mat: float32[16]): void
Image.calcHist(image: Image, roi: Rect, rgb: uint32, lut: uint32[256]): void
Image.drawMesh(image: Image, mesh: Mesh, mode: int32): int32
Mesh
Mesh.create(size: int32): Mesh
Mesh.recycle(recycle: Mesh, size: int32): Mesh
Mesh.destroy(mesh: Mesh): void
Mesh.openObj(path: char[*]): Mesh
Mesh.open3ds(path: char[*]): Mesh
Mesh.saveObj(mesh: Mesh, path: char[*]): void
Mesh.normalize(mesh: Mesh, tolerance: float32, center: float32[3], resize: float32[3]): void
Mesh.addVertex(mesh: Mesh, x: float32, y: float32, z: float32): int32
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32): int32
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32, v4: int32): int32
Mesh.setVertex(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool
Mesh.setNormal(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool
Mesh.setTexture(mesh: Mesh, idx: int32, s: float32, t: float32): bool
Mesh.ambient(mesh: Mesh, r: float32, g: float32, b: float32): void
Mesh.diffuse(mesh: Mesh, r: float32, g: float32, b: float32): void
Mesh.specular(mesh: Mesh, r: float32, g: float32, b: float32): void
Mesh.shine(mesh: Mesh, value: float32): void
Mesh.texture(mesh: Mesh, texture: Image): void
Mesh.clearDepth
Mesh.clearColor
Mesh.cullBack
Mesh.cullFront
Mesh.drawPlot
Mesh.drawWire
Mesh.drawFill
Mesh.drawMode
Mesh.useTexture
Mesh.useLights
Mesh.vertices
Mesh.triangles
Mesh.segments
gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
gradient.Linear
gradient.Radial
gradient.Square
gradient.Spiral
gradient.Conical
gradient.MaskLinear
gradient.MaskRadial
gradient.MaskSquare
camera
camera.projection(fovy: float32, aspect: float32, near: float32, far: float32): void
camera.lookAt(eye: float32[3], at: float32[3], up: float32[3]): void
camera.readUp(result: float32[3]): void
camera.readRight(result: float32[3]): void
camera.readForward(result: float32[3]): void
camera.rotate(direction: float32[3], orbit: float32[3], angle: float32): void
camera.move(direction: float32[3], amount: float32): void
lights
lights.enabled(light: int32): bool
lights.enable(light: int32, on: bool): void
lights.position(light: int32, x: float32, y: float32, z: float32): void
lights.ambient(light: int32, r: float32, g: float32, b: float32): void
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void
lights.specular(light: int32, r: float32, g: float32, b: float32): void
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void
Gui
Gui.KEY_PRESS
Gui.KEY_RELEASE
Gui.MOUSE_PRESS
Gui.MOUSE_MOTION
Gui.MOUSE_RELEASE
Gui.FINGER_PRESS
Gui.FINGER_MOTION
Gui.FINGER_RELEASE
Gui.EVENT_TIMEOUT
Gui.WINDOW_INIT
Gui.WINDOW_DRAW
Gui.WINDOW_CLOSE
Gui.WINDOW_ENTER
Gui.WINDOW_LEAVE
Gui.KEY_MASK_SHIFT
Gui.KEY_MASK_CONTROL
Gui.showWindow(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
Gui.setTitle(title: char[*]): void
argb
argb.v
argb.<?>
argb.<?>.b
argb.<?>.g
argb.<?>.r
argb.<?>.a
argb.b
argb.g
argb.r
argb.a
argb(argb: uint32): argb
uint32(value: argb): uint32
clamp_s8(c: int32): uint32
clamp_u8(c: uint32): uint32
_gray(c: uint32): argb
gray(c: int32): argb
gray(c: uint32): argb
gray(c: float32): argb
gray(c: float64): argb
_argb(r: uint32, g: uint32, b: uint32): argb
_argb(a: uint32, r: uint32, g: uint32, b: uint32): argb
argb(r: int32, g: int32, b: int32): argb
argb(r: uint32, g: uint32, b: uint32): argb
argb(r: float32, g: float32, b: float32): argb
argb(r: float64, g: float64, b: float64): argb
argb(a: int32, r: int32, g: int32, b: int32): argb
argb(a: uint32, r: uint32, g: uint32, b: uint32): argb
argb(a: float32, r: float32, g: float32, b: float32): argb
argb(a: float64, r: float64, g: float64, b: float64): argb
ach(color: argb): int32
rch(color: argb): int32
gch(color: argb): int32
bch(color: argb): int32
lum(color: argb): int32
lerpLut(lut: uint32[], alpha: int32, invert: bool, colors: argb[]): void
argb(vec: vec4f): argb
lum(vec: vec4f): float32
hsv2rgb(hsv: vec4f): vec4f
hsv2rgb(h: float32, s: float32, v: float32): argb
drawLut(image: Image, roi: Rect, bars: uint32[256], lines: uint32[256]): void
Image(width: int32, height: int32, depth: int32): Image
Image(fileName: char[*], depth: int32): Image
Image(fileName: char[*]): Image
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): Image
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): Image
Image(fileName: char[*], width: int32, height: int32, depth: int32): Image
Mesh(fileName: char[*]): Mesh
Image(copy: Image): Image
Image(copy: Image, aspect: float64): Image
set(image: Image, x: int32, y: int32, color: argb): void
resize(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32): void
clip(src: Image, roi: Rect): bool
fill(image: Image, color: uint32): void
fill(image: Image, roi: Rect, color: uint32): void
fill(image: Image, roi: Rect, pad: int32, color: uint32): void
drawRect(image: Image, roi: Rect, color: uint32): void
eval(image: Image, roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
tile(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
show(mesh: Mesh, w: int32, h: int32, fovy: float32): void
show(surf: Image): void
show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void
showDiff(image1: Image, image2: Image): void
show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void
