/**
 * standard library extension file
 */

define rand(int min, int max) = int(min + System.rand() % (max - min));
define rand(double min, double max) = double(min + (System.rand() / float64(RAND_MAX)) * (max - min));

// Math functions
static struct Math {

	// constants
	enum: float64 {
		pi = 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e = 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E = 1. / ln2;
		ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E = 1. / ln10;
		phi = 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE = 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan = 0 / 0.;
		inf = 1 / 0.;
	}

	float64 modf(float64 x, float64 &intPart) {
		if (x < 1) {
			if (x < 0) {
				result = -modf(-x, intPart);
				intPart = -intPart;
				return result;
			}
			result = x;
			intPart = 0;
			return result;
		}
		result = x % 1;
		intPart = x - result;
		return result;
	}

	define isNan(float64 x) = bool(x != x);
	define isNan(float32 x) = bool(x != x);

	define isInf(float64 x) = bool(x != 0 && x == 2 * x);
	define isInf(float32 x) = bool(x != 0 && x == 2 * x);

	define isFinite(float64 x) = bool(x - x == 0);
	define isFinite(float32 x) = bool(x - x == 0);

	define abs(int32 x) = (x < 0 ? -x : x);
	define abs(int64 x) = (x < 0 ? -x : x);
	define abs(uint32 x) = x;
	define abs(float32 x) = (x < 0 ? -x : x);
	define abs(float64 x) = (x < 0 ? -x : x);

	define sign(int32 x) = (x ? x < 0 ? -1 : 1 : 0);
	define sign(int64 x) = (x ? x < 0 ? -1 : 1 : 0);
	define sign(uint32 x) = (x ? 1 : 0);
	define sign(float32 x) = (x ? x < 0 ? -1 : 1 : 0);
	define sign(float64 x) = (x ? x < 0 ? -1 : 1 : 0);

	float32 mod(float32 x, float32 y) {
		return x >= 0 ? x % y : (x % y + abs(y)) % y;
	}

	float64 floor(float64 x) {
		modf(x, &result);
		return result;
	}
	define floor(float32 x) = float32(floor(float64(x)));

	define ceil(float64 x) = -floor(-x);
	define ceil(float32 x) = float32(ceil(float64(-x)));

	define round(float64 x) = floor(x + .5);
	define round(float32 x) = float32(round(float64(x)));

	define max(int32 a, int32 b) = (a > b ? a : b);
	define max(int64 a, int64 b) = (a > b ? a : b);
	define max(uint32 a, uint32 b) = (a > b ? a : b);
	define max(float32 a, float32 b) = (a > b ? a : b);
	define max(float64 a, float64 b) = (a > b ? a : b);

	define min(int32 a, int32 b) = (a < b ? a : b);
	define min(int64 a, int64 b) = (a < b ? a : b);
	define min(uint32 a, uint32 b) = (a < b ? a : b);
	define min(float32 a, float32 b) = (a < b ? a : b);
	define min(float64 a, float64 b) = (a < b ? a : b);

	//~ define clamp(int32 t, int32 a, int32 b) = min(max(t, a), b);
	define clamp(int32 t, int32 a, int32 b) = (t < a ? a : t > b ? b : t);
	define clamp(float32 t, float32 a, float32 b) = (t < a ? a : t > b ? b : t);
	define clamp(float64 t, float64 a, float64 b) = (t < a ? a : t > b ? b : t);

	define lerp(float32 t, float32 a, float32 b) = (a + t * (b - a));
	define lerp(float64 t, float64 a, float64 b) = (a + t * (b - a));

	define smooth(float32 t) = (t * t * (3 - 2 * t));
	define smooth(float64 t) = (t * t * (3 - 2 * t));
	define smooth(float32 t, float32 a, float32 b) = smooth(clamp((t - a) / (b - a), float32(0), float32(1)));
	define smooth(float64 t, float64 a, float64 b) = smooth(clamp((t - a) / (b - a), float64(0), float64(1)));

	//TODO: float64 eval(float64 x, float64 poly...) {...}
	define eval(float64 x, float64 a0, float64 a1) = (a0 + x * a1);
	define eval(float64 x, float64 a0, float64 a1, float64 a2) = (a0 + x * eval(x, a1, a2));
	define eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = (a0 + x * eval(x, a1, a2, a3));
	define eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4) = (a0 + x * eval(x, a1, a2, a3, a4));
	define eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4, float64 a5) = (a0 + x * eval(x, a1, a2, a3, a4, a5));
	define eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4, float64 a5, float64 a6) = (a0 + x * eval(x, a1, a2, a3, a4, a5, a6));
	define eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4, float64 a5, float64 a6, float64 a7) = (a0 + x * eval(x, a1, a2, a3, a4, a5, a6, a7));

	float64 Min(float64 data[]) {
		/*TODO: if (isNullOrEmpty(data)) {
			return nan;
		}*/
		result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result > data[i]) {
				result = data[i];
			}
		}
		return result;
	}
	float64 Max(float64 data[]) {
		/*TODO: if (isNullOrEmpty(data)) {
			return nan;
		}*/
		result = data[0];
		for (int i = 1; i < data.length; i += 1) {
			if (result < data[i]) {
				result = data[i];
			}
		}
		return result;
	}
	float64 Sum(float64 data[]) {
		result = 0;
		for (int i = 0; i < data.length; i += 1) {
			result += data[i];
		}
		return result;
	}
	float64 Mean(float64 data[]) {
		return Sum(data) / data.length;
	}

	int Cmp(float32 a, float32 b, float32 eps) {
		if (a < b) {
			if (eps < (b - a))
				return -1;
		}
		else {
			if (eps < (a - b))
				return +1;
		}
		return 0;
	}
	int Cmp(float64 a, float64 b, float64 eps) {
		if (a < b) {
			if (eps < (b - a))
				return -1;
		}
		else {
			if (eps < (a - b))
				return +1;
		}
		return 0;
	}

	define deg2rad(float64 x) = float64(x * pi / 180);
	define rad2deg(float64 x) = float64(x * 180 / pi);
}

// Perlin noise generator
static struct Perlin {
	define B = 0x100;
	define BM = 0xff;
	define N = 0x1000;
	define NP = 12;   // 2^N
	define NM = 0xfff;

	int p[B + B + 2];
	float g3[B + B + 2][3];
	float g2[B + B + 2][2];
	float g1[B + B + 2];

	bool start = true;

	void init() {
		int i;
		System.srand(System.time());
		define sqr(float x) = float(x * x);
		for (i = 0; i < B ; i += 1) {
			p[i] = i;

			g1[i] = float((System.rand() % (B + B)) - B) / B;

			for (int j = 0 ; j < 2 ; j += 1) {
				g2[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize2(g2[i]);
			float n2 = float64.sqrt(sqr(g2[i][0]) + sqr(g2[i][1]));
			if (n2 != 0) {
				g2[i][0] /= n2;
				g2[i][1] /= n2;
			}

			for (int j = 0 ; j < 3 ; j += 1) {
				g3[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize3(g3[i]);
			float n3 = float64.sqrt(sqr(g3[i][0]) + sqr(g3[i][1]) + sqr(g3[i][1]));
			if (n3 != 0) {
				g3[i][0] /= n3;
				g3[i][1] /= n3;
				g3[i][2] /= n3;
			}
		}

		for ( ; i -= 1; ) {
			int k = p[i];
			int j = System.rand() % B;
			p[i] = p[j];
			p[j] = k;
		}

		for (i = 0 ; i < B + 2 ; i += 1) {
			p[B + i] = p[i];
			g1[B + i] = g1[i];
			for (int j = 0 ; j < 2 ; j += 1) {
				g2[B + i][j] = g2[i][j];
			}
			for (int j = 0 ; j < 3 ; j += 1) {
				g3[B + i][j] = g3[i][j];
			}
		}
	}

	void setup(float vec_i, int &b0, int &b1, float &r0,float &r1) {
		float t = vec_i + N;
		b0 = int(t) & BM;
		b1 = (b0+1) & BM;
		r0 = t - int(t);
		r1 = r0 - 1.;
	}

	define smooth(float32 t) = Math.smooth(t);
	define lerp(float32 t, float32 a, float32 b) = Math.lerp(t, a, b);

	float Noise1f(float x) {
		int bx0;
		int bx1;
		float rx0;
		float rx1;
		float sx;
		float u;
		float v;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);

		sx = smooth(rx0);

		u = rx0 * g1[p[bx0]];
		v = rx1 * g1[p[bx1]];

		result = lerp(sx, u, v);
	}
	float Noise2f(float x, float y) {
		int bx0;
		int bx1;
		int by0;
		int by1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);

		define at2(float rx, float ry, int i) = float(rx * g2[i][0] + ry * g2[i][1]);

		float a = lerp(sx, at2(rx0, ry0, b00), at2(rx1, ry0, b10));
		float b = lerp(sx, at2(rx0, ry1, b01), at2(rx1, ry1, b11));

		result = lerp(sy, a, b);
	}
	float Noise3f(float x, float y, float z) {

		int bx0;
		int bx1;
		int by0;
		int by1;
		int bz0;
		int bz1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;
		float rz0;
		float rz1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);
		setup(z, &bz0, &bz1, &rz0, &rz1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);
		float sz = smooth(rz0);

		define at3(float rx, float ry, float rz, int i) = float(rx * g3[i][0] + ry * g3[i][1] + rz * g3[i][2]);

		float a;
		float b;
		float c;
		float d;
		float u;
		float v;

		u = at3(rx0, ry0, rz0, b00 + bz0);
		v = at3(rx1, ry0, rz0, b10 + bz0);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz0, b01 + bz0);
		v = at3(rx1, ry1, rz0, b11 + bz0);
		b = lerp(sx, u, v);

		c = lerp(sy, a, b);

		u = at3(rx0, ry0, rz1, b00 + bz1);
		v = at3(rx1, ry0, rz1, b10 + bz1);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz1, b01 + bz1);
		v = at3(rx1, ry1, rz1, b11 + bz1);
		b = lerp(sx, u, v);

		d = lerp(sy, a, b);

		result = lerp(sz, c, d);
	}

	define Noise(float x) = Noise1f(x);
	define Noise(float x, float y) = Noise2f(x, y);
	define Noise(float x, float y, float z) = Noise3f(x, y, z);
}

define debug(string message, variant inspect) = raise(raise.debug, message, inspect, raise.noTrace);
define debug(string message) = raise(raise.debug, message, variant(null), raise.noTrace);
define debug(variant inspect) = raise(raise.debug, null, inspect, raise.noTrace);

define trace(string message, variant inspect) = raise(raise.debug, message, inspect, raise.defTrace);
define trace(string message) = raise(raise.debug, message, variant(null), raise.defTrace);
define trace(variant inspect) = raise(raise.debug, null, inspect, raise.defTrace);

define abort(string message, variant inspect) = raise(raise.error, message, inspect, raise.defTrace);
define abort(string message) = raise(raise.error, message, variant(null), raise.defTrace);
define abort() = raise(raise.error, "execution aborted!", variant(null), raise.defTrace);

//~ TODO: define assert(bool condition, string message, variant inspect) = void(condition ? void(0) : abort(message, inspect));
//~ TODO: define assert(bool condition, string message) = void(condition ? void(0) : abort(message));
//~ TODO: define assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

define sizeof(typename type) = int(type.size);
