tests/test.Core.all.cvx:50: warning[2]: using overload `mad(a: float64, b: float64, c: float64)` of 2 declared symbols.
tests/test.Core.all.cvx:168: warning[2]: constant expected, got: `color(0.100000, 0.500000, 1.000000)`
tests/test.Core.all.cvx:169: warning[2]: constant expected, got: `color(-1)`
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Core.all.cvx:272: warning[2]: converting `arr3` to variant is discarding one property
tests/test.Core.all.cvx:274: warning[2]: converting `arr3` to variant is discarding one property
tests/test.Core.all.cvx:97: vec4f({
	x: float32(21.000000),
	y: float32(22.000000),
	z: float32(23.000000),
	w: float32(24.000000)
})
tests/test.Core.all.cvx:272: unsorted: int32[](<15>[187, 51, 16, 270, 139, 148, 203, 54, 238, 270, 253, 214, 237, 216, 71])
tests/test.Core.all.cvx:274: sorted: int32[](<15>[16, 51, 54, 71, 139, 148, 187, 203, 214, 216, 237, 238, 253, 270, 270])
tests/test.Core.all.cvx:400: random maximum: float64(0.994284)
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Core.tracing.cvx:9: warning[2]: argument `f` is not explicitly passed by reference
tests/test.Core.tracing.cvx:4: stack trace :-)
	tests/test.Core.tracing.cvx:4: f(arg: int32)(arg&: 0)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:9: f(arg: int32)(arg&: 1)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:9: f(arg: int32)(arg&: 2)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:9: f(arg: int32)(arg&: 3)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:9: f(arg: int32)(arg&: 4)
	tests/test.Core.tracing.cvx:13: .main
tests/test.Core.tracing.cvx:41: stack trace :-)
	tests/test.Core.tracing.cvx:41: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388168@7ffe48>)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:48: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388184@7ffe58>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388200@7ffe68>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388216@7ffe78>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388232@7ffe88>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388248@7ffe98>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388276@7ffeb4>)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:48: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388292@7ffec4>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <+8388308@7ffed4>)
	tests/test.Core.tracing.cvx:46: f3(maxRecursiveCalls: pointer)(maxRecursiveCalls: <n@0485d8>)
	native.code:0: tryExec(args: pointer, action(args: pointer): void)(args: pointer, action: void)
	tests/test.Core.tracing.cvx:64: .main
tests/test.Lang.cvx:45: warning[1]: marking function to be static: `Struct.f3(a: int32, b: int32): int32 := {...}`
tests/test.Lang.cvx:44: warning[8]: ignoring initialization of non static member `Struct.f2(a: int32, b: int32): int32 := null`
tests/test.Lang.cvx:43: warning[8]: ignoring initialization of non static member `Struct.f1(a: int32, b: int32): int32 := f3`
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Lang.enum.cvx:10: warning[2]: constant expected, got: `vec3f(0, 0, 0)`
tests/test.Lang.enum.cvx:11: warning[2]: constant expected, got: `vec3f(1, 0, 0)`
tests/test.Lang.enum.cvx:12: warning[2]: constant expected, got: `vec3f(0, 1, 0)`
tests/test.Lang.enum.cvx:13: warning[2]: constant expected, got: `vec3f(0, 0, 1)`
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Lang.function.cvx:18: log: int32(1)
	tests/test.Lang.function.cvx:18: method1(x: int32)(x: 1)
	tests/test.Lang.function.cvx:21: method1()(: void: struct {
})
	tests/test.Lang.function.cvx:37: .main
tests/test.Lang.function.cvx:18: log: int32(3)
	tests/test.Lang.function.cvx:18: method1(x: int32)(x: 2)
	tests/test.Lang.function.cvx:24: method2()(: void: struct {
})
	tests/test.Lang.function.cvx:38: .main
tests/test.Lang.function.cvx:29: method is null
	tests/test.Lang.function.cvx:29: methodCall(method(): int32)(method: null)
	tests/test.Lang.function.cvx:41: .main
tests/test.Lang.function.cvx:18: log: int32(5)
	tests/test.Lang.function.cvx:18: method1(x: int32)(x: 2)
	tests/test.Lang.function.cvx:24: method2()(: void: struct {
})
	tests/test.Lang.function.cvx:32: methodCall(method(): int32)(method: <method2@048703>)
	tests/test.Lang.function.cvx:43: .main
tests/test.Lang.function.cvx:33: log: int32(5)
	tests/test.Lang.function.cvx:33: methodCall(method(): int32)(method: <method2@048703>)
	tests/test.Lang.function.cvx:43: .main
tests/test.Lang.function.cvx:29: method is null
	tests/test.Lang.function.cvx:29: methodCall(method(): int32)(method: null)
	tests/test.Lang.function.cvx:51: .main
tests/test.Lang.function.cvx:91: Invoke: int64(90)
tests/test.Lang.function.cvx:92: Invoke: int64(81)
tests/test.Lang.function.cvx:93: Invoke: int64(9)
tests/test.Lang.function.cvx:94: Invoke: int64(79)
tests/test.Lang.function.cvx:95: Invoke: int64(77)
tests/test.Lang.function.cvx:96: Invoke: int64(-1)
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Lang.variant.cvx:25: warning[2]: converting `intSlice` to variant is discarding one property
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.Lstd.Math.cvx:72: test failed: Info({
	function: string("Math.Tan"),
	argument: float64(7.738872),
	expected: float64(8.64900232648597544482527155196294188499450683593750),
	returned: float64(8.64900232648603406460097176022827625274658203125000)
})
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.base64.cvx:134: Base64.encode: string("tests/base64.dec.txt")
tests/test.base64.cvx:142: Base64.decode: string("tests/base64.enc.txt")
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.it.Fibonacci.cvx:27: Fib: int64(0)
tests/test.it.Fibonacci.cvx:27: Fib: int64(1)
tests/test.it.Fibonacci.cvx:27: Fib: int64(1)
tests/test.it.Fibonacci.cvx:27: Fib: int64(2)
tests/test.it.Fibonacci.cvx:27: Fib: int64(3)
tests/test.it.Fibonacci.cvx:27: Fib: int64(5)
tests/test.it.Fibonacci.cvx:27: Fib: int64(8)
tests/test.it.Fibonacci.cvx:27: Fib: int64(13)
tests/test.it.Fibonacci.cvx:27: Fib: int64(21)
tests/test.it.Fibonacci.cvx:27: Fib: int64(34)
tests/test.it.Fibonacci.cvx:27: Fib: int64(55)
tests/test.it.Fibonacci.cvx:27: Fib: int64(89)
tests/test.it.Fibonacci.cvx:27: Fib: int64(144)
tests/test.it.Fibonacci.cvx:27: Fib: int64(233)
tests/test.it.Fibonacci.cvx:27: Fib: int64(377)
tests/test.it.Fibonacci.cvx:27: Fib: int64(610)
tests/test.it.Fibonacci.cvx:27: Fib: int64(987)
tests/test.it.Fibonacci.cvx:27: Fib: int64(1597)
tests/test.it.Fibonacci.cvx:27: Fib: int64(2584)
tests/test.it.Fibonacci.cvx:27: Fib: int64(4181)
tests/test.it.Fibonacci.cvx:27: Fib: int64(6765)
tests/test.it.Fibonacci.cvx:27: Fib: int64(10946)
tests/test.it.Fibonacci.cvx:27: Fib: int64(17711)
tests/test.it.Fibonacci.cvx:27: Fib: int64(28657)
tests/test.it.Fibonacci.cvx:27: Fib: int64(46368)
tests/test.it.Fibonacci.cvx:27: Fib: int64(75025)
tests/test.it.Fibonacci.cvx:27: Fib: int64(121393)
tests/test.it.Fibonacci.cvx:27: Fib: int64(196418)
tests/test.it.Fibonacci.cvx:27: Fib: int64(317811)
tests/test.it.Fibonacci.cvx:27: Fib: int64(514229)
tests/test.it.Fibonacci.cvx:27: Fib: int64(832040)
tests/test.it.Fibonacci.cvx:27: Fib: int64(1346269)
tests/test.it.Fibonacci.cvx:27: Fib: int64(2178309)
tests/test.it.Fibonacci.cvx:27: Fib: int64(3524578)
tests/test.it.Fibonacci.cvx:27: Fib: int64(5702887)
tests/test.it.Fibonacci.cvx:27: Fib: int64(9227465)
tests/test.it.Fibonacci.cvx:27: Fib: int64(14930352)
tests/test.it.Fibonacci.cvx:27: Fib: int64(24157817)
tests/test.it.Fibonacci.cvx:27: Fib: int64(39088169)
tests/test.it.Fibonacci.cvx:27: Fib: int64(63245986)
tests/test.it.Fibonacci.cvx:27: Fib: int64(102334155)
tests/test.it.Fibonacci.cvx:27: Fib: int64(165580141)
tests/test.it.Fibonacci.cvx:27: Fib: int64(267914296)
tests/test.it.Fibonacci.cvx:27: Fib: int64(433494437)
tests/test.it.files.cvx:8: warning[2]: argument `strlen(str)` is passed by value: int32: struct {
}
tests/test.it.files.cvx:8: warning[2]: argument `string(str)` is passed by reference
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:2012: warning[2]: converting `arr` to pointer is discarding one property
(/)(/)( )(i)(t)(e)(r)(a)(t)(i)(n)(g)( )(t)(h)(r)(o)(u)(g)(h)( )(f)(i)(l)(e)(s)( )(.)(.)(.)()(
)()(
)(/)(/)( )(m)(a)(k)(e)( )(f)(i)(l)(e)(s)( )(i)(t)(e)(r)(a)(b)(l)(e)( )(:)())()(
)(d)(e)(f)(i)(n)(e)( )(i)(t)(e)(r)(a)(t)(o)(r)(()(F)(i)(l)(e)( )(&)(f)(i)(l)(e)())( )(=)( )(()(f)(i)(l)(e)())(;)()(
)()(
)(v)(o)(i)(d)( )(p)(r)(i)(n)(t)(()(s)(t)(r)(i)(n)(g)( )(s)(t)(r)())( )({)()(
)(	)(s)(t)(a)(t)(i)(c)( )(F)(i)(l)(e)( )(s)(t)(d)(O)(u)(t)( )(=)( )(F)(i)(l)(e)(.)(D)(b)(g)(O)(u)(t)(;)()(
)(	)(c)(h)(a)(r)( )(s)(l)(i)(c)(e)([)(])( )(=)( )(e)(m)(i)(t)(()(s)(t)(r)(u)(c)(t)(,)( )(s)(t)(r)(i)(n)(g)(()(s)(t)(r)())(,)( )(s)(t)(r)(l)(e)(n)(()(s)(t)(r)())())(;)()(
)(	)(F)(i)(l)(e)(.)(W)(r)(i)(t)(e)(()(s)(t)(d)(O)(u)(t)(,)( )(s)(l)(i)(c)(e)())(;)()(
)(})()(
)(v)(o)(i)(d)( )(p)(r)(i)(n)(t)(()(c)(h)(a)(r)( )(c)(h)(r)())( )({)()(
)(	)(c)(h)(a)(r)( )(s)(t)(r)([)(2)(])( )(=)( )({)(c)(h)(r)(,)( )(0)(})(;)()(
)(	)(p)(r)(i)(n)(t)(()(s)(t)(r)(i)(n)(g)(()(s)(t)(r)())())(;)()(
)(})()(
)()(
)(/)(/)( )(i)(t)(e)(r)(a)(t)(i)(n)(g)( )(b)(y)( )(c)(h)(a)(r)(s)()(
)(b)(o)(o)(l)( )(n)(e)(x)(t)(()(F)(i)(l)(e)( )(&)(f)(i)(l)(e)(,)( )(c)(h)(a)(r)( )(&)(v)(a)(l)(u)(e)())( )({)()(
)(	)(i)(n)(t)( )(c)(h)( )(=)( )(F)(i)(l)(e)(.)(R)(e)(a)(d)(()(f)(i)(l)(e)())(;)()(
)(	)(r)(e)(s)(u)(l)(t)( )(=)( )(c)(h)( )(!)(=)( )(-)(1)(;)()(
)(	)(i)(f)( )(()(r)(e)(s)(u)(l)(t)())( )({)()(
)(	)(	)(v)(a)(l)(u)(e)( )(=)( )(c)(h)(;)()(
)(	)(})()(
)(})()(
)()(
)(/)(/)( )(i)(t)(e)(r)(a)(t)(i)(n)(g)( )(b)(y)( )(l)(i)(n)(e)(s)()(
)(b)(o)(o)(l)( )(n)(e)(x)(t)(()(F)(i)(l)(e)( )(&)(f)(i)(l)(e)(,)( )(c)(h)(a)(r)( )(b)(u)(f)(f)([)(])())( )({)()(
)(	)(i)(n)(t)( )(m)(a)(x)( )(=)( )(b)(u)(f)(f)(.)(l)(e)(n)(g)(t)(h)( )(-)( )(1)(;)()(
)(	)(i)(n)(t)( )(p)(o)(s)( )(=)( )(0)(;)()(
)()(
)(	)(/)(/)(~)( )(T)(O)(D)(O)(:)( )(p)(u)(t)( )(t)(h)(i)(s)( )(b)(a)(c)(k)(:)( )(a)(s)(s)(e)(r)(t)(()(m)(a)(x)( )(>)( )(0)())(;)()(
)(	)(r)(e)(s)(u)(l)(t)( )(=)( )(f)(a)(l)(s)(e)(;)( )(/)(/)( )(b)(y)( )(d)(e)(f)(a)(u)(l)(t)()(
)(	)(f)(o)(r)( )(()(;)( )(p)(o)(s)( )(<)( )(m)(a)(x)(;)( )(p)(o)(s)( )(+)(=)( )(1)())( )({)()(
)(	)(	)(i)(n)(t)( )(c)(h)(r)( )(=)( )(F)(i)(l)(e)(.)(R)(e)(a)(d)(()(f)(i)(l)(e)())(;)()(
)(	)(	)(b)(u)(f)(f)([)(p)(o)(s)(])( )(=)( )(c)(h)(r)(;)()(
)()(
)(	)(	)(i)(f)( )(()(c)(h)(r)( )(=)(=)( )(')(\)(n)(')( )(|)(|)( )(c)(h)(r)( )(=)(=)( )(')(\)(r)(')())( )({)()(
)(	)(	)(	)(i)(f)( )(()(c)(h)(r)( )(=)(=)( )(')(\)(r)(')())( )({)()(
)(	)(	)(	)(	)(c)(h)(r)( )(=)( )(F)(i)(l)(e)(.)(P)(e)(e)(k)(()(f)(i)(l)(e)())(;)()(
)(	)(	)(	)(	)(i)(f)( )(()(c)(h)(r)( )(=)(=)( )(')(\)(n)(')())( )({)()(
)(	)(	)(	)(	)(	)(F)(i)(l)(e)(.)(R)(e)(a)(d)(()(f)(i)(l)(e)())(;)()(
)(	)(	)(	)(	)(})()(
)(	)(	)(	)(})()(
)(	)(	)(	)(/)(/)( )(e)(n)(d)( )(o)(f)( )(l)(i)(n)(e)()(
)(	)(	)(	)(b)(u)(f)(f)([)(p)(o)(s)( )(+)( )(1)(])( )(=)( )(0)(;)()(
)(	)(	)(	)(r)(e)(t)(u)(r)(n)( )(t)(r)(u)(e)(;)()(
)(	)(	)(})()(
)()(
)(	)(	)(i)(f)( )(()(c)(h)(r)( )(<)( )(0)())( )({)()(
)(	)(	)(	)(/)(/)( )(e)(n)(d)( )(o)(f)( )(f)(i)(l)(e)()(
)(	)(	)(	)(b)(u)(f)(f)([)(p)(o)(s)(])( )(=)( )(0)(;)()(
)(	)(	)(	)(r)(e)(t)(u)(r)(n)( )(r)(e)(s)(u)(l)(t)(;)()(
)(	)(	)(})()(
)(	)(	)(r)(e)(s)(u)(l)(t)( )(=)( )(t)(r)(u)(e)(;)()(
)(	)(})()(
)()(
)(	)(/)(/)( )(e)(n)(d)( )(o)(f)( )(b)(u)(f)(f)( )(()(l)(i)(n)(e)( )(i)(s)( )(s)(p)(l)(i)(t)(t)(e)(d)())()(
)(	)(b)(u)(f)(f)([)(p)(o)(s)(])( )(=)( )(0)(;)()(
)(	)(t)(r)(a)(c)(e)(()(")(t)(h)(i)(s)( )(l)(i)(n)(e)( )(d)(i)(d)( )(n)(o)(t)( )(f)(i)(t)( )(i)(n)( )(t)(h)(e)( )(b)(u)(f)(f)(e)(r)(")(,)( )(v)(a)(r)(i)(a)(n)(t)(()(s)(t)(r)(i)(n)(g)(()(b)(u)(f)(f)())())())(;)()(
)(	)(r)(e)(t)(u)(r)(n)( )(t)(r)(u)(e)(;)()(
)(})()(
)()(
)(d)(e)(f)(i)(n)(e)( )(t)(e)(s)(t)(F)(i)(l)(e)( )(=)( )(")(t)(e)(s)(t)(s)(/)(t)(e)(s)(t)(.)(i)(t)(.)(f)(i)(l)(e)(s)(.)(c)(v)(x)(")(;)()(
)(d)(e)(f)(i)(n)(e)( )(p)(r)(i)(n)(t)(i)(n)( )(=)( )(!)(f)(a)(l)(s)(e)(;)()(
)()(
)(/)(/)(~)( )(/)(+)( )(i)(t)(e)(r)(a)(t)(e)( )(f)(i)(l)(e)( )(b)(y)( )(c)(h)(a)(r)(s)()(
)(F)(i)(l)(e)( )(f)(i)(l)(e)(1)( )(=)( )(F)(i)(l)(e)(.)(O)(p)(e)(n)(()(t)(e)(s)(t)(F)(i)(l)(e)())(;)()(
)(f)(o)(r)( )(()(c)(h)(a)(r)( )(c)(h)(r)( )(:)( )(f)(i)(l)(e)(1)())( )({)()(
)(	)(s)(t)(a)(t)(i)(c)( )(i)(f)( )(()(p)(r)(i)(n)(t)(i)(n)())( )({)()(
)(	)(	)(p)(r)(i)(n)(t)(()(')(()(')())(;)()(
)(	)(})()(
)(	)(p)(r)(i)(n)(t)(()(c)(h)(r)())(;)()(
)(	)(s)(t)(a)(t)(i)(c)( )(i)(f)( )(()(p)(r)(i)(n)(t)(i)(n)())( )({)()(
)(	)(	)(p)(r)(i)(n)(t)(()(')())(')())(;)()(
)(	)(})()(
)(})()(
)(F)(i)(l)(e)(.)(C)(l)(o)(s)(e)(()(f)(i)(l)(e)(1)())(;)()(
)(/)(/)(~)( )(+)(/)()(
)()(
)(/)(/)(~)( )(/)(+)( )(i)(t)(e)(r)(a)(t)(e)( )(f)(i)(l)(e)( )(b)(y)( )(l)(i)(n)(e)(s)()(
)(F)(i)(l)(e)( )(f)(i)(l)(e)(2)( )(=)( )(F)(i)(l)(e)(.)(O)(p)(e)(n)(()(t)(e)(s)(t)(F)(i)(l)(e)())(;)()(
)(F)(i)(l)(e)( )(o)(u)(t)( )(=)( )(F)(i)(l)(e)(.)(S)(t)(d)(O)(u)(t)(;)()(
)(f)(o)(r)( )(()(c)(h)(a)(r)( )(s)(t)(r)([)(7)(0)(])( )(:)( )(f)(i)(l)(e)(2)())( )({)()(
)(	)(s)(t)(a)(t)(i)(c)( )(i)(f)( )(()(p)(r)(i)(n)(t)(i)(n)())( )({)()(
)(	)(	)(p)(r)(i)(n)(t)(()(')([)(')())(;)()(
)(	)(})()(
)(	)(p)(r)(i)(n)(t)(()(s)(t)(r)(i)(n)(g)(()(s)(t)(r)())())(;)()(
)(	)(s)(t)(a)(t)(i)(c)( )(i)(f)( )(()(p)(r)(i)(n)(t)(i)(n)())( )({)()(
)(	)(	)(p)(r)(i)(n)(t)(()(')(])(')())(;)()(
)(	)(})()(
)(})()(
)(F)(i)(l)(e)(.)(C)(l)(o)(s)(e)(()(f)(i)(l)(e)(2)())(;)()(
)(/)(/)(~)( )(+)(/)()(
)()(
)(/)(+)( )(c)(o)(p)(y)( )(f)(i)(l)(e)( )(w)(i)(t)(h)( )(i)(t)(e)(r)(a)(t)(o)(r)()(
)(F)(i)(l)(e)( )(f)(i)(l)(e)(3)( )(=)( )(F)(i)(l)(e)(.)(O)(p)(e)(n)(()(t)(e)(s)(t)(F)(i)(l)(e)())(;)()(
)(F)(i)(l)(e)( )(f)(i)(l)(e)(O)( )(=)( )(F)(i)(l)(e)(.)(C)(r)(e)(a)(t)(e)(()(")(o)(u)(t)(.)(t)(x)(t)(")())(;)()(
)(f)(o)(r)( )(()(c)(h)(a)(r)( )(c)(h)(r)( )(:)( )(f)(i)(l)(e)(3)())( )({)()(
)(	)(F)(i)(l)(e)(.)(W)(r)(i)(t)(e)(()(f)(i)(l)(e)(O)(,)( )(c)(h)(r)())(;)()(
)(})()(
)(F)(i)(l)(e)(.)(C)(l)(o)(s)(e)(()(f)(i)(l)(e)(O)())(;)()(
)(F)(i)(l)(e)(.)(C)(l)(o)(s)(e)(()(f)(i)(l)(e)(3)())(;)()(
)(/)(/)(~)( )(+)(/)()(
)[// iterating through files ...][][// make files iterable :)][define iterator(File &file) = (file);][][void print(string str) {][	static File stdOut = File.DbgOut;][	char slice[] = emit(struct, string(str), strlen(str));][	File.Write(stdOut, slice);][}][void print(char chr) {][	char str[2] = {chr, 0};][	print(string(str));][}][][// iterating by chars][bool next(File &file, char &value) {][	int ch = File.Read(file);][	result = ch != -1;][	if (result) {][		value = ch;][	}][}][][// iterating by lines][bool next(File &file, char buff[]) {][	int max = buff.length - 1;][	int pos = 0;][][	//~ TODO: put this back: assert(max > 0);][	result = false; // by default][	for (; pos < max; pos += 1) {][		int chr = File.Read(file);][		buff[pos] = chr;][][		if (chr == '\n' || chr == '\r') {][			if (chr == '\r') {][				chr = File.Peek(file);][				if (chr == '\n') {][					File.Read(file);][				}][			}][			// end of line][			buff[pos + 1] = 0;][			return true;][		}][][		if (chr < 0) {][			// end of file][			buff[pos] = 0;][			return result;][		}][		result = true;][	}][][	// end of buff (line is splitted)][	buff[pos] = 0;]tests/test.it.files.cvx:58: this line did not fit in the buffer: string("¨þ")
	tests/test.it.files.cvx:58: next(file: File, buff: char[])(file&: <+8388256@7ffea0>, buff: <70>['	', 't', 'r', 'a', 'c', 'e', '(', '"', 't', 'h', 'i', 's', ' ', 'l', 'i', 'n', 'e', ' ', 'd', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'b', 'u', 'f', 'f', 'e', 'r', '"', ',', ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', '(', 's', 't', 'r', 'i', 'n', 'g', '(', 'b', 'u', 'f', 'f', ')', ')', ')', ';', ''])
	native.code:0: .main
[	trace("this line did not fit in the buffer", variant(string(buff)));][][	return true;][}][][define testFile = "tests/test.it.files.cvx";][define printin = !false;][][//~ /+ iterate file by chars][File file1 = File.Open(testFile);][for (char chr : file1) {][	static if (printin) {][		print('(');][	}][	print(chr);][	static if (printin) {][		print(')');][	}][}][File.Close(file1);][//~ +/][][//~ /+ iterate file by lines][File file2 = File.Open(testFile);][File out = File.StdOut;][for (char str[70] : file2) {][	static if (printin) {][		print('[');][	}][	print(string(str));][	static if (printin) {][		print(']');][	}][}][File.Close(file2);][//~ +/][][/+ copy file with iterator][File file3 = File.Open(testFile);][File fileO = File.Create("out.txt");][for (char chr : file3) {][	File.Write(fileO, chr);][}][File.Close(fileO);][File.Close(file3);][//~ +/]stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
tests/test.it.range.cvx:38: iterating: Range.Iterator({
	Value: int32(10),
	max: int32(13)
})
tests/test.it.range.cvx:38: iterating: Range.Iterator({
	Value: int32(11),
	max: int32(13)
})
tests/test.it.range.cvx:38: iterating: Range.Iterator({
	Value: int32(12),
	max: int32(13)
})
tests/test.it.range.cvx:38: iterating: Range.Iterator({
	Value: int32(13),
	max: int32(13)
})
tests/test.it.range.cvx:44: iterating: int32(10)
tests/test.it.range.cvx:44: iterating: int32(11)
tests/test.it.range.cvx:44: iterating: int32(12)
tests/test.it.range.cvx:44: iterating: int32(13)
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
stdlib.cvx:807: warning[1]: operators `&&` and `||` does not short-circuit yet
